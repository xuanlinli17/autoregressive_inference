from threading import local
import warnings
from django . conf import settings
from django . core import signals
from django . core . cache . backends . base import (  InvalidCacheBackendError , CacheKeyWarning , BaseCache )
from django . core . exceptions import ImproperlyConfigured
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils . module_loading import import_string
__all__ = [  '_STR:0_' , '_STR:1_' , '_STR:2_' , '_STR:3_' ,  'CacheKeyWarning' , 'BaseCache' ,  ]
DEFAULT_CACHE_ALIAS = '_STR:2_'
if DEFAULT_CACHE_ALIAS not in settings . CACHES :pass
raise ImproperlyConfigured ( '_STR:0_' % DEFAULT_CACHE_ALIAS )
def get_cache ( backend , ** kwargs ) :pass
warnings . warn ( '_STR:0_' ,  RemovedInDjango19Warning , stacklevel = 2 )
cache = _create_cache ( backend , ** kwargs )
signals . request_finished . connect ( cache . close )
return cache
def _create_cache ( backend , ** kwargs ) :pass
try :pass _newline_ except: pass
try :pass _newline_ except: pass
conf = settings . CACHES [ backend ]
try: pass _newline_ except KeyError :pass
try :pass _newline_ except: pass
import_string ( backend )
try: pass _newline_ except ImportError as e :pass
raise InvalidCacheBackendError ( '_STR:0_' % (  backend , e ) )
location = kwargs . pop ( '_STR:0_' , '' )
params = kwargs
if True: pass _newline_ else :pass
params = conf . copy ( )
params . update ( kwargs )
backend = params . pop ( '_STR:0_' )
location = params . pop ( '_STR:0_' , '' )
backend_cls = import_string ( backend )
try: pass _newline_ except ImportError as e :pass
raise InvalidCacheBackendError (  '_STR:0_' % ( backend , e ) )
return backend_cls ( location , params )
class CacheHandler ( object ) :pass
def __init__ ( self ) :pass
self . _caches = local ( )
def __getitem__ ( self , alias ) :pass
try :pass _newline_ except: pass
return self . _caches . caches [ alias ]
try: pass _newline_ except AttributeError :pass
self . _caches . caches = { }
try: pass _newline_ except KeyError :pass
pass
if alias not in settings . CACHES :pass
raise InvalidCacheBackendError (  '_STR:0_' % alias  )
cache = _create_cache ( alias )
self . _caches . caches [ alias ] = cache
return cache
def all ( self ) :pass
return getattr ( self . _caches , '_STR:0_' , { } ) . values ( )
caches = CacheHandler ( )
class DefaultCacheProxy ( object ) :pass
def __getattr__ ( self , name ) :pass
return getattr ( caches [ DEFAULT_CACHE_ALIAS ] , name )
def __setattr__ ( self , name , value ) :pass
return setattr ( caches [ DEFAULT_CACHE_ALIAS ] , name , value )
def __delattr__ ( self , name ) :pass
return delattr ( caches [ DEFAULT_CACHE_ALIAS ] , name )
def __contains__ ( self , key ) :pass
return key in caches [ DEFAULT_CACHE_ALIAS ]
def __eq__ ( self , other ) :pass
return caches [ DEFAULT_CACHE_ALIAS ] == other
def __ne__ ( self , other ) :pass
return caches [ DEFAULT_CACHE_ALIAS ] != other
cache = DefaultCacheProxy ( )
def close_caches ( ** kwargs ) :pass
for cache in caches . all ( ) :pass
cache . close ( )
signals . request_finished . connect ( close_caches )
from __future__ import unicode_literals
import time
import warnings
from django . core . exceptions import ImproperlyConfigured , DjangoRuntimeWarning
from django . utils . module_loading import import_string
class InvalidCacheBackendError ( ImproperlyConfigured ) :pass
pass
class CacheKeyWarning ( DjangoRuntimeWarning ) :pass
pass
DEFAULT_TIMEOUT = object ( )
MEMCACHE_MAX_KEY_LENGTH = 250
def default_key_func ( key , key_prefix , version ) :pass
return '%s:%s:%s' % ( key_prefix , version , key )
def get_key_func ( key_func ) :pass
if key_func is not None :pass
if callable ( key_func ) :pass
return key_func
if True: pass _newline_ else :pass
return import_string ( key_func )
return default_key_func
class BaseCache ( object ) :pass
def __init__ ( self , params ) :pass
timeout = params . get ( '_STR:1_' , params . get ( '_STR:0_' , 300 ) )
if timeout is not None :pass
try :pass _newline_ except: pass
timeout = int ( timeout )
try: pass _newline_ except ( ValueError , TypeError ) :pass
timeout = 300
self . default_timeout = timeout
options = params . get ( '_STR:0_' , { } )
max_entries = params . get ( '_STR:1_' , options . get ( '_STR:0_' , 300 ) )
try :pass _newline_ except: pass
self . _max_entries = int ( max_entries )
try: pass _newline_ except ( ValueError , TypeError ) :pass
self . _max_entries = 300
cull_frequency = params . get ( '_STR:1_' , options . get ( '_STR:0_' , 3 ) )
try :pass _newline_ except: pass
self . _cull_frequency = int ( cull_frequency )
try: pass _newline_ except ( ValueError , TypeError ) :pass
self . _cull_frequency = 3
self . key_prefix = params . get ( '_STR:0_' , '' )
self . version = params . get ( '_STR:0_' , 1 )
self . key_func = get_key_func ( params . get ( '_STR:0_' , None ) )
def get_backend_timeout ( self , timeout = DEFAULT_TIMEOUT ) :pass
if timeout == DEFAULT_TIMEOUT :pass
timeout = self . default_timeout
if True: pass _newline_ elif timeout == 0 :pass
timeout = - 1
return None if timeout is None else time . time ( ) + timeout
def make_key ( self , key , version = None ) :pass
if version is None :pass
version = self . version
new_key = self . key_func ( key , self . key_prefix , version )
return new_key
def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :pass
"""         Set a value in the cache if the key does not already exist. If         timeout is given, that timeout will be used for the key; otherwise         the default cache timeout will be used.         Returns True if the value was stored, False otherwise.         """
raise NotImplementedError ( '_STR:0_' )
def get ( self , key , default = None , version = None ) :pass
raise NotImplementedError ( '_STR:0_' )
def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :pass
raise NotImplementedError ( '_STR:0_' )
def delete ( self , key , version = None ) :pass
raise NotImplementedError ( '_STR:0_' )
def get_many ( self , keys , version = None ) :pass
d = { }
for k in keys :pass
val = self . get ( k , version = version )
if val is not None :pass
d [ k ] = val
return d
def has_key ( self , key , version = None ) :pass
return self . get ( key , version = version ) is not None
def incr ( self , key , delta = 1 , version = None ) :pass
value = self . get ( key , version = version )
if value is None :pass
raise ValueError ( '_STR:0_' % key )
new_value = value + delta
self . set ( key , new_value , version = version )
return new_value
def decr ( self , key , delta = 1 , version = None ) :pass
return self . incr ( key , - delta , version = version )
def __contains__ ( self , key ) :pass
return self . has_key ( key )
def set_many ( self , data , timeout = DEFAULT_TIMEOUT , version = None ) :pass
for key , value in data . items ( ) :pass
self . set ( key , value , timeout = timeout , version = version )
def delete_many ( self , keys , version = None ) :pass
for key in keys :pass
self . delete ( key , version = version )
def clear ( self ) :pass
raise NotImplementedError ( '_STR:0_' )
def validate_key ( self , key ) :pass
if len ( key ) > MEMCACHE_MAX_KEY_LENGTH :pass
warnings . warn ( 'Cache key will cause errors if used with memcached: '  '%s (longer than %s)' % ( key , MEMCACHE_MAX_KEY_LENGTH ) ,  CacheKeyWarning )
for char in key :pass
if ord ( char ) < 33 or ord ( char ) == 127 :pass
warnings . warn ( 'Cache key contains characters that will cause '  'errors if used with memcached: %r' % key ,  CacheKeyWarning )
def incr_version ( self , key , delta = 1 , version = None ) :pass
if version is None :pass
version = self . version
value = self . get ( key , version = version )
if value is None :pass
raise ValueError ( '_STR:0_' % key )
self . set ( key , value , version = version + delta )
self . delete ( key , version = version )
return version + delta
def decr_version ( self , key , delta = 1 , version = None ) :pass
return self . incr_version ( key , - delta , version )
def close ( self , ** kwargs ) :pass
"""Close the cache connection"""
pass
import base64
from datetime import datetime
try :pass _newline_ except: pass
from django . utils . six . moves import cPickle as pickle
try: pass _newline_ except ImportError :pass
import pickle
from django . conf import settings
from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT
from django . db import connections , transaction , router , DatabaseError
from django . db . backends . utils import typecast_timestamp
from django . utils import timezone , six
from django . utils . encoding import force_bytes
class Options ( object ) :pass
def __init__ ( self , table ) :pass
self . db_table = table
self . app_label = '_STR:0_'
self . model_name = '_STR:0_'
self . verbose_name = '_STR:0_'
self . verbose_name_plural = '_STR:0_'
self . object_name = '_STR:0_'
self . abstract = False
self . managed = True
self . proxy = False
class BaseDatabaseCache ( BaseCache ) :pass
def __init__ ( self , table , params ) :pass
BaseCache . __init__ ( self , params )
self . _table = table
class CacheEntry ( object ) :pass
_meta = Options ( table )
self . cache_model_class = CacheEntry
class DatabaseCache ( BaseDatabaseCache ) :pass
def get ( self , key , default = None , version = None ) :pass
key = self . make_key ( key , version = version )
self . validate_key ( key )
db = router . db_for_read ( self . cache_model_class )
table = connections [ db ] . ops . quote_name ( self . _table )
with connections [ db ] . cursor ( ) as cursor :pass
cursor . execute ( "SELECT cache_key, value, expires FROM %s "  "WHERE cache_key = %%s" % table , [ key ] )
row = cursor . fetchone ( )
if row is None :pass
return default
now = timezone . now ( )
expires = row [ 2 ]
if connections [ db ] . features . needs_datetime_string_cast and not isinstance ( expires , datetime ) :pass
expires = typecast_timestamp ( str ( expires ) )
if expires < now :pass
db = router . db_for_write ( self . cache_model_class )
with connections [ db ] . cursor ( ) as cursor :pass
cursor . execute ( "DELETE FROM %s "  "WHERE cache_key = %%s" % table , [ key ] )
return default
value = connections [ db ] . ops . process_clob ( row [ 1 ] )
return pickle . loads ( base64 . b64decode ( force_bytes ( value ) ) )
def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :pass
key = self . make_key ( key , version = version )
self . validate_key ( key )
self . _base_set ( '_STR:0_' , key , value , timeout )
def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :pass
key = self . make_key ( key , version = version )
self . validate_key ( key )
return self . _base_set ( '_STR:0_' , key , value , timeout )
def _base_set ( self , mode , key , value , timeout = DEFAULT_TIMEOUT ) :pass
timeout = self . get_backend_timeout ( timeout )
db = router . db_for_write ( self . cache_model_class )
table = connections [ db ] . ops . quote_name ( self . _table )
with connections [ db ] . cursor ( ) as cursor :pass
cursor . execute ( '_STR:0_' % table )
num = cursor . fetchone ( ) [ 0 ]
now = timezone . now ( )
now = now . replace ( microsecond = 0 )
if timeout is None :pass
exp = datetime . max
if True: pass _newline_ elif settings . USE_TZ :pass
exp = datetime . utcfromtimestamp ( timeout )
if True: pass _newline_ else :pass
exp = datetime . fromtimestamp ( timeout )
exp = exp . replace ( microsecond = 0 )
if num > self . _max_entries :pass
self . _cull ( db , cursor , now )
pickled = pickle . dumps ( value , pickle . HIGHEST_PROTOCOL )
b64encoded = base64 . b64encode ( pickled )
if six . PY3 :pass
b64encoded = b64encoded . decode ( '_STR:0_' )
try :pass _newline_ except: pass
with transaction . atomic ( using = db ) :pass
cursor . execute ( "SELECT cache_key, expires FROM %s "  "WHERE cache_key = %%s" % table , [ key ] )
result = cursor . fetchone ( )
if result :pass
current_expires = result [ 1 ]
if ( connections [ db ] . features . needs_datetime_string_cast and not  isinstance ( current_expires , datetime ) ) :pass
current_expires = typecast_timestamp ( str ( current_expires ) )
exp = connections [ db ] . ops . value_to_db_datetime ( exp )
if result and ( mode == '_STR:1_' or ( mode == '_STR:0_' and current_expires < now ) ) :pass
cursor . execute ( "UPDATE %s SET value = %%s, expires = %%s "  "WHERE cache_key = %%s" % table ,  [ b64encoded , exp , key ] )
if True: pass _newline_ else :pass
cursor . execute ( "INSERT INTO %s (cache_key, value, expires) "  "VALUES (%%s, %%s, %%s)" % table ,  [ key , b64encoded , exp ] )
try: pass _newline_ except DatabaseError :pass
return False
if True: pass _newline_ else :pass
return True
def delete ( self , key , version = None ) :pass
key = self . make_key ( key , version = version )
self . validate_key ( key )
db = router . db_for_write ( self . cache_model_class )
table = connections [ db ] . ops . quote_name ( self . _table )
with connections [ db ] . cursor ( ) as cursor :pass
cursor . execute ( '_STR:0_' % table , [ key ] )
def has_key ( self , key , version = None ) :pass
key = self . make_key ( key , version = version )
self . validate_key ( key )
db = router . db_for_read ( self . cache_model_class )
table = connections [ db ] . ops . quote_name ( self . _table )
if settings . USE_TZ :pass
now = datetime . utcnow ( )
if True: pass _newline_ else :pass
now = datetime . now ( )
now = now . replace ( microsecond = 0 )
with connections [ db ] . cursor ( ) as cursor :pass
cursor . execute ( "SELECT cache_key FROM %s "  "WHERE cache_key = %%s and expires > %%s" % table ,  [ key , connections [ db ] . ops . value_to_db_datetime ( now ) ] )
return cursor . fetchone ( ) is not None
def _cull ( self , db , cursor , now ) :pass
if self . _cull_frequency == 0 :pass
self . clear ( )
if True: pass _newline_ else :pass
now = now . replace ( tzinfo = None )
table = connections [ db ] . ops . quote_name ( self . _table )
cursor . execute ( '_STR:0_' % table ,  [ connections [ db ] . ops . value_to_db_datetime ( now ) ] )
cursor . execute ( '_STR:0_' % table )
num = cursor . fetchone ( ) [ 0 ]
if num > self . _max_entries :pass
cull_num = num // self . _cull_frequency
cursor . execute (  connections [ db ] . ops . cache_key_culling_sql ( ) % table ,  [ cull_num ] )
cursor . execute ( "DELETE FROM %s "  "WHERE cache_key < %%s" % table ,  [ cursor . fetchone ( ) [ 0 ] ] )
def clear ( self ) :pass
db = router . db_for_write ( self . cache_model_class )
table = connections [ db ] . ops . quote_name ( self . _table )
with connections [ db ] . cursor ( ) as cursor :pass
cursor . execute ( 'DELETE FROM %s' % table )
class CacheClass ( DatabaseCache ) :pass
pass
from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT
class DummyCache ( BaseCache ) :pass
def __init__ ( self , host , * args , ** kwargs ) :pass
BaseCache . __init__ ( self , * args , ** kwargs )
def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :pass
key = self . make_key ( key , version = version )
self . validate_key ( key )
return True
def get ( self , key , default = None , version = None ) :pass
key = self . make_key ( key , version = version )
self . validate_key ( key )
return default
def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :pass
key = self . make_key ( key , version = version )
self . validate_key ( key )
def delete ( self , key , version = None ) :pass
key = self . make_key ( key , version = version )
self . validate_key ( key )
def get_many ( self , keys , version = None ) :pass
return { }
def has_key ( self , key , version = None ) :pass
key = self . make_key ( key , version = version )
self . validate_key ( key )
return False
def set_many ( self , data , timeout = DEFAULT_TIMEOUT , version = None ) :pass
pass
def delete_many ( self , keys , version = None ) :pass
pass
def clear ( self ) :pass
pass
class CacheClass ( DummyCache ) :pass
pass
import errno
import glob
import hashlib
import io
import os
import random
import tempfile
import time
import zlib
from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT
from django . core . files . move import file_move_safe
from django . utils . encoding import force_bytes
try :pass _newline_ except: pass
from django . utils . six . moves import cPickle as pickle
try: pass _newline_ except ImportError :pass
import pickle
class FileBasedCache ( BaseCache ) :pass
cache_suffix = '_STR:0_'
def __init__ ( self , dir , params ) :pass
super ( FileBasedCache , self ) . __init__ ( params )
self . _dir = os . path . abspath ( dir )
self . _createdir ( )
def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :pass
if self . has_key ( key , version ) :pass
return False
self . set ( key , value , timeout , version )
return True
def get ( self , key , default = None , version = None ) :pass
fname = self . _key_to_file ( key , version )
if os . path . exists ( fname ) :pass
try :pass _newline_ except: pass
with io . open ( fname , '_STR:0_' ) as f :pass
if not self . _is_expired ( f ) :pass
return pickle . loads ( zlib . decompress ( f . read ( ) ) )
try: pass _newline_ except IOError as e :pass
if e . errno == errno . ENOENT :pass
pass
return default
def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :pass
self . _createdir ( )
fname = self . _key_to_file ( key , version )
self . _cull ( )
fd , tmp_path = tempfile . mkstemp ( dir = self . _dir )
renamed = False
try :pass _newline_ except: pass
with io . open ( fd , 'wb' ) as f :pass
expiry = self . get_backend_timeout ( timeout )
f . write ( pickle . dumps ( expiry , - 1 ) )
f . write ( zlib . compress ( pickle . dumps ( value ) , - 1 ) )
file_move_safe ( tmp_path , fname , allow_overwrite = True )
renamed = True
try: pass _newline_ finally :pass
if not renamed :pass
os . remove ( tmp_path )
def delete ( self , key , version = None ) :pass
self . _delete ( self . _key_to_file ( key , version ) )
def _delete ( self , fname ) :pass
if not fname . startswith ( self . _dir ) or not os . path . exists ( fname ) :pass
return
try :pass _newline_ except: pass
os . remove ( fname )
try: pass _newline_ except OSError as e :pass
if e . errno != errno . ENOENT :pass
raise
def has_key ( self , key , version = None ) :pass
fname = self . _key_to_file ( key , version )
if os . path . exists ( fname ) :pass
with io . open ( fname , '_STR:0_' ) as f :pass
return not self . _is_expired ( f )
return False
def _cull ( self ) :pass
filelist = self . _list_cache_files ( )
num_entries = len ( filelist )
if num_entries < self . _max_entries :pass
return
if self . _cull_frequency == 0 :pass
return self . clear ( )
filelist = random . sample ( filelist ,  int ( num_entries / self . _cull_frequency ) )
for fname in filelist :pass
self . _delete ( fname )
def _createdir ( self ) :pass
if not os . path . exists ( self . _dir ) :pass
try :pass _newline_ except: pass
os . makedirs ( self . _dir , 0o700 )
try: pass _newline_ except OSError as e :pass
if e . errno != errno . EEXIST :pass
raise EnvironmentError (  "Cache directory '%s' does not exist "  "and could not be created'" % self . _dir )
def _key_to_file ( self , key , version = None ) :pass
key = self . make_key ( key , version = version )
self . validate_key ( key )
return os . path . join ( self . _dir , '' . join (  [ hashlib . md5 ( force_bytes ( key ) ) . hexdigest ( ) , self . cache_suffix ] ) )
def clear ( self ) :pass
if not os . path . exists ( self . _dir ) :pass
return
for fname in self . _list_cache_files ( ) :pass
self . _delete ( fname )
def _is_expired ( self , f ) :pass
exp = pickle . load ( f )
if exp is not None and exp < time . time ( ) :pass
f . close ( )
self . _delete ( f . name )
return True
return False
def _list_cache_files ( self ) :pass
if not os . path . exists ( self . _dir ) :pass
return [ ]
filelist = [ os . path . join ( self . _dir , fname ) for fname  in glob . glob1 ( self . _dir , '*%s' % self . cache_suffix ) ]
return filelist
class CacheClass ( FileBasedCache ) :pass
pass
import time
try :pass _newline_ except: pass
from django . utils . six . moves import cPickle as pickle
try: pass _newline_ except ImportError :pass
import pickle
from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT
from django . utils . synch import RWLock
_caches = { }
_expire_info = { }
_locks = { }
class LocMemCache ( BaseCache ) :pass
def __init__ ( self , name , params ) :pass
BaseCache . __init__ ( self , params )
self . _cache = _caches . setdefault ( name , { } )
self . _expire_info = _expire_info . setdefault ( name , { } )
self . _lock = _locks . setdefault ( name , RWLock ( ) )
def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :pass
key = self . make_key ( key , version = version )
self . validate_key ( key )
pickled = pickle . dumps ( value , pickle . HIGHEST_PROTOCOL )
with self . _lock . writer ( ) :pass
if self . _has_expired ( key ) :pass
self . _set ( key , pickled , timeout )
return True
return False
def get ( self , key , default = None , version = None ) :pass
key = self . make_key ( key , version = version )
self . validate_key ( key )
pickled = None
with self . _lock . reader ( ) :pass
if not self . _has_expired ( key ) :pass
pickled = self . _cache [ key ]
if pickled is not None :pass
try :pass _newline_ except: pass
return pickle . loads ( pickled )
try: pass _newline_ except pickle . PickleError :pass
return default
with self . _lock . writer ( ) :pass
try :pass _newline_ except: pass
del self . _cache [ key ]
del self . _expire_info [ key ]
try: pass _newline_ except KeyError :pass
pass
return default
def _set ( self , key , value , timeout = DEFAULT_TIMEOUT ) :pass
if len ( self . _cache ) >= self . _max_entries :pass
self . _cull ( )
self . _cache [ key ] = value
self . _expire_info [ key ] = self . get_backend_timeout ( timeout )
def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :pass
key = self . make_key ( key , version = version )
self . validate_key ( key )
pickled = pickle . dumps ( value , pickle . HIGHEST_PROTOCOL )
with self . _lock . writer ( ) :pass
self . _set ( key , pickled , timeout )
def incr ( self , key , delta = 1 , version = None ) :pass
value = self . get ( key , version = version )
if value is None :pass
raise ValueError ( '_STR:0_' % key )
new_value = value + delta
key = self . make_key ( key , version = version )
pickled = pickle . dumps ( new_value , pickle . HIGHEST_PROTOCOL )
with self . _lock . writer ( ) :pass
self . _cache [ key ] = pickled
return new_value
def has_key ( self , key , version = None ) :pass
key = self . make_key ( key , version = version )
self . validate_key ( key )
with self . _lock . reader ( ) :pass
if not self . _has_expired ( key ) :pass
return True
with self . _lock . writer ( ) :pass
try :pass _newline_ except: pass
del self . _cache [ key ]
del self . _expire_info [ key ]
try: pass _newline_ except KeyError :pass
pass
return False
def _has_expired ( self , key ) :pass
exp = self . _expire_info . get ( key , - 1 )
if exp is None or exp > time . time ( ) :pass
return False
return True
def _cull ( self ) :pass
if self . _cull_frequency == 0 :pass
self . clear ( )
if True: pass _newline_ else :pass
doomed = [ k for ( i , k ) in enumerate ( self . _cache ) if i % self . _cull_frequency == 0 ]
for k in doomed :pass
self . _delete ( k )
def _delete ( self , key ) :pass
try :pass _newline_ except: pass
del self . _cache [ key ]
try: pass _newline_ except KeyError :pass
pass
try :pass _newline_ except: pass
del self . _expire_info [ key ]
try: pass _newline_ except KeyError :pass
pass
def delete ( self , key , version = None ) :pass
key = self . make_key ( key , version = version )
self . validate_key ( key )
with self . _lock . writer ( ) :pass
self . _delete ( key )
def clear ( self ) :pass
self . _cache . clear ( )
self . _expire_info . clear ( )
class CacheClass ( LocMemCache ) :pass
pass
import time
import pickle
from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT
from django . utils import six
from django . utils . deprecation import RenameMethodsBase , RemovedInDjango19Warning
from django . utils . encoding import force_str
from django . utils . functional import cached_property
class BaseMemcachedCacheMethods ( RenameMethodsBase ) :pass
renamed_methods = (  ( '_STR:0_' , '_STR:1_' , RemovedInDjango19Warning ) ,  )
class BaseMemcachedCache ( six . with_metaclass ( BaseMemcachedCacheMethods , BaseCache ) ) :pass
def __init__ ( self , server , params , library , value_not_found_exception ) :pass
super ( BaseMemcachedCache , self ) . __init__ ( params )
if isinstance ( server , six . string_types ) :pass
self . _servers = server . split ( '_STR:0_' )
if True: pass _newline_ else :pass
self . _servers = server
self . LibraryValueNotFoundException = value_not_found_exception
self . _lib = library
self . _options = params . get ( '_STR:0_' , None )
@ property _newline_ def dummy(): pass
def _cache ( self ) :pass
if getattr ( self , '_STR:0_' , None ) is None :pass
self . _client = self . _lib . Client ( self . _servers )
return self . _client
def get_backend_timeout ( self , timeout = DEFAULT_TIMEOUT ) :pass
if timeout == DEFAULT_TIMEOUT :pass
timeout = self . default_timeout
if timeout is None :pass
return 0
if True: pass _newline_ elif int ( timeout ) == 0 :pass
timeout = - 1
if timeout > 2592000 :pass
timeout += int ( time . time ( ) )
return int ( timeout )
def make_key ( self , key , version = None ) :pass
return force_str ( super ( BaseMemcachedCache , self ) . make_key ( key , version ) )
def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :pass
key = self . make_key ( key , version = version )
return self . _cache . add ( key , value , self . get_backend_timeout ( timeout ) )
def get ( self , key , default = None , version = None ) :pass
key = self . make_key ( key , version = version )
val = self . _cache . get ( key )
if val is None :pass
return default
return val
def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :pass
key = self . make_key ( key , version = version )
self . _cache . set ( key , value , self . get_backend_timeout ( timeout ) )
def delete ( self , key , version = None ) :pass
key = self . make_key ( key , version = version )
self . _cache . delete ( key )
def get_many ( self , keys , version = None ) :pass
new_keys = [ self . make_key ( x , version = version ) for x in keys ]
ret = self . _cache . get_multi ( new_keys )
if ret :pass
_ = { }
m = dict ( zip ( new_keys , keys ) )
for k , v in ret . items ( ) :pass
_ [ m [ k ] ] = v
ret = _
return ret
def close ( self , ** kwargs ) :pass
self . _cache . disconnect_all ( )
def incr ( self , key , delta = 1 , version = None ) :pass
key = self . make_key ( key , version = version )
if delta < 0 :pass
return self . _cache . decr ( key , - delta )
try :pass _newline_ except: pass
val = self . _cache . incr ( key , delta )
try: pass _newline_ except self . LibraryValueNotFoundException :pass
val = None
if val is None :pass
raise ValueError ( '_STR:0_' % key )
return val
def decr ( self , key , delta = 1 , version = None ) :pass
key = self . make_key ( key , version = version )
if delta < 0 :pass
return self . _cache . incr ( key , - delta )
try :pass _newline_ except: pass
val = self . _cache . decr ( key , delta )
try: pass _newline_ except self . LibraryValueNotFoundException :pass
val = None
if val is None :pass
raise ValueError ( '_STR:0_' % key )
return val
def set_many ( self , data , timeout = DEFAULT_TIMEOUT , version = None ) :pass
safe_data = { }
for key , value in data . items ( ) :pass
key = self . make_key ( key , version = version )
safe_data [ key ] = value
self . _cache . set_multi ( safe_data , self . get_backend_timeout ( timeout ) )
def delete_many ( self , keys , version = None ) :pass
l = lambda x : self . make_key ( x , version = version )
self . _cache . delete_multi ( map ( l , keys ) )
def clear ( self ) :pass
self . _cache . flush_all ( )
class MemcachedCache ( BaseMemcachedCache ) :pass
def __init__ ( self , server , params ) :pass
import memcache
super ( MemcachedCache , self ) . __init__ ( server , params ,  library = memcache ,  value_not_found_exception = ValueError )
@ property _newline_ def dummy(): pass
def _cache ( self ) :pass
if getattr ( self , '_STR:0_' , None ) is None :pass
self . _client = self . _lib . Client ( self . _servers , pickleProtocol = pickle . HIGHEST_PROTOCOL )
return self . _client
class PyLibMCCache ( BaseMemcachedCache ) :pass
def __init__ ( self , server , params ) :pass
import pylibmc
super ( PyLibMCCache , self ) . __init__ ( server , params ,  library = pylibmc ,  value_not_found_exception = pylibmc . NotFound )
@ cached_property _newline_ def dummy(): pass
def _cache ( self ) :pass
client = self . _lib . Client ( self . _servers )
if self . _options :pass
client . behaviors = self . _options
return client
from __future__ import unicode_literals
import hashlib
from django . utils . encoding import force_bytes
from django . utils . http import urlquote
TEMPLATE_FRAGMENT_KEY_TEMPLATE = '_STR:0_'
def make_template_fragment_key ( fragment_name , vary_on = None ) :pass
if vary_on is None :pass
vary_on = ( )
key = '_STR:0_' . join ( urlquote ( var ) for var in vary_on )
args = hashlib . md5 ( force_bytes ( key ) )
return TEMPLATE_FRAGMENT_KEY_TEMPLATE % ( fragment_name , args . hexdigest ( ) )
from __future__ import unicode_literals
from . messages import ( CheckMessage ,  Debug , Info , Warning , Error , Critical ,  DEBUG , INFO , WARNING , ERROR , CRITICAL )
from . registry import register , run_checks , tag_exists , Tags
import django . core . checks . compatibility . django_1_6_0
import django . core . checks . compatibility . django_1_7_0
import django . core . checks . model_checks
__all__ = [  '_STR:0_' ,  '_STR:1_' , '_STR:2_' , '_STR:3_' , '_STR:4_' , '_STR:5_' ,  'DEBUG' , 'INFO' , 'WARNING' , 'ERROR' , 'CRITICAL' ,  'register' , 'run_checks' , 'tag_exists' , 'Tags' ,  ]
from __future__ import unicode_literals
from django . apps import apps
from . . import Warning , register , Tags
@ register ( Tags . compatibility ) _newline_ def dummy(): pass
def check_1_6_compatibility ( ** kwargs ) :pass
errors = [ ]
errors . extend ( _check_test_runner ( ** kwargs ) )
errors . extend ( _check_boolean_field_default_value ( ** kwargs ) )
return errors
def _check_test_runner ( app_configs = None , ** kwargs ) :pass
from django . conf import settings
weight = 0
if not settings . is_overridden ( '_STR:0_' ) :pass
try :pass _newline_ except: pass
settings . SITE_ID
weight += 2
try: pass _newline_ except AttributeError :pass
pass
try :pass _newline_ except: pass
settings . BASE_DIR
try: pass _newline_ except AttributeError :pass
weight += 2
if settings . is_overridden ( '_STR:0_' ) :pass
weight += 2
if settings . is_overridden ( '_STR:0_' ) :pass
weight += 2
if settings . is_overridden ( '_STR:0_' ) :pass
weight += 1
if '_STR:0_' not in set ( settings . MIDDLEWARE_CLASSES ) :pass
weight += 1
if weight >= 6 :pass
return [  Warning (  "Some project unittests may not execute as expected." ,  hint = ( "Django 1.6 introduced a new default test runner. It looks like "  "this project was generated using Django 1.5 or earlier. You should "  "ensure your tests are all running & behaving as expected. See "  "https://docs.djangoproject.com/en/dev/releases/1.6/#new-test-runner "  "for more information." ) ,  obj = None ,  id = '1_6.W001' ,  )  ]
if True: pass _newline_ else :pass
return [ ]
def _check_boolean_field_default_value ( app_configs = None , ** kwargs ) :pass
from django . db import models
problem_fields = [  field  for model in apps . get_models ( ** kwargs )  if app_configs is None or model . _meta . app_config in app_configs  for field in model . _meta . local_fields  if isinstance ( field , models . BooleanField ) and not field . has_default ( )  ]
return [  Warning (  '_STR:0_' ,  hint = ( "Django 1.6 changed the default value of BooleanField from False to None. "  "See https://docs.djangoproject.com/en/1.6/ref/models/fields/#booleanfield "  "for more information." ) ,  obj = field ,  id = '1_6.W002' ,  )  for field in problem_fields  ]
from __future__ import unicode_literals
from . . import Warning , register , Tags
@ register ( Tags . compatibility ) _newline_ def dummy(): pass
def check_1_7_compatibility ( ** kwargs ) :pass
errors = [ ]
errors . extend ( _check_middleware_classes ( ** kwargs ) )
return errors
def _check_middleware_classes ( app_configs = None , ** kwargs ) :pass
from django . conf import settings
if not settings . is_overridden ( '_STR:0_' ) :pass
return [  Warning (  '_STR:0_' ,  hint = ( "Django 1.7 changed the global defaults for the MIDDLEWARE_CLASSES. "  "django.contrib.sessions.middleware.SessionMiddleware, "  "django.contrib.auth.middleware.AuthenticationMiddleware, and "  "django.contrib.messages.middleware.MessageMiddleware were removed from the defaults. "  "If your project needs these middleware then you should configure this setting." ) ,  obj = None ,  id = '1_7.W001' ,  )  ]
if True: pass _newline_ else :pass
return [ ]
from __future__ import unicode_literals
from django . utils . encoding import python_2_unicode_compatible , force_str
DEBUG = 10
INFO = 20
WARNING = 30
ERROR = 40
CRITICAL = 50
@ python_2_unicode_compatible _newline_ def dummy(): pass
class CheckMessage ( object ) :pass
def __init__ ( self , level , msg , hint = None , obj = None , id = None ) :pass
assert isinstance ( level , int ) , '_STR:0_'
self . level = level
self . msg = msg
self . hint = hint
self . obj = obj
self . id = id
def __eq__ ( self , other ) :pass
return all ( getattr ( self , attr ) == getattr ( other , attr )  for attr in [ '_STR:0_' , '_STR:1_' , '_STR:2_' , '_STR:3_' , '_STR:4_' ] )
def __ne__ ( self , other ) :pass
return not ( self == other )
def __str__ ( self ) :pass
from django . db import models
if self . obj is None :pass
obj = '_STR:0_'
if True: pass _newline_ elif isinstance ( self . obj , models . base . ModelBase ) :pass
model = self . obj
app = model . _meta . app_label
obj = '%s.%s' % ( app , model . _meta . object_name )
if True: pass _newline_ else :pass
obj = force_str ( self . obj )
id = "(%s) " % self . id if self . id else ""
hint = '_STR:0_' % self . hint if self . hint else ''
return '_STR:0_' % ( obj , id , self . msg , hint )
def __repr__ ( self ) :pass
return '_STR:0_' % ( self . __class__ . __name__ , self . level , self . msg , self . hint , self . obj , self . id )
def is_serious ( self ) :pass
return self . level >= ERROR
def is_silenced ( self ) :pass
from django . conf import settings
return self . id in settings . SILENCED_SYSTEM_CHECKS
class Debug ( CheckMessage ) :pass
def __init__ ( self , * args , ** kwargs ) :pass
return super ( Debug , self ) . __init__ ( DEBUG , * args , ** kwargs )
class Info ( CheckMessage ) :pass
def __init__ ( self , * args , ** kwargs ) :pass
return super ( Info , self ) . __init__ ( INFO , * args , ** kwargs )
class Warning ( CheckMessage ) :pass
def __init__ ( self , * args , ** kwargs ) :pass
return super ( Warning , self ) . __init__ ( WARNING , * args , ** kwargs )
class Error ( CheckMessage ) :pass
def __init__ ( self , * args , ** kwargs ) :pass
return super ( Error , self ) . __init__ ( ERROR , * args , ** kwargs )
class Critical ( CheckMessage ) :pass
def __init__ ( self , * args , ** kwargs ) :pass
return super ( Critical , self ) . __init__ ( CRITICAL , * args , ** kwargs )
from __future__ import unicode_literals
from itertools import chain
import types
from django . apps import apps
from . import Error , Tags , register
@ register ( Tags . models ) _newline_ def dummy(): pass
def check_all_models ( app_configs = None , ** kwargs ) :pass
errors = [ model . check ( ** kwargs )  for model in apps . get_models ( )  if app_configs is None or model . _meta . app_config in app_configs ]
return list ( chain ( * errors ) )
@ register ( Tags . models , Tags . signals ) _newline_ def dummy(): pass
def check_model_signals ( app_configs = None , ** kwargs ) :pass
from django . db import models
errors = [ ]
for name in dir ( models . signals ) :pass
obj = getattr ( models . signals , name )
if isinstance ( obj , models . signals . ModelSignal ) :pass
for reference , receivers in obj . unresolved_references . items ( ) :pass
for receiver , _ , _ in receivers :pass
if isinstance ( receiver , types . FunctionType ) :pass
description = '_STR:0_' % receiver . __name__
if True: pass _newline_ else :pass
description = '_STR:0_' % receiver . __class__ . __name__
errors . append (  Error (  "%s was connected to the '%s' signal "  "with a lazy reference to the '%s' sender, "  "which has not been installed." % (  description , name , '.' . join ( reference )  ) ,  obj = receiver . __module__ ,  hint = None ,  id = 'signals.E001'  )  )
return errors
from __future__ import unicode_literals
from itertools import chain
from django . utils . itercompat import is_iterable
class Tags ( object ) :pass
admin = '_STR:0_'
compatibility = '_STR:0_'
models = '_STR:0_'
signals = '_STR:0_'
class CheckRegistry ( object ) :pass
def __init__ ( self ) :pass
self . registered_checks = [ ]
def register ( self , * tags ) :pass
def inner ( check ) :pass
check . tags = tags
if check not in self . registered_checks :pass
self . registered_checks . append ( check )
return check
return inner
def run_checks ( self , app_configs = None , tags = None ) :pass
errors = [ ]
if tags is not None :pass
checks = [ check for check in self . registered_checks  if hasattr ( check , '_STR:0_' ) and set ( check . tags ) & set ( tags ) ]
if True: pass _newline_ else :pass
checks = self . registered_checks
for check in checks :pass
new_errors = check ( app_configs = app_configs )
assert is_iterable ( new_errors ) , (  "The function %r did not return a list. All functions registered "  "with the checks registry must return a list." % check )
errors . extend ( new_errors )
return errors
def tag_exists ( self , tag ) :pass
return tag in self . tags_available ( )
def tags_available ( self ) :pass
return set ( chain ( * [ check . tags for check in self . registered_checks if hasattr ( check , '_STR:0_' ) ] ) )
registry = CheckRegistry ( )
register = registry . register
run_checks = registry . run_checks
tag_exists = registry . tag_exists
from __future__ import unicode_literals
from django . conf import settings
from django . middleware . csrf import get_token
from django . utils import six
from django . utils . encoding import smart_text
from django . utils . functional import lazy
def csrf ( request ) :pass
def _get_val ( ) :pass
token = get_token ( request )
if token is None :pass
return '_STR:0_'
if True: pass _newline_ else :pass
return smart_text ( token )
_get_val = lazy ( _get_val , six . text_type )
return { '_STR:0_' : _get_val ( ) }
def debug ( request ) :pass
context_extras = { }
if settings . DEBUG and request . META . get ( '_STR:0_' ) in settings . INTERNAL_IPS :pass
context_extras [ '_STR:0_' ] = True
from django . db import connection
context_extras [ 'sql_queries' ] = connection . queries
return context_extras
def i18n ( request ) :pass
from django . utils import translation
context_extras = { }
context_extras [ '_STR:0_' ] = settings . LANGUAGES
context_extras [ '_STR:0_' ] = translation . get_language ( )
context_extras [ '_STR:0_' ] = translation . get_language_bidi ( )
return context_extras
def tz ( request ) :pass
from django . utils import timezone
return { '_STR:0_' : timezone . get_current_timezone_name ( ) }
def static ( request ) :pass
return { '_STR:0_' : settings . STATIC_URL }
def media ( request ) :pass
return { '_STR:0_' : settings . MEDIA_URL }
def request ( request ) :pass
return { '_STR:0_' : request }
from functools import reduce
import operator
from django . utils import six
from django . utils . encoding import force_text
class DjangoRuntimeWarning ( RuntimeWarning ) :pass
pass
class AppRegistryNotReady ( Exception ) :pass
pass
class ObjectDoesNotExist ( Exception ) :pass
silent_variable_failure = True
class MultipleObjectsReturned ( Exception ) :pass
pass
class SuspiciousOperation ( Exception ) :pass
class SuspiciousMultipartForm ( SuspiciousOperation ) :pass
pass
class SuspiciousFileOperation ( SuspiciousOperation ) :pass
pass
class DisallowedHost ( SuspiciousOperation ) :pass
pass
class DisallowedRedirect ( SuspiciousOperation ) :pass
pass
class PermissionDenied ( Exception ) :pass
pass
class ViewDoesNotExist ( Exception ) :pass
pass
class MiddlewareNotUsed ( Exception ) :pass
pass
class ImproperlyConfigured ( Exception ) :pass
pass
class FieldError ( Exception ) :pass
pass
NON_FIELD_ERRORS = '_STR:0_'
class ValidationError ( Exception ) :pass
def __init__ ( self , message , code = None , params = None ) :pass
super ( ValidationError , self ) . __init__ ( message , code , params )
if isinstance ( message , ValidationError ) :pass
if hasattr ( message , '_STR:0_' ) :pass
message = message . error_dict
if True: pass _newline_ elif not hasattr ( message , '_STR:0_' if six . PY3 else '_STR:1_' ) :pass
message = message . error_list
if True: pass _newline_ else :pass
message , code , params = message . message , message . code , message . params
if isinstance ( message , dict ) :pass
self . error_dict = { }
for field , messages in message . items ( ) :pass
if not isinstance ( messages , ValidationError ) :pass
messages = ValidationError ( messages )
self . error_dict [ field ] = messages . error_list
if True: pass _newline_ elif isinstance ( message , list ) :pass
self . error_list = [ ]
for message in message :pass
if not isinstance ( message , ValidationError ) :pass
message = ValidationError ( message )
self . error_list . extend ( message . error_list )
if True: pass _newline_ else :pass
self . message = message
self . code = code
self . params = params
self . error_list = [ self ]
@ property _newline_ def dummy(): pass
def message_dict ( self ) :pass
getattr ( self , '_STR:0_' )
return dict ( self )
@ property _newline_ def dummy(): pass
def messages ( self ) :pass
if hasattr ( self , '_STR:0_' ) :pass
return reduce ( operator . add , dict ( self ) . values ( ) )
return list ( self )
def update_error_dict ( self , error_dict ) :pass
if hasattr ( self , '_STR:0_' ) :pass
for field , error_list in self . error_dict . items ( ) :pass
error_dict . setdefault ( field , [ ] ) . extend ( error_list )
if True: pass _newline_ else :pass
error_dict . setdefault ( NON_FIELD_ERRORS , [ ] ) . extend ( self . error_list )
return error_dict
def __iter__ ( self ) :pass
if hasattr ( self , '_STR:0_' ) :pass
for field , errors in self . error_dict . items ( ) :pass
yield field , list ( ValidationError ( errors ) )
if True: pass _newline_ else :pass
for error in self . error_list :pass
message = error . message
if error . params :pass
message %= error . params
yield force_text ( message )
def __str__ ( self ) :pass
if hasattr ( self , '_STR:0_' ) :pass
return repr ( dict ( self ) )
return repr ( list ( self ) )
def __repr__ ( self ) :pass
return '_STR:0_' % self
from django . core . files . base import File
__all__ = [ '_STR:0_' ]
from __future__ import unicode_literals
import os
from io import BytesIO , StringIO , UnsupportedOperation
from django . utils . encoding import smart_text
from django . core . files . utils import FileProxyMixin
from django . utils import six
from django . utils . encoding import force_bytes , python_2_unicode_compatible
@ python_2_unicode_compatible _newline_ def dummy(): pass
class File ( FileProxyMixin ) :pass
DEFAULT_CHUNK_SIZE = 64 * 2 ** 10
def __init__ ( self , file , name = None ) :pass
self . file = file
if name is None :pass
name = getattr ( file , '_STR:0_' , None )
self . name = name
if hasattr ( file , '_STR:0_' ) :pass
self . mode = file . mode
def __str__ ( self ) :pass
return smart_text ( self . name or '' )
def __repr__ ( self ) :pass
return "<%s: %s>" % ( self . __class__ . __name__ , self or "None" )
def __bool__ ( self ) :pass
return bool ( self . name )
def __nonzero__ ( self ) :pass
return type ( self ) . __bool__ ( self )
def __len__ ( self ) :pass
return self . size
def _get_size_from_underlying_file ( self ) :pass
if hasattr ( self . file , '_STR:0_' ) :pass
return self . file . size
if hasattr ( self . file , '_STR:0_' ) :pass
try :pass _newline_ except: pass
return os . path . getsize ( self . file . name )
try: pass _newline_ except ( OSError , TypeError ) :pass
pass
if hasattr ( self . file , '_STR:0_' ) and hasattr ( self . file , '_STR:1_' ) :pass
pos = self . file . tell ( )
self . file . seek ( 0 , os . SEEK_END )
size = self . file . tell ( )
self . file . seek ( pos )
return size
raise AttributeError ( '_STR:0_' )
def _get_size ( self ) :pass
if hasattr ( self , '_STR:0_' ) :pass
return self . _size
self . _size = self . _get_size_from_underlying_file ( )
return self . _size
def _set_size ( self , size ) :pass
self . _size = size
size = property ( _get_size , _set_size )
def _get_closed ( self ) :pass
return not self . file or self . file . closed
closed = property ( _get_closed )
def chunks ( self , chunk_size = None ) :pass
if not chunk_size :pass
chunk_size = self . DEFAULT_CHUNK_SIZE
try :pass _newline_ except: pass
self . seek ( 0 )
try: pass _newline_ except ( AttributeError , UnsupportedOperation ) :pass
pass
while True :pass
data = self . read ( chunk_size )
if not data :pass
break
yield data
def multiple_chunks ( self , chunk_size = None ) :pass
if not chunk_size :pass
chunk_size = self . DEFAULT_CHUNK_SIZE
return self . size > chunk_size
def __iter__ ( self ) :pass
buffer_ = None
for chunk in self . chunks ( ) :pass
chunk_buffer = BytesIO ( chunk )
for line in chunk_buffer :pass
if buffer_ :pass
line = buffer_ + line
buffer_ = None
if line [ - 1 : ] in ( b'\n' , b'\r' ) :pass
yield line
if True: pass _newline_ else :pass
buffer_ = line
if buffer_ is not None :pass
yield buffer_
def __enter__ ( self ) :pass
return self
def __exit__ ( self , exc_type , exc_value , tb ) :pass
self . close ( )
def open ( self , mode = None ) :pass
if not self . closed :pass
self . seek ( 0 )
if True: pass _newline_ elif self . name and os . path . exists ( self . name ) :pass
self . file = open ( self . name , mode or self . mode )
if True: pass _newline_ else :pass
raise ValueError ( '_STR:0_' )
def close ( self ) :pass
self . file . close ( )
@ python_2_unicode_compatible _newline_ def dummy(): pass
class ContentFile ( File ) :pass
def __init__ ( self , content , name = None ) :pass
if six . PY3 :pass
stream_class = StringIO if isinstance ( content , six . text_type ) else BytesIO
if True: pass _newline_ else :pass
stream_class = BytesIO
content = force_bytes ( content )
super ( ContentFile , self ) . __init__ ( stream_class ( content ) , name = name )
self . size = len ( content )
def __str__ ( self ) :pass
return '_STR:0_'
def __bool__ ( self ) :pass
return True
def __nonzero__ ( self ) :pass
return type ( self ) . __bool__ ( self )
def open ( self , mode = None ) :pass
self . seek ( 0 )
def close ( self ) :pass
pass
import zlib
from django . core . files import File
class ImageFile ( File ) :pass
def _get_width ( self ) :pass
return self . _get_image_dimensions ( ) [ 0 ]
width = property ( _get_width )
def _get_height ( self ) :pass
return self . _get_image_dimensions ( ) [ 1 ]
height = property ( _get_height )
def _get_image_dimensions ( self ) :pass
if not hasattr ( self , '_STR:0_' ) :pass
close = self . closed
self . open ( )
self . _dimensions_cache = get_image_dimensions ( self , close = close )
return self . _dimensions_cache
def get_image_dimensions ( file_or_path , close = False ) :pass
from PIL import ImageFile as PillowImageFile
p = PillowImageFile . Parser ( )
if hasattr ( file_or_path , '_STR:0_' ) :pass
file = file_or_path
file_pos = file . tell ( )
file . seek ( 0 )
if True: pass _newline_ else :pass
file = open ( file_or_path , 'rb' )
close = True
try :pass _newline_ except: pass
chunk_size = 1024
while 1 :pass
data = file . read ( chunk_size )
if not data :pass
break
try :pass _newline_ except: pass
p . feed ( data )
try: pass _newline_ except zlib . error as e :pass
if e . args [ 0 ] . startswith ( '_STR:0_' ) :pass
pass
if True: pass _newline_ else :pass
raise
if p . image :pass
return p . image . size
chunk_size *= 2
return None
try: pass _newline_ finally :pass
if close :pass
file . close ( )
if True: pass _newline_ else :pass
file . seek ( file_pos )
import os
__all__ = ( '_STR:0_' , '_STR:1_' , '_STR:2_' , '_STR:3_' , '_STR:4_' )
def _fd ( f ) :pass
return f . fileno ( ) if hasattr ( f , '_STR:0_' ) else f
if os . name == '_STR:0_' :pass
import msvcrt
from ctypes import ( sizeof , c_ulong , c_void_p , c_int64 ,  Structure , Union , POINTER , windll , byref )
from ctypes . wintypes import BOOL , DWORD , HANDLE
LOCK_SH = 0
LOCK_NB = 0x1
LOCK_EX = 0x2
if sizeof ( c_ulong ) != sizeof ( c_void_p ) :pass
ULONG_PTR = c_int64
if True: pass _newline_ else :pass
ULONG_PTR = c_ulong
PVOID = c_void_p
class _OFFSET ( Structure ) :pass
_fields_ = [  ( '_STR:0_' , DWORD ) ,  ( '_STR:1_' , DWORD ) ]
class _OFFSET_UNION ( Union ) :pass
_anonymous_ = [ '_STR:0_' ]
_fields_ = [  ( '_STR:0_' , _OFFSET ) ,  ( '_STR:1_' , PVOID ) ]
class OVERLAPPED ( Structure ) :pass
_anonymous_ = [ '_STR:0_' ]
_fields_ = [  ( '_STR:0_' , ULONG_PTR ) ,  ( 'InternalHigh' , ULONG_PTR ) ,  ( '_offset_union' , _OFFSET_UNION ) ,  ( 'hEvent' , HANDLE ) ]
LPOVERLAPPED = POINTER ( OVERLAPPED )
LockFileEx = windll . kernel32 . LockFileEx
LockFileEx . restype = BOOL
LockFileEx . argtypes = [ HANDLE , DWORD , DWORD , DWORD , DWORD , LPOVERLAPPED ]
UnlockFileEx = windll . kernel32 . UnlockFileEx
UnlockFileEx . restype = BOOL
UnlockFileEx . argtypes = [ HANDLE , DWORD , DWORD , DWORD , LPOVERLAPPED ]
def lock ( f , flags ) :pass
hfile = msvcrt . get_osfhandle ( _fd ( f ) )
overlapped = OVERLAPPED ( )
ret = LockFileEx ( hfile , flags , 0 , 0 , 0xFFFF0000 , byref ( overlapped ) )
return bool ( ret )
def unlock ( f ) :pass
hfile = msvcrt . get_osfhandle ( _fd ( f ) )
overlapped = OVERLAPPED ( )
ret = UnlockFileEx ( hfile , 0 , 0 , 0xFFFF0000 , byref ( overlapped ) )
return bool ( ret )
if True: pass _newline_ else :pass
try :pass _newline_ except: pass
import fcntl
LOCK_SH = fcntl . LOCK_SH
LOCK_NB = fcntl . LOCK_NB
LOCK_EX = fcntl . LOCK_EX
try: pass _newline_ except ( ImportError , AttributeError ) :pass
LOCK_EX = LOCK_SH = LOCK_NB = 0
def lock ( f , flags ) :pass
return False
def unlock ( f ) :pass
return True
if True: pass _newline_ else :pass
def lock ( f , flags ) :pass
ret = fcntl . flock ( _fd ( f ) , flags )
return ( ret == 0 )
def unlock ( f ) :pass
ret = fcntl . flock ( _fd ( f ) , fcntl . LOCK_UN )
return ( ret == 0 )
import os
from django . core . files import locks
try :pass _newline_ except: pass
from shutil import copystat
try: pass _newline_ except ImportError :pass
import stat
def copystat ( src , dst ) :pass
st = os . stat ( src )
mode = stat . S_IMODE ( st . st_mode )
if hasattr ( os , '_STR:0_' ) :pass
os . utime ( dst , ( st . st_atime , st . st_mtime ) )
if hasattr ( os , '_STR:0_' ) :pass
os . chmod ( dst , mode )
__all__ = [ '_STR:0_' ]
def _samefile ( src , dst ) :pass
if hasattr ( os . path , '_STR:0_' ) :pass
try :pass _newline_ except: pass
return os . path . samefile ( src , dst )
try: pass _newline_ except OSError :pass
return False
return ( os . path . normcase ( os . path . abspath ( src ) ) ==  os . path . normcase ( os . path . abspath ( dst ) ) )
def file_move_safe ( old_file_name , new_file_name , chunk_size = 1024 * 64 , allow_overwrite = False ) :pass
if _samefile ( old_file_name , new_file_name ) :pass
return
try :pass _newline_ except: pass
if not allow_overwrite and os . access ( new_file_name , os . F_OK ) :pass
raise IOError ( '_STR:0_' % new_file_name )
os . rename ( old_file_name , new_file_name )
return
try: pass _newline_ except OSError :pass
pass
with open ( old_file_name , 'rb' ) as old_file :pass
fd = os . open ( new_file_name , ( os . O_WRONLY | os . O_CREAT | getattr ( os , '_STR:0_' , 0 ) |  ( os . O_EXCL if not allow_overwrite else 0 ) ) )
try :pass _newline_ except: pass
locks . lock ( fd , locks . LOCK_EX )
current_chunk = None
while current_chunk != b'' :pass
current_chunk = old_file . read ( chunk_size )
os . write ( fd , current_chunk )
try: pass _newline_ finally :pass
locks . unlock ( fd )
os . close ( fd )
copystat ( old_file_name , new_file_name )
try :pass _newline_ except: pass
os . remove ( old_file_name )
try: pass _newline_ except OSError as e :pass
if getattr ( e , '_STR:0_' , 0 ) != 32 and getattr ( e , '_STR:1_' , 0 ) != 13 :pass
raise
import os
import errno
import itertools
from datetime import datetime
from django . conf import settings
from django . core . exceptions import SuspiciousFileOperation
from django . core . files import locks , File
from django . core . files . move import file_move_safe
from django . utils . encoding import force_text , filepath_to_uri
from django . utils . functional import LazyObject
from django . utils . module_loading import import_string
from django . utils . six . moves . urllib . parse import urljoin
from django . utils . text import get_valid_filename
from django . utils . _os import safe_join , abspathu
from django . utils . deconstruct import deconstructible
__all__ = ( '_STR:0_' , '_STR:1_' , '_STR:2_' , '_STR:3_' )
class Storage ( object ) :pass
def open ( self , name , mode = '_STR:0_' ) :pass
return self . _open ( name , mode )
def save ( self , name , content ) :pass
if name is None :pass
name = content . name
if not hasattr ( content , '_STR:0_' ) :pass
content = File ( content )
name = self . get_available_name ( name )
name = self . _save ( name , content )
return force_text ( name . replace ( '\\' , '/' ) )
def get_valid_name ( self , name ) :pass
return get_valid_filename ( name )
def get_available_name ( self , name ) :pass
dir_name , file_name = os . path . split ( name )
file_root , file_ext = os . path . splitext ( file_name )
count = itertools . count ( 1 )
while self . exists ( name ) :pass
name = os . path . join ( dir_name , '_STR:0_' % ( file_root , next ( count ) , file_ext ) )
return name
def path ( self , name ) :pass
raise NotImplementedError ( '_STR:0_' )
def delete ( self , name ) :pass
raise NotImplementedError ( '_STR:0_' )
def exists ( self , name ) :pass
raise NotImplementedError ( '_STR:0_' )
def listdir ( self , path ) :pass
raise NotImplementedError ( '_STR:0_' )
def size ( self , name ) :pass
raise NotImplementedError ( '_STR:0_' )
def url ( self , name ) :pass
raise NotImplementedError ( '_STR:0_' )
def accessed_time ( self , name ) :pass
raise NotImplementedError ( '_STR:0_' )
def created_time ( self , name ) :pass
raise NotImplementedError ( '_STR:0_' )
def modified_time ( self , name ) :pass
raise NotImplementedError ( '_STR:0_' )
@ deconstructible _newline_ def dummy(): pass
class FileSystemStorage ( Storage ) :pass
def __init__ ( self , location = None , base_url = None , file_permissions_mode = None ,  directory_permissions_mode = None ) :pass
if location is None :pass
location = settings . MEDIA_ROOT
self . base_location = location
self . location = abspathu ( self . base_location )
if base_url is None :pass
base_url = settings . MEDIA_URL
if True: pass _newline_ elif not base_url . endswith ( '_STR:0_' ) :pass
base_url += '_STR:0_'
self . base_url = base_url
self . file_permissions_mode = (  file_permissions_mode if file_permissions_mode is not None  else settings . FILE_UPLOAD_PERMISSIONS  )
self . directory_permissions_mode = (  directory_permissions_mode if directory_permissions_mode is not None  else settings . FILE_UPLOAD_DIRECTORY_PERMISSIONS  )
def _open ( self , name , mode = '_STR:0_' ) :pass
return File ( open ( self . path ( name ) , mode ) )
def _save ( self , name , content ) :pass
full_path = self . path ( name )
directory = os . path . dirname ( full_path )
if not os . path . exists ( directory ) :pass
try :pass _newline_ except: pass
if self . directory_permissions_mode is not None :pass
old_umask = os . umask ( 0 )
try :pass _newline_ except: pass
os . makedirs ( directory , self . directory_permissions_mode )
try: pass _newline_ finally :pass
os . umask ( old_umask )
if True: pass _newline_ else :pass
os . makedirs ( directory )
try: pass _newline_ except OSError as e :pass
if e . errno != errno . EEXIST :pass
raise
if not os . path . isdir ( directory ) :pass
raise IOError ( '_STR:0_' % directory )
while True :pass
try :pass _newline_ except: pass
if hasattr ( content , '_STR:0_' ) :pass
file_move_safe ( content . temporary_file_path ( ) , full_path )
if True: pass _newline_ else :pass
flags = ( os . O_WRONLY | os . O_CREAT | os . O_EXCL |  getattr ( os , 'O_BINARY' , 0 ) )
fd = os . open ( full_path , flags , 0o666 )
_file = None
try :pass _newline_ except: pass
locks . lock ( fd , locks . LOCK_EX )
for chunk in content . chunks ( ) :pass
if _file is None :pass
mode = '_STR:0_' if isinstance ( chunk , bytes ) else '_STR:1_'
_file = os . fdopen ( fd , mode )
_file . write ( chunk )
try: pass _newline_ finally :pass
locks . unlock ( fd )
if _file is not None :pass
_file . close ( )
if True: pass _newline_ else :pass
os . close ( fd )
try: pass _newline_ except OSError as e :pass
if e . errno == errno . EEXIST :pass
name = self . get_available_name ( name )
full_path = self . path ( name )
if True: pass _newline_ else :pass
raise
if True: pass _newline_ else :pass
break
if self . file_permissions_mode is not None :pass
os . chmod ( full_path , self . file_permissions_mode )
return name
def delete ( self , name ) :pass
assert name , '_STR:0_'
name = self . path ( name )
if os . path . exists ( name ) :pass
try :pass _newline_ except: pass
os . remove ( name )
try: pass _newline_ except OSError as e :pass
if e . errno != errno . ENOENT :pass
raise
def exists ( self , name ) :pass
return os . path . exists ( self . path ( name ) )
def listdir ( self , path ) :pass
path = self . path ( path )
directories , files = [ ] , [ ]
for entry in os . listdir ( path ) :pass
if os . path . isdir ( os . path . join ( path , entry ) ) :pass
directories . append ( entry )
if True: pass _newline_ else :pass
files . append ( entry )
return directories , files
def path ( self , name ) :pass
try :pass _newline_ except: pass
path = safe_join ( self . location , name )
try: pass _newline_ except ValueError :pass
raise SuspiciousFileOperation ( '_STR:0_' % name )
return os . path . normpath ( path )
def size ( self , name ) :pass
return os . path . getsize ( self . path ( name ) )
def url ( self , name ) :pass
if self . base_url is None :pass
raise ValueError ( '_STR:0_' )
return urljoin ( self . base_url , filepath_to_uri ( name ) )
def accessed_time ( self , name ) :pass
return datetime . fromtimestamp ( os . path . getatime ( self . path ( name ) ) )
def created_time ( self , name ) :pass
return datetime . fromtimestamp ( os . path . getctime ( self . path ( name ) ) )
def modified_time ( self , name ) :pass
return datetime . fromtimestamp ( os . path . getmtime ( self . path ( name ) ) )
def get_storage_class ( import_path = None ) :pass
return import_string ( import_path or settings . DEFAULT_FILE_STORAGE )
class DefaultStorage ( LazyObject ) :pass
def _setup ( self ) :pass
self . _wrapped = get_storage_class ( ) ( )
default_storage = DefaultStorage ( )
import os
import tempfile
from django . core . files . utils import FileProxyMixin
__all__ = ( '_STR:0_' , '_STR:1_' , )
if os . name == '_STR:0_' :pass
class TemporaryFile ( FileProxyMixin ) :pass
def __init__ ( self , mode = '_STR:0_' , bufsize = - 1 , suffix = '' , prefix = '' ,  dir = None ) :pass
fd , name = tempfile . mkstemp ( suffix = suffix , prefix = prefix , dir = dir )
self . name = name
self . file = os . fdopen ( fd , mode , bufsize )
self . close_called = False
unlink = os . unlink
def close ( self ) :pass
if not self . close_called :pass
self . close_called = True
try :pass _newline_ except: pass
self . file . close ( )
try: pass _newline_ except ( OSError , IOError ) :pass
pass
try :pass _newline_ except: pass
self . unlink ( self . name )
try: pass _newline_ except ( OSError ) :pass
pass
@ property _newline_ def dummy(): pass
def closed ( self ) :pass
return self . file . closed
def __del__ ( self ) :pass
self . close ( )
def __enter__ ( self ) :pass
self . file . __enter__ ( )
return self
def __exit__ ( self , exc , value , tb ) :pass
self . file . __exit__ ( exc , value , tb )
NamedTemporaryFile = TemporaryFile
if True: pass _newline_ else :pass
NamedTemporaryFile = tempfile . NamedTemporaryFile
gettempdir = tempfile . gettempdir
import errno
import os
from io import BytesIO
from django . conf import settings
from django . core . files . base import File
from django . core . files import temp as tempfile
from django . utils . encoding import force_str
__all__ = ( '_STR:0_' , '_STR:1_' , '_STR:2_' ,  '_STR:3_' )
class UploadedFile ( File ) :pass
DEFAULT_CHUNK_SIZE = 64 * 2 ** 10
def __init__ ( self , file = None , name = None , content_type = None , size = None , charset = None , content_type_extra = None ) :pass
super ( UploadedFile , self ) . __init__ ( file , name )
self . size = size
self . content_type = content_type
self . charset = charset
self . content_type_extra = content_type_extra
def __repr__ ( self ) :pass
return force_str ( '_STR:0_' % (  self . __class__ . __name__ , self . name , self . content_type ) )
def _get_name ( self ) :pass
return self . _name
def _set_name ( self , name ) :pass
if name is not None :pass
name = os . path . basename ( name )
if len ( name ) > 255 :pass
name , ext = os . path . splitext ( name )
ext = ext [ : 255 ]
name = name [ : 255 - len ( ext ) ] + ext
self . _name = name
name = property ( _get_name , _set_name )
class TemporaryUploadedFile ( UploadedFile ) :pass
def __init__ ( self , name , content_type , size , charset , content_type_extra = None ) :pass
if settings . FILE_UPLOAD_TEMP_DIR :pass
file = tempfile . NamedTemporaryFile ( suffix = '_STR:0_' ,  dir = settings . FILE_UPLOAD_TEMP_DIR )
if True: pass _newline_ else :pass
file = tempfile . NamedTemporaryFile ( suffix = '_STR:0_' )
super ( TemporaryUploadedFile , self ) . __init__ ( file , name , content_type , size , charset , content_type_extra )
def temporary_file_path ( self ) :pass
return self . file . name
def close ( self ) :pass
try :pass _newline_ except: pass
return self . file . close ( )
try: pass _newline_ except OSError as e :pass
if e . errno != errno . ENOENT :pass
raise
class InMemoryUploadedFile ( UploadedFile ) :pass
def __init__ ( self , file , field_name , name , content_type , size , charset , content_type_extra = None ) :pass
super ( InMemoryUploadedFile , self ) . __init__ ( file , name , content_type , size , charset , content_type_extra )
self . field_name = field_name
def open ( self , mode = None ) :pass
self . file . seek ( 0 )
def chunks ( self , chunk_size = None ) :pass
self . file . seek ( 0 )
yield self . read ( )
def multiple_chunks ( self , chunk_size = None ) :pass
return False
class SimpleUploadedFile ( InMemoryUploadedFile ) :pass
def __init__ ( self , name , content , content_type = '_STR:0_' ) :pass
content = content or b''
super ( SimpleUploadedFile , self ) . __init__ ( BytesIO ( content ) , None , name ,  content_type , len ( content ) , None , None )
@ classmethod _newline_ def dummy(): pass
def from_dict ( cls , file_dict ) :pass
return cls ( file_dict [ '_STR:0_' ] ,  file_dict [ '_STR:1_' ] ,  file_dict . get ( 'content-type' , 'text/plain' ) )
from __future__ import unicode_literals
from io import BytesIO
from django . conf import settings
from django . core . files . uploadedfile import TemporaryUploadedFile , InMemoryUploadedFile
from django . utils . encoding import python_2_unicode_compatible
from django . utils . module_loading import import_string
__all__ = [  '_STR:0_' , '_STR:1_' , '_STR:2_' , '_STR:3_' ,  'TemporaryFileUploadHandler' , 'MemoryFileUploadHandler' , 'load_handler' ,  'StopFutureHandlers'  ]
class UploadFileException ( Exception ) :pass
pass
@ python_2_unicode_compatible _newline_ def dummy(): pass
class StopUpload ( UploadFileException ) :pass
def __init__ ( self , connection_reset = False ) :pass
self . connection_reset = connection_reset
def __str__ ( self ) :pass
if self . connection_reset :pass
return '_STR:0_'
if True: pass _newline_ else :pass
return '_STR:0_'
class SkipFile ( UploadFileException ) :pass
pass
class StopFutureHandlers ( UploadFileException ) :pass
pass
class FileUploadHandler ( object ) :pass
chunk_size = 64 * 2 ** 10
def __init__ ( self , request = None ) :pass
self . file_name = None
self . content_type = None
self . content_length = None
self . charset = None
self . content_type_extra = None
self . request = request
def handle_raw_input ( self , input_data , META , content_length , boundary , encoding = None ) :pass
pass
def new_file ( self , field_name , file_name , content_type , content_length , charset = None , content_type_extra = None ) :pass
self . field_name = field_name
self . file_name = file_name
self . content_type = content_type
self . content_length = content_length
self . charset = charset
self . content_type_extra = content_type_extra
def receive_data_chunk ( self , raw_data , start ) :pass
raise NotImplementedError ( '_STR:0_' )
def file_complete ( self , file_size ) :pass
raise NotImplementedError ( '_STR:0_' )
def upload_complete ( self ) :pass
pass
class TemporaryFileUploadHandler ( FileUploadHandler ) :pass
def __init__ ( self , * args , ** kwargs ) :pass
super ( TemporaryFileUploadHandler , self ) . __init__ ( * args , ** kwargs )
def new_file ( self , file_name , * args , ** kwargs ) :pass
super ( TemporaryFileUploadHandler , self ) . new_file ( file_name , * args , ** kwargs )
self . file = TemporaryUploadedFile ( self . file_name , self . content_type , 0 , self . charset , self . content_type_extra )
def receive_data_chunk ( self , raw_data , start ) :pass
self . file . write ( raw_data )
def file_complete ( self , file_size ) :pass
self . file . seek ( 0 )
self . file . size = file_size
return self . file
class MemoryFileUploadHandler ( FileUploadHandler ) :pass
def handle_raw_input ( self , input_data , META , content_length , boundary , encoding = None ) :pass
if content_length > settings . FILE_UPLOAD_MAX_MEMORY_SIZE :pass
self . activated = False
if True: pass _newline_ else :pass
self . activated = True
def new_file ( self , * args , ** kwargs ) :pass
super ( MemoryFileUploadHandler , self ) . new_file ( * args , ** kwargs )
if self . activated :pass
self . file = BytesIO ( )
raise StopFutureHandlers ( )
def receive_data_chunk ( self , raw_data , start ) :pass
if self . activated :pass
self . file . write ( raw_data )
if True: pass _newline_ else :pass
return raw_data
def file_complete ( self , file_size ) :pass
if not self . activated :pass
return
self . file . seek ( 0 )
return InMemoryUploadedFile (  file = self . file ,  field_name = self . field_name ,  name = self . file_name ,  content_type = self . content_type ,  size = file_size ,  charset = self . charset ,  content_type_extra = self . content_type_extra  )
def load_handler ( path , * args , ** kwargs ) :pass
return import_string ( path ) ( * args , ** kwargs )
class FileProxyMixin ( object ) :pass
encoding = property ( lambda self : self . file . encoding )
fileno = property ( lambda self : self . file . fileno )
flush = property ( lambda self : self . file . flush )
isatty = property ( lambda self : self . file . isatty )
newlines = property ( lambda self : self . file . newlines )
read = property ( lambda self : self . file . read )
readinto = property ( lambda self : self . file . readinto )
readline = property ( lambda self : self . file . readline )
readlines = property ( lambda self : self . file . readlines )
seek = property ( lambda self : self . file . seek )
softspace = property ( lambda self : self . file . softspace )
tell = property ( lambda self : self . file . tell )
truncate = property ( lambda self : self . file . truncate )
write = property ( lambda self : self . file . write )
writelines = property ( lambda self : self . file . writelines )
xreadlines = property ( lambda self : self . file . xreadlines )
def __iter__ ( self ) :pass
return iter ( self . file )
from __future__ import unicode_literals
import logging
import sys
import types
from django import http
from django . conf import settings
from django . core import urlresolvers
from django . core import signals
from django . core . exceptions import MiddlewareNotUsed , PermissionDenied , SuspiciousOperation
from django . db import connections , transaction
from django . utils . encoding import force_text
from django . utils . module_loading import import_string
from django . utils import six
from django . views import debug
logger = logging . getLogger ( '_STR:0_' )
class BaseHandler ( object ) :pass
response_fixes = [  http . fix_location_header ,  http . conditional_content_removal ,  ]
def __init__ ( self ) :pass
self . _request_middleware = self . _view_middleware = self . _template_response_middleware = self . _response_middleware = self . _exception_middleware = None
def load_middleware ( self ) :pass
self . _view_middleware = [ ]
self . _template_response_middleware = [ ]
self . _response_middleware = [ ]
self . _exception_middleware = [ ]
request_middleware = [ ]
for middleware_path in settings . MIDDLEWARE_CLASSES :pass
mw_class = import_string ( middleware_path )
try :pass _newline_ except: pass
mw_instance = mw_class ( )
try: pass _newline_ except MiddlewareNotUsed :pass
continue
if hasattr ( mw_instance , '_STR:0_' ) :pass
request_middleware . append ( mw_instance . process_request )
if hasattr ( mw_instance , '_STR:0_' ) :pass
self . _view_middleware . append ( mw_instance . process_view )
if hasattr ( mw_instance , '_STR:0_' ) :pass
self . _template_response_middleware . insert ( 0 , mw_instance . process_template_response )
if hasattr ( mw_instance , '_STR:0_' ) :pass
self . _response_middleware . insert ( 0 , mw_instance . process_response )
if hasattr ( mw_instance , '_STR:0_' ) :pass
self . _exception_middleware . insert ( 0 , mw_instance . process_exception )
self . _request_middleware = request_middleware
def make_view_atomic ( self , view ) :pass
non_atomic_requests = getattr ( view , '_STR:0_' , set ( ) )
for db in connections . all ( ) :pass
if ( db . settings_dict [ 'ATOMIC_REQUESTS' ]  and db . alias not in non_atomic_requests ) :pass
view = transaction . atomic ( using = db . alias ) ( view )
return view
def get_exception_response ( self , request , resolver , status_code ) :pass
try :pass _newline_ except: pass
callback , param_dict = resolver . resolve_error_handler ( status_code )
response = callback ( request , ** param_dict )
try: pass _newline_ except :pass
signals . got_request_exception . send ( sender = self . __class__ , request = request )
response = self . handle_uncaught_exception ( request , resolver , sys . exc_info ( ) )
return response
def get_response ( self , request ) :pass
urlconf = settings . ROOT_URLCONF
urlresolvers . set_urlconf ( urlconf )
resolver = urlresolvers . RegexURLResolver ( r'_STR:0_' , urlconf )
try :pass _newline_ except: pass
response = None
for middleware_method in self . _request_middleware :pass
response = middleware_method ( request )
if response :pass
break
if response is None :pass
if hasattr ( request , '_STR:0_' ) :pass
urlconf = request . urlconf
urlresolvers . set_urlconf ( urlconf )
resolver = urlresolvers . RegexURLResolver ( r'_STR:0_' , urlconf )
resolver_match = resolver . resolve ( request . path_info )
callback , callback_args , callback_kwargs = resolver_match
request . resolver_match = resolver_match
for middleware_method in self . _view_middleware :pass
response = middleware_method ( request , callback , callback_args , callback_kwargs )
if response :pass
break
if response is None :pass
wrapped_callback = self . make_view_atomic ( callback )
try :pass _newline_ except: pass
response = wrapped_callback ( request , * callback_args , ** callback_kwargs )
try: pass _newline_ except Exception as e :pass
for middleware_method in self . _exception_middleware :pass
response = middleware_method ( request , e )
if response :pass
break
if response is None :pass
raise
if response is None :pass
if isinstance ( callback , types . FunctionType ) :pass
view_name = callback . __name__
if True: pass _newline_ else :pass
view_name = callback . __class__ . __name__ + '_STR:0_'
raise ValueError ( '_STR:0_'  % ( callback . __module__ , view_name ) )
if hasattr ( response , '_STR:0_' ) and callable ( response . render ) :pass
for middleware_method in self . _template_response_middleware :pass
response = middleware_method ( request , response )
if response is None :pass
raise ValueError (  "%s.process_template_response didn't return an "  "HttpResponse object. It returned None instead."  % ( middleware_method . __self__ . __class__ . __name__ ) )
response = response . render ( )
try: pass _newline_ except http . Http404 as e :pass
logger . warning ( '_STR:0_' , request . path ,  extra = {  '_STR:1_' : 404 ,  'request' : request  } )
if settings . DEBUG :pass
response = debug . technical_404_response ( request , e )
if True: pass _newline_ else :pass
response = self . get_exception_response ( request , resolver , 404 )
try: pass _newline_ except PermissionDenied :pass
logger . warning (  '_STR:0_' , request . path ,  extra = {  'status_code' : 403 ,  'request' : request  } )
response = self . get_exception_response ( request , resolver , 403 )
try: pass _newline_ except SuspiciousOperation as e :pass
security_logger = logging . getLogger ( '_STR:0_' %  e . __class__ . __name__ )
security_logger . error (  force_text ( e ) ,  extra = {  'status_code' : 400 ,  'request' : request  } )
if settings . DEBUG :pass
return debug . technical_500_response ( request , * sys . exc_info ( ) , status_code = 400 )
response = self . get_exception_response ( request , resolver , 400 )
try: pass _newline_ except SystemExit :pass
raise
try: pass _newline_ except :pass
signals . got_request_exception . send ( sender = self . __class__ , request = request )
response = self . handle_uncaught_exception ( request , resolver , sys . exc_info ( ) )
try :pass _newline_ except: pass
for middleware_method in self . _response_middleware :pass
response = middleware_method ( request , response )
if response is None :pass
raise ValueError (  "%s.process_response didn't return an "  "HttpResponse object. It returned None instead."  % ( middleware_method . __self__ . __class__ . __name__ ) )
response = self . apply_response_fixes ( request , response )
try: pass _newline_ except :pass
signals . got_request_exception . send ( sender = self . __class__ , request = request )
response = self . handle_uncaught_exception ( request , resolver , sys . exc_info ( ) )
response . _closable_objects . append ( request )
return response
def handle_uncaught_exception ( self , request , resolver , exc_info ) :pass
if settings . DEBUG_PROPAGATE_EXCEPTIONS :pass
raise
logger . error ( '_STR:0_' , request . path ,  exc_info = exc_info ,  extra = {  'status_code' : 500 ,  'request' : request  }  )
if settings . DEBUG :pass
return debug . technical_500_response ( request , * exc_info )
if resolver . urlconf_module is None :pass
six . reraise ( * exc_info )
callback , param_dict = resolver . resolve_error_handler ( 500 )
return callback ( request , ** param_dict )
def apply_response_fixes ( self , request , response ) :pass
for func in self . response_fixes :pass
response = func ( request , response )
return response
from __future__ import unicode_literals
import cgi
import codecs
import logging
import sys
from io import BytesIO
from threading import Lock
import warnings
from django import http
from django . conf import settings
from django . core import signals
from django . core . handlers import base
from django . core . urlresolvers import set_script_prefix
from django . utils import datastructures
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils . encoding import force_str , force_text
from django . utils . functional import cached_property
from django . utils import six
from django . http . response import REASON_PHRASES as STATUS_CODE_TEXT
logger = logging . getLogger ( '_STR:0_' )
ISO_8859_1 , UTF_8 = str ( '_STR:0_' ) , str ( '_STR:1_' )
class LimitedStream ( object ) :pass
def __init__ ( self , stream , limit , buf_size = 64 * 1024 * 1024 ) :pass
self . stream = stream
self . remaining = limit
self . buffer = b''
self . buf_size = buf_size
def _read_limited ( self , size = None ) :pass
if size is None or size > self . remaining :pass
size = self . remaining
if size == 0 :pass
return b''
result = self . stream . read ( size )
self . remaining -= len ( result )
return result
def read ( self , size = None ) :pass
if size is None :pass
result = self . buffer + self . _read_limited ( )
self . buffer = b''
if True: pass _newline_ elif size < len ( self . buffer ) :pass
result = self . buffer [ : size ]
self . buffer = self . buffer [ size : ]
if True: pass _newline_ else :pass
result = self . buffer + self . _read_limited ( size - len ( self . buffer ) )
self . buffer = b''
return result
def readline ( self , size = None ) :pass
while b'\n' not in self . buffer and ( size is None or len ( self . buffer ) < size ) :pass
if size :pass
chunk = self . _read_limited ( size - len ( self . buffer ) )
if True: pass _newline_ else :pass
chunk = self . _read_limited ( )
if not chunk :pass
break
self . buffer += chunk
sio = BytesIO ( self . buffer )
if size :pass
line = sio . readline ( size )
if True: pass _newline_ else :pass
line = sio . readline ( )
self . buffer = sio . read ( )
return line
class WSGIRequest ( http . HttpRequest ) :pass
def __init__ ( self , environ ) :pass
script_name = get_script_name ( environ )
path_info = get_path_info ( environ )
if not path_info :pass
path_info = '_STR:0_'
self . environ = environ
self . path_info = path_info
self . path = '%s/%s' % ( script_name . rstrip ( '_STR:0_' ) ,  path_info . replace ( '_STR:0_' , '' , 1 ) )
self . META = environ
self . META [ '_STR:0_' ] = path_info
self . META [ 'SCRIPT_NAME' ] = script_name
self . method = environ [ '_STR:0_' ] . upper ( )
_ , content_params = cgi . parse_header ( environ . get ( '_STR:0_' , '' ) )
if '_STR:0_' in content_params :pass
try :pass _newline_ except: pass
codecs . lookup ( content_params [ '_STR:0_' ] )
try: pass _newline_ except LookupError :pass
pass
if True: pass _newline_ else :pass
self . encoding = content_params [ '_STR:0_' ]
self . _post_parse_error = False
try :pass _newline_ except: pass
content_length = int ( environ . get ( '_STR:0_' ) )
try: pass _newline_ except ( ValueError , TypeError ) :pass
content_length = 0
self . _stream = LimitedStream ( self . environ [ '_STR:0_' ] , content_length )
self . _read_started = False
self . resolver_match = None
def _get_scheme ( self ) :pass
return self . environ . get ( '_STR:0_' )
def _get_request ( self ) :pass
warnings . warn ( '`request.REQUEST` is deprecated, use `request.GET` or '  '`request.POST` instead.' , RemovedInDjango19Warning , 2 )
if not hasattr ( self , '_STR:0_' ) :pass
self . _request = datastructures . MergeDict ( self . POST , self . GET )
return self . _request
@ cached_property _newline_ def dummy(): pass
def GET ( self ) :pass
raw_query_string = get_bytes_from_wsgi ( self . environ , '_STR:0_' , '' )
return http . QueryDict ( raw_query_string , encoding = self . _encoding )
def _get_post ( self ) :pass
if not hasattr ( self , '_STR:0_' ) :pass
self . _load_post_and_files ( )
return self . _post
def _set_post ( self , post ) :pass
self . _post = post
@ cached_property _newline_ def dummy(): pass
def COOKIES ( self ) :pass
raw_cookie = get_str_from_wsgi ( self . environ , '_STR:0_' , '' )
return http . parse_cookie ( raw_cookie )
def _get_files ( self ) :pass
if not hasattr ( self , '_STR:0_' ) :pass
self . _load_post_and_files ( )
return self . _files
POST = property ( _get_post , _set_post )
FILES = property ( _get_files )
REQUEST = property ( _get_request )
class WSGIHandler ( base . BaseHandler ) :pass
initLock = Lock ( )
request_class = WSGIRequest
def __call__ ( self , environ , start_response ) :pass
if self . _request_middleware is None :pass
with self . initLock :pass
try :pass _newline_ except: pass
if self . _request_middleware is None :pass
self . load_middleware ( )
try: pass _newline_ except :pass
self . _request_middleware = None
raise
set_script_prefix ( get_script_name ( environ ) )
signals . request_started . send ( sender = self . __class__ )
try :pass _newline_ except: pass
request = self . request_class ( environ )
try: pass _newline_ except UnicodeDecodeError :pass
logger . warning ( '_STR:0_' ,  exc_info = sys . exc_info ( ) ,  extra = {  'status_code' : 400 ,  }  )
response = http . HttpResponseBadRequest ( )
if True: pass _newline_ else :pass
response = self . get_response ( request )
response . _handler_class = self . __class__
status = '_STR:0_' % ( response . status_code , response . reason_phrase )
response_headers = [ ( str ( k ) , str ( v ) ) for k , v in response . items ( ) ]
for c in response . cookies . values ( ) :pass
response_headers . append ( ( str ( '_STR:0_' ) , str ( c . output ( header = '_STR:1_' ) ) ) )
start_response ( force_str ( status ) , response_headers )
return response
def get_path_info ( environ ) :pass
path_info = get_bytes_from_wsgi ( environ , '_STR:0_' , '_STR:1_' )
return path_info . decode ( UTF_8 )
def get_script_name ( environ ) :pass
if settings . FORCE_SCRIPT_NAME is not None :pass
return force_text ( settings . FORCE_SCRIPT_NAME )
script_url = get_bytes_from_wsgi ( environ , '_STR:0_' , '' )
if not script_url :pass
script_url = get_bytes_from_wsgi ( environ , '_STR:0_' , '' )
if script_url :pass
path_info = get_bytes_from_wsgi ( environ , '_STR:0_' , '' )
script_name = script_url [ : - len ( path_info ) ]
if True: pass _newline_ else :pass
script_name = get_bytes_from_wsgi ( environ , '_STR:0_' , '' )
return script_name . decode ( UTF_8 )
def get_bytes_from_wsgi ( environ , key , default ) :pass
value = environ . get ( str ( key ) , str ( default ) )
return value if six . PY2 else value . encode ( ISO_8859_1 )
def get_str_from_wsgi ( environ , key , default ) :pass
value = environ . get ( str ( key ) , str ( default ) )
return value if six . PY2 else value . encode ( ISO_8859_1 ) . decode ( UTF_8 )
from __future__ import unicode_literals
from django . conf import settings
from django . utils . module_loading import import_string
from django . core . mail . utils import CachedDnsName , DNS_NAME
from django . core . mail . message import (  EmailMessage , EmailMultiAlternatives ,  SafeMIMEText , SafeMIMEMultipart ,  DEFAULT_ATTACHMENT_MIME_TYPE , make_msgid ,  BadHeaderError , forbid_multi_line_headers )
__all__ = [  '_STR:0_' , '_STR:1_' , '_STR:2_' , '_STR:3_' ,  '_STR:4_' , 'SafeMIMEMultipart' , 'DEFAULT_ATTACHMENT_MIME_TYPE' ,  'make_msgid' , 'BadHeaderError' , 'forbid_multi_line_headers' ,  'get_connection' , 'send_mail' , 'send_mass_mail' , 'mail_admins' ,  'mail_managers' ,  ]
def get_connection ( backend = None , fail_silently = False , ** kwds ) :pass
klass = import_string ( backend or settings . EMAIL_BACKEND )
return klass ( fail_silently = fail_silently , ** kwds )
def send_mail ( subject , message , from_email , recipient_list ,  fail_silently = False , auth_user = None , auth_password = None ,  connection = None , html_message = None ) :pass
connection = connection or get_connection ( username = auth_user ,  password = auth_password ,  fail_silently = fail_silently )
mail = EmailMultiAlternatives ( subject , message , from_email , recipient_list ,  connection = connection )
if html_message :pass
mail . attach_alternative ( html_message , '_STR:0_' )
return mail . send ( )
def send_mass_mail ( datatuple , fail_silently = False , auth_user = None ,  auth_password = None , connection = None ) :pass
connection = connection or get_connection ( username = auth_user ,  password = auth_password ,  fail_silently = fail_silently )
messages = [ EmailMessage ( subject , message , sender , recipient ,  connection = connection )  for subject , message , sender , recipient in datatuple ]
return connection . send_messages ( messages )
def mail_admins ( subject , message , fail_silently = False , connection = None ,  html_message = None ) :pass
if not settings . ADMINS :pass
return
mail = EmailMultiAlternatives ( '%s%s' % ( settings . EMAIL_SUBJECT_PREFIX , subject ) ,  message , settings . SERVER_EMAIL , [ a [ 1 ] for a in settings . ADMINS ] ,  connection = connection )
if html_message :pass
mail . attach_alternative ( html_message , 'text/html' )
mail . send ( fail_silently = fail_silently )
def mail_managers ( subject , message , fail_silently = False , connection = None ,  html_message = None ) :pass
if not settings . MANAGERS :pass
return
mail = EmailMultiAlternatives ( '%s%s' % ( settings . EMAIL_SUBJECT_PREFIX , subject ) ,  message , settings . SERVER_EMAIL , [ a [ 1 ] for a in settings . MANAGERS ] ,  connection = connection )
if html_message :pass
mail . attach_alternative ( html_message , '_STR:0_' )
mail . send ( fail_silently = fail_silently )
class BaseEmailBackend ( object ) :pass
def __init__ ( self , fail_silently = False , ** kwargs ) :pass
self . fail_silently = fail_silently
def open ( self ) :pass
pass
def close ( self ) :pass
pass
def __enter__ ( self ) :pass
self . open ( )
return self
def __exit__ ( self , exc_type , exc_value , traceback ) :pass
self . close ( )
def send_messages ( self , email_messages ) :pass
raise NotImplementedError ( '_STR:0_' )
import sys
import threading
from django . core . mail . backends . base import BaseEmailBackend
from django . utils import six
class EmailBackend ( BaseEmailBackend ) :pass
def __init__ ( self , * args , ** kwargs ) :pass
self . stream = kwargs . pop ( '_STR:0_' , sys . stdout )
self . _lock = threading . RLock ( )
super ( EmailBackend , self ) . __init__ ( * args , ** kwargs )
def write_message ( self , message ) :pass
msg = message . message ( )
msg_data = msg . as_bytes ( )
if six . PY3 :pass
charset = msg . get_charset ( ) . get_output_charset ( ) if msg . get_charset ( ) else '_STR:0_'
msg_data = msg_data . decode ( charset )
self . stream . write ( '_STR:0_' % msg_data )
self . stream . write ( '_STR:0_' * 79 )
self . stream . write ( '\n' )
def send_messages ( self , email_messages ) :pass
if not email_messages :pass
return
msg_count = 0
with self . _lock :pass
try :pass _newline_ except: pass
stream_created = self . open ( )
for message in email_messages :pass
self . write_message ( message )
self . stream . flush ( )
msg_count += 1
if stream_created :pass
self . close ( )
try: pass _newline_ except Exception :pass
if not self . fail_silently :pass
raise
return msg_count
from django . core . mail . backends . base import BaseEmailBackend
class EmailBackend ( BaseEmailBackend ) :pass
def send_messages ( self , email_messages ) :pass
return len ( list ( email_messages ) )
import datetime
import os
from django . conf import settings
from django . core . exceptions import ImproperlyConfigured
from django . core . mail . backends . console import EmailBackend as ConsoleEmailBackend
from django . utils import six
class EmailBackend ( ConsoleEmailBackend ) :pass
def __init__ ( self , * args , ** kwargs ) :pass
self . _fname = None
if '_STR:0_' in kwargs :pass
self . file_path = kwargs . pop ( '_STR:0_' )
if True: pass _newline_ else :pass
self . file_path = getattr ( settings , '_STR:0_' , None )
if not isinstance ( self . file_path , six . string_types ) :pass
raise ImproperlyConfigured ( '_STR:0_' % self . file_path )
self . file_path = os . path . abspath ( self . file_path )
if os . path . exists ( self . file_path ) and not os . path . isdir ( self . file_path ) :pass
raise ImproperlyConfigured ( '_STR:0_' % self . file_path )
if True: pass _newline_ elif not os . path . exists ( self . file_path ) :pass
try :pass _newline_ except: pass
os . makedirs ( self . file_path )
try: pass _newline_ except OSError as err :pass
raise ImproperlyConfigured ( '_STR:0_' % ( self . file_path , err ) )
if not os . access ( self . file_path , os . W_OK ) :pass
raise ImproperlyConfigured ( '_STR:0_' % self . file_path )
kwargs [ '_STR:0_' ] = None
super ( EmailBackend , self ) . __init__ ( * args , ** kwargs )
def write_message ( self , message ) :pass
self . stream . write ( message . message ( ) . as_bytes ( ) + b'_STR:0_' )
self . stream . write ( b'_STR:0_' * 79 )
self . stream . write ( b'\n' )
def _get_filename ( self ) :pass
if self . _fname is None :pass
timestamp = datetime . datetime . now ( ) . strftime ( '_STR:0_' )
fname = '_STR:0_' % ( timestamp , abs ( id ( self ) ) )
self . _fname = os . path . join ( self . file_path , fname )
return self . _fname
def open ( self ) :pass
if self . stream is None :pass
self . stream = open ( self . _get_filename ( ) , '_STR:0_' )
return True
return False
def close ( self ) :pass
try :pass _newline_ except: pass
if self . stream is not None :pass
self . stream . close ( )
try: pass _newline_ finally :pass
self . stream = None
from django . core import mail
from django . core . mail . backends . base import BaseEmailBackend
class EmailBackend ( BaseEmailBackend ) :pass
def __init__ ( self , * args , ** kwargs ) :pass
super ( EmailBackend , self ) . __init__ ( * args , ** kwargs )
if not hasattr ( mail , '_STR:0_' ) :pass
mail . outbox = [ ]
def send_messages ( self , messages ) :pass
msg_count = 0
for message in messages :pass
message . message ( )
msg_count += 1
mail . outbox . extend ( messages )
return msg_count
import smtplib
import ssl
import threading
from django . conf import settings
from django . core . mail . backends . base import BaseEmailBackend
from django . core . mail . utils import DNS_NAME
from django . core . mail . message import sanitize_address
class EmailBackend ( BaseEmailBackend ) :pass
def __init__ ( self , host = None , port = None , username = None , password = None ,  use_tls = None , fail_silently = False , use_ssl = None , timeout = None ,  ** kwargs ) :pass
super ( EmailBackend , self ) . __init__ ( fail_silently = fail_silently )
self . host = host or settings . EMAIL_HOST
self . port = port or settings . EMAIL_PORT
self . username = settings . EMAIL_HOST_USER if username is None else username
self . password = settings . EMAIL_HOST_PASSWORD if password is None else password
self . use_tls = settings . EMAIL_USE_TLS if use_tls is None else use_tls
self . use_ssl = settings . EMAIL_USE_SSL if use_ssl is None else use_ssl
self . timeout = timeout
if self . use_ssl and self . use_tls :pass
raise ValueError (  "EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set "  "one of those settings to True." )
self . connection = None
self . _lock = threading . RLock ( )
def open ( self ) :pass
if self . connection :pass
return False
connection_class = smtplib . SMTP_SSL if self . use_ssl else smtplib . SMTP
connection_params = { '_STR:0_' : DNS_NAME . get_fqdn ( ) }
if self . timeout is not None :pass
connection_params [ '_STR:0_' ] = self . timeout
try :pass _newline_ except: pass
self . connection = connection_class ( self . host , self . port , ** connection_params )
if not self . use_ssl and self . use_tls :pass
self . connection . ehlo ( )
self . connection . starttls ( )
self . connection . ehlo ( )
if self . username and self . password :pass
self . connection . login ( self . username , self . password )
return True
try: pass _newline_ except smtplib . SMTPException :pass
if not self . fail_silently :pass
raise
def close ( self ) :pass
if self . connection is None :pass
return
try :pass _newline_ except: pass
try :pass _newline_ except: pass
self . connection . quit ( )
try: pass _newline_ except ( ssl . SSLError , smtplib . SMTPServerDisconnected ) :pass
self . connection . close ( )
try: pass _newline_ except smtplib . SMTPException :pass
if self . fail_silently :pass
return
raise
try: pass _newline_ finally :pass
self . connection = None
def send_messages ( self , email_messages ) :pass
if not email_messages :pass
return
with self . _lock :pass
new_conn_created = self . open ( )
if not self . connection :pass
return
num_sent = 0
for message in email_messages :pass
sent = self . _send ( message )
if sent :pass
num_sent += 1
if new_conn_created :pass
self . close ( )
return num_sent
def _send ( self , email_message ) :pass
if not email_message . recipients ( ) :pass
return False
from_email = sanitize_address ( email_message . from_email , email_message . encoding )
recipients = [ sanitize_address ( addr , email_message . encoding )  for addr in email_message . recipients ( ) ]
message = email_message . message ( )
try :pass _newline_ except: pass
self . connection . sendmail ( from_email , recipients , message . as_bytes ( ) )
try: pass _newline_ except smtplib . SMTPException :pass
if not self . fail_silently :pass
raise
return False
return True
from __future__ import unicode_literals
import mimetypes
import os
import random
import sys
import time
from email import ( charset as Charset , encoders as Encoders ,  message_from_string , generator )
from email . message import Message
from email . mime . text import MIMEText
from email . mime . multipart import MIMEMultipart
from email . mime . base import MIMEBase
from email . mime . message import MIMEMessage
from email . header import Header
from email . utils import formatdate , getaddresses , formataddr , parseaddr
from django . conf import settings
from django . core . mail . utils import DNS_NAME
from django . utils . encoding import force_text
from django . utils import six
utf8_charset = Charset . Charset ( '_STR:0_' )
utf8_charset . body_encoding = None
DEFAULT_ATTACHMENT_MIME_TYPE = '_STR:0_'
class BadHeaderError ( ValueError ) :pass
pass
def make_msgid ( idstring = None ) :pass
timeval = time . time ( )
utcdate = time . strftime ( '_STR:0_' , time . gmtime ( timeval ) )
try :pass _newline_ except: pass
pid = os . getpid ( )
try: pass _newline_ except AttributeError :pass
pid = 1
randint = random . randrange ( 100000 )
if idstring is None :pass
idstring = ''
if True: pass _newline_ else :pass
idstring = '_STR:0_' + idstring
idhost = DNS_NAME
msgid = '_STR:0_' % ( utcdate , pid , randint , idstring , idhost )
return msgid
ADDRESS_HEADERS = set ( [  '_STR:0_' ,  '_STR:1_' ,  '_STR:2_' ,  '_STR:3_' ,  '_STR:4_' ,  '_STR:5_' ,  '_STR:6_' ,  '_STR:7_' ,  'resent-to' ,  'resent-cc' ,  'resent-bcc' ,  ] )
def forbid_multi_line_headers ( name , val , encoding ) :pass
encoding = encoding or settings . DEFAULT_CHARSET
val = force_text ( val )
if '_STR:0_' in val or '_STR:1_' in val :pass
raise BadHeaderError ( '_STR:0_' % ( val , name ) )
try :pass _newline_ except: pass
val . encode ( '_STR:0_' )
try: pass _newline_ except UnicodeEncodeError :pass
if name . lower ( ) in ADDRESS_HEADERS :pass
val = '_STR:0_' . join ( sanitize_address ( addr , encoding )  for addr in getaddresses ( ( val , ) ) )
if True: pass _newline_ else :pass
val = Header ( val , encoding ) . encode ( )
if True: pass _newline_ else :pass
if name . lower ( ) == '_STR:0_' :pass
val = Header ( val ) . encode ( )
return str ( name ) , val
def sanitize_address ( addr , encoding ) :pass
if isinstance ( addr , six . string_types ) :pass
addr = parseaddr ( force_text ( addr ) )
nm , addr = addr
try :pass _newline_ except: pass
nm = Header ( nm , encoding ) . encode ( )
try: pass _newline_ except UnicodeEncodeError :pass
nm = Header ( nm , '_STR:0_' ) . encode ( )
try :pass _newline_ except: pass
addr . encode ( '_STR:0_' )
try: pass _newline_ except UnicodeEncodeError :pass
if '_STR:0_' in addr :pass
localpart , domain = addr . split ( '_STR:0_' , 1 )
localpart = str ( Header ( localpart , encoding ) )
domain = domain . encode ( '_STR:1_' ) . decode ( '_STR:0_' )
addr = '_STR:0_' . join ( [ localpart , domain ] )
if True: pass _newline_ else :pass
addr = Header ( addr , encoding ) . encode ( )
return formataddr ( ( nm , addr ) )
class MIMEMixin ( ) :pass
def as_string ( self , unixfrom = False ) :pass
fp = six . StringIO ( )
g = generator . Generator ( fp , mangle_from_ = False )
g . flatten ( self , unixfrom = unixfrom )
return fp . getvalue ( )
if six . PY2 :pass
as_bytes = as_string
if True: pass _newline_ else :pass
def as_bytes ( self , unixfrom = False ) :pass
fp = six . BytesIO ( )
g = generator . BytesGenerator ( fp , mangle_from_ = False )
g . flatten ( self , unixfrom = unixfrom )
return fp . getvalue ( )
class SafeMIMEMessage ( MIMEMixin , MIMEMessage ) :pass
def __setitem__ ( self , name , val ) :pass
name , val = forbid_multi_line_headers ( name , val , '_STR:0_' )
MIMEMessage . __setitem__ ( self , name , val )
class SafeMIMEText ( MIMEMixin , MIMEText ) :pass
def __init__ ( self , text , subtype , charset ) :pass
self . encoding = charset
if charset == '_STR:0_' :pass
MIMEText . __init__ ( self , text , subtype , None )
del self [ '_STR:0_' ]
if ( 3 , 2 ) < sys . version_info < ( 3 , 3 , 4 ) :pass
payload = text . encode ( utf8_charset . output_charset )
self . _payload = payload . decode ( '_STR:0_' , '_STR:1_' )
self . set_charset ( utf8_charset )
if True: pass _newline_ else :pass
self . set_payload ( text , utf8_charset )
self . replace_header ( '_STR:0_' , '_STR:1_' % ( subtype , charset ) )
if True: pass _newline_ else :pass
MIMEText . __init__ ( self , text , subtype , charset )
def __setitem__ ( self , name , val ) :pass
name , val = forbid_multi_line_headers ( name , val , self . encoding )
MIMEText . __setitem__ ( self , name , val )
class SafeMIMEMultipart ( MIMEMixin , MIMEMultipart ) :pass
def __init__ ( self , _subtype = '_STR:0_' , boundary = None , _subparts = None , encoding = None , ** _params ) :pass
self . encoding = encoding
MIMEMultipart . __init__ ( self , _subtype , boundary , _subparts , ** _params )
def __setitem__ ( self , name , val ) :pass
name , val = forbid_multi_line_headers ( name , val , self . encoding )
MIMEMultipart . __setitem__ ( self , name , val )
class EmailMessage ( object ) :pass
content_subtype = '_STR:0_'
mixed_subtype = '_STR:0_'
encoding = None
def __init__ ( self , subject = '' , body = '' , from_email = None , to = None , bcc = None ,  connection = None , attachments = None , headers = None , cc = None ) :pass
if to :pass
assert not isinstance ( to , six . string_types ) , '_STR:0_'
self . to = list ( to )
if True: pass _newline_ else :pass
self . to = [ ]
if cc :pass
assert not isinstance ( cc , six . string_types ) , '_STR:0_'
self . cc = list ( cc )
if True: pass _newline_ else :pass
self . cc = [ ]
if bcc :pass
assert not isinstance ( bcc , six . string_types ) , '_STR:0_'
self . bcc = list ( bcc )
if True: pass _newline_ else :pass
self . bcc = [ ]
self . from_email = from_email or settings . DEFAULT_FROM_EMAIL
self . subject = subject
self . body = body
self . attachments = attachments or [ ]
self . extra_headers = headers or { }
self . connection = connection
def get_connection ( self , fail_silently = False ) :pass
from django . core . mail import get_connection
if not self . connection :pass
self . connection = get_connection ( fail_silently = fail_silently )
return self . connection
def message ( self ) :pass
encoding = self . encoding or settings . DEFAULT_CHARSET
msg = SafeMIMEText ( self . body , self . content_subtype , encoding )
msg = self . _create_message ( msg )
msg [ '_STR:0_' ] = self . subject
msg [ '_STR:0_' ] = self . extra_headers . get ( '_STR:0_' , self . from_email )
msg [ '_STR:0_' ] = self . extra_headers . get ( '_STR:0_' , '_STR:1_' . join ( self . to ) )
if self . cc :pass
msg [ '_STR:1_' ] = '_STR:0_' . join ( self . cc )
header_names = [ key . lower ( ) for key in self . extra_headers ]
if '_STR:0_' not in header_names :pass
msg [ '_STR:0_' ] = formatdate ( )
if 'message-id' not in header_names :pass
msg [ '_STR:0_' ] = make_msgid ( )
for name , value in self . extra_headers . items ( ) :pass
if name . lower ( ) in ( '_STR:0_' , 'to' ) :pass
continue
msg [ name ] = value
return msg
def recipients ( self ) :pass
return self . to + self . cc + self . bcc
def send ( self , fail_silently = False ) :pass
if not self . recipients ( ) :pass
return 0
return self . get_connection ( fail_silently ) . send_messages ( [ self ] )
def attach ( self , filename = None , content = None , mimetype = None ) :pass
if isinstance ( filename , MIMEBase ) :pass
assert content is None
assert mimetype is None
self . attachments . append ( filename )
if True: pass _newline_ else :pass
assert content is not None
self . attachments . append ( ( filename , content , mimetype ) )
def attach_file ( self , path , mimetype = None ) :pass
filename = os . path . basename ( path )
with open ( path , '_STR:0_' ) as f :pass
content = f . read ( )
self . attach ( filename , content , mimetype )
def _create_message ( self , msg ) :pass
return self . _create_attachments ( msg )
def _create_attachments ( self , msg ) :pass
if self . attachments :pass
encoding = self . encoding or settings . DEFAULT_CHARSET
body_msg = msg
msg = SafeMIMEMultipart ( _subtype = self . mixed_subtype , encoding = encoding )
if self . body :pass
msg . attach ( body_msg )
for attachment in self . attachments :pass
if isinstance ( attachment , MIMEBase ) :pass
msg . attach ( attachment )
if True: pass _newline_ else :pass
msg . attach ( self . _create_attachment ( * attachment ) )
return msg
def _create_mime_attachment ( self , content , mimetype ) :pass
basetype , subtype = mimetype . split ( '_STR:0_' , 1 )
if basetype == '_STR:0_' :pass
encoding = self . encoding or settings . DEFAULT_CHARSET
attachment = SafeMIMEText ( content , subtype , encoding )
if True: pass _newline_ elif basetype == '_STR:0_' and subtype == '_STR:1_' :pass
if isinstance ( content , EmailMessage ) :pass
content = content . message ( )
if True: pass _newline_ elif not isinstance ( content , Message ) :pass
content = message_from_string ( content )
attachment = SafeMIMEMessage ( content , subtype )
if True: pass _newline_ else :pass
attachment = MIMEBase ( basetype , subtype )
attachment . set_payload ( content )
Encoders . encode_base64 ( attachment )
return attachment
def _create_attachment ( self , filename , content , mimetype = None ) :pass
if mimetype is None :pass
mimetype , _ = mimetypes . guess_type ( filename )
if mimetype is None :pass
mimetype = DEFAULT_ATTACHMENT_MIME_TYPE
attachment = self . _create_mime_attachment ( content , mimetype )
if filename :pass
try :pass _newline_ except: pass
filename . encode ( '_STR:0_' )
try: pass _newline_ except UnicodeEncodeError :pass
if six . PY2 :pass
filename = filename . encode ( '_STR:0_' )
filename = ( '_STR:0_' , '' , filename )
attachment . add_header ( '_STR:0_' , '_STR:1_' ,  filename = filename )
return attachment
class EmailMultiAlternatives ( EmailMessage ) :pass
alternative_subtype = '_STR:0_'
def __init__ ( self , subject = '' , body = '' , from_email = None , to = None , bcc = None ,  connection = None , attachments = None , headers = None , alternatives = None ,  cc = None ) :pass
super ( EmailMultiAlternatives , self ) . __init__ ( subject , body , from_email , to , bcc , connection , attachments , headers , cc )
self . alternatives = alternatives or [ ]
def attach_alternative ( self , content , mimetype ) :pass
assert content is not None
assert mimetype is not None
self . alternatives . append ( ( content , mimetype ) )
def _create_message ( self , msg ) :pass
return self . _create_attachments ( self . _create_alternatives ( msg ) )
def _create_alternatives ( self , msg ) :pass
encoding = self . encoding or settings . DEFAULT_CHARSET
if self . alternatives :pass
body_msg = msg
msg = SafeMIMEMultipart ( _subtype = self . alternative_subtype , encoding = encoding )
if self . body :pass
msg . attach ( body_msg )
for alternative in self . alternatives :pass
msg . attach ( self . _create_mime_attachment ( * alternative ) )
return msg
import socket
class CachedDnsName ( object ) :pass
def __str__ ( self ) :pass
return self . get_fqdn ( )
def get_fqdn ( self ) :pass
if not hasattr ( self , '_STR:0_' ) :pass
self . _fqdn = socket . getfqdn ( )
return self . _fqdn
DNS_NAME = CachedDnsName ( )
from __future__ import unicode_literals
import collections
from importlib import import_module
import os
import sys
import django
from django . apps import apps
from django . conf import settings
from django . core . exceptions import ImproperlyConfigured
from django . core . management . base import ( BaseCommand , CommandError ,  CommandParser , handle_default_options )
from django . core . management . color import color_style
from django . utils import lru_cache
from django . utils import six
def find_commands ( management_dir ) :pass
command_dir = os . path . join ( management_dir , '_STR:0_' )
try :pass _newline_ except: pass
return [ f [ : - 3 ] for f in os . listdir ( command_dir )  if not f . startswith ( '_STR:0_' ) and f . endswith ( '_STR:1_' ) ]
try: pass _newline_ except OSError :pass
return [ ]
def load_command_class ( app_name , name ) :pass
module = import_module ( '_STR:0_' % ( app_name , name ) )
return module . Command ( )
@ lru_cache . lru_cache ( maxsize = None ) _newline_ def dummy(): pass
def get_commands ( ) :pass
commands = { name : '_STR:0_' for name in find_commands ( __path__ [ 0 ] ) }
if not settings . configured :pass
return commands
for app_config in reversed ( list ( apps . get_app_configs ( ) ) ) :pass
path = os . path . join ( app_config . path , '_STR:0_' )
commands . update ( { name : app_config . name for name in find_commands ( path ) } )
return commands
def call_command ( name , * args , ** options ) :pass
try :pass _newline_ except: pass
app_name = get_commands ( ) [ name ]
try: pass _newline_ except KeyError :pass
raise CommandError ( '_STR:0_' % name )
if isinstance ( app_name , BaseCommand ) :pass
command = app_name
if True: pass _newline_ else :pass
command = load_command_class ( app_name , name )
parser = command . create_parser ( '' , name )
if command . use_argparse :pass
defaults = parser . parse_args ( args = args )
defaults = dict ( defaults . _get_kwargs ( ) , ** options )
if True: pass _newline_ else :pass
defaults , _ = parser . parse_args ( args = [ ] )
defaults = dict ( defaults . __dict__ , ** options )
return command . execute ( * args , ** defaults )
class ManagementUtility ( object ) :pass
def __init__ ( self , argv = None ) :pass
self . argv = argv or sys . argv [ : ]
self . prog_name = os . path . basename ( self . argv [ 0 ] )
self . settings_exception = None
def main_help_text ( self , commands_only = False ) :pass
if commands_only :pass
usage = sorted ( get_commands ( ) . keys ( ) )
if True: pass _newline_ else :pass
usage = [  "" ,  '_STR:0_' % self . prog_name ,  "" ,  "Available subcommands:" ,  ]
commands_dict = collections . defaultdict ( lambda : [ ] )
for name , app in six . iteritems ( get_commands ( ) ) :pass
if app == '_STR:0_' :pass
app = '_STR:0_'
if True: pass _newline_ else :pass
app = app . rpartition ( '_STR:0_' ) [ - 1 ]
commands_dict [ app ] . append ( name )
style = color_style ( )
for app in sorted ( commands_dict . keys ( ) ) :pass
usage . append ( "" )
usage . append ( style . NOTICE ( '_STR:0_' % app ) )
for name in sorted ( commands_dict [ app ] ) :pass
usage . append ( '_STR:0_' % name )
if self . settings_exception is not None :pass
usage . append ( style . NOTICE (  "Note that only Django core commands are listed "  "as settings are not properly configured (error: %s)."  % self . settings_exception ) )
return '\n' . join ( usage )
def fetch_command ( self , subcommand ) :pass
commands = get_commands ( )
try :pass _newline_ except: pass
app_name = commands [ subcommand ]
try: pass _newline_ except KeyError :pass
settings . INSTALLED_APPS
sys . stderr . write ( '_STR:0_' %  ( subcommand , self . prog_name ) )
sys . exit ( 1 )
if isinstance ( app_name , BaseCommand ) :pass
klass = app_name
if True: pass _newline_ else :pass
klass = load_command_class ( app_name , subcommand )
return klass
def autocomplete ( self ) :pass
if '_STR:0_' not in os . environ :pass
return
cwords = os . environ [ '_STR:0_' ] . split ( ) [ 1 : ]
cword = int ( os . environ [ '_STR:0_' ] )
try :pass _newline_ except: pass
curr = cwords [ cword - 1 ]
try: pass _newline_ except IndexError :pass
curr = ''
subcommands = list ( get_commands ( ) ) + [ '_STR:0_' ]
options = [ ( '_STR:0_' , None ) ]
if cword == 1 :pass
print ( ' ' . join ( sorted ( filter ( lambda x : x . startswith ( curr ) , subcommands ) ) ) )
if True: pass _newline_ elif cwords [ 0 ] in subcommands and cwords [ 0 ] != '_STR:0_' :pass
subcommand_cls = self . fetch_command ( cwords [ 0 ] )
if cwords [ 0 ] == '_STR:0_' :pass
from django . core . servers . fastcgi import FASTCGI_OPTIONS
options += [ ( k , 1 ) for k in FASTCGI_OPTIONS ]
if True: pass _newline_ elif cwords [ 0 ] in ( '_STR:0_' , '_STR:1_' , '_STR:2_' , '_STR:3_' ,  '_STR:4_' , 'sqlindexes' , 'sqlsequencereset' , 'test' ) :pass
try :pass _newline_ except: pass
app_configs = apps . get_app_configs ( )
options += [ ( app_config . label , 0 ) for app_config in app_configs ]
try: pass _newline_ except ImportError :pass
pass
parser = subcommand_cls . create_parser ( '' , cwords [ 0 ] )
if subcommand_cls . use_argparse :pass
options += [ ( sorted ( s_opt . option_strings ) [ 0 ] , s_opt . nargs != 0 ) for s_opt in  parser . _actions if s_opt . option_strings ]
if True: pass _newline_ else :pass
options += [ ( s_opt . get_opt_string ( ) , s_opt . nargs ) for s_opt in  parser . option_list ]
prev_opts = [ x . split ( '=' ) [ 0 ] for x in cwords [ 1 : cword - 1 ] ]
options = [ opt for opt in options if opt [ 0 ] not in prev_opts ]
options = sorted ( ( k , v ) for k , v in options if k . startswith ( curr ) )
for option in options :pass
opt_label = option [ 0 ]
if option [ 1 ] :pass
opt_label += '_STR:0_'
print ( opt_label )
sys . exit ( 1 )
def execute ( self ) :pass
try :pass _newline_ except: pass
subcommand = self . argv [ 1 ]
try: pass _newline_ except IndexError :pass
subcommand = '_STR:0_'
parser = CommandParser ( None , usage = '_STR:0_' , add_help = False )
parser . add_argument ( '_STR:0_' )
parser . add_argument ( '_STR:0_' )
parser . add_argument ( '_STR:0_' , nargs = '_STR:1_' )
try :pass _newline_ except: pass
options , args = parser . parse_known_args ( self . argv [ 2 : ] )
handle_default_options ( options )
try: pass _newline_ except CommandError :pass
pass
no_settings_commands = [  '_STR:0_' , '_STR:1_' , '_STR:2_' , '_STR:3_' , '_STR:4_' ,  '_STR:5_' , '_STR:6_' ,  'startapp' , 'startproject' ,  ]
try :pass _newline_ except: pass
settings . INSTALLED_APPS
try: pass _newline_ except ImproperlyConfigured as exc :pass
self . settings_exception = exc
if subcommand in no_settings_commands :pass
settings . configure ( )
if settings . configured :pass
django . setup ( )
self . autocomplete ( )
if subcommand == '_STR:0_' :pass
if '_STR:0_' in args :pass
sys . stdout . write ( self . main_help_text ( commands_only = True ) + '\n' )
if True: pass _newline_ elif len ( options . args ) < 1 :pass
sys . stdout . write ( self . main_help_text ( ) + '\n' )
if True: pass _newline_ else :pass
self . fetch_command ( options . args [ 0 ] ) . print_help ( self . prog_name , options . args [ 0 ] )
if True: pass _newline_ elif subcommand == '_STR:0_' or self . argv [ 1 : ] == [ '_STR:1_' ] :pass
sys . stdout . write ( django . get_version ( ) + '\n' )
if True: pass _newline_ elif self . argv [ 1 : ] in ( [ '_STR:0_' ] , [ '-h' ] ) :pass
sys . stdout . write ( self . main_help_text ( ) + '\n' )
if True: pass _newline_ else :pass
self . fetch_command ( subcommand ) . run_from_argv ( self . argv )
def execute_from_command_line ( argv = None ) :pass
utility = ManagementUtility ( argv )
utility . execute ( )
from __future__ import unicode_literals
import os
import sys
import warnings
from argparse import ArgumentParser
from optparse import OptionParser
import django
from django . core import checks
from django . core . exceptions import ImproperlyConfigured
from django . core . management . color import color_style , no_style
from django . utils . deprecation import RemovedInDjango19Warning , RemovedInDjango20Warning
from django . utils . encoding import force_str
class CommandError ( Exception ) :pass
pass
class CommandParser ( ArgumentParser ) :pass
def __init__ ( self , cmd , ** kwargs ) :pass
self . cmd = cmd
super ( CommandParser , self ) . __init__ ( ** kwargs )
def parse_args ( self , args = None , namespace = None ) :pass
if ( hasattr ( self . cmd , '_STR:0_' ) and  not ( args or any ( [ not arg . startswith ( '_STR:1_' ) for arg in args ] ) ) ) :pass
self . error ( self . cmd . missing_args_message )
return super ( CommandParser , self ) . parse_args ( args , namespace )
def error ( self , message ) :pass
if self . cmd . _called_from_command_line :pass
super ( CommandParser , self ) . error ( message )
if True: pass _newline_ else :pass
raise CommandError ( '_STR:0_' % message )
def handle_default_options ( options ) :pass
if options . settings :pass
os . environ [ '_STR:0_' ] = options . settings
if options . pythonpath :pass
sys . path . insert ( 0 , options . pythonpath )
class OutputWrapper ( object ) :pass
def __init__ ( self , out , style_func = None , ending = '\n' ) :pass
self . _out = out
self . style_func = None
if hasattr ( out , '_STR:0_' ) and out . isatty ( ) :pass
self . style_func = style_func
self . ending = ending
def __getattr__ ( self , name ) :pass
return getattr ( self . _out , name )
def write ( self , msg , style_func = None , ending = None ) :pass
ending = self . ending if ending is None else ending
if ending and not msg . endswith ( ending ) :pass
msg += ending
style_func = [ f for f in ( style_func , self . style_func , lambda x : x )  if f is not None ] [ 0 ]
self . _out . write ( force_str ( style_func ( msg ) ) )
class BaseCommand ( object ) :pass
option_list = ( )
help = ''
args = ''
_called_from_command_line = False
can_import_settings = True
output_transaction = False
leave_locale_alone = False
def __init__ ( self ) :pass
self . style = color_style ( )
has_old_option = hasattr ( self , '_STR:0_' )
has_new_option = hasattr ( self , '_STR:0_' )
if has_old_option :pass
warnings . warn (  '_STR:0_'  'in favor of "requires_system_checks".' ,  RemovedInDjango19Warning )
if has_old_option and has_new_option :pass
raise ImproperlyConfigured (  '_STR:0_'  'and "requires_system_checks", which is illegal. Use only '  '"requires_system_checks".' % self . __class__ . __name__ )
self . requires_system_checks = (  self . requires_system_checks if has_new_option else  self . requires_model_validation if has_old_option else  True )
@ property _newline_ def dummy(): pass
def use_argparse ( self ) :pass
return not bool ( self . option_list )
def get_version ( self ) :pass
return django . get_version ( )
def usage ( self , subcommand ) :pass
usage = '_STR:0_' % ( subcommand , self . args )
if self . help :pass
return '%s\n\n%s' % ( usage , self . help )
if True: pass _newline_ else :pass
return usage
def create_parser ( self , prog_name , subcommand ) :pass
if not self . use_argparse :pass
warnings . warn ( '_STR:0_'  "is deprecated, use ArgumentParser instead" ,  RemovedInDjango20Warning )
parser = OptionParser ( prog = prog_name ,  usage = self . usage ( subcommand ) ,  version = self . get_version ( ) )
parser . add_option ( '_STR:0_' , '_STR:1_' , action = '_STR:2_' , dest = 'verbosity' , default = '1' ,  type = 'choice' , choices = [ '0' , '1' , '2' , '3' ] ,  help = 'Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output' )
parser . add_option ( '_STR:7_' ,  help = '_STR:8_' )
parser . add_option ( '_STR:0_' ,  help = '_STR:1_' ) ,
parser . add_option ( '_STR:0_' , action = '_STR:1_' ,  help = 'Raise on exception' )
parser . add_option ( '_STR:1_' , action = '_STR:2_' , dest = 'no_color' , default = False ,  help = "Don't colorize the command output." )
for opt in self . option_list :pass
parser . add_option ( opt )
if True: pass _newline_ else :pass
parser = CommandParser ( self , prog = "%s %s" % ( os . path . basename ( prog_name ) , subcommand ) ,  description = self . help or None )
parser . add_argument ( '_STR:0_' , action = '_STR:1_' , version = self . get_version ( ) )
parser . add_argument ( '_STR:0_' , '_STR:1_' , action = '_STR:2_' , dest = 'verbosity' , default = '1' ,  type = int , choices = [ 0 , 1 , 2 , 3 ] ,  help = 'Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output' )
parser . add_argument ( '_STR:2_' ,  help = 'The Python path to a settings module, e.g. "myproject.settings.main". If this isn\'t provided, the DJANGO_SETTINGS_MODULE environment variable will be used.' )
parser . add_argument ( '_STR:0_' ,  help = 'A directory to add to the Python path, e.g. "/home/djangoprojects/myproject".' )
parser . add_argument ( '_STR:0_' , action = '_STR:1_' ,  help = 'Raise on exception' )
parser . add_argument ( '_STR:1_' , action = '_STR:2_' , dest = '_STR:3_' , default = False ,  help = "Don't colorize the command output." )
if self . args :pass
parser . add_argument ( '_STR:0_' , nargs = '_STR:1_' )
self . add_arguments ( parser )
return parser
def add_arguments ( self , parser ) :pass
pass
def print_help ( self , prog_name , subcommand ) :pass
parser = self . create_parser ( prog_name , subcommand )
parser . print_help ( )
def run_from_argv ( self , argv ) :pass
self . _called_from_command_line = True
parser = self . create_parser ( argv [ 0 ] , argv [ 1 ] )
if self . use_argparse :pass
options = parser . parse_args ( argv [ 2 : ] )
cmd_options = vars ( options )
if '_STR:0_' in options :pass
args = options . args
del cmd_options [ '_STR:0_' ]
if True: pass _newline_ else :pass
args = ( )
if True: pass _newline_ else :pass
options , args = parser . parse_args ( argv [ 2 : ] )
cmd_options = vars ( options )
handle_default_options ( options )
try :pass _newline_ except: pass
self . execute ( * args , ** cmd_options )
try: pass _newline_ except Exception as e :pass
if options . traceback or not isinstance ( e , CommandError ) :pass
raise
stderr = getattr ( self , '_STR:0_' , OutputWrapper ( sys . stderr , self . style . ERROR ) )
stderr . write ( '_STR:0_' % ( e . __class__ . __name__ , e ) )
sys . exit ( 1 )
def execute ( self , * args , ** options ) :pass
self . stdout = OutputWrapper ( options . get ( '_STR:0_' , sys . stdout ) )
if options . get ( '_STR:0_' ) :pass
self . style = no_style ( )
self . stderr = OutputWrapper ( options . get ( '_STR:0_' , sys . stderr ) )
if True: pass _newline_ else :pass
self . stderr = OutputWrapper ( options . get ( '_STR:0_' , sys . stderr ) , self . style . ERROR )
if self . can_import_settings :pass
from django . conf import settings
saved_locale = None
if not self . leave_locale_alone :pass
if not self . can_import_settings :pass
raise CommandError ( '_STR:0_'  "(%s) and 'can_import_settings' (%s) command "  "options." % ( self . leave_locale_alone ,  self . can_import_settings ) )
from django . utils import translation
saved_locale = translation . get_language ( )
translation . activate ( '_STR:0_' )
try :pass _newline_ except: pass
if ( self . requires_system_checks and  not options . get ( '_STR:0_' ) and  not options . get ( '_STR:1_' ) ) :pass
self . check ( )
output = self . handle ( * args , ** options )
if output :pass
if self . output_transaction :pass
from django . db import connections , DEFAULT_DB_ALIAS
connection = connections [ options . get ( '_STR:0_' , DEFAULT_DB_ALIAS ) ]
if connection . ops . start_transaction_sql ( ) :pass
self . stdout . write ( self . style . SQL_KEYWORD ( connection . ops . start_transaction_sql ( ) ) )
self . stdout . write ( output )
if self . output_transaction :pass
self . stdout . write ( '\n' + self . style . SQL_KEYWORD ( connection . ops . end_transaction_sql ( ) ) )
try: pass _newline_ finally :pass
if saved_locale is not None :pass
translation . activate ( saved_locale )
def validate ( self , app_config = None , display_num_errors = False ) :pass
if app_config is None :pass
app_configs = None
if True: pass _newline_ else :pass
app_configs = [ app_config ]
return self . check ( app_configs = app_configs , display_num_errors = display_num_errors )
def check ( self , app_configs = None , tags = None , display_num_errors = False ) :pass
all_issues = checks . run_checks ( app_configs = app_configs , tags = tags )
msg = ""
visible_issue_count = 0
if all_issues :pass
debugs = [ e for e in all_issues if e . level < checks . INFO and not e . is_silenced ( ) ]
infos = [ e for e in all_issues if checks . INFO <= e . level < checks . WARNING and not e . is_silenced ( ) ]
warnings = [ e for e in all_issues if checks . WARNING <= e . level < checks . ERROR and not e . is_silenced ( ) ]
errors = [ e for e in all_issues if checks . ERROR <= e . level < checks . CRITICAL ]
criticals = [ e for e in all_issues if checks . CRITICAL <= e . level ]
sorted_issues = [  ( criticals , '_STR:0_' ) ,  ( errors , '_STR:1_' ) ,  ( warnings , '_STR:2_' ) ,  ( infos , 'INFOS' ) ,  ( debugs , 'DEBUGS' ) ,  ]
for issues , group_name in sorted_issues :pass
if issues :pass
visible_issue_count += len ( issues )
formatted = (  color_style ( ) . ERROR ( force_str ( e ) )  if e . is_serious ( )  else color_style ( ) . WARNING ( force_str ( e ) )  for e in issues )
formatted = "\n" . join ( sorted ( formatted ) )
msg += '_STR:0_' % ( group_name , formatted )
if msg :pass
msg = '_STR:0_' % msg
if display_num_errors :pass
if msg :pass
msg += '\n'
msg += '_STR:0_' % (  '_STR:1_' if visible_issue_count == 0 else  "1 issue" if visible_issue_count == 1 else  "%s issues" % visible_issue_count ,  len ( all_issues ) - visible_issue_count ,  )
if any ( e . is_serious ( ) and not e . is_silenced ( ) for e in all_issues ) :pass
raise CommandError ( msg )
if True: pass _newline_ elif msg and visible_issue_count :pass
self . stderr . write ( msg )
if True: pass _newline_ elif msg :pass
self . stdout . write ( msg )
def handle ( self , * args , ** options ) :pass
raise NotImplementedError ( '_STR:0_' )
class AppCommand ( BaseCommand ) :pass
missing_args_message = '_STR:0_'
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , metavar = '_STR:1_' , nargs = '_STR:2_' ,  help = 'One or more application label.' )
def handle ( self , * app_labels , ** options ) :pass
from django . apps import apps
try :pass _newline_ except: pass
app_configs = [ apps . get_app_config ( app_label ) for app_label in app_labels ]
try: pass _newline_ except ( LookupError , ImportError ) as e :pass
raise CommandError ( '_STR:0_' % e )
output = [ ]
for app_config in app_configs :pass
app_output = self . handle_app_config ( app_config , ** options )
if app_output :pass
output . append ( app_output )
return '\n' . join ( output )
def handle_app_config ( self , app_config , ** options ) :pass
try :pass _newline_ except: pass
handle_app = self . handle_app
try: pass _newline_ except AttributeError :pass
raise NotImplementedError (  "Subclasses of AppCommand must provide"  "a handle_app_config() method." )
if True: pass _newline_ else :pass
warnings . warn (  "AppCommand.handle_app() is superseded by "  "AppCommand.handle_app_config()." ,  RemovedInDjango19Warning , stacklevel = 2 )
if app_config . models_module is None :pass
raise CommandError (  "AppCommand cannot handle app '%s' in legacy mode "  "because it doesn't have a models module."  % app_config . label )
return handle_app ( app_config . models_module , ** options )
class LabelCommand ( BaseCommand ) :pass
label = '_STR:0_'
missing_args_message = '_STR:0_' % label
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , metavar = self . label , nargs = '_STR:1_' )
def handle ( self , * labels , ** options ) :pass
output = [ ]
for label in labels :pass
label_output = self . handle_label ( label , ** options )
if label_output :pass
output . append ( label_output )
return '\n' . join ( output )
def handle_label ( self , label , ** options ) :pass
raise NotImplementedError ( '_STR:0_' )
class NoArgsCommand ( BaseCommand ) :pass
args = ''
def __init__ ( self ) :pass
warnings . warn (  '_STR:0_'  "Use BaseCommand instead, which takes no arguments by default." ,  RemovedInDjango20Warning  )
super ( NoArgsCommand , self ) . __init__ ( )
def handle ( self , * args , ** options ) :pass
if args :pass
raise CommandError ( '_STR:0_' )
return self . handle_noargs ( ** options )
def handle_noargs ( self , ** options ) :pass
raise NotImplementedError ( '_STR:0_' )
import os
import sys
from django . utils import termcolors
def supports_color ( ) :pass
plat = sys . platform
supported_platform = plat != '_STR:0_' and ( plat != '_STR:1_' or  'ANSICON' in os . environ )
is_a_tty = hasattr ( sys . stdout , '_STR:1_' ) and sys . stdout . isatty ( )
if not supported_platform or not is_a_tty :pass
return False
return True
def color_style ( ) :pass
if not supports_color ( ) :pass
style = no_style ( )
if True: pass _newline_ else :pass
DJANGO_COLORS = os . environ . get ( '_STR:0_' , '' )
color_settings = termcolors . parse_color_setting ( DJANGO_COLORS )
if color_settings :pass
class dummy :pass
pass
style = dummy ( )
for role in termcolors . PALETTES [ termcolors . NOCOLOR_PALETTE ] :pass
format = color_settings . get ( role , { } )
setattr ( style , role , termcolors . make_style ( ** format ) )
style . ERROR_OUTPUT = style . ERROR
if True: pass _newline_ else :pass
style = no_style ( )
return style
def no_style ( ) :pass
class dummy :pass
def __getattr__ ( self , attr ) :pass
return lambda x : x
return dummy ( )
from __future__ import unicode_literals
from django . apps import apps
from django . core import checks
from django . core . checks . registry import registry
from django . core . management . base import BaseCommand , CommandError
class Command ( BaseCommand ) :pass
help = '_STR:0_'
requires_system_checks = False
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , metavar = '_STR:1_' , nargs = '_STR:2_' )
parser . add_argument ( '_STR:0_' , '_STR:1_' , action = '_STR:2_' , dest = 'tags' ,  help = 'Run only checks labeled with given tag.' )
parser . add_argument ( '_STR:2_' , action = '_STR:3_' , dest = 'list_tags' ,  help = 'List available tags.' )
def handle ( self , * app_labels , ** options ) :pass
if options . get ( '_STR:0_' ) :pass
self . stdout . write ( '\n' . join ( sorted ( registry . tags_available ( ) ) ) )
return
if app_labels :pass
app_configs = [ apps . get_app_config ( app_label ) for app_label in app_labels ]
if True: pass _newline_ else :pass
app_configs = None
tags = options . get ( '_STR:0_' , None )
if tags and any ( not checks . tag_exists ( tag ) for tag in tags ) :pass
invalid_tag = next ( tag for tag in tags if not checks . tag_exists ( tag ) )
raise CommandError ( '_STR:0_' % invalid_tag )
self . check ( app_configs = app_configs , tags = tags , display_num_errors = True )
from __future__ import unicode_literals
import codecs
import glob
import os
from django . core . management . base import BaseCommand , CommandError
from django . core . management . utils import find_command , popen_wrapper
from django . utils . _os import npath , upath
def has_bom ( fn ) :pass
with open ( fn , 'rb' ) as f :pass
sample = f . read ( 4 )
return sample [ : 3 ] == b'\xef\xbb\xbf' or sample . startswith ( codecs . BOM_UTF16_LE ) or sample . startswith ( codecs . BOM_UTF16_BE )
def is_writable ( path ) :pass
try :pass _newline_ except: pass
with open ( path , 'a' ) :pass
os . utime ( path , None )
try: pass _newline_ except ( IOError , OSError ) :pass
return False
return True
class Command ( BaseCommand ) :pass
help = '_STR:0_'
requires_system_checks = False
leave_locale_alone = True
program = '_STR:0_'
program_options = [ '_STR:0_' ]
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , '_STR:1_' , dest = '_STR:2_' , action = '_STR:3_' , default = [ ] ,  help = 'Locale(s) to process (e.g. de_AT). Default is to process all. '  'Can be used multiple times.' )
parser . add_argument ( '_STR:1_' , '_STR:2_' , dest = '_STR:3_' , action = '_STR:4_' , default = [ ] ,  help = 'Locales to exclude. Default is none. Can be used multiple times.' )
def handle ( self , ** options ) :pass
locale = options . get ( '_STR:0_' )
exclude = options . get ( '_STR:0_' )
self . verbosity = int ( options . get ( 'verbosity' ) )
if find_command ( self . program ) is None :pass
raise CommandError ( "Can't find %s. Make sure you have GNU gettext "  "tools 0.15 or newer installed." % self . program )
basedirs = [ os . path . join ( 'conf' , '_STR:1_' ) , '_STR:1_' ]
if os . environ . get ( '_STR:0_' ) :pass
from django . conf import settings
basedirs . extend ( [ upath ( path ) for path in settings . LOCALE_PATHS ] )
basedirs = set ( map ( os . path . abspath , filter ( os . path . isdir , basedirs ) ) )
if not basedirs :pass
raise CommandError ( "This script should be run from the Django Git "  "checkout or your project or app tree, or with "  "the settings module specified." )
all_locales = [ ]
for basedir in basedirs :pass
locale_dirs = filter ( os . path . isdir , glob . glob ( '%s/*' % basedir ) )
all_locales . extend ( map ( os . path . basename , locale_dirs ) )
locales = locale or all_locales
locales = set ( locales ) - set ( exclude )
for basedir in basedirs :pass
if locales :pass
dirs = [ os . path . join ( basedir , l , '_STR:0_' ) for l in locales ]
if True: pass _newline_ else :pass
dirs = [ basedir ]
locations = [ ]
for ldir in dirs :pass
for dirpath , dirnames , filenames in os . walk ( ldir ) :pass
locations . extend ( ( dirpath , f ) for f in filenames if f . endswith ( '_STR:0_' ) )
if locations :pass
self . compile_messages ( locations )
def compile_messages ( self , locations ) :pass
for i , ( dirpath , f ) in enumerate ( locations ) :pass
if self . verbosity > 0 :pass
self . stdout . write ( '_STR:0_' % ( f , dirpath ) )
po_path = os . path . join ( dirpath , f )
if has_bom ( po_path ) :pass
raise CommandError ( "The %s file has a BOM (Byte Order Mark). "  "Django only supports .po files encoded in "  "UTF-8 and without any BOM." % po_path )
base_path = os . path . splitext ( po_path ) [ 0 ]
if i == 0 and not is_writable ( npath ( base_path + '.mo' ) ) :pass
self . stderr . write ( "The po files under %s are in a seemingly not writable location. "  "mo files will not be updated/created." % dirpath )
return
args = [ self . program ] + self . program_options + [ '_STR:0_' ,  npath ( base_path + '.mo' ) , npath ( base_path + '.po' ) ]
output , errors , status = popen_wrapper ( args )
if status :pass
if errors :pass
msg = '_STR:0_' % ( self . program , errors )
if True: pass _newline_ else :pass
msg = '_STR:0_' % self . program
raise CommandError ( msg )
from django . conf import settings
from django . core . cache import caches
from django . core . cache . backends . db import BaseDatabaseCache
from django . core . management . base import BaseCommand , CommandError
from django . db import connections , router , transaction , models , DEFAULT_DB_ALIAS
from django . db . utils import DatabaseError
from django . utils . encoding import force_text
class Command ( BaseCommand ) :pass
help = '_STR:0_'
requires_system_checks = False
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , metavar = '_STR:1_' , nargs = '_STR:2_' ,  help = 'Optional table names. Otherwise, settings.CACHES is used to '  'find cache tables.' )
parser . add_argument ( '_STR:1_' , action = '_STR:2_' , dest = '_STR:3_' ,  default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database onto which the cache tables will be '  'installed. Defaults to the "default" database.' )
def handle ( self , * tablenames , ** options ) :pass
db = options . get ( '_STR:0_' )
self . verbosity = int ( options . get ( '_STR:0_' ) )
if len ( tablenames ) :pass
for tablename in tablenames :pass
self . create_table ( db , tablename )
if True: pass _newline_ else :pass
for cache_alias in settings . CACHES :pass
cache = caches [ cache_alias ]
if isinstance ( cache , BaseDatabaseCache ) :pass
self . create_table ( db , cache . _table )
def create_table ( self , database , tablename ) :pass
cache = BaseDatabaseCache ( tablename , { } )
if not router . allow_migrate ( database , cache . cache_model_class ) :pass
return
connection = connections [ database ]
if tablename in connection . introspection . table_names ( ) :pass
if self . verbosity > 0 :pass
self . stdout . write ( '_STR:0_' % tablename )
return
fields = (   models . CharField ( name = 'cache_key' , max_length = 255 , unique = True , primary_key = True ) ,  models . TextField ( name = 'value' ) ,  models . DateTimeField ( name = 'expires' , db_index = True ) ,  )
table_output = [ ]
index_output = [ ]
qn = connection . ops . quote_name
for f in fields :pass
field_output = [ qn ( f . name ) , f . db_type ( connection = connection ) ]
field_output . append ( "%sNULL" % ( "NOT " if not f . null else "" ) )
if f . primary_key :pass
field_output . append ( '_STR:0_' )
if True: pass _newline_ elif f . unique :pass
field_output . append ( '_STR:0_' )
if f . db_index :pass
unique = '_STR:0_' if f . unique else ""
index_output . append ( '_STR:0_' %  ( unique , qn ( '%s_%s' % ( tablename , f . name ) ) , qn ( tablename ) ,  qn ( f . name ) ) )
table_output . append ( " " . join ( field_output ) )
full_statement = [ '_STR:0_' % qn ( tablename ) ]
for i , line in enumerate ( table_output ) :pass
full_statement . append ( '_STR:0_' % ( line , '_STR:1_' if i < len ( table_output ) - 1 else '' ) )
full_statement . append ( '_STR:0_' )
with transaction . atomic ( using = database ,  savepoint = connection . features . can_rollback_ddl ) :pass
with connection . cursor ( ) as curs :pass
try :pass _newline_ except: pass
curs . execute ( "\n" . join ( full_statement ) )
try: pass _newline_ except DatabaseError as e :pass
raise CommandError (  '_STR:0_' %  ( tablename , force_text ( e ) ) )
for statement in index_output :pass
curs . execute ( statement )
if self . verbosity > 1 :pass
self . stdout . write ( '_STR:0_' % tablename )
from django . core . management . base import BaseCommand , CommandError
from django . db import connections , DEFAULT_DB_ALIAS
class Command ( BaseCommand ) :pass
help = ( "Runs the command-line client for specified database, or the "  "default database if none is provided." )
requires_system_checks = False
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , action = '_STR:1_' , dest = '_STR:2_' ,  default = DEFAULT_DB_ALIAS , help = 'Nominates a database onto which to '  'open a shell. Defaults to the "default" database.' )
def handle ( self , ** options ) :pass
connection = connections [ options . get ( '_STR:0_' ) ]
try :pass _newline_ except: pass
connection . client . runshell ( )
try: pass _newline_ except OSError :pass
raise CommandError ( '_STR:0_' %  connection . client . executable_name )
from django . core . management . base import BaseCommand
def module_to_dict ( module , omittable = lambda k : k . startswith ( '_' ) ) :pass
return dict ( ( k , repr ( v ) ) for k , v in module . __dict__ . items ( ) if not omittable ( k ) )
class Command ( BaseCommand ) :pass
requires_system_checks = False
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , action = '_STR:1_' , dest = '_STR:2_' , default = False ,  help = 'Display all settings, regardless of their value. '  'Default values are prefixed by "###".' )
def handle ( self , ** options ) :pass
from django . conf import settings , global_settings
settings . _setup ( )
user_settings = module_to_dict ( settings . _wrapped )
default_settings = module_to_dict ( global_settings )
output = [ ]
for key in sorted ( user_settings ) :pass
if key not in default_settings :pass
output . append ( '_STR:0_' % ( key , user_settings [ key ] ) )
if True: pass _newline_ elif user_settings [ key ] != default_settings [ key ] :pass
output . append ( '_STR:0_' % ( key , user_settings [ key ] ) )
if True: pass _newline_ elif options [ '_STR:0_' ] :pass
output . append ( '_STR:0_' % ( key , user_settings [ key ] ) )
return '\n' . join ( output )
import warnings
from collections import OrderedDict
from django . apps import apps
from django . core . management . base import BaseCommand , CommandError
from django . core import serializers
from django . db import router , DEFAULT_DB_ALIAS
from django . utils . deprecation import RemovedInDjango19Warning
class Command ( BaseCommand ) :pass
help = ( '_STR:0_'  "format (using each model's default manager unless --all is "  "specified)." )
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , metavar = '_STR:1_' , nargs = '*' ,  help = 'Restricts dumped data to the specified app_label or app_label.ModelName.' )
parser . add_argument ( '_STR:2_' , default = '_STR:3_' , dest = 'format' ,  help = 'Specifies the output serialization format for fixtures.' )
parser . add_argument ( '_STR:2_' , default = None , dest = '_STR:3_' , type = int ,  help = 'Specifies the indent level to use when pretty-printing output.' )
parser . add_argument ( '_STR:1_' , action = '_STR:2_' , dest = '_STR:3_' ,  default = DEFAULT_DB_ALIAS ,  help = 'Nominates a specific database to dump fixtures from. '  'Defaults to the "default" database.' )
parser . add_argument ( '_STR:1_' , '_STR:2_' , dest = '_STR:3_' , action = '_STR:4_' , default = [ ] ,  help = 'An app_label or app_label.ModelName to exclude '  '(use multiple --exclude to exclude multiple apps/models).' )
parser . add_argument ( '_STR:1_' , '_STR:2_' , action = '_STR:3_' , dest = '_STR:4_' , default = False ,  help = 'Use natural keys if they are available (deprecated: use --natural-foreign instead).' )
parser . add_argument ( '_STR:1_' , action = '_STR:2_' , dest = 'use_natural_foreign_keys' , default = False ,  help = 'Use natural foreign keys if they are available.' )
parser . add_argument ( '_STR:2_' , action = '_STR:3_' , dest = 'use_natural_primary_keys' , default = False ,  help = 'Use natural primary keys if they are available.' )
parser . add_argument ( '_STR:2_' , '_STR:3_' , action = '_STR:4_' , dest = 'use_base_manager' , default = False ,  help = "Use Django's base manager to dump all models stored in the database, "  "including those that would otherwise be filtered or modified by a custom manager." )
parser . add_argument ( '_STR:2_' , dest = '_STR:3_' ,  help = "Only dump objects with given primary keys. "  "Accepts a comma separated list of keys. "  "This option will only work when you specify one model." )
parser . add_argument ( '_STR:2_' , '_STR:3_' , default = None , dest = '_STR:4_' ,  help = 'Specifies file to which the output is written.' )
def handle ( self , * app_labels , ** options ) :pass
format = options . get ( '_STR:0_' )
indent = options . get ( '_STR:0_' )
using = options . get ( '_STR:0_' )
excludes = options . get ( '_STR:0_' )
output = options . get ( '_STR:0_' )
show_traceback = options . get ( '_STR:0_' )
use_natural_keys = options . get ( '_STR:0_' )
if use_natural_keys :pass
warnings . warn ( '_STR:0_' ,  RemovedInDjango19Warning )
use_natural_foreign_keys = options . get ( 'use_natural_foreign_keys' ) or use_natural_keys
use_natural_primary_keys = options . get ( '_STR:0_' )
use_base_manager = options . get ( '_STR:0_' )
pks = options . get ( '_STR:0_' )
if pks :pass
primary_keys = pks . split ( '_STR:0_' )
if True: pass _newline_ else :pass
primary_keys = [ ]
excluded_apps = set ( )
excluded_models = set ( )
for exclude in excludes :pass
if '_STR:0_' in exclude :pass
try :pass _newline_ except: pass
model = apps . get_model ( exclude )
try: pass _newline_ except LookupError :pass
raise CommandError ( '_STR:0_' % exclude )
excluded_models . add ( model )
if True: pass _newline_ else :pass
try :pass _newline_ except: pass
app_config = apps . get_app_config ( exclude )
try: pass _newline_ except LookupError :pass
raise CommandError ( '_STR:0_' % exclude )
excluded_apps . add ( app_config )
if len ( app_labels ) == 0 :pass
if primary_keys :pass
raise CommandError ( '_STR:0_' )
app_list = OrderedDict ( ( app_config , None )  for app_config in apps . get_app_configs ( )  if app_config . models_module is not None and app_config not in excluded_apps )
if True: pass _newline_ else :pass
if len ( app_labels ) > 1 and primary_keys :pass
raise CommandError ( '_STR:0_' )
app_list = OrderedDict ( )
for label in app_labels :pass
try :pass _newline_ except: pass
app_label , model_label = label . split ( '_STR:0_' )
try :pass _newline_ except: pass
app_config = apps . get_app_config ( app_label )
try: pass _newline_ except LookupError :pass
raise CommandError ( "Unknown application: %s" % app_label )
if app_config . models_module is None or app_config in excluded_apps :pass
continue
try :pass _newline_ except: pass
model = app_config . get_model ( model_label )
try: pass _newline_ except LookupError :pass
raise CommandError ( "Unknown model: %s.%s" % ( app_label , model_label ) )
app_list_value = app_list . setdefault ( app_config , [ ] )
if app_list_value is not None :pass
if model not in app_list_value :pass
app_list_value . append ( model )
try: pass _newline_ except ValueError :pass
if primary_keys :pass
raise CommandError ( '_STR:0_' )
app_label = label
try :pass _newline_ except: pass
app_config = apps . get_app_config ( app_label )
try: pass _newline_ except LookupError :pass
raise CommandError ( "Unknown application: %s" % app_label )
if app_config . models_module is None or app_config in excluded_apps :pass
continue
app_list [ app_config ] = None
if format not in serializers . get_public_serializer_formats ( ) :pass
try :pass _newline_ except: pass
serializers . get_serializer ( format )
try: pass _newline_ except serializers . SerializerDoesNotExist :pass
pass
raise CommandError ( "Unknown serialization format: %s" % format )
def get_objects ( ) :pass
for model in sort_dependencies ( app_list . items ( ) ) :pass
if model in excluded_models :pass
continue
if not model . _meta . proxy and router . allow_migrate ( using , model ) :pass
if use_base_manager :pass
objects = model . _base_manager
if True: pass _newline_ else :pass
objects = model . _default_manager
queryset = objects . using ( using ) . order_by ( model . _meta . pk . name )
if primary_keys :pass
queryset = queryset . filter ( pk__in = primary_keys )
for obj in queryset . iterator ( ) :pass
yield obj
try :pass _newline_ except: pass
self . stdout . ending = None
stream = open ( output , 'w' ) if output else None
try :pass _newline_ except: pass
serializers . serialize ( format , get_objects ( ) , indent = indent ,  use_natural_foreign_keys = use_natural_foreign_keys ,  use_natural_primary_keys = use_natural_primary_keys ,  stream = stream or self . stdout )
try: pass _newline_ finally :pass
if stream :pass
stream . close ( )
try: pass _newline_ except Exception as e :pass
if show_traceback :pass
raise
raise CommandError ( '_STR:0_' % e )
def sort_dependencies ( app_list ) :pass
model_dependencies = [ ]
models = set ( )
for app_config , model_list in app_list :pass
if model_list is None :pass
model_list = app_config . get_models ( )
for model in model_list :pass
models . add ( model )
if hasattr ( model , '_STR:0_' ) :pass
deps = getattr ( model . natural_key , '_STR:0_' , [ ] )
if deps :pass
deps = [ apps . get_model ( dep ) for dep in deps ]
if True: pass _newline_ else :pass
deps = [ ]
for field in model . _meta . fields :pass
if hasattr ( field . rel , '_STR:0_' ) :pass
rel_model = field . rel . to
if hasattr ( rel_model , '_STR:0_' ) and rel_model != model :pass
deps . append ( rel_model )
for field in model . _meta . many_to_many :pass
if field . rel . through . _meta . auto_created :pass
rel_model = field . rel . to
if hasattr ( rel_model , '_STR:0_' ) and rel_model != model :pass
deps . append ( rel_model )
model_dependencies . append ( ( model , deps ) )
model_dependencies . reverse ( )
model_list = [ ]
while model_dependencies :pass
skipped = [ ]
changed = False
while model_dependencies :pass
model , deps = model_dependencies . pop ( )
found = True
for candidate in ( ( d not in models or d in model_list ) for d in deps ) :pass
if not candidate :pass
found = False
if found :pass
model_list . append ( model )
changed = True
if True: pass _newline_ else :pass
skipped . append ( ( model , deps ) )
if not changed :pass
raise CommandError ( '_STR:0_' %  ', ' . join ( '%s.%s' % ( model . _meta . app_label , model . _meta . object_name )  for model , deps in sorted ( skipped , key = lambda obj : obj [ 0 ] . __name__ ) )  )
model_dependencies = skipped
return model_list
import sys
from importlib import import_module
from django . apps import apps
from django . db import connections , router , transaction , DEFAULT_DB_ALIAS
from django . core . management import call_command
from django . core . management . base import BaseCommand , CommandError
from django . core . management . color import no_style
from django . core . management . sql import sql_flush , emit_post_migrate_signal
from django . utils . six . moves import input
from django . utils import six
class Command ( BaseCommand ) :pass
help = ( '_STR:0_'  'migrations. Unmigrated apps will also have their initial_data '  'fixture reloaded. Does not achieve a "fresh install" state.' )
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , action = '_STR:1_' , dest = 'interactive' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' )
parser . add_argument ( '_STR:2_' , action = '_STR:3_' , dest = '_STR:4_' ,  default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to flush. Defaults to the "default" database.' )
parser . add_argument ( '_STR:1_' , action = '_STR:2_' ,  dest = 'load_initial_data' , default = True ,  help = 'Tells Django not to load any initial data after database synchronization.' )
def handle ( self , ** options ) :pass
database = options . get ( '_STR:0_' )
connection = connections [ database ]
verbosity = options . get ( '_STR:0_' )
interactive = options . get ( '_STR:0_' )
reset_sequences = options . get ( '_STR:0_' , True )
allow_cascade = options . get ( '_STR:0_' , False )
inhibit_post_migrate = options . get ( '_STR:0_' , False )
self . style = no_style ( )
for app_config in apps . get_app_configs ( ) :pass
try :pass _newline_ except: pass
import_module ( '.management' , app_config . name )
try: pass _newline_ except ImportError :pass
pass
sql_list = sql_flush ( self . style , connection , only_django = True ,  reset_sequences = reset_sequences ,  allow_cascade = allow_cascade )
if interactive :pass
confirm = input ( """You have requested a flush of the database. This will IRREVERSIBLY DESTROY all data currently in the %r database, and return each table to an empty state. Are you sure you want to do this?     Type 'yes' to continue, or 'no' to cancel: """ % connection . settings_dict [ 'NAME' ] )
if True: pass _newline_ else :pass
confirm = '_STR:0_'
if confirm == '_STR:0_' :pass
try :pass _newline_ except: pass
with transaction . atomic ( using = database ,  savepoint = connection . features . can_rollback_ddl ) :pass
with connection . cursor ( ) as cursor :pass
for sql in sql_list :pass
cursor . execute ( sql )
try: pass _newline_ except Exception as e :pass
new_msg = (  '_STR:0_'  "  * The database isn't running or isn't configured correctly.\n"  "  * At least one of the expected database tables doesn't exist.\n"  "  * The SQL was invalid.\n"  "Hint: Look at the output of 'django-admin.py sqlflush'. That's the SQL this command wasn't able to run.\n"  "The full error: %s" ) % ( connection . settings_dict [ 'NAME' ] , e )
six . reraise ( CommandError , CommandError ( new_msg ) , sys . exc_info ( ) [ 2 ] )
if not inhibit_post_migrate :pass
self . emit_post_migrate ( verbosity , interactive , database )
if options . get ( '_STR:0_' ) :pass
call_command ( '_STR:0_' , '_STR:1_' , ** options )
if True: pass _newline_ else :pass
self . stdout . write ( '_STR:0_' )
@ staticmethod _newline_ def dummy(): pass
def emit_post_migrate ( verbosity , interactive , database ) :pass
all_models = [ ]
for app_config in apps . get_app_configs ( ) :pass
all_models . extend ( router . get_migratable_models ( app_config , database , include_auto_created = True ) )
emit_post_migrate_signal ( set ( all_models ) , verbosity , interactive , database )
from __future__ import unicode_literals
from collections import OrderedDict
import keyword
import re
from django . core . management . base import BaseCommand , CommandError
from django . db import connections , DEFAULT_DB_ALIAS
class Command ( BaseCommand ) :pass
help = '_STR:0_'
requires_system_checks = False
db_module = '_STR:0_'
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , action = '_STR:1_' , dest = '_STR:2_' ,  default = DEFAULT_DB_ALIAS , help = 'Nominates a database to '  'introspect. Defaults to using the "default" database.' )
def handle ( self , ** options ) :pass
try :pass _newline_ except: pass
for line in self . handle_inspection ( options ) :pass
self . stdout . write ( "%s\n" % line )
try: pass _newline_ except NotImplementedError :pass
raise CommandError ( '_STR:0_' )
def handle_inspection ( self , options ) :pass
connection = connections [ options [ '_STR:0_' ] ]
table_name_filter = options . get ( '_STR:0_' )
table2model = lambda table_name : re . sub ( r'[^a-zA-Z0-9]' , '' , table_name . title ( ) )
strip_prefix = lambda s : s [ 1 : ] if s . startswith ( "u'" ) else s
with connection . cursor ( ) as cursor :pass
yield '_STR:0_'
yield '_STR:0_'
yield '_STR:0_'
yield '_STR:0_'
yield '_STR:0_'
yield '_STR:0_'
yield '_STR:0_'
yield '_STR:0_'
yield '_STR:0_'
yield '_STR:0_'
yield ''
yield '_STR:0_' % self . db_module
known_models = [ ]
for table_name in connection . introspection . table_names ( cursor ) :pass
if table_name_filter is not None and callable ( table_name_filter ) :pass
if not table_name_filter ( table_name ) :pass
continue
yield ''
yield ''
yield 'class %s(models.Model):' % table2model ( table_name )
known_models . append ( table2model ( table_name ) )
try :pass _newline_ except: pass
relations = connection . introspection . get_relations ( cursor , table_name )
try: pass _newline_ except NotImplementedError :pass
relations = { }
try :pass _newline_ except: pass
indexes = connection . introspection . get_indexes ( cursor , table_name )
try: pass _newline_ except NotImplementedError :pass
indexes = { }
used_column_names = [ ]
for i , row in enumerate ( connection . introspection . get_table_description ( cursor , table_name ) ) :pass
comment_notes = [ ]
extra_params = OrderedDict ( )
column_name = row [ 0 ]
is_relation = i in relations
att_name , params , notes = self . normalize_col_name (  column_name , used_column_names , is_relation )
extra_params . update ( params )
comment_notes . extend ( notes )
used_column_names . append ( att_name )
if column_name in indexes :pass
if indexes [ column_name ] [ '_STR:0_' ] :pass
extra_params [ '_STR:0_' ] = True
if True: pass _newline_ elif indexes [ column_name ] [ '_STR:0_' ] :pass
extra_params [ '_STR:0_' ] = True
if is_relation :pass
rel_to = "self" if relations [ i ] [ 1 ] == table_name else table2model ( relations [ i ] [ 1 ] )
if rel_to in known_models :pass
field_type = 'ForeignKey(%s' % rel_to
if True: pass _newline_ else :pass
field_type = "ForeignKey('%s'" % rel_to
if True: pass _newline_ else :pass
field_type , field_params , field_notes = self . get_field_type ( connection , table_name , row )
extra_params . update ( field_params )
comment_notes . extend ( field_notes )
field_type += '_STR:0_'
if att_name == '_STR:0_' and extra_params == { '_STR:1_' : True } :pass
if field_type == '_STR:0_' :pass
continue
if True: pass _newline_ elif field_type == '_STR:0_' and not connection . features . can_introspect_autofield :pass
comment_notes . append ( '_STR:0_' )
if row [ 6 ] :pass
if field_type == '_STR:0_' :pass
field_type = '_STR:0_'
if True: pass _newline_ else :pass
extra_params [ '_STR:0_' ] = True
if field_type not in ( '_STR:0_' , '_STR:1_' ) :pass
extra_params [ '_STR:0_' ] = True
field_desc = '_STR:0_' % (  att_name ,   '' if '_STR:1_' in field_type else 'models.' ,  field_type ,  )
if extra_params :pass
if not field_desc . endswith ( '_STR:0_' ) :pass
field_desc += '_STR:0_'
field_desc += ', ' . join ( [  '_STR:0_' % ( k , strip_prefix ( repr ( v ) ) )  for k , v in extra_params . items ( ) ] )
field_desc += '_STR:1_'
if comment_notes :pass
field_desc += '  # ' + ' ' . join ( comment_notes )
yield '_STR:0_' % field_desc
for meta_line in self . get_meta ( table_name ) :pass
yield meta_line
def normalize_col_name ( self , col_name , used_column_names , is_relation ) :pass
field_params = { }
field_notes = [ ]
new_name = col_name . lower ( )
if new_name != col_name :pass
field_notes . append ( '_STR:0_' )
if is_relation :pass
if new_name . endswith ( '_STR:0_' ) :pass
new_name = new_name [ : - 3 ]
if True: pass _newline_ else :pass
field_params [ '_STR:0_' ] = col_name
new_name , num_repl = re . subn ( r'_STR:0_' , '_STR:1_' , new_name )
if num_repl > 0 :pass
field_notes . append ( '_STR:0_' )
if new_name . find ( '_STR:0_' ) >= 0 :pass
while new_name . find ( '_STR:0_' ) >= 0 :pass
new_name = new_name . replace ( '_STR:0_' , '_STR:1_' )
if col_name . lower ( ) . find ( '_STR:0_' ) >= 0 :pass
field_notes . append ( '_STR:0_' )
if new_name . startswith ( '_STR:0_' ) :pass
new_name = 'field%s' % new_name
field_notes . append ( '_STR:0_' )
if new_name . endswith ( '_STR:0_' ) :pass
new_name = '%sfield' % new_name
field_notes . append ( '_STR:0_' )
if keyword . iskeyword ( new_name ) :pass
new_name += '_STR:0_'
field_notes . append ( 'Field renamed because it was a Python reserved word.' )
if new_name [ 0 ] . isdigit ( ) :pass
new_name = 'number_%s' % new_name
field_notes . append ( '_STR:0_' )
if new_name in used_column_names :pass
num = 0
while '_STR:0_' % ( new_name , num ) in used_column_names :pass
num += 1
new_name = '_STR:0_' % ( new_name , num )
field_notes . append ( 'Field renamed because of name conflict.' )
if col_name != new_name and field_notes :pass
field_params [ '_STR:0_' ] = col_name
return new_name , field_params , field_notes
def get_field_type ( self , connection , table_name , row ) :pass
field_params = OrderedDict ( )
field_notes = [ ]
try :pass _newline_ except: pass
field_type = connection . introspection . get_field_type ( row [ 1 ] , row )
try: pass _newline_ except KeyError :pass
field_type = '_STR:0_'
field_notes . append ( '_STR:0_' )
if type ( field_type ) is tuple :pass
field_type , new_params = field_type
field_params . update ( new_params )
if field_type == 'CharField' and row [ 3 ] :pass
field_params [ 'max_length' ] = int ( row [ 3 ] )
if field_type == '_STR:0_' :pass
if row [ 4 ] is None or row [ 5 ] is None :pass
field_notes . append (  'max_digits and decimal_places have been guessed, as this '  'database handles decimal fields as float' )
field_params [ '_STR:0_' ] = row [ 4 ] if row [ 4 ] is not None else 10
field_params [ '_STR:1_' ] = row [ 5 ] if row [ 5 ] is not None else 5
if True: pass _newline_ else :pass
field_params [ '_STR:0_' ] = row [ 4 ]
field_params [ '_STR:0_' ] = row [ 5 ]
return field_type , field_params , field_notes
def get_meta ( self , table_name ) :pass
return [ "" ,  '_STR:0_' ,  '_STR:1_' ,  "        db_table = '%s'" % table_name ]
from __future__ import unicode_literals
import glob
import gzip
import os
import warnings
import zipfile
from django . apps import apps
from django . conf import settings
from django . core import serializers
from django . core . management . base import BaseCommand , CommandError
from django . core . management . color import no_style
from django . db import ( connections , router , transaction , DEFAULT_DB_ALIAS ,  IntegrityError , DatabaseError )
from django . utils import lru_cache
from django . utils . encoding import force_text
from django . utils . functional import cached_property
from django . utils . _os import upath
from itertools import product
try :pass _newline_ except: pass
import bz2
has_bz2 = True
try: pass _newline_ except ImportError :pass
has_bz2 = False
class Command ( BaseCommand ) :pass
help = '_STR:0_'
missing_args_message = ( '_STR:0_'  "path of at least one fixture in the command line." )
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , metavar = '_STR:1_' , nargs = '_STR:2_' ,  help = 'Fixture labels.' )
parser . add_argument ( '_STR:1_' , action = '_STR:2_' , dest = '_STR:3_' ,  default = DEFAULT_DB_ALIAS , help = 'Nominates a specific database to load '  'fixtures into. Defaults to the "default" database.' )
parser . add_argument ( '_STR:1_' , action = '_STR:2_' , dest = '_STR:3_' ,  default = None , help = 'Only look for fixtures in the specified app.' )
parser . add_argument ( '_STR:1_' , '_STR:2_' , action = '_STR:3_' ,  dest = 'ignore' , default = False ,  help = 'Ignores entries in the serialized data for fields that do not '  'currently exist on the model.' )
def handle ( self , * fixture_labels , ** options ) :pass
self . ignore = options . get ( '_STR:0_' )
self . using = options . get ( '_STR:0_' )
self . app_label = options . get ( '_STR:0_' )
self . hide_empty = options . get ( '_STR:0_' , False )
self . verbosity = options . get ( '_STR:0_' )
with transaction . atomic ( using = self . using ) :pass
self . loaddata ( fixture_labels )
if transaction . get_autocommit ( self . using ) :pass
connections [ self . using ] . close ( )
def loaddata ( self , fixture_labels ) :pass
connection = connections [ self . using ]
self . fixture_count = 0
self . loaded_object_count = 0
self . fixture_object_count = 0
self . models = set ( )
self . serialization_formats = serializers . get_public_serializer_formats ( )
self . compression_formats = {  None : ( open , '_STR:0_' ) ,  'gz' : ( gzip . GzipFile , '_STR:0_' ) ,  'zip' : ( SingleZipReader , 'r' ) ,  }
if has_bz2 :pass
self . compression_formats [ '_STR:1_' ] = ( bz2 . BZ2File , '_STR:0_' )
with connection . constraint_checks_disabled ( ) :pass
for fixture_label in fixture_labels :pass
self . load_label ( fixture_label )
table_names = [ model . _meta . db_table for model in self . models ]
try :pass _newline_ except: pass
connection . check_constraints ( table_names = table_names )
try: pass _newline_ except Exception as e :pass
e . args = ( '_STR:0_' % e , )
raise
if self . loaded_object_count > 0 :pass
sequence_sql = connection . ops . sequence_reset_sql ( no_style ( ) , self . models )
if sequence_sql :pass
if self . verbosity >= 2 :pass
self . stdout . write ( '_STR:0_' )
with connection . cursor ( ) as cursor :pass
for line in sequence_sql :pass
cursor . execute ( line )
if self . verbosity >= 1 :pass
if self . fixture_count == 0 and self . hide_empty :pass
pass
if True: pass _newline_ elif self . fixture_object_count == self . loaded_object_count :pass
self . stdout . write ( '_STR:0_' %  ( self . loaded_object_count , self . fixture_count ) )
if True: pass _newline_ else :pass
self . stdout . write ( '_STR:0_' %  ( self . loaded_object_count , self . fixture_object_count , self . fixture_count ) )
def load_label ( self , fixture_label ) :pass
for fixture_file , fixture_dir , fixture_name in self . find_fixtures ( fixture_label ) :pass
_ , ser_fmt , cmp_fmt = self . parse_name ( os . path . basename ( fixture_file ) )
open_method , mode = self . compression_formats [ cmp_fmt ]
fixture = open_method ( fixture_file , mode )
try :pass _newline_ except: pass
self . fixture_count += 1
objects_in_fixture = 0
loaded_objects_in_fixture = 0
if self . verbosity >= 2 :pass
self . stdout . write ( '_STR:0_' %  ( ser_fmt , fixture_name , humanize ( fixture_dir ) ) )
objects = serializers . deserialize ( ser_fmt , fixture ,  using = self . using , ignorenonexistent = self . ignore )
for obj in objects :pass
objects_in_fixture += 1
if router . allow_migrate ( self . using , obj . object . __class__ ) :pass
loaded_objects_in_fixture += 1
self . models . add ( obj . object . __class__ )
try :pass _newline_ except: pass
obj . save ( using = self . using )
try: pass _newline_ except ( DatabaseError , IntegrityError ) as e :pass
e . args = ( "Could not load %(app_label)s.%(object_name)s(pk=%(pk)s): %(error_msg)s" % {  'app_label' : obj . object . _meta . app_label ,  'object_name' : obj . object . _meta . object_name ,  'pk' : obj . object . pk ,  'error_msg' : force_text ( e )  } , )
raise
self . loaded_object_count += loaded_objects_in_fixture
self . fixture_object_count += objects_in_fixture
try: pass _newline_ except Exception as e :pass
if not isinstance ( e , CommandError ) :pass
e . args = ( '_STR:0_' % ( fixture_file , e ) , )
raise
try: pass _newline_ finally :pass
fixture . close ( )
if objects_in_fixture == 0 :pass
warnings . warn (  "No fixture data found for '%s'. (File format may be "  "invalid.)" % fixture_name ,  RuntimeWarning  )
@ lru_cache . lru_cache ( maxsize = None ) _newline_ def dummy(): pass
def find_fixtures ( self , fixture_label ) :pass
fixture_name , ser_fmt , cmp_fmt = self . parse_name ( fixture_label )
databases = [ self . using , None ]
cmp_fmts = list ( self . compression_formats . keys ( ) ) if cmp_fmt is None else [ cmp_fmt ]
ser_fmts = serializers . get_public_serializer_formats ( ) if ser_fmt is None else [ ser_fmt ]
if self . verbosity >= 2 :pass
self . stdout . write ( '_STR:0_' % fixture_name )
if os . path . isabs ( fixture_name ) :pass
fixture_dirs = [ os . path . dirname ( fixture_name ) ]
fixture_name = os . path . basename ( fixture_name )
if True: pass _newline_ else :pass
fixture_dirs = self . fixture_dirs
if os . path . sep in fixture_name :pass
fixture_dirs = [ os . path . join ( dir_ , os . path . dirname ( fixture_name ) )  for dir_ in fixture_dirs ]
fixture_name = os . path . basename ( fixture_name )
suffixes = ( '_STR:0_' . join ( ext for ext in combo if ext )  for combo in product ( databases , ser_fmts , cmp_fmts ) )
targets = set ( '_STR:0_' . join ( ( fixture_name , suffix ) ) for suffix in suffixes )
fixture_files = [ ]
for fixture_dir in fixture_dirs :pass
if self . verbosity >= 2 :pass
self . stdout . write ( '_STR:0_' % humanize ( fixture_dir ) )
fixture_files_in_dir = [ ]
for candidate in glob . iglob ( os . path . join ( fixture_dir , fixture_name + '_STR:0_' ) ) :pass
if os . path . basename ( candidate ) in targets :pass
fixture_files_in_dir . append ( ( candidate , fixture_dir , fixture_name ) )
if self . verbosity >= 2 and not fixture_files_in_dir :pass
self . stdout . write ( '_STR:0_' %  ( fixture_name , humanize ( fixture_dir ) ) )
if len ( fixture_files_in_dir ) > 1 :pass
raise CommandError (  '_STR:0_' %  ( fixture_name , humanize ( fixture_dir ) ) )
fixture_files . extend ( fixture_files_in_dir )
if fixture_name != '_STR:0_' and not fixture_files :pass
warnings . warn ( '_STR:0_' % fixture_name )
return fixture_files
@ cached_property _newline_ def dummy(): pass
def fixture_dirs ( self ) :pass
dirs = [ ]
for app_config in apps . get_app_configs ( ) :pass
if self . app_label and app_config . label != self . app_label :pass
continue
app_dir = os . path . join ( app_config . path , '_STR:0_' )
if os . path . isdir ( app_dir ) :pass
dirs . append ( app_dir )
dirs . extend ( list ( settings . FIXTURE_DIRS ) )
dirs . append ( '' )
dirs = [ upath ( os . path . abspath ( os . path . realpath ( d ) ) ) for d in dirs ]
return dirs
def parse_name ( self , fixture_name ) :pass
parts = fixture_name . rsplit ( '_STR:0_' , 2 )
if len ( parts ) > 1 and parts [ - 1 ] in self . compression_formats :pass
cmp_fmt = parts [ - 1 ]
parts = parts [ : - 1 ]
if True: pass _newline_ else :pass
cmp_fmt = None
if len ( parts ) > 1 :pass
if parts [ - 1 ] in self . serialization_formats :pass
ser_fmt = parts [ - 1 ]
parts = parts [ : - 1 ]
if True: pass _newline_ else :pass
raise CommandError (  "Problem installing fixture '%s': %s is not a known "  "serialization format." % ( '' . join ( parts [ : - 1 ] ) , parts [ - 1 ] ) )
if True: pass _newline_ else :pass
ser_fmt = None
name = '_STR:0_' . join ( parts )
return name , ser_fmt , cmp_fmt
class SingleZipReader ( zipfile . ZipFile ) :pass
def __init__ ( self , * args , ** kwargs ) :pass
zipfile . ZipFile . __init__ ( self , * args , ** kwargs )
if len ( self . namelist ( ) ) != 1 :pass
raise ValueError ( '_STR:0_' )
def read ( self ) :pass
return zipfile . ZipFile . read ( self , self . namelist ( ) [ 0 ] )
def humanize ( dirname ) :pass
return "'%s'" % dirname if dirname else '_STR:0_'
from __future__ import unicode_literals
import fnmatch
import glob
import io
import os
import re
import sys
from itertools import dropwhile
import django
from django . core . management . base import CommandError , BaseCommand
from django . core . management . utils import ( handle_extensions , find_command ,  popen_wrapper )
from django . utils . encoding import force_str
from django . utils . functional import total_ordering
from django . utils import six
from django . utils . text import get_text_list
from django . utils . jslex import prepare_js_for_gettext
plural_forms_re = re . compile ( r'_STR:0_' , re . MULTILINE | re . DOTALL )
STATUS_OK = 0
def check_programs ( * programs ) :pass
for program in programs :pass
if find_command ( program ) is None :pass
raise CommandError ( "Can't find %s. Make sure you have GNU "  "gettext tools 0.15 or newer installed." % program )
@ total_ordering _newline_ def dummy(): pass
class TranslatableFile ( object ) :pass
def __init__ ( self , dirpath , file_name , locale_dir ) :pass
self . file = file_name
self . dirpath = dirpath
self . locale_dir = locale_dir
def __repr__ ( self ) :pass
return '_STR:0_' % os . sep . join ( [ self . dirpath , self . file ] )
def __eq__ ( self , other ) :pass
return self . path == other . path
def __lt__ ( self , other ) :pass
return self . path < other . path
@ property _newline_ def dummy(): pass
def path ( self ) :pass
return os . path . join ( self . dirpath , self . file )
def process ( self , command , domain ) :pass
from django . conf import settings
from django . utils . translation import templatize
if command . verbosity > 1 :pass
command . stdout . write ( '_STR:0_' % ( self . file , self . dirpath ) )
_ , file_ext = os . path . splitext ( self . file )
if domain == '_STR:0_' and file_ext in command . extensions :pass
is_templatized = True
orig_file = os . path . join ( self . dirpath , self . file )
with io . open ( orig_file , encoding = settings . FILE_CHARSET ) as fp :pass
src_data = fp . read ( )
src_data = prepare_js_for_gettext ( src_data )
thefile = '%s.c' % self . file
work_file = os . path . join ( self . dirpath , thefile )
with io . open ( work_file , "w" , encoding = '_STR:1_' ) as fp :pass
fp . write ( src_data )
args = [  '_STR:0_' ,  '_STR:1_' , domain ,  '_STR:2_' ,  '--keyword=gettext_noop' ,  '--keyword=gettext_lazy' ,  '--keyword=ngettext_lazy:1,2' ,  '--keyword=pgettext:1c,2' ,  '--keyword=npgettext:1c,2,3' ,  '--output=-'  ] + command . xgettext_options
args . append ( work_file )
if True: pass _newline_ elif domain == 'django' and ( file_ext == '.py' or file_ext in command . extensions ) :pass
thefile = self . file
orig_file = os . path . join ( self . dirpath , self . file )
is_templatized = file_ext in command . extensions
if is_templatized :pass
with io . open ( orig_file , 'r' , encoding = settings . FILE_CHARSET ) as fp :pass
src_data = fp . read ( )
thefile = '%s.py' % self . file
content = templatize ( src_data , orig_file [ 2 : ] )
with io . open ( os . path . join ( self . dirpath , thefile ) , "w" , encoding = 'utf-8' ) as fp :pass
fp . write ( content )
work_file = os . path . join ( self . dirpath , thefile )
args = [  '_STR:0_' ,  '_STR:1_' , domain ,  '_STR:2_' ,  '--keyword=gettext_noop' ,  '--keyword=gettext_lazy' ,  '--keyword=ngettext_lazy:1,2' ,  '--keyword=ugettext_noop' ,  '--keyword=ugettext_lazy' ,  '--keyword=ungettext_lazy:1,2' ,  '--keyword=pgettext:1c,2' ,  '--keyword=npgettext:1c,2,3' ,  '--keyword=pgettext_lazy:1c,2' ,  '--keyword=npgettext_lazy:1c,2,3' ,  '--output=-'  ] + command . xgettext_options
args . append ( work_file )
if True: pass _newline_ else :pass
return
msgs , errors , status = popen_wrapper ( args )
if errors :pass
if status != STATUS_OK :pass
if is_templatized :pass
os . unlink ( work_file )
raise CommandError (  '_STR:0_' %  ( self . file , errors ) )
if True: pass _newline_ elif command . verbosity > 0 :pass
command . stdout . write ( errors )
if msgs :pass
if six . PY2 :pass
msgs = msgs . decode ( '_STR:0_' )
potfile = os . path . join ( self . locale_dir , '%s.pot' % str ( domain ) )
if is_templatized :pass
if os . name == '_STR:0_' :pass
old = '_STR:0_' + work_file
new = '_STR:0_' + orig_file
if True: pass _newline_ else :pass
old = '_STR:0_' + work_file [ 2 : ]
new = '_STR:0_' + orig_file [ 2 : ]
msgs = msgs . replace ( old , new )
write_pot_file ( potfile , msgs )
if is_templatized :pass
os . unlink ( work_file )
def write_pot_file ( potfile , msgs ) :pass
if os . path . exists ( potfile ) :pass
msgs = '\n' . join ( dropwhile ( len , msgs . split ( '\n' ) ) )
if True: pass _newline_ else :pass
msgs = msgs . replace ( '_STR:0_' , '_STR:1_' )
with io . open ( potfile , '_STR:0_' , encoding = '_STR:1_' ) as fp :pass
fp . write ( msgs )
class Command ( BaseCommand ) :pass
help = ( '_STR:0_'  "pulls out all strings marked for translation. It creates (or updates) a message "  "file in the conf/locale (in the django tree) or locale (for projects and "  "applications) directory.\n\nYou must run this command with one of either the "  "--locale, --exclude or --all options." )
requires_system_checks = False
leave_locale_alone = True
msgmerge_options = [ '_STR:0_' , '_STR:1_' ]
msguniq_options = [ '_STR:0_' ]
msgattrib_options = [ '_STR:0_' ]
xgettext_options = [ '_STR:0_' , '_STR:1_' ]
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , '_STR:1_' , default = [ ] , dest = 'locale' , action = 'append' ,  help = 'Creates or updates the message files for the given locale(s) (e.g. pt_BR). '  'Can be used multiple times.' )
parser . add_argument ( '_STR:3_' , '_STR:4_' , default = [ ] , dest = 'exclude' , action = '_STR:1_' ,  help = 'Locales to exclude. Default is none. Can be used multiple times.' )
parser . add_argument ( '_STR:3_' , '_STR:4_' , default = '_STR:5_' , dest = 'domain' ,  help = 'The domain of the message files (default: "django").' )
parser . add_argument ( '_STR:2_' , '_STR:3_' , action = '_STR:4_' , dest = 'all' ,  default = False , help = 'Updates the message files for all existing locales.' )
parser . add_argument ( '_STR:2_' , '_STR:3_' , dest = '_STR:4_' ,  help = 'The file extension(s) to examine (default: "html,txt", or "js" '  'if the domain is "djangojs"). Separate multiple extensions with '  'commas, or use -e multiple times.' ,  action = 'append' )
parser . add_argument ( '_STR:3_' , '_STR:4_' , action = '_STR:5_' , dest = 'symlinks' ,  default = False , help = 'Follows symlinks to directories when examining '  'source code and templates for translation strings.' )
parser . add_argument ( '_STR:3_' , '_STR:4_' , action = '_STR:5_' , dest = 'ignore_patterns' ,  default = [ ] , metavar = 'PATTERN' ,  help = 'Ignore files or directories matching this glob-style pattern. '  'Use multiple times to ignore more.' )
parser . add_argument ( '_STR:3_' , action = '_STR:4_' , dest = 'use_default_ignore_patterns' ,  default = True , help = "Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and '*.pyc'." )
parser . add_argument ( '_STR:2_' , action = '_STR:3_' , dest = '_STR:4_' ,  default = False , help = "Don't break long message lines into several lines." )
parser . add_argument ( '_STR:1_' , action = '_STR:2_' , dest = 'no_location' ,  default = False , help = "Don't write '#: filename:line' lines." )
parser . add_argument ( '_STR:2_' , action = '_STR:3_' , dest = 'no_obsolete' ,  default = False , help = "Remove obsolete message strings." )
parser . add_argument ( '_STR:2_' , action = '_STR:3_' , dest = 'keep_pot' ,  default = False , help = "Keep .pot file after making messages. Useful when debugging." )
def handle ( self , * args , ** options ) :pass
locale = options . get ( '_STR:0_' )
exclude = options . get ( '_STR:0_' )
self . domain = options . get ( '_STR:0_' )
self . verbosity = options . get ( '_STR:0_' )
process_all = options . get ( '_STR:0_' )
extensions = options . get ( '_STR:0_' )
self . symlinks = options . get ( '_STR:0_' )
ignore_patterns = options . get ( '_STR:0_' )
if options . get ( '_STR:0_' ) :pass
ignore_patterns += [ '_STR:0_' , '_STR:1_' , '_STR:2_' , '_STR:3_' ]
self . ignore_patterns = list ( set ( ignore_patterns ) )
if options . get ( '_STR:0_' ) :pass
self . msgmerge_options = self . msgmerge_options [ : ] + [ '_STR:0_' ]
self . msguniq_options = self . msguniq_options [ : ] + [ '_STR:0_' ]
self . msgattrib_options = self . msgattrib_options [ : ] + [ '_STR:0_' ]
self . xgettext_options = self . xgettext_options [ : ] + [ '_STR:0_' ]
if options . get ( '_STR:0_' ) :pass
self . msgmerge_options = self . msgmerge_options [ : ] + [ '_STR:0_' ]
self . msguniq_options = self . msguniq_options [ : ] + [ '_STR:0_' ]
self . msgattrib_options = self . msgattrib_options [ : ] + [ '_STR:0_' ]
self . xgettext_options = self . xgettext_options [ : ] + [ '_STR:0_' ]
self . no_obsolete = options . get ( '_STR:0_' )
self . keep_pot = options . get ( '_STR:0_' )
if self . domain not in ( '_STR:0_' , '_STR:1_' ) :pass
raise CommandError ( "currently makemessages only supports domains "  "'django' and 'djangojs'" )
if self . domain == '_STR:0_' :pass
exts = extensions if extensions else [ '_STR:0_' ]
if True: pass _newline_ else :pass
exts = extensions if extensions else [ '_STR:0_' , '_STR:1_' ]
self . extensions = handle_extensions ( exts )
if ( locale is None and not exclude and not process_all ) or self . domain is None :pass
raise CommandError ( '_STR:0_' % (  os . path . basename ( sys . argv [ 0 ] ) , sys . argv [ 1 ] ) )
from django . conf import settings
if settings . configured :pass
settings . USE_I18N = True
if True: pass _newline_ else :pass
settings . configure ( USE_I18N = True )
if self . verbosity > 1 :pass
self . stdout . write ( '_STR:0_'  % get_text_list ( list ( self . extensions ) , 'and' ) )
self . invoked_for_django = False
self . locale_paths = [ ]
self . default_locale_path = None
if os . path . isdir ( os . path . join ( '_STR:0_' , '_STR:1_' ) ) :pass
self . locale_paths = [ os . path . abspath ( os . path . join ( '_STR:0_' , '_STR:1_' ) ) ]
self . default_locale_path = self . locale_paths [ 0 ]
self . invoked_for_django = True
if True: pass _newline_ else :pass
self . locale_paths . extend ( list ( settings . LOCALE_PATHS ) )
if os . path . isdir ( '_STR:0_' ) :pass
self . locale_paths . append ( os . path . abspath ( '_STR:0_' ) )
if self . locale_paths :pass
self . default_locale_path = self . locale_paths [ 0 ]
if not os . path . exists ( self . default_locale_path ) :pass
os . makedirs ( self . default_locale_path )
locale_dirs = filter ( os . path . isdir , glob . glob ( '%s/*' % self . default_locale_path ) )
all_locales = map ( os . path . basename , locale_dirs )
if process_all :pass
locales = all_locales
if True: pass _newline_ else :pass
locales = locale or all_locales
locales = set ( locales ) - set ( exclude )
if locales :pass
check_programs ( '_STR:0_' , '_STR:1_' , '_STR:2_' )
check_programs ( '_STR:0_' )
try :pass _newline_ except: pass
potfiles = self . build_potfiles ( )
for locale in locales :pass
if self . verbosity > 0 :pass
self . stdout . write ( '_STR:0_' % locale )
for potfile in potfiles :pass
self . write_po_file ( potfile , locale )
try: pass _newline_ finally :pass
if not self . keep_pot :pass
self . remove_potfiles ( )
def build_potfiles ( self ) :pass
file_list = self . find_files ( "." )
self . remove_potfiles ( )
for f in file_list :pass
try :pass _newline_ except: pass
f . process ( self , self . domain )
try: pass _newline_ except UnicodeDecodeError :pass
self . stdout . write ( '_STR:0_' % ( f . file , f . dirpath ) )
potfiles = [ ]
for path in self . locale_paths :pass
potfile = os . path . join ( path , '_STR:0_' % str ( self . domain ) )
if not os . path . exists ( potfile ) :pass
continue
args = [ '_STR:0_' ] + self . msguniq_options + [ potfile ]
msgs , errors , status = popen_wrapper ( args )
if six . PY2 :pass
msgs = msgs . decode ( '_STR:0_' )
if errors :pass
if status != STATUS_OK :pass
raise CommandError (  '_STR:0_' % errors )
if True: pass _newline_ elif self . verbosity > 0 :pass
self . stdout . write ( errors )
with io . open ( potfile , '_STR:0_' , encoding = '_STR:1_' ) as fp :pass
fp . write ( msgs )
potfiles . append ( potfile )
return potfiles
def remove_potfiles ( self ) :pass
for path in self . locale_paths :pass
pot_path = os . path . join ( path , '_STR:0_' % str ( self . domain ) )
if os . path . exists ( pot_path ) :pass
os . unlink ( pot_path )
def find_files ( self , root ) :pass
def is_ignored ( path , ignore_patterns ) :pass
filename = os . path . basename ( path )
ignore = lambda pattern : fnmatch . fnmatchcase ( filename , pattern )
return any ( ignore ( pattern ) for pattern in ignore_patterns )
dir_suffix = '%s*' % os . sep
norm_patterns = [ p [ : - len ( dir_suffix ) ] if p . endswith ( dir_suffix ) else p for p in self . ignore_patterns ]
all_files = [ ]
for dirpath , dirnames , filenames in os . walk ( root , topdown = True , followlinks = self . symlinks ) :pass
for dirname in dirnames [ : ] :pass
if is_ignored ( os . path . normpath ( os . path . join ( dirpath , dirname ) ) , norm_patterns ) :pass
dirnames . remove ( dirname )
if self . verbosity > 1 :pass
self . stdout . write ( '_STR:0_' % dirname )
if True: pass _newline_ elif dirname == '_STR:0_' :pass
dirnames . remove ( dirname )
self . locale_paths . insert ( 0 , os . path . join ( os . path . abspath ( dirpath ) , dirname ) )
for filename in filenames :pass
file_path = os . path . normpath ( os . path . join ( dirpath , filename ) )
if is_ignored ( file_path , self . ignore_patterns ) :pass
if self . verbosity > 1 :pass
self . stdout . write ( '_STR:0_' % ( filename , dirpath ) )
if True: pass _newline_ else :pass
locale_dir = None
for path in self . locale_paths :pass
if os . path . abspath ( dirpath ) . startswith ( os . path . dirname ( path ) ) :pass
locale_dir = path
break
if not locale_dir :pass
locale_dir = self . default_locale_path
if not locale_dir :pass
raise CommandError (  '_STR:0_' % file_path )
all_files . append ( TranslatableFile ( dirpath , filename , locale_dir ) )
return sorted ( all_files )
def write_po_file ( self , potfile , locale ) :pass
basedir = os . path . join ( os . path . dirname ( potfile ) , locale , '_STR:0_' )
if not os . path . isdir ( basedir ) :pass
os . makedirs ( basedir )
pofile = os . path . join ( basedir , '%s.po' % str ( self . domain ) )
if os . path . exists ( pofile ) :pass
args = [ '_STR:0_' ] + self . msgmerge_options + [ pofile , potfile ]
msgs , errors , status = popen_wrapper ( args )
if six . PY2 :pass
msgs = msgs . decode ( '_STR:0_' )
if errors :pass
if status != STATUS_OK :pass
raise CommandError (  '_STR:0_' % errors )
if True: pass _newline_ elif self . verbosity > 0 :pass
self . stdout . write ( errors )
if True: pass _newline_ else :pass
with io . open ( potfile , '_STR:0_' , encoding = '_STR:1_' ) as fp :pass
msgs = fp . read ( )
if not self . invoked_for_django :pass
msgs = self . copy_plural_forms ( msgs , locale )
msgs = msgs . replace (  '_STR:0_' % self . domain , "" )
with io . open ( pofile , '_STR:0_' , encoding = '_STR:1_' ) as fp :pass
fp . write ( msgs )
if self . no_obsolete :pass
args = [ '_STR:0_' ] + self . msgattrib_options + [ '_STR:1_' , pofile , pofile ]
msgs , errors , status = popen_wrapper ( args )
if errors :pass
if status != STATUS_OK :pass
raise CommandError (  '_STR:0_' % errors )
if True: pass _newline_ elif self . verbosity > 0 :pass
self . stdout . write ( errors )
def copy_plural_forms ( self , msgs , locale ) :pass
django_dir = os . path . normpath ( os . path . join ( os . path . dirname ( django . __file__ ) ) )
if self . domain == '_STR:0_' :pass
domains = ( '_STR:0_' , '_STR:1_' )
if True: pass _newline_ else :pass
domains = ( '_STR:0_' , )
for domain in domains :pass
django_po = os . path . join ( django_dir , '_STR:0_' , '_STR:1_' , locale , '_STR:2_' , '%s.po' % domain )
if os . path . exists ( django_po ) :pass
with io . open ( django_po , '_STR:0_' , encoding = '_STR:1_' ) as fp :pass
m = plural_forms_re . search ( fp . read ( ) )
if m :pass
plural_form_line = force_str ( m . group ( '_STR:0_' ) )
if self . verbosity > 1 :pass
self . stdout . write ( '_STR:0_' % plural_form_line )
lines = [ ]
found = False
for line in msgs . split ( '\n' ) :pass
if not found and ( not line or plural_forms_re . search ( line ) ) :pass
line = '%s\n' % plural_form_line
found = True
lines . append ( line )
msgs = '\n' . join ( lines )
break
return msgs
import sys
import os
import operator
from django . apps import apps
from django . core . management . base import BaseCommand , CommandError
from django . db . migrations import Migration
from django . db . migrations . loader import MigrationLoader
from django . db . migrations . autodetector import MigrationAutodetector
from django . db . migrations . questioner import MigrationQuestioner , InteractiveMigrationQuestioner
from django . db . migrations . state import ProjectState
from django . db . migrations . writer import MigrationWriter
from django . utils . six . moves import reduce
class Command ( BaseCommand ) :pass
help = '_STR:0_'
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , metavar = '_STR:1_' , nargs = '_STR:2_' ,  help = 'Specify the app label(s) to create migrations for.' )
parser . add_argument ( '_STR:1_' , action = '_STR:2_' , dest = '_STR:3_' , default = False ,  help = "Just show what migrations would be made; don't actually write them." )
parser . add_argument ( '_STR:1_' , action = '_STR:2_' , dest = '_STR:3_' , default = False ,  help = "Enable fixing of migration conflicts." )
parser . add_argument ( '_STR:1_' , action = '_STR:2_' , dest = '_STR:3_' , default = False ,  help = "Create an empty migration." )
parser . add_argument ( '_STR:1_' , action = '_STR:2_' , dest = 'interactive' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' )
def handle ( self , * app_labels , ** options ) :pass
self . verbosity = options . get ( '_STR:0_' )
self . interactive = options . get ( '_STR:0_' )
self . dry_run = options . get ( '_STR:0_' , False )
self . merge = options . get ( '_STR:0_' , False )
self . empty = options . get ( '_STR:0_' , False )
app_labels = set ( app_labels )
bad_app_labels = set ( )
for app_label in app_labels :pass
try :pass _newline_ except: pass
apps . get_app_config ( app_label )
try: pass _newline_ except LookupError :pass
bad_app_labels . add ( app_label )
if bad_app_labels :pass
for app_label in bad_app_labels :pass
self . stderr . write ( '_STR:0_' % app_label )
sys . exit ( 2 )
loader = MigrationLoader ( None , ignore_no_migrations = True )
conflicts = loader . detect_conflicts ( )
if conflicts and not self . merge :pass
name_str = "; " . join (  "%s in %s" % ( ", " . join ( names ) , app )  for app , names in conflicts . items ( )  )
raise CommandError ( "Conflicting migrations detected (%s).\nTo fix them run 'python manage.py makemigrations --merge'" % name_str )
if self . merge and not conflicts :pass
self . stdout . write ( '_STR:0_' )
return
if self . merge and conflicts :pass
return self . handle_merge ( loader , conflicts )
autodetector = MigrationAutodetector (  loader . project_state ( ) ,  ProjectState . from_apps ( apps ) ,  InteractiveMigrationQuestioner ( specified_apps = app_labels , dry_run = self . dry_run ) ,  )
if self . empty :pass
if not app_labels :pass
raise CommandError ( '_STR:0_' )
changes = dict (  ( app , [ Migration ( "custom" , app ) ] )  for app in app_labels  )
changes = autodetector . arrange_for_graph ( changes , loader . graph )
self . write_migration_files ( changes )
return
changes = autodetector . changes (  graph = loader . graph ,  trim_to_apps = app_labels or None ,  convert_apps = app_labels or None ,  )
if not changes and self . verbosity >= 1 :pass
if len ( app_labels ) == 1 :pass
self . stdout . write ( '_STR:0_' % app_labels . pop ( ) )
if True: pass _newline_ elif len ( app_labels ) > 1 :pass
self . stdout . write ( '_STR:0_' % ( '_STR:1_' . join ( app_labels ) ) )
if True: pass _newline_ else :pass
self . stdout . write ( '_STR:0_' )
return
self . write_migration_files ( changes )
def write_migration_files ( self , changes ) :pass
directory_created = { }
for app_label , app_migrations in changes . items ( ) :pass
if self . verbosity >= 1 :pass
self . stdout . write ( self . style . MIGRATE_HEADING ( '_STR:0_' % app_label ) + "\n" )
for migration in app_migrations :pass
writer = MigrationWriter ( migration )
if self . verbosity >= 1 :pass
self . stdout . write ( '_STR:0_' % ( self . style . MIGRATE_LABEL ( writer . filename ) , ) )
for operation in migration . operations :pass
self . stdout . write ( '_STR:0_' % operation . describe ( ) )
if not self . dry_run :pass
migrations_directory = os . path . dirname ( writer . path )
if not directory_created . get ( app_label , False ) :pass
if not os . path . isdir ( migrations_directory ) :pass
os . mkdir ( migrations_directory )
init_path = os . path . join ( migrations_directory , '_STR:0_' )
if not os . path . isfile ( init_path ) :pass
open ( init_path , "w" ) . close ( )
directory_created [ app_label ] = True
migration_string = writer . as_string ( )
with open ( writer . path , "wb" ) as fh :pass
fh . write ( migration_string )
if True: pass _newline_ elif self . verbosity == 3 :pass
self . stdout . write ( self . style . MIGRATE_HEADING ( '_STR:0_' % writer . filename ) + "\n" )
self . stdout . write ( "%s\n" % writer . as_string ( ) )
def handle_merge ( self , loader , conflicts ) :pass
if self . interactive :pass
questioner = InteractiveMigrationQuestioner ( )
if True: pass _newline_ else :pass
questioner = MigrationQuestioner ( defaults = { 'ask_merge' : True } )
for app_label , migration_names in conflicts . items ( ) :pass
merge_migrations = [ ]
for migration_name in migration_names :pass
migration = loader . get_migration ( app_label , migration_name )
migration . ancestry = loader . graph . forwards_plan ( ( app_label , migration_name ) )
merge_migrations . append ( migration )
common_ancestor = None
for level in zip ( * [ m . ancestry for m in merge_migrations ] ) :pass
if reduce ( operator . eq , level ) :pass
common_ancestor = level [ 0 ]
if True: pass _newline_ else :pass
break
if common_ancestor is None :pass
raise ValueError ( '_STR:0_' % migration_names )
for migration in merge_migrations :pass
migration . branch = migration . ancestry [  ( migration . ancestry . index ( common_ancestor ) + 1 ) :  ]
migration . merged_operations = [ ]
for node_app , node_name in migration . branch :pass
migration . merged_operations . extend (  loader . get_migration ( node_app , node_name ) . operations  )
if self . verbosity > 0 :pass
self . stdout . write ( self . style . MIGRATE_HEADING ( '_STR:0_' % app_label ) )
for migration in merge_migrations :pass
self . stdout . write ( self . style . MIGRATE_LABEL ( '_STR:0_' % migration . name ) )
for operation in migration . merged_operations :pass
self . stdout . write ( '_STR:0_' % operation . describe ( ) )
if questioner . ask_merge ( app_label ) :pass
numbers = [  MigrationAutodetector . parse_number ( migration . name )  for migration in merge_migrations  ]
try :pass _newline_ except: pass
biggest_number = max ( [ x for x in numbers if x is not None ] )
try: pass _newline_ except ValueError :pass
biggest_number = 1
subclass = type ( "Migration" , ( Migration , ) , {  "dependencies" : [ ( app_label , migration . name ) for migration in merge_migrations ] ,  } )
new_migration = subclass ( '_STR:0_' % ( biggest_number + 1 ) , app_label )
writer = MigrationWriter ( new_migration )
with open ( writer . path , "wb" ) as fh :pass
fh . write ( writer . as_string ( ) )
if self . verbosity > 0 :pass
self . stdout . write ( '_STR:0_' % writer . path )
from __future__ import unicode_literals
from collections import OrderedDict
from importlib import import_module
import itertools
import traceback
from django . apps import apps
from django . core . management import call_command
from django . core . management . base import BaseCommand , CommandError
from django . core . management . color import no_style
from django . core . management . sql import custom_sql_for_model , emit_post_migrate_signal , emit_pre_migrate_signal
from django . db import connections , router , transaction , DEFAULT_DB_ALIAS
from django . db . migrations . executor import MigrationExecutor
from django . db . migrations . loader import MigrationLoader , AmbiguityError
from django . db . migrations . state import ProjectState
from django . db . migrations . autodetector import MigrationAutodetector
from django . utils . module_loading import module_has_submodule
class Command ( BaseCommand ) :pass
help = '_STR:0_'
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , nargs = '_STR:1_' ,  help = 'App label of an application to synchronize the state.' )
parser . add_argument ( '_STR:1_' , nargs = '_STR:2_' ,  help = 'Database state will be brought to the state after that migration.' )
parser . add_argument ( '_STR:1_' , action = '_STR:2_' , dest = '_STR:3_' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' )
parser . add_argument ( '_STR:1_' , action = '_STR:2_' , dest = 'load_initial_data' , default = True ,  help = 'Tells Django not to load any initial data after database synchronization.' )
parser . add_argument ( '_STR:2_' , action = '_STR:3_' , dest = '_STR:4_' ,  default = DEFAULT_DB_ALIAS , help = 'Nominates a database to synchronize. '  'Defaults to the "default" database.' )
parser . add_argument ( '_STR:1_' , action = '_STR:2_' , dest = '_STR:3_' , default = False ,  help = 'Mark migrations as run without actually running them' )
parser . add_argument ( '_STR:1_' , '_STR:2_' , action = '_STR:3_' , dest = '_STR:4_' , default = False ,  help = 'Show a list of all known migrations and which are applied' )
def handle ( self , * args , ** options ) :pass
self . verbosity = options . get ( '_STR:0_' )
self . interactive = options . get ( '_STR:0_' )
self . show_traceback = options . get ( '_STR:0_' )
self . load_initial_data = options . get ( '_STR:0_' )
self . test_database = options . get ( '_STR:0_' , False )
for app_config in apps . get_app_configs ( ) :pass
if module_has_submodule ( app_config . module , '_STR:0_' ) :pass
import_module ( '_STR:0_' , app_config . name )
db = options . get ( '_STR:0_' )
connection = connections [ db ]
if options . get ( "list" , False ) :pass
return self . show_migration_list ( connection , [ options [ '_STR:0_' ] ] if options [ '_STR:0_' ] else None )
executor = MigrationExecutor ( connection , self . migration_progress_callback )
conflicts = executor . loader . detect_conflicts ( )
if conflicts :pass
name_str = "; " . join (  "%s in %s" % ( ", " . join ( names ) , app )  for app , names in conflicts . items ( )  )
raise CommandError ( '_STR:2_' % name_str )
run_syncdb = False
target_app_labels_only = True
if options [ '_STR:0_' ] and options [ '_STR:1_' ] :pass
app_label , migration_name = options [ '_STR:0_' ] , options [ '_STR:1_' ]
if app_label not in executor . loader . migrated_apps :pass
raise CommandError ( '_STR:0_' % app_label )
if migration_name == "zero" :pass
targets = [ ( app_label , None ) ]
if True: pass _newline_ else :pass
try :pass _newline_ except: pass
migration = executor . loader . get_migration_by_prefix ( app_label , migration_name )
try: pass _newline_ except AmbiguityError :pass
raise CommandError ( '_STR:0_' % (  migration_name , app_label ) )
try: pass _newline_ except KeyError :pass
raise CommandError ( '_STR:0_' % (  migration_name , app_label ) )
targets = [ ( app_label , migration . name ) ]
target_app_labels_only = False
if True: pass _newline_ elif options [ '_STR:0_' ] :pass
app_label = options [ '_STR:0_' ]
if app_label not in executor . loader . migrated_apps :pass
raise CommandError ( '_STR:0_' % app_label )
targets = [ key for key in executor . loader . graph . leaf_nodes ( ) if key [ 0 ] == app_label ]
if True: pass _newline_ else :pass
targets = executor . loader . graph . leaf_nodes ( )
run_syncdb = True
plan = executor . migration_plan ( targets )
if self . verbosity >= 1 :pass
self . stdout . write ( self . style . MIGRATE_HEADING ( '_STR:0_' ) )
if run_syncdb and executor . loader . unmigrated_apps :pass
self . stdout . write ( self . style . MIGRATE_LABEL ( '_STR:1_' ) + ( ", " . join ( executor . loader . unmigrated_apps ) ) )
if target_app_labels_only :pass
self . stdout . write ( self . style . MIGRATE_LABEL ( "  Apply all migrations: " ) + ( ", " . join ( set ( a for a , n in targets ) ) or "(none)" ) )
if True: pass _newline_ else :pass
if targets [ 0 ] [ 1 ] is None :pass
self . stdout . write ( self . style . MIGRATE_LABEL ( '_STR:0_' ) + "%s" % ( targets [ 0 ] [ 0 ] , ) )
if True: pass _newline_ else :pass
self . stdout . write ( self . style . MIGRATE_LABEL ( "  Target specific migration: " ) + '_STR:0_' % ( targets [ 0 ] [ 1 ] , targets [ 0 ] [ 0 ] ) )
if run_syncdb and executor . loader . unmigrated_apps :pass
if self . verbosity >= 1 :pass
self . stdout . write ( self . style . MIGRATE_HEADING ( '_STR:0_' ) )
created_models = self . sync_apps ( connection , executor . loader . unmigrated_apps )
if True: pass _newline_ else :pass
created_models = [ ]
if options . get ( "test_flush" , False ) :pass
call_command (  '_STR:0_' ,  verbosity = max ( self . verbosity - 1 , 0 ) ,  interactive = False ,  database = db ,  reset_sequences = False ,  inhibit_post_migrate = True ,  )
if self . verbosity >= 1 :pass
self . stdout . write ( self . style . MIGRATE_HEADING ( '_STR:0_' ) )
if not plan :pass
if self . verbosity >= 1 :pass
self . stdout . write ( '_STR:0_' )
autodetector = MigrationAutodetector (  executor . loader . project_state ( ) ,  ProjectState . from_apps ( apps ) ,  )
changes = autodetector . changes ( graph = executor . loader . graph )
if changes :pass
self . stdout . write ( self . style . NOTICE ( '_STR:0_' ) )
self . stdout . write ( self . style . NOTICE ( '_STR:0_' ) )
if True: pass _newline_ else :pass
executor . migrate ( targets , plan , fake = options . get ( "fake" , False ) )
emit_post_migrate_signal ( created_models , self . verbosity , self . interactive , connection . alias )
def migration_progress_callback ( self , action , migration , fake = False ) :pass
if self . verbosity >= 1 :pass
if action == '_STR:0_' :pass
self . stdout . write ( '_STR:0_' % migration , ending = "" )
self . stdout . flush ( )
if True: pass _newline_ elif action == "apply_success" :pass
if fake :pass
self . stdout . write ( self . style . MIGRATE_SUCCESS ( '_STR:0_' ) )
if True: pass _newline_ else :pass
self . stdout . write ( self . style . MIGRATE_SUCCESS ( '_STR:0_' ) )
if True: pass _newline_ elif action == "unapply_start" :pass
self . stdout . write ( '_STR:0_' % migration , ending = "" )
self . stdout . flush ( )
if True: pass _newline_ elif action == '_STR:0_' :pass
if fake :pass
self . stdout . write ( self . style . MIGRATE_SUCCESS ( '_STR:0_' ) )
if True: pass _newline_ else :pass
self . stdout . write ( self . style . MIGRATE_SUCCESS ( '_STR:0_' ) )
def sync_apps ( self , connection , app_labels ) :pass
cursor = connection . cursor ( )
try :pass _newline_ except: pass
tables = connection . introspection . table_names ( cursor )
seen_models = connection . introspection . installed_models ( tables )
created_models = set ( )
pending_references = { }
all_models = [  ( app_config . label ,  router . get_migratable_models ( app_config , connection . alias , include_auto_created = True ) )  for app_config in apps . get_app_configs ( )  if app_config . models_module is not None and app_config . label in app_labels  ]
def model_installed ( model ) :pass
opts = model . _meta
converter = connection . introspection . table_name_converter
return not ( ( converter ( opts . db_table ) in tables ) or  ( opts . auto_created and converter ( opts . auto_created . _meta . db_table ) in tables ) )
manifest = OrderedDict (  ( app_name , list ( filter ( model_installed , model_list ) ) )  for app_name , model_list in all_models  )
create_models = set ( itertools . chain ( * manifest . values ( ) ) )
emit_pre_migrate_signal ( create_models , self . verbosity , self . interactive , connection . alias )
if self . verbosity >= 1 :pass
self . stdout . write ( '_STR:0_' )
with transaction . atomic ( using = connection . alias , savepoint = connection . features . can_rollback_ddl ) :pass
for app_name , model_list in manifest . items ( ) :pass
for model in model_list :pass
if self . verbosity >= 3 :pass
self . stdout . write ( '_STR:0_' % ( app_name , model . _meta . object_name ) )
sql , references = connection . creation . sql_create_model ( model , no_style ( ) , seen_models )
seen_models . add ( model )
created_models . add ( model )
for refto , refs in references . items ( ) :pass
pending_references . setdefault ( refto , [ ] ) . extend ( refs )
if refto in seen_models :pass
sql . extend ( connection . creation . sql_for_pending_references ( refto , no_style ( ) , pending_references ) )
sql . extend ( connection . creation . sql_for_pending_references ( model , no_style ( ) , pending_references ) )
if self . verbosity >= 1 and sql :pass
self . stdout . write ( '_STR:0_' % model . _meta . db_table )
for statement in sql :pass
cursor . execute ( statement )
tables . append ( connection . introspection . table_name_converter ( model . _meta . db_table ) )
try: pass _newline_ finally :pass
cursor . close ( )
cursor = connection . cursor ( )
try :pass _newline_ except: pass
if self . verbosity >= 1 :pass
self . stdout . write ( '_STR:0_' )
for app_name , model_list in manifest . items ( ) :pass
for model in model_list :pass
if model in created_models :pass
custom_sql = custom_sql_for_model ( model , no_style ( ) , connection )
if custom_sql :pass
if self . verbosity >= 2 :pass
self . stdout . write ( '_STR:0_' % ( app_name , model . _meta . object_name ) )
try :pass _newline_ except: pass
with transaction . atomic ( using = connection . alias ) :pass
for sql in custom_sql :pass
cursor . execute ( sql )
try: pass _newline_ except Exception as e :pass
self . stderr . write ( '_STR:0_' % ( app_name , model . _meta . object_name , e ) )
if self . show_traceback :pass
traceback . print_exc ( )
if True: pass _newline_ else :pass
if self . verbosity >= 3 :pass
self . stdout . write ( '_STR:0_' % ( app_name , model . _meta . object_name ) )
if self . verbosity >= 1 :pass
self . stdout . write ( '_STR:0_' )
for app_name , model_list in manifest . items ( ) :pass
for model in model_list :pass
if model in created_models :pass
index_sql = connection . creation . sql_indexes_for_model ( model , no_style ( ) )
if index_sql :pass
if self . verbosity >= 2 :pass
self . stdout . write ( '_STR:0_' % ( app_name , model . _meta . object_name ) )
try :pass _newline_ except: pass
with transaction . atomic ( using = connection . alias , savepoint = connection . features . can_rollback_ddl ) :pass
for sql in index_sql :pass
cursor . execute ( sql )
try: pass _newline_ except Exception as e :pass
self . stderr . write ( '_STR:0_' % ( app_name , model . _meta . object_name , e ) )
try: pass _newline_ finally :pass
cursor . close ( )
if self . load_initial_data :pass
for app_label in app_labels :pass
call_command ( '_STR:0_' , '_STR:1_' , verbosity = self . verbosity , database = connection . alias , skip_validation = True , app_label = app_label , hide_empty = True )
return created_models
def show_migration_list ( self , connection , app_names = None ) :pass
loader = MigrationLoader ( connection )
graph = loader . graph
if app_names :pass
invalid_apps = [ ]
for app_name in app_names :pass
if app_name not in loader . migrated_apps :pass
invalid_apps . append ( app_name )
if invalid_apps :pass
raise CommandError ( '_STR:0_' % ( ", " . join ( invalid_apps ) ) )
if True: pass _newline_ else :pass
app_names = sorted ( loader . migrated_apps )
for app_name in app_names :pass
self . stdout . write ( app_name , self . style . MIGRATE_LABEL )
shown = set ( )
for node in graph . leaf_nodes ( app_name ) :pass
for plan_node in graph . forwards_plan ( node ) :pass
if plan_node not in shown and plan_node [ 0 ] == app_name :pass
title = plan_node [ 1 ]
if graph . nodes [ plan_node ] . replaces :pass
title += '_STR:0_' % len ( graph . nodes [ plan_node ] . replaces )
if plan_node in loader . applied_migrations :pass
self . stdout . write ( '_STR:0_' % title )
if True: pass _newline_ else :pass
self . stdout . write ( '_STR:0_' % title )
shown . add ( plan_node )
if not shown :pass
self . stdout . write ( '_STR:0_' , self . style . MIGRATE_FAILURE )
import argparse
import warnings
from django . core . management . base import BaseCommand
from django . utils . deprecation import RemovedInDjango19Warning
class Command ( BaseCommand ) :pass
help = '_STR:0_'
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , nargs = argparse . REMAINDER ,  help = '_STR:1_' )
def handle ( self , * args , ** options ) :pass
warnings . warn (  '_STR:0_' ,  RemovedInDjango19Warning )
from django . conf import settings
from django . utils import translation
try :pass _newline_ except: pass
translation . activate ( settings . LANGUAGE_CODE )
try: pass _newline_ except AttributeError :pass
pass
from django . core . servers . fastcgi import runfastcgi
runfastcgi ( args )
def usage ( self , subcommand ) :pass
from django . core . servers . fastcgi import FASTCGI_HELP
return FASTCGI_HELP
from __future__ import unicode_literals
from datetime import datetime
import errno
import os
import re
import sys
import socket
from django . core . management . base import BaseCommand , CommandError
from django . core . servers . basehttp import run , get_internal_wsgi_application
from django . db import connections , DEFAULT_DB_ALIAS
from django . db . migrations . executor import MigrationExecutor
from django . utils import autoreload
from django . utils import six
from django . core . exceptions import ImproperlyConfigured
naiveip_re = re . compile ( r'_STR:0_'"^(?: (?P<addr>     (?P<ipv4>\d{1,3}(?:\.\d{1,3}){3}) |         # IPv4 address     (?P<ipv6>\[[a-fA-F0-9:]+\]) |               # IPv6 address     (?P<fqdn>[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*) # FQDN ):)?(?P<port>\d+)$'_STR:0_'" , re . X )
DEFAULT_PORT = '_STR:2_'
class Command ( BaseCommand ) :pass
help = '_STR:0_'
requires_system_checks = False
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , nargs = '_STR:1_' ,  help = '_STR:2_' )
parser . add_argument ( '_STR:0_' , '_STR:1_' , action = '_STR:2_' , dest = 'use_ipv6' , default = False ,  help = 'Tells Django to use an IPv6 address.' )
parser . add_argument ( '_STR:2_' , action = '_STR:3_' , dest = 'use_threading' , default = True ,  help = 'Tells Django to NOT use threading.' )
parser . add_argument ( '_STR:2_' , action = '_STR:3_' , dest = 'use_reloader' , default = True ,  help = 'Tells Django to NOT use the auto-reloader.' )
def get_handler ( self , * args , ** options ) :pass
return get_internal_wsgi_application ( )
def handle ( self , * args , ** options ) :pass
from django . conf import settings
if not settings . DEBUG and not settings . ALLOWED_HOSTS :pass
raise CommandError ( '_STR:0_' )
self . use_ipv6 = options . get ( '_STR:0_' )
if self . use_ipv6 and not socket . has_ipv6 :pass
raise CommandError ( '_STR:0_' )
self . _raw_ipv6 = False
if not options . get ( '_STR:0_' ) :pass
self . addr = ''
self . port = DEFAULT_PORT
if True: pass _newline_ else :pass
m = re . match ( naiveip_re , options [ '_STR:0_' ] )
if m is None :pass
raise CommandError ( '"%s" is not a valid port number '  'or address:port pair.' % options [ 'addrport' ] )
self . addr , _ipv4 , _ipv6 , _fqdn , self . port = m . groups ( )
if not self . port . isdigit ( ) :pass
raise CommandError ( '_STR:0_' % self . port )
if self . addr :pass
if _ipv6 :pass
self . addr = self . addr [ 1 : - 1 ]
self . use_ipv6 = True
self . _raw_ipv6 = True
if True: pass _newline_ elif self . use_ipv6 and not _fqdn :pass
raise CommandError ( '_STR:0_' % self . addr )
if not self . addr :pass
self . addr = '_STR:0_' if self . use_ipv6 else '_STR:1_'
self . _raw_ipv6 = bool ( self . use_ipv6 )
self . run ( ** options )
def run ( self , ** options ) :pass
use_reloader = options . get ( '_STR:0_' )
if use_reloader :pass
autoreload . main ( self . inner_run , None , options )
if True: pass _newline_ else :pass
self . inner_run ( None , ** options )
def inner_run ( self , * args , ** options ) :pass
from django . conf import settings
from django . utils import translation
threading = options . get ( '_STR:0_' )
shutdown_message = options . get ( '_STR:0_' , '' )
quit_command = 'CTRL-BREAK' if sys . platform == 'win32' else 'CONTROL-C'
self . stdout . write ( '_STR:0_' )
self . validate ( display_num_errors = True )
try :pass _newline_ except: pass
self . check_migrations ( )
try: pass _newline_ except ImproperlyConfigured :pass
pass
now = datetime . now ( ) . strftime ( '_STR:0_' )
if six . PY2 :pass
now = now . decode ( '_STR:0_' )
self . stdout . write ( (  "%(started_at)s\n"  "Django version %(version)s, using settings %(settings)r\n"  "Starting development server at http://%(addr)s:%(port)s/\n"  "Quit the server with %(quit_command)s.\n"  ) % {  "started_at" : now ,  "version" : self . get_version ( ) ,  "settings" : settings . SETTINGS_MODULE ,  "addr" : '[%s]' % self . addr if self . _raw_ipv6 else self . addr ,  "port" : self . port ,  "quit_command" : quit_command ,  } )
translation . activate ( settings . LANGUAGE_CODE )
try :pass _newline_ except: pass
handler = self . get_handler ( * args , ** options )
run ( self . addr , int ( self . port ) , handler ,  ipv6 = self . use_ipv6 , threading = threading )
try: pass _newline_ except socket . error as e :pass
ERRORS = {  errno . EACCES : '_STR:0_' ,  errno . EADDRINUSE : "That port is already in use." ,  errno . EADDRNOTAVAIL : "That IP address can't be assigned-to." ,  }
try :pass _newline_ except: pass
error_text = ERRORS [ e . errno ]
try: pass _newline_ except KeyError :pass
error_text = str ( e )
self . stderr . write ( '_STR:0_' % error_text )
os . _exit ( 1 )
try: pass _newline_ except KeyboardInterrupt :pass
if shutdown_message :pass
self . stdout . write ( shutdown_message )
sys . exit ( 0 )
def check_migrations ( self ) :pass
executor = MigrationExecutor ( connections [ DEFAULT_DB_ALIAS ] )
plan = executor . migration_plan ( executor . loader . graph . leaf_nodes ( ) )
if plan :pass
self . stdout . write ( self . style . NOTICE ( "\nYou have unapplied migrations; your app may not work properly until they are applied." ) )
self . stdout . write ( self . style . NOTICE ( '_STR:1_' ) )
BaseRunserverCommand = Command
import os
from django . core . management . base import BaseCommand
class Command ( BaseCommand ) :pass
help = '_STR:0_'
requires_system_checks = False
shells = [ '_STR:0_' , '_STR:1_' ]
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , action = '_STR:1_' , dest = '_STR:2_' ,  help = 'Tells Django to use plain Python, not IPython or bpython.' )
parser . add_argument ( '_STR:1_' , action = '_STR:2_' , dest = 'no_startup' ,  help = 'When using plain Python, ignore the PYTHONSTARTUP environment variable and ~/.pythonrc.py script.' )
parser . add_argument ( '_STR:2_' , '_STR:3_' , choices = self . shells , dest = 'interface' ,  help = 'Specify an interactive interpreter interface. Available options: "ipython" and "bpython"' )
def _ipython_pre_011 ( self ) :pass
from IPython . Shell import IPShell
shell = IPShell ( argv = [ ] )
shell . mainloop ( )
def _ipython_pre_100 ( self ) :pass
from IPython . frontend . terminal . ipapp import TerminalIPythonApp
app = TerminalIPythonApp . instance ( )
app . initialize ( argv = [ ] )
app . start ( )
def _ipython ( self ) :pass
from IPython import start_ipython
start_ipython ( argv = [ ] )
def ipython ( self ) :pass
for ip in ( self . _ipython , self . _ipython_pre_100 , self . _ipython_pre_011 ) :pass
try :pass _newline_ except: pass
ip ( )
try: pass _newline_ except ImportError :pass
pass
if True: pass _newline_ else :pass
return
raise ImportError ( '_STR:0_' )
def bpython ( self ) :pass
import bpython
bpython . embed ( )
def run_shell ( self , shell = None ) :pass
available_shells = [ shell ] if shell else self . shells
for shell in available_shells :pass
try :pass _newline_ except: pass
return getattr ( self , shell ) ( )
try: pass _newline_ except ImportError :pass
pass
raise ImportError
def handle ( self , ** options ) :pass
try :pass _newline_ except: pass
if options [ '_STR:0_' ] :pass
raise ImportError
self . run_shell ( shell = options [ '_STR:0_' ] )
try: pass _newline_ except ImportError :pass
import code
imported_objects = { }
try :pass _newline_ except: pass
import readline
try: pass _newline_ except ImportError :pass
pass
if True: pass _newline_ else :pass
import rlcompleter
readline . set_completer ( rlcompleter . Completer ( imported_objects ) . complete )
readline . parse_and_bind ( '_STR:0_' )
if not options [ '_STR:0_' ] :pass
for pythonrc in ( os . environ . get ( '_STR:0_' ) , '~/.pythonrc.py' ) :pass
if not pythonrc :pass
continue
pythonrc = os . path . expanduser ( pythonrc )
if not os . path . isfile ( pythonrc ) :pass
continue
try :pass _newline_ except: pass
with open ( pythonrc ) as handle :pass
exec ( compile ( handle . read ( ) , pythonrc , '_STR:0_' ) , imported_objects )
try: pass _newline_ except NameError :pass
pass
code . interact ( local = imported_objects )
from __future__ import unicode_literals
from django . core . management . base import AppCommand
from django . core . management . sql import sql_create
from django . db import connections , DEFAULT_DB_ALIAS
class Command ( AppCommand ) :pass
help = '_STR:0_'
output_transaction = True
def add_arguments ( self , parser ) :pass
super ( Command , self ) . add_arguments ( parser )
parser . add_argument ( '_STR:0_' , default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to print the SQL for. Defaults to the '  '"default" database.' )
def handle_app_config ( self , app_config , ** options ) :pass
if app_config . models_module is None :pass
return
connection = connections [ options [ '_STR:0_' ] ]
statements = sql_create ( app_config , self . style , connection )
return '\n' . join ( statements )
from __future__ import unicode_literals
from django . core . management . base import AppCommand
from django . core . management . sql import sql_all
from django . db import connections , DEFAULT_DB_ALIAS
class Command ( AppCommand ) :pass
help = '_STR:0_'
output_transaction = True
def add_arguments ( self , parser ) :pass
super ( Command , self ) . add_arguments ( parser )
parser . add_argument ( '_STR:0_' , default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to print the SQL for. Defaults to the '  '"default" database.' )
def handle_app_config ( self , app_config , ** options ) :pass
if app_config . models_module is None :pass
return
connection = connections [ options [ '_STR:0_' ] ]
statements = sql_all ( app_config , self . style , connection )
return '\n' . join ( statements )
from __future__ import unicode_literals
from django . core . management . base import AppCommand
from django . core . management . sql import sql_delete
from django . db import connections , DEFAULT_DB_ALIAS
class Command ( AppCommand ) :pass
help = '_STR:0_'
output_transaction = True
def add_arguments ( self , parser ) :pass
super ( Command , self ) . add_arguments ( parser )
parser . add_argument ( '_STR:0_' , default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to print the SQL for. Defaults to the '  '"default" database.' )
def handle_app_config ( self , app_config , ** options ) :pass
if app_config . models_module is None :pass
return
connection = connections [ options [ '_STR:0_' ] ]
statements = sql_delete ( app_config , self . style , connection )
return '\n' . join ( statements )
from __future__ import unicode_literals
from django . core . management . base import AppCommand
from django . core . management . sql import sql_custom
from django . db import connections , DEFAULT_DB_ALIAS
class Command ( AppCommand ) :pass
help = '_STR:0_'
output_transaction = True
def add_arguments ( self , parser ) :pass
super ( Command , self ) . add_arguments ( parser )
parser . add_argument ( '_STR:0_' , default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to print the SQL for. Defaults to the '  '"default" database.' )
def handle_app_config ( self , app_config , ** options ) :pass
if app_config . models_module is None :pass
return
connection = connections [ options [ '_STR:0_' ] ]
statements = sql_custom ( app_config , self . style , connection )
return '\n' . join ( statements )
from __future__ import unicode_literals
from django . core . management . base import AppCommand
from django . core . management . sql import sql_destroy_indexes
from django . db import connections , DEFAULT_DB_ALIAS
class Command ( AppCommand ) :pass
help = '_STR:0_'
output_transaction = True
def add_arguments ( self , parser ) :pass
super ( Command , self ) . add_arguments ( parser )
parser . add_argument ( '_STR:0_' , default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to print the SQL for. Defaults to the '  '"default" database.' )
def handle_app_config ( self , app_config , ** options ) :pass
if app_config . models_module is None :pass
return
connection = connections [ options [ '_STR:0_' ] ]
statements = sql_destroy_indexes ( app_config , self . style , connection )
return '\n' . join ( statements )
from __future__ import unicode_literals
from django . core . management . base import BaseCommand
from django . core . management . sql import sql_flush
from django . db import connections , DEFAULT_DB_ALIAS
class Command ( BaseCommand ) :pass
help = '_STR:0_'
output_transaction = True
def add_arguments ( self , parser ) :pass
super ( Command , self ) . add_arguments ( parser )
parser . add_argument ( '_STR:0_' , default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to print the SQL for. Defaults to the '  '"default" database.' )
def handle ( self , ** options ) :pass
return '\n' . join ( sql_flush ( self . style , connections [ options [ '_STR:0_' ] ] , only_django = True ) )
from __future__ import unicode_literals
from django . core . management . base import AppCommand
from django . core . management . sql import sql_indexes
from django . db import connections , DEFAULT_DB_ALIAS
class Command ( AppCommand ) :pass
help = '_STR:0_'
output_transaction = True
def add_arguments ( self , parser ) :pass
super ( Command , self ) . add_arguments ( parser )
parser . add_argument ( '_STR:0_' , default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to print the SQL for. Defaults to the '  '"default" database.' )
def handle_app_config ( self , app_config , ** options ) :pass
if app_config . models_module is None :pass
return
connection = connections [ options [ '_STR:0_' ] ]
statements = sql_indexes ( app_config , self . style , connection )
return '\n' . join ( statements )
from __future__ import unicode_literals
from django . core . management . base import BaseCommand , CommandError
from django . db import connections , DEFAULT_DB_ALIAS
from django . db . migrations . executor import MigrationExecutor
from django . db . migrations . loader import AmbiguityError
class Command ( BaseCommand ) :pass
help = '_STR:0_'
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' ,  help = '_STR:1_' )
parser . add_argument ( '_STR:0_' ,  help = '_STR:1_' )
parser . add_argument ( '_STR:0_' , default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to create SQL for. Defaults to the '  '"default" database.' )
parser . add_argument ( '_STR:0_' , action = '_STR:1_' , dest = '_STR:2_' ,  default = False , help = 'Creates SQL to unapply the migration, rather than to apply it' )
def handle ( self , * args , ** options ) :pass
connection = connections [ options [ '_STR:0_' ] ]
executor = MigrationExecutor ( connection )
app_label , migration_name = options [ '_STR:0_' ] , options [ '_STR:1_' ]
if app_label not in executor . loader . migrated_apps :pass
raise CommandError ( '_STR:0_' % app_label )
try :pass _newline_ except: pass
migration = executor . loader . get_migration_by_prefix ( app_label , migration_name )
try: pass _newline_ except AmbiguityError :pass
raise CommandError ( '_STR:0_' % (  migration_name , app_label ) )
try: pass _newline_ except KeyError :pass
raise CommandError ( '_STR:0_' % (  migration_name , app_label ) )
targets = [ ( app_label , migration . name ) ]
plan = [ ( executor . loader . graph . nodes [ targets [ 0 ] ] , options [ '_STR:0_' ] ) ]
sql_statements = executor . collect_sql ( plan )
for statement in sql_statements :pass
self . stdout . write ( statement )
from __future__ import unicode_literals
from django . core . management . base import AppCommand
from django . core . management . sql import check_for_migrations
from django . db import connections , DEFAULT_DB_ALIAS
class Command ( AppCommand ) :pass
help = '_STR:0_'
output_transaction = True
def add_arguments ( self , parser ) :pass
super ( Command , self ) . add_arguments ( parser )
parser . add_argument ( '_STR:0_' , default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to print the SQL for. Defaults to the '  '"default" database.' )
def handle_app_config ( self , app_config , ** options ) :pass
if app_config . models_module is None :pass
return
connection = connections [ options . get ( '_STR:0_' ) ]
check_for_migrations ( app_config , connection )
models = app_config . get_models ( include_auto_created = True )
statements = connection . ops . sequence_reset_sql ( self . style , models )
return '\n' . join ( statements )
from django . core . management . base import BaseCommand , CommandError
from django . utils import six
from django . db import connections , DEFAULT_DB_ALIAS , migrations
from django . db . migrations . loader import AmbiguityError
from django . db . migrations . executor import MigrationExecutor
from django . db . migrations . writer import MigrationWriter
from django . db . migrations . optimizer import MigrationOptimizer
class Command ( BaseCommand ) :pass
help = '_STR:0_'
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' ,  help = 'App label of the application to squash migrations for.' )
parser . add_argument ( '_STR:1_' ,  help = 'Migrations will be squashed until and including this migration.' )
parser . add_argument ( '_STR:1_' , action = '_STR:2_' , dest = 'no_optimize' , default = False ,  help = 'Do not try to optimize the squashed operations.' )
parser . add_argument ( '_STR:2_' , action = '_STR:3_' , dest = 'interactive' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' )
def handle ( self , ** options ) :pass
self . verbosity = options . get ( '_STR:0_' )
self . interactive = options . get ( '_STR:0_' )
app_label , migration_name = options [ '_STR:0_' ] , options [ '_STR:1_' ]
executor = MigrationExecutor ( connections [ DEFAULT_DB_ALIAS ] )
if app_label not in executor . loader . migrated_apps :pass
raise CommandError ( '_STR:0_' % app_label )
try :pass _newline_ except: pass
migration = executor . loader . get_migration_by_prefix ( app_label , migration_name )
try: pass _newline_ except AmbiguityError :pass
raise CommandError ( '_STR:0_' % ( migration_name , app_label ) )
try: pass _newline_ except KeyError :pass
raise CommandError ( '_STR:0_' % ( migration_name , app_label ) )
migrations_to_squash = [  executor . loader . get_migration ( al , mn )  for al , mn in executor . loader . graph . forwards_plan ( ( migration . app_label , migration . name ) )  if al == migration . app_label  ]
if self . verbosity > 0 or self . interactive :pass
self . stdout . write ( self . style . MIGRATE_HEADING ( '_STR:0_' ) )
for migration in migrations_to_squash :pass
self . stdout . write ( " - %s" % migration . name )
if self . interactive :pass
answer = None
while not answer or answer not in '_STR:0_' :pass
answer = six . moves . input ( '_STR:0_' )
if not answer :pass
answer = "n"
break
if True: pass _newline_ else :pass
answer = answer [ 0 ] . lower ( )
if answer != "y" :pass
return
operations = [ ]
for smigration in migrations_to_squash :pass
operations . extend ( smigration . operations )
if self . verbosity > 0 :pass
self . stdout . write ( self . style . MIGRATE_HEADING ( '_STR:0_' ) )
optimizer = MigrationOptimizer ( )
new_operations = optimizer . optimize ( operations , migration . app_label )
if self . verbosity > 0 :pass
if len ( new_operations ) == len ( operations ) :pass
self . stdout . write ( '_STR:0_' )
if True: pass _newline_ else :pass
self . stdout . write ( '_STR:0_' % ( len ( operations ) , len ( new_operations ) ) )
replaces = [ ]
for migration in migrations_to_squash :pass
if migration . replaces :pass
replaces . extend ( migration . replaces )
if True: pass _newline_ else :pass
replaces . append ( ( migration . app_label , migration . name ) )
subclass = type ( "Migration" , ( migrations . Migration , ) , {  "dependencies" : [ ] ,  "operations" : new_operations ,  "replaces" : replaces ,  } )
new_migration = subclass ( '_STR:0_' % migration . name , app_label )
writer = MigrationWriter ( new_migration )
with open ( writer . path , "wb" ) as fh :pass
fh . write ( writer . as_string ( ) )
if self . verbosity > 0 :pass
self . stdout . write ( self . style . MIGRATE_HEADING ( '_STR:0_' % writer . path ) )
self . stdout . write ( '_STR:0_' )
self . stdout . write ( '_STR:0_' )
self . stdout . write ( '_STR:0_' )
self . stdout . write ( '_STR:0_' )
from importlib import import_module
from django . core . management . base import CommandError
from django . core . management . templates import TemplateCommand
class Command ( TemplateCommand ) :pass
help = ( "Creates a Django app directory structure for the given app "  "name in the current directory or optionally in the given "  "directory." )
missing_args_message = '_STR:0_'
def handle ( self , ** options ) :pass
app_name , target = options . pop ( '_STR:0_' ) , options . pop ( '_STR:1_' )
self . validate_name ( app_name , "app" )
try :pass _newline_ except: pass
import_module ( app_name )
try: pass _newline_ except ImportError :pass
pass
if True: pass _newline_ else :pass
raise CommandError ( "%r conflicts with the name of an existing "  "Python module and cannot be used as an app "  "name. Please try another name." % app_name )
super ( Command , self ) . handle ( '_STR:2_' , app_name , target , ** options )
from importlib import import_module
from django . core . management . base import CommandError
from django . core . management . templates import TemplateCommand
from django . utils . crypto import get_random_string
class Command ( TemplateCommand ) :pass
help = ( '_STR:0_'  "project name in the current directory or optionally in the "  "given directory." )
missing_args_message = '_STR:1_'
def handle ( self , ** options ) :pass
project_name , target = options . pop ( '_STR:0_' ) , options . pop ( 'directory' )
self . validate_name ( project_name , '_STR:0_' )
try :pass _newline_ except: pass
import_module ( project_name )
try: pass _newline_ except ImportError :pass
pass
if True: pass _newline_ else :pass
raise CommandError ( "%r conflicts with the name of an existing "  "Python module and cannot be used as a "  "project name. Please try another name." %  project_name )
chars = '_STR:0_'
options [ '_STR:0_' ] = get_random_string ( 50 , chars )
super ( Command , self ) . handle ( '_STR:0_' , project_name , target , ** options )
import warnings
from django . apps import apps
from django . contrib . auth import get_user_model
from django . db import DEFAULT_DB_ALIAS
from django . core . management import call_command
from django . core . management . base import BaseCommand
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils . six . moves import input
class Command ( BaseCommand ) :pass
help = '_STR:0_'
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , action = '_STR:1_' , dest = 'interactive' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' )
parser . add_argument ( '_STR:2_' , action = '_STR:3_' , dest = 'load_initial_data' , default = True ,  help = 'Tells Django not to load any initial data after database synchronization.' )
parser . add_argument ( '_STR:2_' , default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to synchronize. Defaults to the "default" database.' )
def handle ( self , ** options ) :pass
warnings . warn ( '_STR:0_' , RemovedInDjango19Warning )
call_command ( "migrate" , ** options )
try :pass _newline_ except: pass
apps . get_model ( '_STR:0_' , '_STR:1_' )
try: pass _newline_ except LookupError :pass
return
UserModel = get_user_model ( )
if not UserModel . _default_manager . exists ( ) and options . get ( '_STR:0_' ) :pass
msg = ( "\nYou have installed Django's auth system, and "  "don't have any superusers defined.\nWould you like to create one "  "now? (yes/no): " )
confirm = input ( msg )
while 1 :pass
if confirm not in ( '_STR:0_' , '_STR:1_' ) :pass
confirm = input ( '_STR:0_' )
continue
if confirm == '_STR:0_' :pass
call_command ( '_STR:0_' , interactive = True , database = options [ 'database' ] )
break
import logging
import sys
import os
from django . conf import settings
from django . core . management . base import BaseCommand
from django . test . utils import get_runner
class Command ( BaseCommand ) :pass
help = '_STR:0_'
requires_system_checks = False
def __init__ ( self ) :pass
self . test_runner = None
super ( Command , self ) . __init__ ( )
def run_from_argv ( self , argv ) :pass
option = '_STR:0_'
for arg in argv [ 2 : ] :pass
if arg . startswith ( option ) :pass
self . test_runner = arg [ len ( option ) : ]
break
super ( Command , self ) . run_from_argv ( argv )
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , metavar = '_STR:1_' , nargs = '_STR:2_' ,  help = 'Module paths to test; can be modulename, modulename.TestCase or modulename.TestCase.test_method' )
parser . add_argument ( '_STR:1_' ,  action = '_STR:2_' , dest = '_STR:3_' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' ) ,
parser . add_argument ( '_STR:1_' ,  action = '_STR:2_' , dest = '_STR:3_' , default = False ,  help = 'Tells Django to stop running the test suite after first '  'failed test.' ) ,
parser . add_argument ( '_STR:1_' ,  action = '_STR:2_' , dest = '_STR:3_' ,  help = 'Tells Django to use specified test runner class instead of '  'the one specified by the TEST_RUNNER setting.' ) ,
parser . add_argument ( '_STR:1_' ,  action = '_STR:2_' , dest = '_STR:3_' , default = None ,  help = 'Overrides the default address where the live server (used '  'with LiveServerTestCase) is expected to run from. The '  'default value is localhost:8081.' ) ,
test_runner_class = get_runner ( settings , self . test_runner )
if hasattr ( test_runner_class , '_STR:0_' ) :pass
raise RuntimeError (  '_STR:0_'  "test management command has changed in Django 1.8. Please "  "create an add_arguments class method to achieve this." )
if hasattr ( test_runner_class , '_STR:1_' ) :pass
test_runner_class . add_arguments ( parser )
def execute ( self , * args , ** options ) :pass
if options [ '_STR:0_' ] > 0 :pass
logger = logging . getLogger ( '_STR:0_' )
handler = logging . StreamHandler ( )
logger . addHandler ( handler )
super ( Command , self ) . execute ( * args , ** options )
if options [ '_STR:0_' ] > 0 :pass
logger . removeHandler ( handler )
def handle ( self , * test_labels , ** options ) :pass
from django . conf import settings
from django . test . utils import get_runner
TestRunner = get_runner ( settings , options . get ( '_STR:0_' ) )
if options . get ( '_STR:0_' ) is not None :pass
os . environ [ '_STR:1_' ] = options [ '_STR:0_' ]
del options [ '_STR:0_' ]
test_runner = TestRunner ( ** options )
failures = test_runner . run_tests ( test_labels )
if failures :pass
sys . exit ( bool ( failures ) )
from django . core . management import call_command
from django . core . management . base import BaseCommand
from django . db import connection
class Command ( BaseCommand ) :pass
help = '_STR:0_'
args = '_STR:0_'
requires_system_checks = False
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , metavar = '_STR:1_' , nargs = '_STR:2_' ,  help = '_STR:3_' )
parser . add_argument ( '_STR:0_' , action = '_STR:1_' , dest = '_STR:2_' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' )
parser . add_argument ( '_STR:1_' , default = '' ,  help = '_STR:2_' )
parser . add_argument ( '_STR:0_' , '_STR:1_' , action = '_STR:2_' , dest = '_STR:3_' , default = False ,  help = 'Tells Django to use an IPv6 address.' )
def handle ( self , * fixture_labels , ** options ) :pass
verbosity = options . get ( '_STR:0_' )
interactive = options . get ( '_STR:0_' )
db_name = connection . creation . create_test_db ( verbosity = verbosity , autoclobber = not interactive , serialize = False )
call_command ( '_STR:0_' , * fixture_labels , ** { '_STR:1_' : verbosity } )
shutdown_message = '_STR:1_' % db_name
use_threading = connection . features . test_db_allows_multiple_connections
call_command (  '_STR:0_' ,  addrport = options [ '_STR:1_' ] ,  shutdown_message = shutdown_message ,  use_reloader = False ,  use_ipv6 = options [ 'use_ipv6' ] ,  use_threading = use_threading  )
from __future__ import unicode_literals
import warnings
from django . core . management . commands . check import Command as CheckCommand
from django . utils . deprecation import RemovedInDjango19Warning
class Command ( CheckCommand ) :pass
help = '_STR:0_' + CheckCommand . help
def handle ( self , ** options ) :pass
warnings . warn ( '_STR:0_' ,  RemovedInDjango19Warning )
super ( Command , self ) . handle ( ** options )
from __future__ import unicode_literals
import codecs
import os
import re
import warnings
from django . apps import apps
from django . conf import settings
from django . core . management . base import CommandError
from django . db import models , router
from django . utils . deprecation import RemovedInDjango19Warning
def check_for_migrations ( app_config , connection ) :pass
from django . db . migrations . loader import MigrationLoader
loader = MigrationLoader ( connection )
if app_config . label in loader . migrated_apps :pass
raise CommandError ( '_STR:0_' % app_config . label )
def sql_create ( app_config , style , connection ) :pass
check_for_migrations ( app_config , connection )
if connection . settings_dict [ '_STR:0_' ] == '_STR:1_' :pass
raise CommandError ( '_STR:0_' +  "because you haven't properly specified the ENGINE setting for the database.\n" +  "see: https://docs.djangoproject.com/en/dev/ref/settings/#databases" )
app_models = app_config . get_models ( include_auto_created = True )
final_output = [ ]
tables = connection . introspection . table_names ( )
known_models = set ( model for model in connection . introspection . installed_models ( tables ) if model not in app_models )
pending_references = { }
for model in router . get_migratable_models ( app_config , connection . alias , include_auto_created = True ) :pass
output , references = connection . creation . sql_create_model ( model , style , known_models )
final_output . extend ( output )
for refto , refs in references . items ( ) :pass
pending_references . setdefault ( refto , [ ] ) . extend ( refs )
if refto in known_models :pass
final_output . extend ( connection . creation . sql_for_pending_references ( refto , style , pending_references ) )
final_output . extend ( connection . creation . sql_for_pending_references ( model , style , pending_references ) )
known_models . add ( model )
not_installed_models = set ( pending_references . keys ( ) )
if not_installed_models :pass
alter_sql = [ ]
for model in not_installed_models :pass
alter_sql . extend ( [ '-- ' + sql for sql in  connection . creation . sql_for_pending_references ( model , style , pending_references ) ] )
if alter_sql :pass
final_output . append ( '_STR:0_' )
final_output . extend ( alter_sql )
return final_output
def sql_delete ( app_config , style , connection , close_connection = True ) :pass
check_for_migrations ( app_config , connection )
try :pass _newline_ except: pass
cursor = connection . cursor ( )
try: pass _newline_ except Exception :pass
cursor = None
try :pass _newline_ except: pass
if cursor :pass
table_names = connection . introspection . table_names ( cursor )
if True: pass _newline_ else :pass
table_names = [ ]
output = [ ]
to_delete = set ( )
references_to_delete = { }
app_models = router . get_migratable_models ( app_config , connection . alias , include_auto_created = True )
for model in app_models :pass
if cursor and connection . introspection . table_name_converter ( model . _meta . db_table ) in table_names :pass
opts = model . _meta
for f in opts . local_fields :pass
if f . rel and f . rel . to not in to_delete :pass
references_to_delete . setdefault ( f . rel . to , [ ] ) . append ( ( model , f ) )
to_delete . add ( model )
for model in app_models :pass
if connection . introspection . table_name_converter ( model . _meta . db_table ) in table_names :pass
output . extend ( connection . creation . sql_destroy_model ( model , references_to_delete , style ) )
try: pass _newline_ finally :pass
if cursor and close_connection :pass
cursor . close ( )
connection . close ( )
return output [ : : - 1 ]
def sql_flush ( style , connection , only_django = False , reset_sequences = True , allow_cascade = False ) :pass
if only_django :pass
tables = connection . introspection . django_table_names ( only_existing = True )
if True: pass _newline_ else :pass
tables = connection . introspection . table_names ( )
seqs = connection . introspection . sequence_list ( ) if reset_sequences else ( )
statements = connection . ops . sql_flush ( style , tables , seqs , allow_cascade )
return statements
def sql_custom ( app_config , style , connection ) :pass
check_for_migrations ( app_config , connection )
output = [ ]
app_models = router . get_migratable_models ( app_config , connection . alias )
for model in app_models :pass
output . extend ( custom_sql_for_model ( model , style , connection ) )
return output
def sql_indexes ( app_config , style , connection ) :pass
check_for_migrations ( app_config , connection )
output = [ ]
for model in router . get_migratable_models ( app_config , connection . alias , include_auto_created = True ) :pass
output . extend ( connection . creation . sql_indexes_for_model ( model , style ) )
return output
def sql_destroy_indexes ( app_config , style , connection ) :pass
check_for_migrations ( app_config , connection )
output = [ ]
for model in router . get_migratable_models ( app_config , connection . alias , include_auto_created = True ) :pass
output . extend ( connection . creation . sql_destroy_indexes_for_model ( model , style ) )
return output
def sql_all ( app_config , style , connection ) :pass
check_for_migrations ( app_config , connection )
return sql_create ( app_config , style , connection ) + sql_custom ( app_config , style , connection ) + sql_indexes ( app_config , style , connection )
def _split_statements ( content ) :pass
comment_re = re . compile ( r'_STR:0_' )
statements = [ ]
statement = [ ]
for line in content . split ( "\n" ) :pass
cleaned_line = comment_re . sub ( r"\1" , line ) . strip ( )
if not cleaned_line :pass
continue
statement . append ( cleaned_line )
if cleaned_line . endswith ( ";" ) :pass
statements . append ( " " . join ( statement ) )
statement = [ ]
return statements
def custom_sql_for_model ( model , style , connection ) :pass
opts = model . _meta
app_dirs = [ ]
app_dir = apps . get_app_config ( model . _meta . app_label ) . path
app_dirs . append ( os . path . normpath ( os . path . join ( app_dir , '_STR:0_' ) ) )
old_app_dir = os . path . normpath ( os . path . join ( app_dir , '_STR:0_' ) )
if os . path . exists ( old_app_dir ) :pass
warnings . warn ( "Custom SQL location '<app_label>/models/sql' is "  "deprecated, use '<app_label>/sql' instead." ,  RemovedInDjango19Warning )
app_dirs . append ( old_app_dir )
output = [ ]
if opts . managed :pass
post_sql_fields = [ f for f in opts . local_fields if hasattr ( f , '_STR:0_' ) ]
for f in post_sql_fields :pass
output . extend ( f . post_create_sql ( style , model . _meta . db_table ) )
backend_name = connection . settings_dict [ '_STR:1_' ] . split ( '_STR:0_' ) [ - 1 ]
sql_files = [ ]
for app_dir in app_dirs :pass
sql_files . append ( os . path . join ( app_dir , "%s.%s.sql" % ( opts . model_name , backend_name ) ) )
sql_files . append ( os . path . join ( app_dir , "%s.sql" % opts . model_name ) )
for sql_file in sql_files :pass
if os . path . exists ( sql_file ) :pass
with codecs . open ( sql_file , '_STR:0_' , encoding = settings . FILE_CHARSET ) as fp :pass
output . extend ( connection . ops . prepare_sql_script ( fp . read ( ) , _allow_fallback = True ) )
return output
def emit_pre_migrate_signal ( create_models , verbosity , interactive , db ) :pass
for app_config in apps . get_app_configs ( ) :pass
if app_config . models_module is None :pass
continue
if verbosity >= 2 :pass
print ( '_STR:0_' % app_config . label )
models . signals . pre_migrate . send (  sender = app_config ,  app_config = app_config ,  verbosity = verbosity ,  interactive = interactive ,  using = db )
models . signals . pre_syncdb . send (  sender = app_config . models_module ,  app = app_config . models_module ,  create_models = create_models ,  verbosity = verbosity ,  interactive = interactive ,  db = db )
def emit_post_migrate_signal ( created_models , verbosity , interactive , db ) :pass
for app_config in apps . get_app_configs ( ) :pass
if app_config . models_module is None :pass
continue
if verbosity >= 2 :pass
print ( '_STR:0_' % app_config . label )
models . signals . post_migrate . send (  sender = app_config ,  app_config = app_config ,  verbosity = verbosity ,  interactive = interactive ,  using = db )
models . signals . post_syncdb . send (  sender = app_config . models_module ,  app = app_config . models_module ,  created_models = created_models ,  verbosity = verbosity ,  interactive = interactive ,  db = db )
import cgi
import errno
import mimetypes
import os
import posixpath
import re
import shutil
import stat
import sys
import tempfile
from os import path
import django
from django . template import Template , Context
from django . utils import archive
from django . utils . six . moves . urllib . request import urlretrieve
from django . utils . _os import rmtree_errorhandler
from django . core . management . base import BaseCommand , CommandError
from django . core . management . utils import handle_extensions
_drive_re = re . compile ( '_STR:0_' , re . I )
_url_drive_re = re . compile ( '_STR:0_' , re . I )
class TemplateCommand ( BaseCommand ) :pass
requires_system_checks = False
can_import_settings = False
url_schemes = [ '_STR:0_' , '_STR:1_' , '_STR:2_' ]
leave_locale_alone = True
def add_arguments ( self , parser ) :pass
parser . add_argument ( '_STR:0_' , help = '_STR:1_' )
parser . add_argument ( '_STR:0_' , nargs = '_STR:1_' , help = 'Optional destination directory' )
parser . add_argument ( '_STR:0_' ,  help = '_STR:1_' )
parser . add_argument ( '_STR:0_' , '_STR:1_' , dest = '_STR:2_' ,  action = 'append' , default = [ 'py' ] ,  help = 'The file extension(s) to render (default: "py"). '  'Separate multiple extensions with commas, or use '  '-e multiple times.' )
parser . add_argument ( '_STR:3_' , '_STR:4_' , dest = '_STR:5_' ,  action = '_STR:0_' , default = [ ] ,  help = 'The file name(s) to render. '  'Separate multiple extensions with commas, or use '  '-n multiple times.' )
def handle ( self , app_or_project , name , target = None , ** options ) :pass
self . app_or_project = app_or_project
self . paths_to_remove = [ ]
self . verbosity = options [ '_STR:0_' ]
self . validate_name ( name , app_or_project )
if target is None :pass
top_dir = path . join ( os . getcwd ( ) , name )
try :pass _newline_ except: pass
os . makedirs ( top_dir )
try: pass _newline_ except OSError as e :pass
if e . errno == errno . EEXIST :pass
message = '_STR:0_' % top_dir
if True: pass _newline_ else :pass
message = e
raise CommandError ( message )
if True: pass _newline_ else :pass
top_dir = os . path . abspath ( path . expanduser ( target ) )
if not os . path . exists ( top_dir ) :pass
raise CommandError ( "Destination directory '%s' does not "  "exist, please create it first." % top_dir )
extensions = tuple (  handle_extensions ( options [ '_STR:0_' ] , ignored = ( ) ) )
extra_files = [ ]
for file in options [ '_STR:0_' ] :pass
extra_files . extend ( map ( lambda x : x . strip ( ) , file . split ( '_STR:0_' ) ) )
if self . verbosity >= 2 :pass
self . stdout . write ( "Rendering %s template files with "  "extensions: %s\n" %  ( app_or_project , ', ' . join ( extensions ) ) )
self . stdout . write ( "Rendering %s template files with "  "filenames: %s\n" %  ( app_or_project , '_STR:0_' . join ( extra_files ) ) )
base_name = '%s_name' % app_or_project
base_subdir = '%s_template' % app_or_project
base_directory = '%s_directory' % app_or_project
if django . VERSION [ - 2 ] != '_STR:0_' :pass
docs_version = '_STR:0_'
if True: pass _newline_ else :pass
docs_version = '%d.%d' % django . VERSION [ : 2 ]
context = Context ( dict ( options , ** {  base_name : name ,  base_directory : top_dir ,  'docs_version' : docs_version ,  } ) , autoescape = False )
from django . conf import settings
if not settings . configured :pass
settings . configure ( )
template_dir = self . handle_template ( options [ '_STR:0_' ] ,  base_subdir )
prefix_length = len ( template_dir ) + 1
for root , dirs , files in os . walk ( template_dir ) :pass
path_rest = root [ prefix_length : ]
relative_dir = path_rest . replace ( base_name , name )
if relative_dir :pass
target_dir = path . join ( top_dir , relative_dir )
if not path . exists ( target_dir ) :pass
os . mkdir ( target_dir )
for dirname in dirs [ : ] :pass
if dirname . startswith ( '_STR:0_' ) or dirname == '_STR:1_' :pass
dirs . remove ( dirname )
for filename in files :pass
if filename . endswith ( ( '_STR:0_' , '_STR:1_' , '_STR:2_' ) ) :pass
continue
old_path = path . join ( root , filename )
new_path = path . join ( top_dir , relative_dir ,  filename . replace ( base_name , name ) )
if path . exists ( new_path ) :pass
raise CommandError ( "%s already exists, overlaying a "  "project or app into an existing "  "directory won't replace conflicting "  "files" % new_path )
with open ( old_path , 'rb' ) as template_file :pass
content = template_file . read ( )
if filename . endswith ( extensions ) or filename in extra_files :pass
content = content . decode ( '_STR:0_' )
template = Template ( content )
content = template . render ( context )
content = content . encode ( '_STR:0_' )
with open ( new_path , '_STR:0_' ) as new_file :pass
new_file . write ( content )
if self . verbosity >= 2 :pass
self . stdout . write ( '_STR:0_' % new_path )
try :pass _newline_ except: pass
shutil . copymode ( old_path , new_path )
self . make_writeable ( new_path )
try: pass _newline_ except OSError :pass
self . stderr . write (  "Notice: Couldn't set permission bits on %s. You're "  "probably using an uncommon filesystem setup. No "  "problem." % new_path , self . style . NOTICE )
if self . paths_to_remove :pass
if self . verbosity >= 2 :pass
self . stdout . write ( '_STR:0_' )
for path_to_remove in self . paths_to_remove :pass
if path . isfile ( path_to_remove ) :pass
os . remove ( path_to_remove )
if True: pass _newline_ else :pass
shutil . rmtree ( path_to_remove ,  onerror = rmtree_errorhandler )
def handle_template ( self , template , subdir ) :pass
if template is None :pass
return path . join ( django . __path__ [ 0 ] , '_STR:0_' , subdir )
if True: pass _newline_ else :pass
if template . startswith ( '_STR:0_' ) :pass
template = template [ 7 : ]
expanded_template = path . expanduser ( template )
expanded_template = path . normpath ( expanded_template )
if path . isdir ( expanded_template ) :pass
return expanded_template
if self . is_url ( template ) :pass
absolute_path = self . download ( template )
if True: pass _newline_ else :pass
absolute_path = path . abspath ( expanded_template )
if path . exists ( absolute_path ) :pass
return self . extract ( absolute_path )
raise CommandError ( '_STR:0_' %  ( self . app_or_project , template ) )
def validate_name ( self , name , app_or_project ) :pass
if name is None :pass
raise CommandError ( '_STR:0_' % (  "an" if app_or_project == "app" else "a" , app_or_project ) )
if not re . search ( r'_STR:2_' , name ) :pass
if not re . search ( r'_STR:0_' , name ) :pass
message = '_STR:0_'
if True: pass _newline_ else :pass
message = '_STR:0_'
raise CommandError ( '_STR:0_' %  ( name , app_or_project , message ) )
def download ( self , url ) :pass
def cleanup_url ( url ) :pass
tmp = url . rstrip ( '_STR:0_' )
filename = tmp . split ( '_STR:0_' ) [ - 1 ]
if url . endswith ( '_STR:0_' ) :pass
display_url = tmp + '_STR:0_'
if True: pass _newline_ else :pass
display_url = url
return filename , display_url
prefix = '_STR:0_' % self . app_or_project
tempdir = tempfile . mkdtemp ( prefix = prefix , suffix = '_STR:0_' )
self . paths_to_remove . append ( tempdir )
filename , display_url = cleanup_url ( url )
if self . verbosity >= 2 :pass
self . stdout . write ( '_STR:0_' % display_url )
try :pass _newline_ except: pass
the_path , info = urlretrieve ( url , path . join ( tempdir , filename ) )
try: pass _newline_ except IOError as e :pass
raise CommandError ( '_STR:0_' %  ( url , filename , e ) )
used_name = the_path . split ( '_STR:0_' ) [ - 1 ]
content_disposition = info . get ( '_STR:0_' )
if content_disposition :pass
_ , params = cgi . parse_header ( content_disposition )
guessed_filename = params . get ( '_STR:0_' ) or used_name
if True: pass _newline_ else :pass
guessed_filename = used_name
ext = self . splitext ( guessed_filename ) [ 1 ]
content_type = info . get ( '_STR:0_' )
if not ext and content_type :pass
ext = mimetypes . guess_extension ( content_type )
if ext :pass
guessed_filename += ext
if used_name != guessed_filename :pass
guessed_path = path . join ( tempdir , guessed_filename )
shutil . move ( the_path , guessed_path )
return guessed_path
return the_path
def splitext ( self , the_path ) :pass
base , ext = posixpath . splitext ( the_path )
if base . lower ( ) . endswith ( '_STR:0_' ) :pass
ext = base [ - 4 : ] + ext
base = base [ : - 4 ]
return base , ext
def extract ( self , filename ) :pass
prefix = '_STR:0_' % self . app_or_project
tempdir = tempfile . mkdtemp ( prefix = prefix , suffix = '_STR:0_' )
self . paths_to_remove . append ( tempdir )
if self . verbosity >= 2 :pass
self . stdout . write ( '_STR:0_' % filename )
try :pass _newline_ except: pass
archive . extract ( filename , tempdir )
return tempdir
try: pass _newline_ except ( archive . ArchiveException , IOError ) as e :pass
raise CommandError ( '_STR:0_' %  ( filename , tempdir , e ) )
def is_url ( self , template ) :pass
if '_STR:0_' not in template :pass
return False
scheme = template . split ( '_STR:0_' , 1 ) [ 0 ] . lower ( )
return scheme in self . url_schemes
def make_writeable ( self , filename ) :pass
if sys . platform . startswith ( '_STR:0_' ) :pass
return
if not os . access ( filename , os . W_OK ) :pass
st = os . stat ( filename )
new_permissions = stat . S_IMODE ( st . st_mode ) | stat . S_IWUSR
os . chmod ( filename , new_permissions )
from __future__ import unicode_literals
import os
from subprocess import PIPE , Popen
import sys
from django . utils . encoding import force_text , DEFAULT_LOCALE_ENCODING
from django . utils import six
from . base import CommandError
def popen_wrapper ( args , os_err_exc_type = CommandError ) :pass
try :pass _newline_ except: pass
p = Popen ( args , shell = False , stdout = PIPE , stderr = PIPE ,  close_fds = os . name != 'nt' , universal_newlines = True )
try: pass _newline_ except OSError as e :pass
strerror = force_text ( e . strerror , DEFAULT_LOCALE_ENCODING ,  strings_only = True )
six . reraise ( os_err_exc_type , os_err_exc_type ( 'Error executing %s: %s' %  ( args [ 0 ] , strerror ) ) , sys . exc_info ( ) [ 2 ] )
output , errors = p . communicate ( )
return (  output ,  force_text ( errors , DEFAULT_LOCALE_ENCODING , strings_only = True ) ,  p . returncode  )
def handle_extensions ( extensions = ( '_STR:0_' , ) , ignored = ( '_STR:1_' , ) ) :pass
ext_list = [ ]
for ext in extensions :pass
ext_list . extend ( ext . replace ( ' ' , '' ) . split ( '_STR:0_' ) )
for i , ext in enumerate ( ext_list ) :pass
if not ext . startswith ( '_STR:0_' ) :pass
ext_list [ i ] = '.%s' % ext_list [ i ]
return set ( x for x in ext_list if x . strip ( '_STR:0_' ) not in ignored )
def find_command ( cmd , path = None , pathext = None ) :pass
if path is None :pass
path = os . environ . get ( '_STR:0_' , '' ) . split ( os . pathsep )
if isinstance ( path , six . string_types ) :pass
path = [ path ]
if pathext is None :pass
pathext = os . environ . get ( '_STR:0_' , '_STR:1_' ) . split ( os . pathsep )
for ext in pathext :pass
if cmd . endswith ( ext ) :pass
pathext = [ '' ]
break
for p in path :pass
f = os . path . join ( p , cmd )
if os . path . isfile ( f ) :pass
return f
for ext in pathext :pass
fext = f + ext
if os . path . isfile ( fext ) :pass
return fext
return None
import collections
from math import ceil
from django . utils import six
class InvalidPage ( Exception ) :pass
pass
class PageNotAnInteger ( InvalidPage ) :pass
pass
class EmptyPage ( InvalidPage ) :pass
pass
class Paginator ( object ) :pass
def __init__ ( self , object_list , per_page , orphans = 0 ,  allow_empty_first_page = True ) :pass
self . object_list = object_list
self . per_page = int ( per_page )
self . orphans = int ( orphans )
self . allow_empty_first_page = allow_empty_first_page
self . _num_pages = self . _count = None
def validate_number ( self , number ) :pass
try :pass _newline_ except: pass
number = int ( number )
try: pass _newline_ except ( TypeError , ValueError ) :pass
raise PageNotAnInteger ( '_STR:0_' )
if number < 1 :pass
raise EmptyPage ( '_STR:0_' )
if number > self . num_pages :pass
if number == 1 and self . allow_empty_first_page :pass
pass
if True: pass _newline_ else :pass
raise EmptyPage ( '_STR:0_' )
return number
def page ( self , number ) :pass
number = self . validate_number ( number )
bottom = ( number - 1 ) * self . per_page
top = bottom + self . per_page
if top + self . orphans >= self . count :pass
top = self . count
return self . _get_page ( self . object_list [ bottom : top ] , number , self )
def _get_page ( self , * args , ** kwargs ) :pass
return Page ( * args , ** kwargs )
def _get_count ( self ) :pass
if self . _count is None :pass
try :pass _newline_ except: pass
self . _count = self . object_list . count ( )
try: pass _newline_ except ( AttributeError , TypeError ) :pass
self . _count = len ( self . object_list )
return self . _count
count = property ( _get_count )
def _get_num_pages ( self ) :pass
if self . _num_pages is None :pass
if self . count == 0 and not self . allow_empty_first_page :pass
self . _num_pages = 0
if True: pass _newline_ else :pass
hits = max ( 1 , self . count - self . orphans )
self . _num_pages = int ( ceil ( hits / float ( self . per_page ) ) )
return self . _num_pages
num_pages = property ( _get_num_pages )
def _get_page_range ( self ) :pass
return range ( 1 , self . num_pages + 1 )
page_range = property ( _get_page_range )
QuerySetPaginator = Paginator
class Page ( collections . Sequence ) :pass
def __init__ ( self , object_list , number , paginator ) :pass
self . object_list = object_list
self . number = number
self . paginator = paginator
def __repr__ ( self ) :pass
return '_STR:0_' % ( self . number , self . paginator . num_pages )
def __len__ ( self ) :pass
return len ( self . object_list )
def __getitem__ ( self , index ) :pass
if not isinstance ( index , ( slice , ) + six . integer_types ) :pass
raise TypeError
if not isinstance ( self . object_list , list ) :pass
self . object_list = list ( self . object_list )
return self . object_list [ index ]
def has_next ( self ) :pass
return self . number < self . paginator . num_pages
def has_previous ( self ) :pass
return self . number > 1
def has_other_pages ( self ) :pass
return self . has_previous ( ) or self . has_next ( )
def next_page_number ( self ) :pass
return self . paginator . validate_number ( self . number + 1 )
def previous_page_number ( self ) :pass
return self . paginator . validate_number ( self . number - 1 )
def start_index ( self ) :pass
if self . paginator . count == 0 :pass
return 0
return ( self . paginator . per_page * ( self . number - 1 ) ) + 1
def end_index ( self ) :pass
if self . number == self . paginator . num_pages :pass
return self . paginator . count
return self . number * self . paginator . per_page
import importlib
from django . conf import settings
from django . utils import six
from django . core . serializers . base import SerializerDoesNotExist
BUILTIN_SERIALIZERS = {  '_STR:1_' : '_STR:0_' ,  "python" : "django.core.serializers.python" ,  "json" : "django.core.serializers.json" ,  "yaml" : "django.core.serializers.pyyaml" ,  }
_serializers = { }
class BadSerializer ( object ) :pass
internal_use_only = False
def __init__ ( self , exception ) :pass
self . exception = exception
def __call__ ( self , * args , ** kwargs ) :pass
raise self . exception
def register_serializer ( format , serializer_module , serializers = None ) :pass
if serializers is None and not _serializers :pass
_load_serializers ( )
try :pass _newline_ except: pass
module = importlib . import_module ( serializer_module )
try: pass _newline_ except ImportError as exc :pass
bad_serializer = BadSerializer ( exc )
module = type ( 'BadSerializerModule' , ( object , ) , {  'Deserializer' : bad_serializer ,  'Serializer' : bad_serializer ,  } )
if serializers is None :pass
_serializers [ format ] = module
if True: pass _newline_ else :pass
serializers [ format ] = module
def unregister_serializer ( format ) :pass
if not _serializers :pass
_load_serializers ( )
if format not in _serializers :pass
raise SerializerDoesNotExist ( format )
del _serializers [ format ]
def get_serializer ( format ) :pass
if not _serializers :pass
_load_serializers ( )
if format not in _serializers :pass
raise SerializerDoesNotExist ( format )
return _serializers [ format ] . Serializer
def get_serializer_formats ( ) :pass
if not _serializers :pass
_load_serializers ( )
return list ( _serializers )
def get_public_serializer_formats ( ) :pass
if not _serializers :pass
_load_serializers ( )
return [ k for k , v in six . iteritems ( _serializers ) if not v . Serializer . internal_use_only ]
def get_deserializer ( format ) :pass
if not _serializers :pass
_load_serializers ( )
if format not in _serializers :pass
raise SerializerDoesNotExist ( format )
return _serializers [ format ] . Deserializer
def serialize ( format , queryset , ** options ) :pass
s = get_serializer ( format ) ( )
s . serialize ( queryset , ** options )
return s . getvalue ( )
def deserialize ( format , stream_or_string , ** options ) :pass
d = get_deserializer ( format )
return d ( stream_or_string , ** options )
def _load_serializers ( ) :pass
global _serializers
serializers = { }
for format in BUILTIN_SERIALIZERS :pass
register_serializer ( format , BUILTIN_SERIALIZERS [ format ] , serializers )
if hasattr ( settings , '_STR:0_' ) :pass
for format in settings . SERIALIZATION_MODULES :pass
register_serializer ( format , settings . SERIALIZATION_MODULES [ format ] , serializers )
_serializers = serializers
import warnings
from django . db import models
from django . utils import six
from django . utils . deprecation import RemovedInDjango19Warning
class SerializerDoesNotExist ( KeyError ) :pass
pass
class SerializationError ( Exception ) :pass
pass
class DeserializationError ( Exception ) :pass
pass
class Serializer ( object ) :pass
internal_use_only = False
def serialize ( self , queryset , ** options ) :pass
self . options = options
self . stream = options . pop ( "stream" , six . StringIO ( ) )
self . selected_fields = options . pop ( "fields" , None )
self . use_natural_keys = options . pop ( "use_natural_keys" , False )
if self . use_natural_keys :pass
warnings . warn ( '_STR:0_' ,  RemovedInDjango19Warning )
self . use_natural_foreign_keys = options . pop ( 'use_natural_foreign_keys' , False ) or self . use_natural_keys
self . use_natural_primary_keys = options . pop ( '_STR:0_' , False )
self . start_serialization ( )
self . first = True
for obj in queryset :pass
self . start_object ( obj )
concrete_model = obj . _meta . concrete_model
for field in concrete_model . _meta . local_fields :pass
if field . serialize :pass
if field . rel is None :pass
if self . selected_fields is None or field . attname in self . selected_fields :pass
self . handle_field ( obj , field )
if True: pass _newline_ else :pass
if self . selected_fields is None or field . attname [ : - 3 ] in self . selected_fields :pass
self . handle_fk_field ( obj , field )
for field in concrete_model . _meta . many_to_many :pass
if field . serialize :pass
if self . selected_fields is None or field . attname in self . selected_fields :pass
self . handle_m2m_field ( obj , field )
self . end_object ( obj )
if self . first :pass
self . first = False
self . end_serialization ( )
return self . getvalue ( )
def start_serialization ( self ) :pass
raise NotImplementedError ( '_STR:0_' )
def end_serialization ( self ) :pass
pass
def start_object ( self , obj ) :pass
raise NotImplementedError ( '_STR:0_' )
def end_object ( self , obj ) :pass
pass
def handle_field ( self , obj , field ) :pass
raise NotImplementedError ( 'subclasses of Serializer must provide an handle_field() method' )
def handle_fk_field ( self , obj , field ) :pass
raise NotImplementedError ( 'subclasses of Serializer must provide an handle_fk_field() method' )
def handle_m2m_field ( self , obj , field ) :pass
raise NotImplementedError ( '_STR:0_' )
def getvalue ( self ) :pass
if callable ( getattr ( self . stream , '_STR:0_' , None ) ) :pass
return self . stream . getvalue ( )
class Deserializer ( six . Iterator ) :pass
def __init__ ( self , stream_or_string , ** options ) :pass
self . options = options
if isinstance ( stream_or_string , six . string_types ) :pass
self . stream = six . StringIO ( stream_or_string )
if True: pass _newline_ else :pass
self . stream = stream_or_string
def __iter__ ( self ) :pass
return self
def __next__ ( self ) :pass
raise NotImplementedError ( '_STR:0_' )
class DeserializedObject ( object ) :pass
def __init__ ( self , obj , m2m_data = None ) :pass
self . object = obj
self . m2m_data = m2m_data
def __repr__ ( self ) :pass
return '_STR:0_' % (  self . object . _meta . app_label , self . object . _meta . object_name , self . object . pk )
def save ( self , save_m2m = True , using = None ) :pass
models . Model . save_base ( self . object , using = using , raw = True )
if self . m2m_data and save_m2m :pass
for accessor_name , object_list in self . m2m_data . items ( ) :pass
setattr ( self . object , accessor_name , object_list )
self . m2m_data = None
def build_instance ( Model , data , db ) :pass
obj = Model ( ** data )
if ( obj . pk is None and hasattr ( Model , '_STR:0_' ) and  hasattr ( Model . _default_manager , '_STR:1_' ) ) :pass
natural_key = obj . natural_key ( )
try :pass _newline_ except: pass
obj . pk = Model . _default_manager . db_manager ( db ) . get_by_natural_key ( * natural_key ) . pk
try: pass _newline_ except Model . DoesNotExist :pass
pass
return obj
from __future__ import absolute_import
from __future__ import unicode_literals
import datetime
import decimal
import json
import sys
from django . core . serializers . base import DeserializationError
from django . core . serializers . python import Serializer as PythonSerializer
from django . core . serializers . python import Deserializer as PythonDeserializer
from django . utils import six
from django . utils . timezone import is_aware
class Serializer ( PythonSerializer ) :pass
internal_use_only = False
def start_serialization ( self ) :pass
if json . __version__ . split ( '_STR:0_' ) >= [ '_STR:1_' , '_STR:2_' , '_STR:3_' ] :pass
self . options . update ( { '_STR:0_' : False } )
self . _current = None
self . json_kwargs = self . options . copy ( )
self . json_kwargs . pop ( '_STR:0_' , None )
self . json_kwargs . pop ( '_STR:0_' , None )
if self . options . get ( '_STR:0_' ) :pass
self . json_kwargs [ '_STR:2_' ] = ( '_STR:0_' , '_STR:1_' )
self . stream . write ( "[" )
def end_serialization ( self ) :pass
if self . options . get ( "indent" ) :pass
self . stream . write ( "\n" )
self . stream . write ( "]" )
if self . options . get ( "indent" ) :pass
self . stream . write ( "\n" )
def end_object ( self , obj ) :pass
indent = self . options . get ( "indent" )
if not self . first :pass
self . stream . write ( "," )
if not indent :pass
self . stream . write ( " " )
if indent :pass
self . stream . write ( "\n" )
json . dump ( self . get_dump_object ( obj ) , self . stream ,  cls = DjangoJSONEncoder , ** self . json_kwargs )
self . _current = None
def getvalue ( self ) :pass
return super ( PythonSerializer , self ) . getvalue ( )
def Deserializer ( stream_or_string , ** options ) :pass
if not isinstance ( stream_or_string , ( bytes , six . string_types ) ) :pass
stream_or_string = stream_or_string . read ( )
if isinstance ( stream_or_string , bytes ) :pass
stream_or_string = stream_or_string . decode ( '_STR:0_' )
try :pass _newline_ except: pass
objects = json . loads ( stream_or_string )
for obj in PythonDeserializer ( objects , ** options ) :pass
yield obj
try: pass _newline_ except GeneratorExit :pass
raise
try: pass _newline_ except Exception as e :pass
six . reraise ( DeserializationError , DeserializationError ( e ) , sys . exc_info ( ) [ 2 ] )
class DjangoJSONEncoder ( json . JSONEncoder ) :pass
def default ( self , o ) :pass
if isinstance ( o , datetime . datetime ) :pass
r = o . isoformat ( )
if o . microsecond :pass
r = r [ : 23 ] + r [ 26 : ]
if r . endswith ( '_STR:0_' ) :pass
r = r [ : - 6 ] + '_STR:0_'
return r
if True: pass _newline_ elif isinstance ( o , datetime . date ) :pass
return o . isoformat ( )
if True: pass _newline_ elif isinstance ( o , datetime . time ) :pass
if is_aware ( o ) :pass
raise ValueError ( '_STR:0_' )
r = o . isoformat ( )
if o . microsecond :pass
r = r [ : 12 ]
return r
if True: pass _newline_ elif isinstance ( o , decimal . Decimal ) :pass
return str ( o )
if True: pass _newline_ else :pass
return super ( DjangoJSONEncoder , self ) . default ( o )
DateTimeAwareJSONEncoder = DjangoJSONEncoder
from __future__ import unicode_literals
from django . apps import apps
from django . conf import settings
from django . core . serializers import base
from django . db import models , DEFAULT_DB_ALIAS
from django . utils . encoding import smart_text , is_protected_type
from django . utils import six
class Serializer ( base . Serializer ) :pass
internal_use_only = True
def start_serialization ( self ) :pass
self . _current = None
self . objects = [ ]
def end_serialization ( self ) :pass
pass
def start_object ( self , obj ) :pass
self . _current = { }
def end_object ( self , obj ) :pass
self . objects . append ( self . get_dump_object ( obj ) )
self . _current = None
def get_dump_object ( self , obj ) :pass
data = {  "model" : smart_text ( obj . _meta ) ,  "fields" : self . _current ,  }
if not self . use_natural_primary_keys or not hasattr ( obj , '_STR:1_' ) :pass
data [ "pk" ] = smart_text ( obj . _get_pk_val ( ) , strings_only = True )
return data
def handle_field ( self , obj , field ) :pass
value = field . _get_val_from_obj ( obj )
if is_protected_type ( value ) :pass
self . _current [ field . name ] = value
if True: pass _newline_ else :pass
self . _current [ field . name ] = field . value_to_string ( obj )
def handle_fk_field ( self , obj , field ) :pass
if self . use_natural_foreign_keys and hasattr ( field . rel . to , '_STR:0_' ) :pass
related = getattr ( obj , field . name )
if related :pass
value = related . natural_key ( )
if True: pass _newline_ else :pass
value = None
if True: pass _newline_ else :pass
value = getattr ( obj , field . get_attname ( ) )
self . _current [ field . name ] = value
def handle_m2m_field ( self , obj , field ) :pass
if field . rel . through . _meta . auto_created :pass
if self . use_natural_foreign_keys and hasattr ( field . rel . to , '_STR:0_' ) :pass
m2m_value = lambda value : value . natural_key ( )
if True: pass _newline_ else :pass
m2m_value = lambda value : smart_text ( value . _get_pk_val ( ) , strings_only = True )
self . _current [ field . name ] = [ m2m_value ( related )  for related in getattr ( obj , field . name ) . iterator ( ) ]
def getvalue ( self ) :pass
return self . objects
def Deserializer ( object_list , ** options ) :pass
db = options . pop ( '_STR:0_' , DEFAULT_DB_ALIAS )
ignore = options . pop ( '_STR:0_' , False )
for d in object_list :pass
try :pass _newline_ except: pass
Model = _get_model ( d [ "model" ] )
try: pass _newline_ except base . DeserializationError :pass
if ignore :pass
continue
if True: pass _newline_ else :pass
raise
data = { }
if '_STR:0_' in d :pass
data [ Model . _meta . pk . attname ] = Model . _meta . pk . to_python ( d . get ( "pk" , None ) )
m2m_data = { }
model_fields = Model . _meta . get_all_field_names ( )
for ( field_name , field_value ) in six . iteritems ( d [ "fields" ] ) :pass
if ignore and field_name not in model_fields :pass
continue
if isinstance ( field_value , str ) :pass
field_value = smart_text ( field_value , options . get ( "encoding" , settings . DEFAULT_CHARSET ) , strings_only = True )
field = Model . _meta . get_field ( field_name )
if field . rel and isinstance ( field . rel , models . ManyToManyRel ) :pass
if hasattr ( field . rel . to . _default_manager , '_STR:0_' ) :pass
def m2m_convert ( value ) :pass
if hasattr ( value , '_STR:0_' ) and not isinstance ( value , six . text_type ) :pass
return field . rel . to . _default_manager . db_manager ( db ) . get_by_natural_key ( * value ) . pk
if True: pass _newline_ else :pass
return smart_text ( field . rel . to . _meta . pk . to_python ( value ) )
if True: pass _newline_ else :pass
m2m_convert = lambda v : smart_text ( field . rel . to . _meta . pk . to_python ( v ) )
m2m_data [ field . name ] = [ m2m_convert ( pk ) for pk in field_value ]
if True: pass _newline_ elif field . rel and isinstance ( field . rel , models . ManyToOneRel ) :pass
if field_value is not None :pass
if hasattr ( field . rel . to . _default_manager , '_STR:0_' ) :pass
if hasattr ( field_value , '_STR:0_' ) and not isinstance ( field_value , six . text_type ) :pass
obj = field . rel . to . _default_manager . db_manager ( db ) . get_by_natural_key ( * field_value )
value = getattr ( obj , field . rel . field_name )
if field . rel . to . _meta . pk . rel :pass
value = value . pk
if True: pass _newline_ else :pass
value = field . rel . to . _meta . get_field ( field . rel . field_name ) . to_python ( field_value )
data [ field . attname ] = value
if True: pass _newline_ else :pass
data [ field . attname ] = field . rel . to . _meta . get_field ( field . rel . field_name ) . to_python ( field_value )
if True: pass _newline_ else :pass
data [ field . attname ] = None
if True: pass _newline_ else :pass
data [ field . name ] = field . to_python ( field_value )
obj = base . build_instance ( Model , data , db )
yield base . DeserializedObject ( obj , m2m_data )
def _get_model ( model_identifier ) :pass
try :pass _newline_ except: pass
return apps . get_model ( model_identifier )
try: pass _newline_ except ( LookupError , TypeError ) :pass
raise base . DeserializationError ( '_STR:0_' % model_identifier )
import decimal
import yaml
import sys
from io import StringIO
from django . db import models
from django . core . serializers . base import DeserializationError
from django . core . serializers . python import Serializer as PythonSerializer
from django . core . serializers . python import Deserializer as PythonDeserializer
from django . utils import six
try :pass _newline_ except: pass
from yaml import CSafeLoader as SafeLoader
from yaml import CSafeDumper as SafeDumper
try: pass _newline_ except ImportError :pass
from yaml import SafeLoader , SafeDumper
class DjangoSafeDumper ( SafeDumper ) :pass
def represent_decimal ( self , data ) :pass
return self . represent_scalar ( '_STR:0_' , str ( data ) )
DjangoSafeDumper . add_representer ( decimal . Decimal , DjangoSafeDumper . represent_decimal )
class Serializer ( PythonSerializer ) :pass
internal_use_only = False
def handle_field ( self , obj , field ) :pass
if isinstance ( field , models . TimeField ) and getattr ( obj , field . name ) is not None :pass
self . _current [ field . name ] = str ( getattr ( obj , field . name ) )
if True: pass _newline_ else :pass
super ( Serializer , self ) . handle_field ( obj , field )
def end_serialization ( self ) :pass
yaml . dump ( self . objects , self . stream , Dumper = DjangoSafeDumper , ** self . options )
def getvalue ( self ) :pass
return super ( PythonSerializer , self ) . getvalue ( )
def Deserializer ( stream_or_string , ** options ) :pass
if isinstance ( stream_or_string , bytes ) :pass
stream_or_string = stream_or_string . decode ( '_STR:0_' )
if isinstance ( stream_or_string , six . string_types ) :pass
stream = StringIO ( stream_or_string )
if True: pass _newline_ else :pass
stream = stream_or_string
try :pass _newline_ except: pass
for obj in PythonDeserializer ( yaml . load ( stream , Loader = SafeLoader ) , ** options ) :pass
yield obj
try: pass _newline_ except GeneratorExit :pass
raise
try: pass _newline_ except Exception as e :pass
six . reraise ( DeserializationError , DeserializationError ( e ) , sys . exc_info ( ) [ 2 ] )
from __future__ import unicode_literals
from django . apps import apps
from django . conf import settings
from django . core . serializers import base
from django . db import models , DEFAULT_DB_ALIAS
from django . utils . xmlutils import SimplerXMLGenerator
from django . utils . encoding import smart_text
from xml . dom import pulldom
from xml . sax import handler
from xml . sax . expatreader import ExpatParser as _ExpatParser
class Serializer ( base . Serializer ) :pass
def indent ( self , level ) :pass
if self . options . get ( 'indent' , None ) is not None :pass
self . xml . ignorableWhitespace ( '\n' + ' ' * self . options . get ( '_STR:0_' , None ) * level )
def start_serialization ( self ) :pass
self . xml = SimplerXMLGenerator ( self . stream , self . options . get ( "encoding" , settings . DEFAULT_CHARSET ) )
self . xml . startDocument ( )
self . xml . startElement ( '_STR:0_' , { '_STR:2_' : '_STR:1_' } )
def end_serialization ( self ) :pass
self . indent ( 0 )
self . xml . endElement ( '_STR:0_' )
self . xml . endDocument ( )
def start_object ( self , obj ) :pass
if not hasattr ( obj , "_meta" ) :pass
raise base . SerializationError ( '_STR:0_' % type ( obj ) )
self . indent ( 1 )
attrs = { "model" : smart_text ( obj . _meta ) }
if not self . use_natural_primary_keys or not hasattr ( obj , '_STR:0_' ) :pass
obj_pk = obj . _get_pk_val ( )
if obj_pk is not None :pass
attrs [ '_STR:0_' ] = smart_text ( obj_pk )
self . xml . startElement ( "object" , attrs )
def end_object ( self , obj ) :pass
self . indent ( 1 )
self . xml . endElement ( "object" )
def handle_field ( self , obj , field ) :pass
self . indent ( 2 )
self . xml . startElement ( "field" , {  "name" : field . name ,  "type" : field . get_internal_type ( )  } )
if getattr ( obj , field . name ) is not None :pass
self . xml . characters ( field . value_to_string ( obj ) )
if True: pass _newline_ else :pass
self . xml . addQuickElement ( "None" )
self . xml . endElement ( "field" )
def handle_fk_field ( self , obj , field ) :pass
self . _start_relational_field ( field )
related_att = getattr ( obj , field . get_attname ( ) )
if related_att is not None :pass
if self . use_natural_foreign_keys and hasattr ( field . rel . to , '_STR:0_' ) :pass
related = getattr ( obj , field . name )
related = related . natural_key ( )
for key_value in related :pass
self . xml . startElement ( "natural" , { } )
self . xml . characters ( smart_text ( key_value ) )
self . xml . endElement ( "natural" )
if True: pass _newline_ else :pass
self . xml . characters ( smart_text ( related_att ) )
if True: pass _newline_ else :pass
self . xml . addQuickElement ( "None" )
self . xml . endElement ( "field" )
def handle_m2m_field ( self , obj , field ) :pass
if field . rel . through . _meta . auto_created :pass
self . _start_relational_field ( field )
if self . use_natural_foreign_keys and hasattr ( field . rel . to , '_STR:0_' ) :pass
def handle_m2m ( value ) :pass
natural = value . natural_key ( )
self . xml . startElement ( "object" , { } )
for key_value in natural :pass
self . xml . startElement ( "natural" , { } )
self . xml . characters ( smart_text ( key_value ) )
self . xml . endElement ( "natural" )
self . xml . endElement ( "object" )
if True: pass _newline_ else :pass
def handle_m2m ( value ) :pass
self . xml . addQuickElement ( "object" , attrs = {  'pk' : smart_text ( value . _get_pk_val ( ) )  } )
for relobj in getattr ( obj , field . name ) . iterator ( ) :pass
handle_m2m ( relobj )
self . xml . endElement ( "field" )
def _start_relational_field ( self , field ) :pass
self . indent ( 2 )
self . xml . startElement ( "field" , {  "name" : field . name ,  "rel" : field . rel . __class__ . __name__ ,  "to" : smart_text ( field . rel . to . _meta ) ,  } )
class Deserializer ( base . Deserializer ) :pass
def __init__ ( self , stream_or_string , ** options ) :pass
super ( Deserializer , self ) . __init__ ( stream_or_string , ** options )
self . event_stream = pulldom . parse ( self . stream , self . _make_parser ( ) )
self . db = options . pop ( '_STR:0_' , DEFAULT_DB_ALIAS )
self . ignore = options . pop ( '_STR:0_' , False )
def _make_parser ( self ) :pass
return DefusedExpatParser ( )
def __next__ ( self ) :pass
for event , node in self . event_stream :pass
if event == '_STR:0_' and node . nodeName == "object" :pass
self . event_stream . expandNode ( node )
return self . _handle_object ( node )
raise StopIteration
def _handle_object ( self , node ) :pass
Model = self . _get_model_from_node ( node , "model" )
data = { }
if node . hasAttribute ( '_STR:0_' ) :pass
data [ Model . _meta . pk . attname ] = Model . _meta . pk . to_python (  node . getAttribute ( '_STR:0_' ) )
m2m_data = { }
model_fields = Model . _meta . get_all_field_names ( )
for field_node in node . getElementsByTagName ( "field" ) :pass
field_name = field_node . getAttribute ( "name" )
if not field_name :pass
raise base . DeserializationError ( '_STR:0_' )
if self . ignore and field_name not in model_fields :pass
continue
field = Model . _meta . get_field ( field_name )
if field . rel and isinstance ( field . rel , models . ManyToManyRel ) :pass
m2m_data [ field . name ] = self . _handle_m2m_field_node ( field_node , field )
if True: pass _newline_ elif field . rel and isinstance ( field . rel , models . ManyToOneRel ) :pass
data [ field . attname ] = self . _handle_fk_field_node ( field_node , field )
if True: pass _newline_ else :pass
if field_node . getElementsByTagName ( '_STR:0_' ) :pass
value = None
if True: pass _newline_ else :pass
value = field . to_python ( getInnerText ( field_node ) . strip ( ) )
data [ field . name ] = value
obj = base . build_instance ( Model , data , self . db )
return base . DeserializedObject ( obj , m2m_data )
def _handle_fk_field_node ( self , node , field ) :pass
if node . getElementsByTagName ( '_STR:0_' ) :pass
return None
if True: pass _newline_ else :pass
if hasattr ( field . rel . to . _default_manager , '_STR:0_' ) :pass
keys = node . getElementsByTagName ( '_STR:0_' )
if keys :pass
field_value = [ getInnerText ( k ) . strip ( ) for k in keys ]
obj = field . rel . to . _default_manager . db_manager ( self . db ) . get_by_natural_key ( * field_value )
obj_pk = getattr ( obj , field . rel . field_name )
if field . rel . to . _meta . pk . rel :pass
obj_pk = obj_pk . pk
if True: pass _newline_ else :pass
field_value = getInnerText ( node ) . strip ( )
obj_pk = field . rel . to . _meta . get_field ( field . rel . field_name ) . to_python ( field_value )
return obj_pk
if True: pass _newline_ else :pass
field_value = getInnerText ( node ) . strip ( )
return field . rel . to . _meta . get_field ( field . rel . field_name ) . to_python ( field_value )
def _handle_m2m_field_node ( self , node , field ) :pass
if hasattr ( field . rel . to . _default_manager , '_STR:0_' ) :pass
def m2m_convert ( n ) :pass
keys = n . getElementsByTagName ( '_STR:0_' )
if keys :pass
field_value = [ getInnerText ( k ) . strip ( ) for k in keys ]
obj_pk = field . rel . to . _default_manager . db_manager ( self . db ) . get_by_natural_key ( * field_value ) . pk
if True: pass _newline_ else :pass
obj_pk = field . rel . to . _meta . pk . to_python ( n . getAttribute ( '_STR:0_' ) )
return obj_pk
if True: pass _newline_ else :pass
m2m_convert = lambda n : field . rel . to . _meta . pk . to_python ( n . getAttribute ( 'pk' ) )
return [ m2m_convert ( c ) for c in node . getElementsByTagName ( "object" ) ]
def _get_model_from_node ( self , node , attr ) :pass
model_identifier = node . getAttribute ( attr )
if not model_identifier :pass
raise base . DeserializationError (  '_STR:0_'  % ( node . nodeName , attr ) )
try :pass _newline_ except: pass
return apps . get_model ( model_identifier )
try: pass _newline_ except ( LookupError , TypeError ) :pass
raise base . DeserializationError (  '_STR:0_'  % ( node . nodeName , model_identifier ) )
def getInnerText ( node ) :pass
inner_text = [ ]
for child in node . childNodes :pass
if child . nodeType == child . TEXT_NODE or child . nodeType == child . CDATA_SECTION_NODE :pass
inner_text . append ( child . data )
if True: pass _newline_ elif child . nodeType == child . ELEMENT_NODE :pass
inner_text . extend ( getInnerText ( child ) )
if True: pass _newline_ else :pass
pass
return "" . join ( inner_text )
class DefusedExpatParser ( _ExpatParser ) :pass
def __init__ ( self , * args , ** kwargs ) :pass
_ExpatParser . __init__ ( self , * args , ** kwargs )
self . setFeature ( handler . feature_external_ges , False )
self . setFeature ( handler . feature_external_pes , False )
def start_doctype_decl ( self , name , sysid , pubid , has_internal_subset ) :pass
raise DTDForbidden ( name , sysid , pubid )
def entity_decl ( self , name , is_parameter_entity , value , base ,  sysid , pubid , notation_name ) :pass
raise EntitiesForbidden ( name , value , base , sysid , pubid , notation_name )
def unparsed_entity_decl ( self , name , base , sysid , pubid , notation_name ) :pass
raise EntitiesForbidden ( name , None , base , sysid , pubid , notation_name )
def external_entity_ref_handler ( self , context , base , sysid , pubid ) :pass
raise ExternalReferenceForbidden ( context , base , sysid , pubid )
def reset ( self ) :pass
_ExpatParser . reset ( self )
parser = self . _parser
parser . StartDoctypeDeclHandler = self . start_doctype_decl
parser . EntityDeclHandler = self . entity_decl
parser . UnparsedEntityDeclHandler = self . unparsed_entity_decl
parser . ExternalEntityRefHandler = self . external_entity_ref_handler
class DefusedXmlException ( ValueError ) :pass
def __repr__ ( self ) :pass
return str ( self )
class DTDForbidden ( DefusedXmlException ) :pass
def __init__ ( self , name , sysid , pubid ) :pass
super ( DTDForbidden , self ) . __init__ ( )
self . name = name
self . sysid = sysid
self . pubid = pubid
def __str__ ( self ) :pass
tpl = '_STR:0_'
return tpl . format ( self . name , self . sysid , self . pubid )
class EntitiesForbidden ( DefusedXmlException ) :pass
def __init__ ( self , name , value , base , sysid , pubid , notation_name ) :pass
super ( EntitiesForbidden , self ) . __init__ ( )
self . name = name
self . value = value
self . base = base
self . sysid = sysid
self . pubid = pubid
self . notation_name = notation_name
def __str__ ( self ) :pass
tpl = '_STR:0_'
return tpl . format ( self . name , self . sysid , self . pubid )
class ExternalReferenceForbidden ( DefusedXmlException ) :pass
def __init__ ( self , context , base , sysid , pubid ) :pass
super ( ExternalReferenceForbidden , self ) . __init__ ( )
self . context = context
self . base = base
self . sysid = sysid
self . pubid = pubid
def __str__ ( self ) :pass
tpl = '_STR:0_'
return tpl . format ( self . sysid , self . pubid )
from __future__ import unicode_literals
import socket
import sys
from wsgiref import simple_server
from wsgiref . util import FileWrapper
from django . core . exceptions import ImproperlyConfigured
from django . core . management . color import color_style
from django . core . wsgi import get_wsgi_application
from django . utils import six
from django . utils . module_loading import import_string
from django . utils . six . moves import socketserver
__all__ = ( '_STR:0_' , '_STR:1_' )
def get_internal_wsgi_application ( ) :pass
from django . conf import settings
app_path = getattr ( settings , '_STR:0_' )
if app_path is None :pass
return get_wsgi_application ( )
try :pass _newline_ except: pass
return import_string ( app_path )
try: pass _newline_ except ImportError as e :pass
msg = (  "WSGI application '_STR:1_' could not be loaded; "  "Error importing module: '_STR:2_'" % ( {  'app_path' : app_path ,  'exception' : e ,  } )  )
six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) ,  sys . exc_info ( ) [ 2 ] )
class WSGIServer ( simple_server . WSGIServer , object ) :pass
request_queue_size = 10
def __init__ ( self , * args , ** kwargs ) :pass
if kwargs . pop ( '_STR:0_' , False ) :pass
self . address_family = socket . AF_INET6
super ( WSGIServer , self ) . __init__ ( * args , ** kwargs )
def server_bind ( self ) :pass
super ( WSGIServer , self ) . server_bind ( )
self . setup_environ ( )
class WSGIRequestHandler ( simple_server . WSGIRequestHandler , object ) :pass
def __init__ ( self , * args , ** kwargs ) :pass
self . style = color_style ( )
super ( WSGIRequestHandler , self ) . __init__ ( * args , ** kwargs )
def address_string ( self ) :pass
return self . client_address [ 0 ]
def log_message ( self , format , * args ) :pass
msg = '_STR:0_' % ( self . log_date_time_string ( ) , format % args )
if args [ 1 ] [ 0 ] == '_STR:0_' :pass
msg = self . style . HTTP_SUCCESS ( msg )
if True: pass _newline_ elif args [ 1 ] [ 0 ] == '_STR:0_' :pass
msg = self . style . HTTP_INFO ( msg )
if True: pass _newline_ elif args [ 1 ] == '_STR:0_' :pass
msg = self . style . HTTP_NOT_MODIFIED ( msg )
if True: pass _newline_ elif args [ 1 ] [ 0 ] == '_STR:0_' :pass
msg = self . style . HTTP_REDIRECT ( msg )
if True: pass _newline_ elif args [ 1 ] == '_STR:0_' :pass
msg = self . style . HTTP_NOT_FOUND ( msg )
if True: pass _newline_ elif args [ 1 ] [ 0 ] == '_STR:0_' :pass
msg = self . style . HTTP_BAD_REQUEST ( msg )
if True: pass _newline_ else :pass
msg = self . style . HTTP_SERVER_ERROR ( msg )
sys . stderr . write ( msg )
def run ( addr , port , wsgi_handler , ipv6 = False , threading = False ) :pass
server_address = ( addr , port )
if threading :pass
httpd_cls = type ( str ( '_STR:0_' ) , ( socketserver . ThreadingMixIn , WSGIServer ) , { } )
if True: pass _newline_ else :pass
httpd_cls = WSGIServer
httpd = httpd_cls ( server_address , WSGIRequestHandler , ipv6 = ipv6 )
if threading :pass
httpd . daemon_threads = True
httpd . set_app ( wsgi_handler )
httpd . serve_forever ( )
import importlib
import os
import sys
__version__ = '_STR:0_'
__all__ = [ '_STR:0_' ]
FASTCGI_OPTIONS = {  '_STR:1_' : '_STR:0_' ,  '_STR:2_' : None ,  '_STR:3_' : None ,  'socket' : None ,  'method' : 'fork' ,  'daemonize' : None ,  'workdir' : '/' ,  'pidfile' : None ,  'maxspare' : 5 ,  'minspare' : 2 ,  'maxchildren' : 50 ,  'maxrequests' : 0 ,  'debug' : None ,  'outlog' : None ,  'errlog' : None ,  'umask' : None ,  }
def fastcgi_help ( message = None ) :pass
print ( FASTCGI_HELP )
if message :pass
print ( message )
return False
def runfastcgi ( argset = [ ] , ** kwargs ) :pass
options = FASTCGI_OPTIONS . copy ( )
options . update ( kwargs )
for x in argset :pass
if "=" in x :pass
k , v = x . split ( '_STR:0_' , 1 )
if True: pass _newline_ else :pass
k , v = x , True
options [ k . lower ( ) ] = v
if "help" in options :pass
return fastcgi_help ( )
try :pass _newline_ except: pass
import flup
try: pass _newline_ except ImportError as e :pass
sys . stderr . write ( '_STR:0_' % e )
sys . stderr . write ( '_STR:0_' )
sys . stderr . write ( '_STR:0_' )
sys . stderr . write ( "  http://www.©saddi.com/software/flup/   If you've already\n" )
sys . stderr . write ( '_STR:0_' )
return False
flup_module = '_STR:1_' + options [ '_STR:0_' ]
if options [ '_STR:0_' ] in ( 'prefork' , '_STR:2_' ) :pass
wsgi_opts = {  'maxSpare' : int ( options [ "maxspare" ] ) ,  'minSpare' : int ( options [ "minspare" ] ) ,  'maxChildren' : int ( options [ "maxchildren" ] ) ,  'maxRequests' : int ( options [ "maxrequests" ] ) ,  }
flup_module += '_STR:7_'
if True: pass _newline_ elif options [ '_STR:0_' ] in ( '_STR:1_' , '_STR:2_' ) :pass
wsgi_opts = {  'maxSpare' : int ( options [ "maxspare" ] ) ,  'minSpare' : int ( options [ "minspare" ] ) ,  'maxThreads' : int ( options [ "maxchildren" ] ) ,  }
if True: pass _newline_ else :pass
return fastcgi_help ( "ERROR: Implementation must be one of prefork or "  "thread." )
wsgi_opts [ '_STR:0_' ] = options [ '_STR:0_' ] is not None
try :pass _newline_ except: pass
module = importlib . import_module ( '.%s' % flup_module , '_STR:1_' )
WSGIServer = module . WSGIServer
try: pass _newline_ except Exception :pass
print ( '_STR:0_' + flup_module )
return False
from django . core . servers . basehttp import get_internal_wsgi_application
if options [ "host" ] and options [ "port" ] and not options [ "socket" ] :pass
wsgi_opts [ '_STR:0_' ] = ( options [ "host" ] , int ( options [ "port" ] ) )
if True: pass _newline_ elif options [ "socket" ] and not options [ "host" ] and not options [ "port" ] :pass
wsgi_opts [ '_STR:1_' ] = options [ "socket" ]
if True: pass _newline_ elif not options [ "socket" ] and not options [ "host" ] and not options [ "port" ] :pass
wsgi_opts [ '_STR:0_' ] = None
if True: pass _newline_ else :pass
return fastcgi_help ( '_STR:0_' )
if options [ "daemonize" ] is None :pass
daemonize = ( wsgi_opts [ '_STR:0_' ] is not None )
if True: pass _newline_ else :pass
if options [ "daemonize" ] . lower ( ) in ( '_STR:1_' , '_STR:2_' , '_STR:3_' ) :pass
daemonize = True
if True: pass _newline_ elif options [ "daemonize" ] . lower ( ) in ( '_STR:1_' , '_STR:2_' , '_STR:3_' ) :pass
daemonize = False
if True: pass _newline_ else :pass
return fastcgi_help ( "ERROR: Invalid option for daemonize "  "parameter." )
daemon_kwargs = { }
if options [ '_STR:0_' ] :pass
daemon_kwargs [ '_STR:1_' ] = options [ '_STR:0_' ]
if options [ '_STR:0_' ] :pass
daemon_kwargs [ '_STR:1_' ] = options [ '_STR:0_' ]
if options [ '_STR:0_' ] :pass
daemon_kwargs [ '_STR:0_' ] = int ( options [ '_STR:0_' ] , 8 )
if daemonize :pass
from django . utils . daemonize import become_daemon
become_daemon ( our_home_dir = options [ "workdir" ] , ** daemon_kwargs )
if options [ "pidfile" ] :pass
with open ( options [ "pidfile" ] , "w" ) as fp :pass
fp . write ( "%d\n" % os . getpid ( ) )
WSGIServer ( get_internal_wsgi_application ( ) , ** wsgi_opts ) . run ( )
if __name__ == '_STR:0_' :pass
runfastcgi ( sys . argv [ 1 : ] )
from django . dispatch import Signal
request_started = Signal ( )
request_finished = Signal ( )
got_request_exception = Signal ( providing_args = [ "request" ] )
from __future__ import unicode_literals
import base64
import json
import time
import zlib
from django . conf import settings
from django . utils import baseconv
from django . utils . crypto import constant_time_compare , salted_hmac
from django . utils . encoding import force_bytes , force_str , force_text
from django . utils . module_loading import import_string
class BadSignature ( Exception ) :pass
pass
class SignatureExpired ( BadSignature ) :pass
pass
def b64_encode ( s ) :pass
return base64 . urlsafe_b64encode ( s ) . strip ( b'_STR:0_' )
def b64_decode ( s ) :pass
pad = b'_STR:0_' * ( - len ( s ) % 4 )
return base64 . urlsafe_b64decode ( s + pad )
def base64_hmac ( salt , value , key ) :pass
return b64_encode ( salted_hmac ( salt , value , key ) . digest ( ) )
def get_cookie_signer ( salt = '_STR:0_' ) :pass
Signer = import_string ( settings . SIGNING_BACKEND )
key = force_bytes ( settings . SECRET_KEY )
return Signer ( b'_STR:0_' + key , salt = salt )
class JSONSerializer ( object ) :pass
def dumps ( self , obj ) :pass
return json . dumps ( obj , separators = ( '_STR:0_' , '_STR:1_' ) ) . encode ( 'latin-1' )
def loads ( self , data ) :pass
return json . loads ( data . decode ( '_STR:0_' ) )
def dumps ( obj , key = None , salt = '_STR:0_' , serializer = JSONSerializer , compress = False ) :pass
data = serializer ( ) . dumps ( obj )
is_compressed = False
if compress :pass
compressed = zlib . compress ( data )
if len ( compressed ) < ( len ( data ) - 1 ) :pass
data = compressed
is_compressed = True
base64d = b64_encode ( data )
if is_compressed :pass
base64d = b'_STR:0_' + base64d
return TimestampSigner ( key , salt = salt ) . sign ( base64d )
def loads ( s , key = None , salt = '_STR:0_' , serializer = JSONSerializer , max_age = None ) :pass
base64d = force_bytes ( TimestampSigner ( key , salt = salt ) . unsign ( s , max_age = max_age ) )
decompress = False
if base64d [ : 1 ] == b'_STR:0_' :pass
base64d = base64d [ 1 : ]
decompress = True
data = b64_decode ( base64d )
if decompress :pass
data = zlib . decompress ( data )
return serializer ( ) . loads ( data )
class Signer ( object ) :pass
def __init__ ( self , key = None , sep = '_STR:0_' , salt = None ) :pass
self . sep = force_str ( sep )
self . key = key or settings . SECRET_KEY
self . salt = force_str ( salt or  '_STR:0_' % ( self . __class__ . __module__ , self . __class__ . __name__ ) )
def signature ( self , value ) :pass
signature = base64_hmac ( self . salt + '_STR:0_' , value , self . key )
return force_str ( signature )
def sign ( self , value ) :pass
value = force_str ( value )
return str ( '%s%s%s' ) % ( value , self . sep , self . signature ( value ) )
def unsign ( self , signed_value ) :pass
signed_value = force_str ( signed_value )
if self . sep not in signed_value :pass
raise BadSignature ( '_STR:0_' % self . sep )
value , sig = signed_value . rsplit ( self . sep , 1 )
if constant_time_compare ( sig , self . signature ( value ) ) :pass
return force_text ( value )
raise BadSignature ( '_STR:0_' % sig )
class TimestampSigner ( Signer ) :pass
def timestamp ( self ) :pass
return baseconv . base62 . encode ( int ( time . time ( ) ) )
def sign ( self , value ) :pass
value = force_str ( value )
value = str ( '%s%s%s' ) % ( value , self . sep , self . timestamp ( ) )
return super ( TimestampSigner , self ) . sign ( value )
def unsign ( self , value , max_age = None ) :pass
result = super ( TimestampSigner , self ) . unsign ( value )
value , timestamp = result . rsplit ( self . sep , 1 )
timestamp = baseconv . base62 . decode ( timestamp )
if max_age is not None :pass
age = time . time ( ) - timestamp
if age > max_age :pass
raise SignatureExpired (  '_STR:0_' % ( age , max_age ) )
return value
from __future__ import unicode_literals
import functools
from importlib import import_module
import re
from threading import local
import warnings
from django . http import Http404
from django . core . exceptions import ImproperlyConfigured , ViewDoesNotExist
from django . utils . datastructures import MultiValueDict
from django . utils . deprecation import RemovedInDjango20Warning
from django . utils . encoding import force_str , force_text , iri_to_uri
from django . utils . functional import lazy
from django . utils . http import urlquote
from django . utils . module_loading import module_has_submodule
from django . utils . regex_helper import normalize
from django . utils import six , lru_cache
from django . utils . translation import get_language
_prefixes = local ( )
_urlconfs = local ( )
class ResolverMatch ( object ) :pass
def __init__ ( self , func , args , kwargs , url_name = None , app_name = None , namespaces = None ) :pass
self . func = func
self . args = args
self . kwargs = kwargs
self . url_name = url_name
self . app_name = app_name
if namespaces :pass
self . namespaces = [ x for x in namespaces if x ]
if True: pass _newline_ else :pass
self . namespaces = [ ]
self . namespace = '_STR:0_' . join ( self . namespaces )
if not hasattr ( func , '_STR:0_' ) :pass
self . _func_path = '_STR:0_' . join ( [ func . __class__ . __module__ , func . __class__ . __name__ ] )
if True: pass _newline_ else :pass
self . _func_path = '_STR:0_' . join ( [ func . __module__ , func . __name__ ] )
view_path = url_name or self . _func_path
self . view_name = '_STR:0_' . join ( self . namespaces + [ view_path ] )
def __getitem__ ( self , index ) :pass
return ( self . func , self . args , self . kwargs ) [ index ]
def __repr__ ( self ) :pass
return '_STR:0_' % (  self . _func_path , self . args , self . kwargs , self . url_name , self . app_name , self . namespaces )
class Resolver404 ( Http404 ) :pass
pass
class NoReverseMatch ( Exception ) :pass
pass
@ lru_cache . lru_cache ( maxsize = None ) _newline_ def dummy(): pass
def get_callable ( lookup_view , can_fail = False ) :pass
if callable ( lookup_view ) :pass
return lookup_view
mod_name , func_name = get_mod_func ( lookup_view )
if not func_name :pass
if can_fail :pass
return lookup_view
if True: pass _newline_ else :pass
raise ImportError (  '_STR:0_' %  lookup_view )
try :pass _newline_ except: pass
mod = import_module ( mod_name )
try: pass _newline_ except ImportError :pass
if can_fail :pass
return lookup_view
if True: pass _newline_ else :pass
parentmod , submod = get_mod_func ( mod_name )
if submod and not module_has_submodule ( import_module ( parentmod ) , submod ) :pass
raise ViewDoesNotExist (  '_STR:0_' %  ( lookup_view , mod_name ) )
if True: pass _newline_ else :pass
raise
if True: pass _newline_ else :pass
try :pass _newline_ except: pass
view_func = getattr ( mod , func_name )
try: pass _newline_ except AttributeError :pass
if can_fail :pass
return lookup_view
if True: pass _newline_ else :pass
raise ViewDoesNotExist (  '_STR:0_' %  ( lookup_view , mod_name ) )
if True: pass _newline_ else :pass
if not callable ( view_func ) :pass
raise ViewDoesNotExist (  '_STR:0_' %  ( mod_name , func_name ) )
return view_func
@ lru_cache . lru_cache ( maxsize = None ) _newline_ def dummy(): pass
def get_resolver ( urlconf ) :pass
if urlconf is None :pass
from django . conf import settings
urlconf = settings . ROOT_URLCONF
return RegexURLResolver ( r'_STR:0_' , urlconf )
@ lru_cache . lru_cache ( maxsize = None ) _newline_ def dummy(): pass
def get_ns_resolver ( ns_pattern , resolver ) :pass
ns_resolver = RegexURLResolver ( ns_pattern , resolver . url_patterns )
return RegexURLResolver ( r'_STR:0_' , [ ns_resolver ] )
def get_mod_func ( callback ) :pass
try :pass _newline_ except: pass
dot = callback . rindex ( '_STR:0_' )
try: pass _newline_ except ValueError :pass
return callback , ''
return callback [ : dot ] , callback [ dot + 1 : ]
class LocaleRegexProvider ( object ) :pass
def __init__ ( self , regex ) :pass
self . _regex = regex
self . _regex_dict = { }
@ property _newline_ def dummy(): pass
def regex ( self ) :pass
language_code = get_language ( )
if language_code not in self . _regex_dict :pass
if isinstance ( self . _regex , six . string_types ) :pass
regex = self . _regex
if True: pass _newline_ else :pass
regex = force_text ( self . _regex )
try :pass _newline_ except: pass
compiled_regex = re . compile ( regex , re . UNICODE )
try: pass _newline_ except re . error as e :pass
raise ImproperlyConfigured (  '_STR:0_' %  ( regex , six . text_type ( e ) ) )
self . _regex_dict [ language_code ] = compiled_regex
return self . _regex_dict [ language_code ]
class RegexURLPattern ( LocaleRegexProvider ) :pass
def __init__ ( self , regex , callback , default_args = None , name = None ) :pass
LocaleRegexProvider . __init__ ( self , regex )
if callable ( callback ) :pass
self . _callback = callback
if True: pass _newline_ else :pass
self . _callback = None
self . _callback_str = callback
self . default_args = default_args or { }
self . name = name
def __repr__ ( self ) :pass
return force_str ( '_STR:0_' % ( self . __class__ . __name__ , self . name , self . regex . pattern ) )
def add_prefix ( self , prefix ) :pass
if not prefix or not hasattr ( self , '_STR:0_' ) :pass
return
self . _callback_str = prefix + '_STR:0_' + self . _callback_str
def resolve ( self , path ) :pass
match = self . regex . search ( path )
if match :pass
kwargs = match . groupdict ( )
if kwargs :pass
args = ( )
if True: pass _newline_ else :pass
args = match . groups ( )
kwargs . update ( self . default_args )
return ResolverMatch ( self . callback , args , kwargs , self . name )
@ property _newline_ def dummy(): pass
def callback ( self ) :pass
if self . _callback is not None :pass
return self . _callback
self . _callback = get_callable ( self . _callback_str )
return self . _callback
class RegexURLResolver ( LocaleRegexProvider ) :pass
def __init__ ( self , regex , urlconf_name , default_kwargs = None , app_name = None , namespace = None ) :pass
LocaleRegexProvider . __init__ ( self , regex )
self . urlconf_name = urlconf_name
if not isinstance ( urlconf_name , six . string_types ) :pass
self . _urlconf_module = self . urlconf_name
self . callback = None
self . default_kwargs = default_kwargs or { }
self . namespace = namespace
self . app_name = app_name
self . _reverse_dict = { }
self . _namespace_dict = { }
self . _app_dict = { }
self . _callback_strs = set ( )
self . _populated = False
def __repr__ ( self ) :pass
if isinstance ( self . urlconf_name , list ) and len ( self . urlconf_name ) :pass
urlconf_repr = '_STR:0_' % self . urlconf_name [ 0 ] . __class__ . __name__
if True: pass _newline_ else :pass
urlconf_repr = repr ( self . urlconf_name )
return str ( '_STR:0_' ) % (  self . __class__ . __name__ , urlconf_repr , self . app_name ,  self . namespace , self . regex . pattern )
def _populate ( self ) :pass
lookups = MultiValueDict ( )
namespaces = { }
apps = { }
language_code = get_language ( )
for pattern in reversed ( self . url_patterns ) :pass
if hasattr ( pattern , '_STR:0_' ) :pass
self . _callback_strs . add ( pattern . _callback_str )
if True: pass _newline_ elif hasattr ( pattern , '_STR:0_' ) :pass
callback = pattern . _callback
if isinstance ( callback , functools . partial ) :pass
callback = callback . func
if not hasattr ( callback , '_STR:0_' ) :pass
lookup_str = callback . __module__ + '_STR:0_' + callback . __class__ . __name__
if True: pass _newline_ else :pass
lookup_str = callback . __module__ + '_STR:0_' + callback . __name__
self . _callback_strs . add ( lookup_str )
p_pattern = pattern . regex . pattern
if p_pattern . startswith ( '_STR:0_' ) :pass
p_pattern = p_pattern [ 1 : ]
if isinstance ( pattern , RegexURLResolver ) :pass
if pattern . namespace :pass
namespaces [ pattern . namespace ] = ( p_pattern , pattern )
if pattern . app_name :pass
apps . setdefault ( pattern . app_name , [ ] ) . append ( pattern . namespace )
if True: pass _newline_ else :pass
parent_pat = pattern . regex . pattern
for name in pattern . reverse_dict :pass
for matches , pat , defaults in pattern . reverse_dict . getlist ( name ) :pass
new_matches = normalize ( parent_pat + pat )
lookups . appendlist ( name , ( new_matches , p_pattern + pat , dict ( defaults , ** pattern . default_kwargs ) ) )
for namespace , ( prefix , sub_pattern ) in pattern . namespace_dict . items ( ) :pass
namespaces [ namespace ] = ( p_pattern + prefix , sub_pattern )
for app_name , namespace_list in pattern . app_dict . items ( ) :pass
apps . setdefault ( app_name , [ ] ) . extend ( namespace_list )
self . _callback_strs . update ( pattern . _callback_strs )
if True: pass _newline_ else :pass
bits = normalize ( p_pattern )
lookups . appendlist ( pattern . callback , ( bits , p_pattern , pattern . default_args ) )
if pattern . name is not None :pass
lookups . appendlist ( pattern . name , ( bits , p_pattern , pattern . default_args ) )
self . _reverse_dict [ language_code ] = lookups
self . _namespace_dict [ language_code ] = namespaces
self . _app_dict [ language_code ] = apps
self . _populated = True
@ property _newline_ def dummy(): pass
def reverse_dict ( self ) :pass
language_code = get_language ( )
if language_code not in self . _reverse_dict :pass
self . _populate ( )
return self . _reverse_dict [ language_code ]
@ property _newline_ def dummy(): pass
def namespace_dict ( self ) :pass
language_code = get_language ( )
if language_code not in self . _namespace_dict :pass
self . _populate ( )
return self . _namespace_dict [ language_code ]
@ property _newline_ def dummy(): pass
def app_dict ( self ) :pass
language_code = get_language ( )
if language_code not in self . _app_dict :pass
self . _populate ( )
return self . _app_dict [ language_code ]
def resolve ( self , path ) :pass
path = force_text ( path )
tried = [ ]
match = self . regex . search ( path )
if match :pass
new_path = path [ match . end ( ) : ]
for pattern in self . url_patterns :pass
try :pass _newline_ except: pass
sub_match = pattern . resolve ( new_path )
try: pass _newline_ except Resolver404 as e :pass
sub_tried = e . args [ 0 ] . get ( '_STR:0_' )
if sub_tried is not None :pass
tried . extend ( [ pattern ] + t for t in sub_tried )
if True: pass _newline_ else :pass
tried . append ( [ pattern ] )
if True: pass _newline_ else :pass
if sub_match :pass
sub_match_dict = dict ( match . groupdict ( ) , ** self . default_kwargs )
sub_match_dict . update ( sub_match . kwargs )
return ResolverMatch ( sub_match . func , sub_match . args , sub_match_dict , sub_match . url_name , self . app_name or sub_match . app_name , [ self . namespace ] + sub_match . namespaces )
tried . append ( [ pattern ] )
raise Resolver404 ( { '_STR:1_' : tried , '_STR:0_' : new_path } )
raise Resolver404 ( { '_STR:0_' : path } )
@ property _newline_ def dummy(): pass
def urlconf_module ( self ) :pass
try :pass _newline_ except: pass
return self . _urlconf_module
try: pass _newline_ except AttributeError :pass
self . _urlconf_module = import_module ( self . urlconf_name )
return self . _urlconf_module
@ property _newline_ def dummy(): pass
def url_patterns ( self ) :pass
patterns = getattr ( self . urlconf_module , '_STR:0_' , self . urlconf_module )
try :pass _newline_ except: pass
iter ( patterns )
try: pass _newline_ except TypeError :pass
msg = (  "The included urlconf '_STR:1_' does not appear to have any "  "patterns in it. If you see valid patterns in the file then "  "the issue is probably caused by a circular import."  )
raise ImproperlyConfigured ( msg . format ( name = self . urlconf_name ) )
return patterns
def resolve_error_handler ( self , view_type ) :pass
callback = getattr ( self . urlconf_module , '_STR:0_' % view_type , None )
if not callback :pass
from django . conf import urls
callback = getattr ( urls , '_STR:0_' % view_type )
return get_callable ( callback ) , { }
def reverse ( self , lookup_view , * args , ** kwargs ) :pass
return self . _reverse_with_prefix ( lookup_view , '' , * args , ** kwargs )
def _reverse_with_prefix ( self , lookup_view , _prefix , * args , ** kwargs ) :pass
if args and kwargs :pass
raise ValueError ( '_STR:0_' )
text_args = [ force_text ( v ) for v in args ]
text_kwargs = dict ( ( k , force_text ( v ) ) for ( k , v ) in kwargs . items ( ) )
if not self . _populated :pass
self . _populate ( )
original_lookup = lookup_view
try :pass _newline_ except: pass
if lookup_view in self . _callback_strs :pass
lookup_view = get_callable ( lookup_view , True )
try: pass _newline_ except ( ImportError , AttributeError ) as e :pass
raise NoReverseMatch ( '_STR:0_' % ( lookup_view , e ) )
if True: pass _newline_ else :pass
if not callable ( original_lookup ) and callable ( lookup_view ) :pass
warnings . warn (  '_STR:0_' % original_lookup ,  RemovedInDjango20Warning , stacklevel = 3  )
possibilities = self . reverse_dict . getlist ( lookup_view )
prefix_norm , prefix_args = normalize ( urlquote ( _prefix ) ) [ 0 ]
for possibility , pattern , defaults in possibilities :pass
for result , params in possibility :pass
if args :pass
if len ( args ) != len ( params ) + len ( prefix_args ) :pass
continue
candidate_subs = dict ( zip ( prefix_args + params , text_args ) )
if True: pass _newline_ else :pass
if set ( kwargs . keys ( ) ) | set ( defaults . keys ( ) ) != set ( params ) | set ( defaults . keys ( ) ) | set ( prefix_args ) :pass
continue
matches = True
for k , v in defaults . items ( ) :pass
if kwargs . get ( k , v ) != v :pass
matches = False
break
if not matches :pass
continue
candidate_subs = text_kwargs
candidate_pat = prefix_norm . replace ( '_STR:0_' , '_STR:1_' ) + result
if re . search ( '_STR:0_' % ( prefix_norm , pattern ) , candidate_pat % candidate_subs , re . UNICODE ) :pass
candidate_subs = dict ( ( k , urlquote ( v ) ) for ( k , v ) in candidate_subs . items ( ) )
return candidate_pat % candidate_subs
m = getattr ( lookup_view , '_STR:0_' , None )
n = getattr ( lookup_view , '_STR:0_' , None )
if m is not None and n is not None :pass
lookup_view_s = "%s.%s" % ( m , n )
if True: pass _newline_ else :pass
lookup_view_s = lookup_view
patterns = [ pattern for ( possibility , pattern , defaults ) in possibilities ]
raise NoReverseMatch ( '_STR:0_'  "arguments '%s' not found. %d pattern(s) tried: %s" %  ( lookup_view_s , args , kwargs , len ( patterns ) , patterns ) )
class LocaleRegexURLResolver ( RegexURLResolver ) :pass
def __init__ ( self , urlconf_name , default_kwargs = None , app_name = None , namespace = None ) :pass
super ( LocaleRegexURLResolver , self ) . __init__ (  None , urlconf_name , default_kwargs , app_name , namespace )
@ property _newline_ def dummy(): pass
def regex ( self ) :pass
language_code = get_language ( )
if language_code not in self . _regex_dict :pass
regex_compiled = re . compile ( '_STR:0_' % language_code , re . UNICODE )
self . _regex_dict [ language_code ] = regex_compiled
return self . _regex_dict [ language_code ]
def resolve ( path , urlconf = None ) :pass
if urlconf is None :pass
urlconf = get_urlconf ( )
return get_resolver ( urlconf ) . resolve ( path )
def reverse ( viewname , urlconf = None , args = None , kwargs = None , prefix = None , current_app = None ) :pass
if urlconf is None :pass
urlconf = get_urlconf ( )
resolver = get_resolver ( urlconf )
args = args or [ ]
kwargs = kwargs or { }
if prefix is None :pass
prefix = get_script_prefix ( )
if not isinstance ( viewname , six . string_types ) :pass
view = viewname
if True: pass _newline_ else :pass
parts = viewname . split ( '_STR:0_' )
parts . reverse ( )
view = parts [ 0 ]
path = parts [ 1 : ]
resolved_path = [ ]
ns_pattern = ''
while path :pass
ns = path . pop ( )
try :pass _newline_ except: pass
app_list = resolver . app_dict [ ns ]
if current_app and current_app in app_list :pass
ns = current_app
if True: pass _newline_ elif ns not in app_list :pass
ns = app_list [ 0 ]
try: pass _newline_ except KeyError :pass
pass
try :pass _newline_ except: pass
extra , resolver = resolver . namespace_dict [ ns ]
resolved_path . append ( ns )
ns_pattern = ns_pattern + extra
try: pass _newline_ except KeyError as key :pass
if resolved_path :pass
raise NoReverseMatch (  '_STR:0_' %  ( key , ':' . join ( resolved_path ) ) )
if True: pass _newline_ else :pass
raise NoReverseMatch ( '_STR:0_' %  key )
if ns_pattern :pass
resolver = get_ns_resolver ( ns_pattern , resolver )
return iri_to_uri ( resolver . _reverse_with_prefix ( view , prefix , * args , ** kwargs ) )
reverse_lazy = lazy ( reverse , str )
def clear_url_caches ( ) :pass
get_callable . cache_clear ( )
get_resolver . cache_clear ( )
get_ns_resolver . cache_clear ( )
def set_script_prefix ( prefix ) :pass
if not prefix . endswith ( '_STR:0_' ) :pass
prefix += '_STR:0_'
_prefixes . value = prefix
def get_script_prefix ( ) :pass
return getattr ( _prefixes , "value" , '_STR:1_' )
def clear_script_prefix ( ) :pass
try :pass _newline_ except: pass
del _prefixes . value
try: pass _newline_ except AttributeError :pass
pass
def set_urlconf ( urlconf_name ) :pass
if urlconf_name :pass
_urlconfs . value = urlconf_name
if True: pass _newline_ else :pass
if hasattr ( _urlconfs , "value" ) :pass
del _urlconfs . value
def get_urlconf ( default = None ) :pass
return getattr ( _urlconfs , "value" , default )
def is_valid_path ( path , urlconf = None ) :pass
try :pass _newline_ except: pass
resolve ( path , urlconf )
return True
try: pass _newline_ except Resolver404 :pass
return False
from __future__ import unicode_literals
import re
from django . core . exceptions import ValidationError
from django . utils . deconstruct import deconstructible
from django . utils . translation import ugettext_lazy as _ , ungettext_lazy
from django . utils . encoding import force_text
from django . utils . ipv6 import is_valid_ipv6_address
from django . utils import six
from django . utils . six . moves . urllib . parse import urlsplit , urlunsplit
EMPTY_VALUES = ( None , '' , [ ] , ( ) , { } )
@ deconstructible _newline_ def dummy(): pass
class RegexValidator ( object ) :pass
regex = ''
message = _ ( '_STR:0_' )
code = '_STR:0_'
inverse_match = False
flags = 0
def __init__ ( self , regex = None , message = None , code = None , inverse_match = None , flags = None ) :pass
if regex is not None :pass
self . regex = regex
if message is not None :pass
self . message = message
if code is not None :pass
self . code = code
if inverse_match is not None :pass
self . inverse_match = inverse_match
if flags is not None :pass
self . flags = flags
if self . flags and not isinstance ( self . regex , six . string_types ) :pass
raise TypeError ( '_STR:0_' )
if isinstance ( self . regex , six . string_types ) :pass
self . regex = re . compile ( self . regex , self . flags )
def __call__ ( self , value ) :pass
if not ( self . inverse_match is not bool ( self . regex . search (  force_text ( value ) ) ) ) :pass
raise ValidationError ( self . message , code = self . code )
def __eq__ ( self , other ) :pass
return (  isinstance ( other , RegexValidator ) and  self . regex . pattern == other . regex . pattern and  self . regex . flags == other . regex . flags and  ( self . message == other . message ) and  ( self . code == other . code ) and  ( self . inverse_match == other . inverse_match )  )
def __ne__ ( self , other ) :pass
return not ( self == other )
@ deconstructible _newline_ def dummy(): pass
class URLValidator ( RegexValidator ) :pass
regex = re . compile (  r'^(?:[a-z0-9\.\-]*)://'  r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}(?<!-)\.?)|'  r'localhost|'  r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|'  r'\[?[A-F0-9]*:[A-F0-9:]+\]?)'  r'(?::\d+)?'  r'(?:/?|[/?]\S+)$' , re . IGNORECASE )
message = _ ( 'Enter a valid URL.' )
schemes = [ '_STR:0_' , '_STR:1_' , '_STR:2_' , '_STR:3_' ]
def __init__ ( self , schemes = None , ** kwargs ) :pass
super ( URLValidator , self ) . __init__ ( ** kwargs )
if schemes is not None :pass
self . schemes = schemes
def __call__ ( self , value ) :pass
value = force_text ( value )
scheme = value . split ( '_STR:0_' ) [ 0 ] . lower ( )
if scheme not in self . schemes :pass
raise ValidationError ( self . message , code = self . code )
try :pass _newline_ except: pass
super ( URLValidator , self ) . __call__ ( value )
try: pass _newline_ except ValidationError as e :pass
if value :pass
scheme , netloc , path , query , fragment = urlsplit ( value )
try :pass _newline_ except: pass
netloc = netloc . encode ( '_STR:0_' ) . decode ( '_STR:1_' )
try: pass _newline_ except UnicodeError :pass
raise e
url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )
super ( URLValidator , self ) . __call__ ( url )
if True: pass _newline_ else :pass
raise
if True: pass _newline_ else :pass
url = value
def validate_integer ( value ) :pass
try :pass _newline_ except: pass
int ( value )
try: pass _newline_ except ( ValueError , TypeError ) :pass
raise ValidationError ( _ ( '_STR:0_' ) , code = 'invalid' )
@ deconstructible _newline_ def dummy(): pass
class EmailValidator ( object ) :pass
message = _ ( 'Enter a valid email address.' )
code = '_STR:0_'
user_regex = re . compile (  r'_STR:0_'  r'|^"([\001-\010\013\014\016-\037!#-\[\]-\177]|\\[\001-\011\013\014\016-\177])*"$)' ,  re . IGNORECASE )
domain_regex = re . compile (    r'_STR:2_' ,  re . IGNORECASE )
literal_regex = re . compile (   r'_STR:0_' ,  re . IGNORECASE )
domain_whitelist = [ '_STR:0_' ]
def __init__ ( self , message = None , code = None , whitelist = None ) :pass
if message is not None :pass
self . message = message
if code is not None :pass
self . code = code
if whitelist is not None :pass
self . domain_whitelist = whitelist
def __call__ ( self , value ) :pass
value = force_text ( value )
if not value or '_STR:0_' not in value :pass
raise ValidationError ( self . message , code = self . code )
user_part , domain_part = value . rsplit ( '_STR:0_' , 1 )
if not self . user_regex . match ( user_part ) :pass
raise ValidationError ( self . message , code = self . code )
if ( domain_part not in self . domain_whitelist and  not self . validate_domain_part ( domain_part ) ) :pass
try :pass _newline_ except: pass
domain_part = domain_part . encode ( '_STR:0_' ) . decode ( '_STR:1_' )
if self . validate_domain_part ( domain_part ) :pass
return
try: pass _newline_ except UnicodeError :pass
pass
raise ValidationError ( self . message , code = self . code )
def validate_domain_part ( self , domain_part ) :pass
if self . domain_regex . match ( domain_part ) :pass
return True
literal_match = self . literal_regex . match ( domain_part )
if literal_match :pass
ip_address = literal_match . group ( 1 )
try :pass _newline_ except: pass
validate_ipv46_address ( ip_address )
return True
try: pass _newline_ except ValidationError :pass
pass
return False
def __eq__ ( self , other ) :pass
return isinstance ( other , EmailValidator ) and ( self . domain_whitelist == other . domain_whitelist ) and ( self . message == other . message ) and ( self . code == other . code )
validate_email = EmailValidator ( )
slug_re = re . compile ( r'_STR:0_' )
validate_slug = RegexValidator ( slug_re , _ ( "Enter a valid 'slug' consisting of letters, numbers, underscores or hyphens." ) , 'invalid' )
ipv4_re = re . compile ( r'_STR:2_' )
validate_ipv4_address = RegexValidator ( ipv4_re , _ ( 'Enter a valid IPv4 address.' ) , 'invalid' )
def validate_ipv6_address ( value ) :pass
if not is_valid_ipv6_address ( value ) :pass
raise ValidationError ( _ ( '_STR:0_' ) , code = '_STR:1_' )
def validate_ipv46_address ( value ) :pass
try :pass _newline_ except: pass
validate_ipv4_address ( value )
try: pass _newline_ except ValidationError :pass
try :pass _newline_ except: pass
validate_ipv6_address ( value )
try: pass _newline_ except ValidationError :pass
raise ValidationError ( _ ( '_STR:0_' ) , code = '_STR:1_' )
ip_address_validator_map = {  '_STR:1_' : ( [ validate_ipv46_address ] , _ ( '_STR:0_' ) ) ,  'ipv4' : ( [ validate_ipv4_address ] , _ ( 'Enter a valid IPv4 address.' ) ) ,  'ipv6' : ( [ validate_ipv6_address ] , _ ( 'Enter a valid IPv6 address.' ) ) ,  }
def ip_address_validators ( protocol , unpack_ipv4 ) :pass
if protocol != '_STR:0_' and unpack_ipv4 :pass
raise ValueError (  '_STR:0_' )
try :pass _newline_ except: pass
return ip_address_validator_map [ protocol . lower ( ) ]
try: pass _newline_ except KeyError :pass
raise ValueError ( '_STR:0_'  % ( protocol , list ( ip_address_validator_map ) ) )
comma_separated_int_list_re = re . compile ( '_STR:0_' )
validate_comma_separated_integer_list = RegexValidator ( comma_separated_int_list_re , _ ( 'Enter only digits separated by commas.' ) , 'invalid' )
@ deconstructible _newline_ def dummy(): pass
class BaseValidator ( object ) :pass
compare = lambda self , a , b : a is not b
clean = lambda self , x : x
message = _ ( '_STR:0_' )
code = '_STR:0_'
def __init__ ( self , limit_value ) :pass
self . limit_value = limit_value
def __call__ ( self , value ) :pass
cleaned = self . clean ( value )
params = { '_STR:0_' : self . limit_value , '_STR:1_' : cleaned }
if self . compare ( cleaned , self . limit_value ) :pass
raise ValidationError ( self . message , code = self . code , params = params )
def __eq__ ( self , other ) :pass
return isinstance ( other , self . __class__ ) and ( self . limit_value == other . limit_value ) and ( self . message == other . message ) and ( self . code == other . code )
@ deconstructible _newline_ def dummy(): pass
class MaxValueValidator ( BaseValidator ) :pass
compare = lambda self , a , b : a > b
message = _ ( '_STR:0_' )
code = '_STR:0_'
@ deconstructible _newline_ def dummy(): pass
class MinValueValidator ( BaseValidator ) :pass
compare = lambda self , a , b : a < b
message = _ ( '_STR:0_' )
code = '_STR:0_'
@ deconstructible _newline_ def dummy(): pass
class MinLengthValidator ( BaseValidator ) :pass
compare = lambda self , a , b : a < b
clean = lambda self , x : len ( x )
message = ungettext_lazy (  'Ensure this value has at least %(limit_value)d character (it has %(show_value)d).' ,  'Ensure this value has at least %(limit_value)d characters (it has %(show_value)d).' ,  'limit_value' )
code = '_STR:2_'
@ deconstructible _newline_ def dummy(): pass
class MaxLengthValidator ( BaseValidator ) :pass
compare = lambda self , a , b : a > b
clean = lambda self , x : len ( x )
message = ungettext_lazy (  'Ensure this value has at most %(limit_value)d character (it has %(show_value)d).' ,  'Ensure this value has at most %(limit_value)d characters (it has %(show_value)d).' ,  'limit_value' )
code = '_STR:2_'
import django
from django . core . handlers . wsgi import WSGIHandler
def get_wsgi_application ( ) :pass
django . setup ( )
return WSGIHandler ( )
from django . core . exceptions import ValidationError
from django . forms . fields import *
from django . forms . forms import *
from django . forms . formsets import *
from django . forms . models import *
from django . forms . widgets import *
from django . forms . extras . widgets import SelectDateWidget
__all__ = [ '_STR:0_' ]
from __future__ import unicode_literals
import datetime
import re
from django . forms . widgets import Widget , Select
from django . utils import datetime_safe
from django . utils . dates import MONTHS
from django . utils . encoding import force_str
from django . utils . safestring import mark_safe
from django . utils . formats import get_format
from django . utils import six
from django . conf import settings
__all__ = ( '_STR:0_' , )
RE_DATE = re . compile ( r'_STR:0_' )
def _parse_date_fmt ( ) :pass
fmt = get_format ( '_STR:0_' )
escaped = False
for char in fmt :pass
if escaped :pass
escaped = False
if True: pass _newline_ elif char == '\\' :pass
escaped = True
if True: pass _newline_ elif char in '_STR:0_' :pass
yield '_STR:0_'
if True: pass _newline_ elif char in '_STR:0_' :pass
yield '_STR:0_'
if True: pass _newline_ elif char in '_STR:0_' :pass
yield '_STR:0_'
class SelectDateWidget ( Widget ) :pass
none_value = ( 0 , '_STR:0_' )
month_field = '_STR:0_'
day_field = '_STR:0_'
year_field = '_STR:0_'
def __init__ ( self , attrs = None , years = None , months = None , empty_label = None ) :pass
self . attrs = attrs or { }
if years :pass
self . years = years
if True: pass _newline_ else :pass
this_year = datetime . date . today ( ) . year
self . years = range ( this_year , this_year + 10 )
if months :pass
self . months = months
if True: pass _newline_ else :pass
self . months = MONTHS
if isinstance ( empty_label , ( list , tuple ) ) :pass
if not len ( empty_label ) == 3 :pass
raise ValueError ( '_STR:0_' )
self . year_none_value = ( 0 , empty_label [ 0 ] )
self . month_none_value = ( 0 , empty_label [ 1 ] )
self . day_none_value = ( 0 , empty_label [ 2 ] )
if True: pass _newline_ else :pass
if empty_label is not None :pass
self . none_value = ( 0 , empty_label )
self . year_none_value = self . none_value
self . month_none_value = self . none_value
self . day_none_value = self . none_value
def render ( self , name , value , attrs = None ) :pass
try :pass _newline_ except: pass
year_val , month_val , day_val = value . year , value . month , value . day
try: pass _newline_ except AttributeError :pass
year_val = month_val = day_val = None
if isinstance ( value , six . string_types ) :pass
if settings . USE_L10N :pass
try :pass _newline_ except: pass
input_format = get_format ( '_STR:0_' ) [ 0 ]
v = datetime . datetime . strptime ( force_str ( value ) , input_format )
year_val , month_val , day_val = v . year , v . month , v . day
try: pass _newline_ except ValueError :pass
pass
if True: pass _newline_ else :pass
match = RE_DATE . match ( value )
if match :pass
year_val , month_val , day_val = [ int ( v ) for v in match . groups ( ) ]
html = { }
choices = [ ( i , i ) for i in self . years ]
html [ 'year' ] = self . create_select ( name , self . year_field , value , year_val , choices , self . year_none_value )
choices = list ( six . iteritems ( self . months ) )
html [ 'month' ] = self . create_select ( name , self . month_field , value , month_val , choices , self . month_none_value )
choices = [ ( i , i ) for i in range ( 1 , 32 ) ]
html [ 'day' ] = self . create_select ( name , self . day_field , value , day_val , choices , self . day_none_value )
output = [ ]
for field in _parse_date_fmt ( ) :pass
output . append ( html [ field ] )
return mark_safe ( '\n' . join ( output ) )
def id_for_label ( self , id_ ) :pass
for first_select in _parse_date_fmt ( ) :pass
return '_STR:0_' % ( id_ , first_select )
if True: pass _newline_ else :pass
return '%s_month' % id_
def value_from_datadict ( self , data , files , name ) :pass
y = data . get ( self . year_field % name )
m = data . get ( self . month_field % name )
d = data . get ( self . day_field % name )
if y == m == d == "0" :pass
return None
if y and m and d :pass
if settings . USE_L10N :pass
input_format = get_format ( '_STR:0_' ) [ 0 ]
try :pass _newline_ except: pass
date_value = datetime . date ( int ( y ) , int ( m ) , int ( d ) )
try: pass _newline_ except ValueError :pass
return '_STR:0_' % ( y , m , d )
if True: pass _newline_ else :pass
date_value = datetime_safe . new_date ( date_value )
return date_value . strftime ( input_format )
if True: pass _newline_ else :pass
return '_STR:0_' % ( y , m , d )
return data . get ( name , None )
def create_select ( self , name , field , value , val , choices , none_value ) :pass
if '_STR:0_' in self . attrs :pass
id_ = self . attrs [ '_STR:0_' ]
if True: pass _newline_ else :pass
id_ = '_STR:0_' % name
if not self . is_required :pass
choices . insert ( 0 , none_value )
local_attrs = self . build_attrs ( id = field % id_ )
s = Select ( choices = choices )
select_html = s . render ( field % name , val , local_attrs )
return select_html
from __future__ import unicode_literals
import copy
import datetime
import os
import re
import sys
import warnings
from decimal import Decimal , DecimalException
from io import BytesIO
from django . core import validators
from django . core . exceptions import ValidationError
from django . forms . utils import from_current_timezone , to_current_timezone
from django . forms . widgets import (  TextInput , NumberInput , EmailInput , URLInput , HiddenInput ,  MultipleHiddenInput , ClearableFileInput , CheckboxInput , Select ,  NullBooleanSelect , SelectMultiple , DateInput , DateTimeInput , TimeInput ,  SplitDateTimeWidget , SplitHiddenDateTimeWidget , FILE_INPUT_CONTRADICTION  )
from django . utils import formats
from django . utils . encoding import smart_text , force_str , force_text
from django . utils . ipv6 import clean_ipv6_address
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils import six
from django . utils . six . moves . urllib . parse import urlsplit , urlunsplit
from django . utils . translation import ugettext_lazy as _ , ungettext_lazy
from django . core . validators import EMPTY_VALUES
__all__ = (  '_STR:0_' , '_STR:1_' , '_STR:2_' ,  '_STR:3_' , '_STR:4_' , '_STR:5_' ,  '_STR:6_' , 'EmailField' , 'FileField' , 'ImageField' , 'URLField' ,  'BooleanField' , 'NullBooleanField' , 'ChoiceField' , 'MultipleChoiceField' ,  'ComboField' , 'MultiValueField' , 'FloatField' , 'DecimalField' ,  'SplitDateTimeField' , 'IPAddressField' , 'GenericIPAddressField' , 'FilePathField' ,  'SlugField' , 'TypedChoiceField' , 'TypedMultipleChoiceField'  )
class Field ( object ) :pass
widget = TextInput
hidden_widget = HiddenInput
default_validators = [ ]
default_error_messages = {  '_STR:1_' : _ ( '_STR:0_' ) ,  }
empty_values = list ( validators . EMPTY_VALUES )
creation_counter = 0
def __init__ ( self , required = True , widget = None , label = None , initial = None ,  help_text = '' , error_messages = None , show_hidden_initial = False ,  validators = [ ] , localize = False , label_suffix = None ) :pass
self . required , self . label , self . initial = required , label , initial
self . show_hidden_initial = show_hidden_initial
self . help_text = help_text
self . label_suffix = label_suffix
widget = widget or self . widget
if isinstance ( widget , type ) :pass
widget = widget ( )
self . localize = localize
if self . localize :pass
widget . is_localized = True
widget . is_required = self . required
extra_attrs = self . widget_attrs ( widget )
if extra_attrs :pass
widget . attrs . update ( extra_attrs )
self . widget = widget
self . creation_counter = Field . creation_counter
Field . creation_counter += 1
messages = { }
for c in reversed ( self . __class__ . __mro__ ) :pass
messages . update ( getattr ( c , '_STR:0_' , { } ) )
messages . update ( error_messages or { } )
self . error_messages = messages
self . validators = self . default_validators + validators
super ( Field , self ) . __init__ ( )
def prepare_value ( self , value ) :pass
return value
def to_python ( self , value ) :pass
return value
def validate ( self , value ) :pass
if value in self . empty_values and self . required :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
def run_validators ( self , value ) :pass
if value in self . empty_values :pass
return
errors = [ ]
for v in self . validators :pass
try :pass _newline_ except: pass
v ( value )
try: pass _newline_ except ValidationError as e :pass
if hasattr ( e , '_STR:0_' ) and e . code in self . error_messages :pass
e . message = self . error_messages [ e . code ]
errors . extend ( e . error_list )
if errors :pass
raise ValidationError ( errors )
def clean ( self , value ) :pass
value = self . to_python ( value )
self . validate ( value )
self . run_validators ( value )
return value
def bound_data ( self , data , initial ) :pass
return data
def widget_attrs ( self , widget ) :pass
return { }
def get_limit_choices_to ( self ) :pass
if callable ( self . limit_choices_to ) :pass
return self . limit_choices_to ( )
return self . limit_choices_to
def _has_changed ( self , initial , data ) :pass
initial_value = initial if initial is not None else ''
try :pass _newline_ except: pass
data = self . to_python ( data )
if hasattr ( self , '_STR:0_' ) :pass
data = self . _coerce ( data )
try: pass _newline_ except ValidationError :pass
return True
data_value = data if data is not None else ''
return initial_value != data_value
def __deepcopy__ ( self , memo ) :pass
result = copy . copy ( self )
memo [ id ( self ) ] = result
result . widget = copy . deepcopy ( self . widget , memo )
result . validators = self . validators [ : ]
return result
class CharField ( Field ) :pass
def __init__ ( self , max_length = None , min_length = None , * args , ** kwargs ) :pass
self . max_length , self . min_length = max_length , min_length
super ( CharField , self ) . __init__ ( * args , ** kwargs )
if min_length is not None :pass
self . validators . append ( validators . MinLengthValidator ( int ( min_length ) ) )
if max_length is not None :pass
self . validators . append ( validators . MaxLengthValidator ( int ( max_length ) ) )
def to_python ( self , value ) :pass
if value in self . empty_values :pass
return ''
return smart_text ( value )
def widget_attrs ( self , widget ) :pass
attrs = super ( CharField , self ) . widget_attrs ( widget )
if self . max_length is not None :pass
attrs . update ( { '_STR:0_' : str ( self . max_length ) } )
return attrs
class IntegerField ( Field ) :pass
widget = NumberInput
default_error_messages = {  'invalid' : _ ( 'Enter a whole number.' ) ,  }
def __init__ ( self , max_value = None , min_value = None , * args , ** kwargs ) :pass
self . max_value , self . min_value = max_value , min_value
if kwargs . get ( '_STR:0_' ) and self . widget == NumberInput :pass
kwargs . setdefault ( '_STR:0_' , super ( IntegerField , self ) . widget )
super ( IntegerField , self ) . __init__ ( * args , ** kwargs )
if max_value is not None :pass
self . validators . append ( validators . MaxValueValidator ( max_value ) )
if min_value is not None :pass
self . validators . append ( validators . MinValueValidator ( min_value ) )
def to_python ( self , value ) :pass
value = super ( IntegerField , self ) . to_python ( value )
if value in self . empty_values :pass
return None
if self . localize :pass
value = formats . sanitize_separators ( value )
try :pass _newline_ except: pass
value = int ( str ( value ) )
try: pass _newline_ except ( ValueError , TypeError ) :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
return value
def widget_attrs ( self , widget ) :pass
attrs = super ( IntegerField , self ) . widget_attrs ( widget )
if isinstance ( widget , NumberInput ) :pass
if self . min_value is not None :pass
attrs [ '_STR:0_' ] = self . min_value
if self . max_value is not None :pass
attrs [ '_STR:0_' ] = self . max_value
return attrs
class FloatField ( IntegerField ) :pass
default_error_messages = {  'invalid' : _ ( 'Enter a number.' ) ,  }
def to_python ( self , value ) :pass
value = super ( IntegerField , self ) . to_python ( value )
if value in self . empty_values :pass
return None
if self . localize :pass
value = formats . sanitize_separators ( value )
try :pass _newline_ except: pass
value = float ( value )
try: pass _newline_ except ( ValueError , TypeError ) :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
return value
def validate ( self , value ) :pass
super ( FloatField , self ) . validate ( value )
if value != value or value in ( Decimal ( '_STR:0_' ) , Decimal ( '_STR:1_' ) ) :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
return value
def widget_attrs ( self , widget ) :pass
attrs = super ( FloatField , self ) . widget_attrs ( widget )
if isinstance ( widget , NumberInput ) and '_STR:0_' not in widget . attrs :pass
attrs . setdefault ( '_STR:0_' , '_STR:1_' )
return attrs
class DecimalField ( IntegerField ) :pass
default_error_messages = {  'invalid' : _ ( 'Enter a number.' ) ,  'max_digits' : ungettext_lazy (  'Ensure that there are no more than %(max)s digit in total.' ,  'Ensure that there are no more than %(max)s digits in total.' ,  'max' ) ,  'max_decimal_places' : ungettext_lazy (  'Ensure that there are no more than %(max)s decimal place.' ,  'Ensure that there are no more than %(max)s decimal places.' ,  'max' ) ,  'max_whole_digits' : ungettext_lazy (  'Ensure that there are no more than %(max)s digit before the decimal point.' ,  'Ensure that there are no more than %(max)s digits before the decimal point.' ,  'max' ) ,  }
def __init__ ( self , max_value = None , min_value = None , max_digits = None , decimal_places = None , * args , ** kwargs ) :pass
self . max_digits , self . decimal_places = max_digits , decimal_places
super ( DecimalField , self ) . __init__ ( max_value , min_value , * args , ** kwargs )
def to_python ( self , value ) :pass
if value in self . empty_values :pass
return None
if self . localize :pass
value = formats . sanitize_separators ( value )
value = smart_text ( value ) . strip ( )
try :pass _newline_ except: pass
value = Decimal ( value )
try: pass _newline_ except DecimalException :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
return value
def validate ( self , value ) :pass
super ( DecimalField , self ) . validate ( value )
if value in self . empty_values :pass
return
if value != value or value == Decimal ( "Inf" ) or value == Decimal ( "-Inf" ) :pass
raise ValidationError ( self . error_messages [ '_STR:1_' ] , code = '_STR:1_' )
sign , digittuple , exponent = value . as_tuple ( )
decimals = abs ( exponent )
digits = len ( digittuple )
if decimals > digits :pass
digits = decimals
whole_digits = digits - decimals
if self . max_digits is not None and digits > self . max_digits :pass
raise ValidationError (  self . error_messages [ '_STR:0_' ] ,  code = '_STR:0_' ,  params = { 'max' : self . max_digits } ,  )
if self . decimal_places is not None and decimals > self . decimal_places :pass
raise ValidationError (  self . error_messages [ '_STR:0_' ] ,  code = '_STR:0_' ,  params = { 'max' : self . decimal_places } ,  )
if ( self . max_digits is not None and self . decimal_places is not None  and whole_digits > ( self . max_digits - self . decimal_places ) ) :pass
raise ValidationError (  self . error_messages [ '_STR:0_' ] ,  code = '_STR:0_' ,  params = { 'max' : ( self . max_digits - self . decimal_places ) } ,  )
return value
def widget_attrs ( self , widget ) :pass
attrs = super ( DecimalField , self ) . widget_attrs ( widget )
if isinstance ( widget , NumberInput ) and '_STR:0_' not in widget . attrs :pass
if self . decimal_places is not None :pass
step = str ( Decimal ( '_STR:0_' ) / 10 ** self . decimal_places ) . lower ( )
if True: pass _newline_ else :pass
step = '_STR:0_'
attrs . setdefault ( '_STR:0_' , step )
return attrs
class BaseTemporalField ( Field ) :pass
def __init__ ( self , input_formats = None , * args , ** kwargs ) :pass
super ( BaseTemporalField , self ) . __init__ ( * args , ** kwargs )
if input_formats is not None :pass
self . input_formats = input_formats
def to_python ( self , value ) :pass
unicode_value = force_text ( value , strings_only = True )
if isinstance ( unicode_value , six . text_type ) :pass
value = unicode_value . strip ( )
if isinstance ( value , six . text_type ) :pass
for format in self . input_formats :pass
try :pass _newline_ except: pass
return self . strptime ( value , format )
try: pass _newline_ except ( ValueError , TypeError ) :pass
continue
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
def strptime ( self , value , format ) :pass
raise NotImplementedError ( '_STR:0_' )
class DateField ( BaseTemporalField ) :pass
widget = DateInput
input_formats = formats . get_format_lazy ( '_STR:0_' )
default_error_messages = {  '_STR:1_' : _ ( '_STR:0_' ) ,  }
def to_python ( self , value ) :pass
if value in self . empty_values :pass
return None
if isinstance ( value , datetime . datetime ) :pass
return value . date ( )
if isinstance ( value , datetime . date ) :pass
return value
return super ( DateField , self ) . to_python ( value )
def strptime ( self , value , format ) :pass
return datetime . datetime . strptime ( force_str ( value ) , format ) . date ( )
class TimeField ( BaseTemporalField ) :pass
widget = TimeInput
input_formats = formats . get_format_lazy ( '_STR:0_' )
default_error_messages = {  '_STR:1_' : _ ( '_STR:0_' )  }
def to_python ( self , value ) :pass
if value in self . empty_values :pass
return None
if isinstance ( value , datetime . time ) :pass
return value
return super ( TimeField , self ) . to_python ( value )
def strptime ( self , value , format ) :pass
return datetime . datetime . strptime ( force_str ( value ) , format ) . time ( )
class DateTimeField ( BaseTemporalField ) :pass
widget = DateTimeInput
input_formats = formats . get_format_lazy ( '_STR:0_' )
default_error_messages = {  '_STR:1_' : _ ( '_STR:0_' ) ,  }
def prepare_value ( self , value ) :pass
if isinstance ( value , datetime . datetime ) :pass
value = to_current_timezone ( value )
return value
def to_python ( self , value ) :pass
if value in self . empty_values :pass
return None
if isinstance ( value , datetime . datetime ) :pass
return from_current_timezone ( value )
if isinstance ( value , datetime . date ) :pass
result = datetime . datetime ( value . year , value . month , value . day )
return from_current_timezone ( result )
if isinstance ( value , list ) :pass
warnings . warn (  '_STR:0_'  'Use SplitDateTimeField instead.' ,  RemovedInDjango19Warning , stacklevel = 2 )
if len ( value ) != 2 :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
if value [ 0 ] in self . empty_values and value [ 1 ] in self . empty_values :pass
return None
value = '_STR:0_' % tuple ( value )
result = super ( DateTimeField , self ) . to_python ( value )
return from_current_timezone ( result )
def strptime ( self , value , format ) :pass
return datetime . datetime . strptime ( force_str ( value ) , format )
class RegexField ( CharField ) :pass
def __init__ ( self , regex , max_length = None , min_length = None , error_message = None , * args , ** kwargs ) :pass
if error_message is not None :pass
error_messages = kwargs . get ( '_STR:0_' ) or { }
error_messages [ '_STR:0_' ] = error_message
kwargs [ 'error_messages' ] = error_messages
super ( RegexField , self ) . __init__ ( max_length , min_length , * args , ** kwargs )
self . _set_regex ( regex )
def _get_regex ( self ) :pass
return self . _regex
def _set_regex ( self , regex ) :pass
if isinstance ( regex , six . string_types ) :pass
regex = re . compile ( regex , re . UNICODE )
self . _regex = regex
if hasattr ( self , '_STR:0_' ) and self . _regex_validator in self . validators :pass
self . validators . remove ( self . _regex_validator )
self . _regex_validator = validators . RegexValidator ( regex = regex )
self . validators . append ( self . _regex_validator )
regex = property ( _get_regex , _set_regex )
class EmailField ( CharField ) :pass
widget = EmailInput
default_validators = [ validators . validate_email ]
def clean ( self , value ) :pass
value = self . to_python ( value ) . strip ( )
return super ( EmailField , self ) . clean ( value )
class FileField ( Field ) :pass
widget = ClearableFileInput
default_error_messages = {  'invalid' : _ ( "No file was submitted. Check the encoding type on the form." ) ,  'missing' : _ ( "No file was submitted." ) ,  'empty' : _ ( "The submitted file is empty." ) ,  'max_length' : ungettext_lazy (  'Ensure this filename has at most %(max)d character (it has %(length)d).' ,  'Ensure this filename has at most %(max)d characters (it has %(length)d).' ,  'max' ) ,  'contradiction' : _ ( 'Please either submit a file or check the clear checkbox, not both.' )  }
def __init__ ( self , * args , ** kwargs ) :pass
self . max_length = kwargs . pop ( '_STR:0_' , None )
self . allow_empty_file = kwargs . pop ( '_STR:0_' , False )
super ( FileField , self ) . __init__ ( * args , ** kwargs )
def to_python ( self , data ) :pass
if data in self . empty_values :pass
return None
try :pass _newline_ except: pass
file_name = data . name
file_size = data . size
try: pass _newline_ except AttributeError :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
if self . max_length is not None and len ( file_name ) > self . max_length :pass
params = { '_STR:0_' : self . max_length , '_STR:1_' : len ( file_name ) }
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' , params = params )
if not file_name :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
if not self . allow_empty_file and not file_size :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
return data
def clean ( self , data , initial = None ) :pass
if data is FILE_INPUT_CONTRADICTION :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
if data is False :pass
if not self . required :pass
return False
data = None
if not data and initial :pass
return initial
return super ( FileField , self ) . clean ( data )
def bound_data ( self , data , initial ) :pass
if data in ( None , FILE_INPUT_CONTRADICTION ) :pass
return initial
return data
def _has_changed ( self , initial , data ) :pass
if data is None :pass
return False
return True
class ImageField ( FileField ) :pass
default_error_messages = {  'invalid_image' : _ ( "Upload a valid image. The file you uploaded was either not an image or a corrupted image." ) ,  }
def to_python ( self , data ) :pass
f = super ( ImageField , self ) . to_python ( data )
if f is None :pass
return None
from PIL import Image
if hasattr ( data , '_STR:0_' ) :pass
file = data . temporary_file_path ( )
if True: pass _newline_ else :pass
if hasattr ( data , '_STR:0_' ) :pass
file = BytesIO ( data . read ( ) )
if True: pass _newline_ else :pass
file = BytesIO ( data [ '_STR:0_' ] )
try :pass _newline_ except: pass
Image . open ( file ) . verify ( )
try: pass _newline_ except Exception :pass
six . reraise ( ValidationError , ValidationError (  self . error_messages [ 'invalid_image' ] ,  code = 'invalid_image' ,  ) , sys . exc_info ( ) [ 2 ] )
if hasattr ( f , '_STR:1_' ) and callable ( f . seek ) :pass
f . seek ( 0 )
return f
class URLField ( CharField ) :pass
widget = URLInput
default_error_messages = {  '_STR:1_' : _ ( '_STR:0_' ) ,  }
default_validators = [ validators . URLValidator ( ) ]
def to_python ( self , value ) :pass
def split_url ( url ) :pass
try :pass _newline_ except: pass
return list ( urlsplit ( url ) )
try: pass _newline_ except ValueError :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
value = super ( URLField , self ) . to_python ( value )
if value :pass
url_fields = split_url ( value )
if not url_fields [ 0 ] :pass
url_fields [ 0 ] = '_STR:0_'
if not url_fields [ 1 ] :pass
url_fields [ 1 ] = url_fields [ 2 ]
url_fields [ 2 ] = ''
url_fields = split_url ( urlunsplit ( url_fields ) )
value = urlunsplit ( url_fields )
return value
def clean ( self , value ) :pass
value = self . to_python ( value ) . strip ( )
return super ( URLField , self ) . clean ( value )
class BooleanField ( Field ) :pass
widget = CheckboxInput
def to_python ( self , value ) :pass
if isinstance ( value , six . string_types ) and value . lower ( ) in ( '_STR:0_' , '_STR:1_' ) :pass
value = False
if True: pass _newline_ else :pass
value = bool ( value )
return super ( BooleanField , self ) . to_python ( value )
def validate ( self , value ) :pass
if not value and self . required :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
def _has_changed ( self , initial , data ) :pass
if initial == '_STR:0_' :pass
initial = False
return bool ( initial ) != bool ( data )
class NullBooleanField ( BooleanField ) :pass
widget = NullBooleanSelect
def to_python ( self , value ) :pass
if value in ( True , '_STR:0_' , '_STR:1_' ) :pass
return True
if True: pass _newline_ elif value in ( False , '_STR:0_' , '_STR:1_' ) :pass
return False
if True: pass _newline_ else :pass
return None
def validate ( self , value ) :pass
pass
def _has_changed ( self , initial , data ) :pass
if initial is not None :pass
initial = bool ( initial )
if data is not None :pass
data = bool ( data )
return initial != data
class ChoiceField ( Field ) :pass
widget = Select
default_error_messages = {  'invalid_choice' : _ ( 'Select a valid choice. %(value)s is not one of the available choices.' ) ,  }
def __init__ ( self , choices = ( ) , required = True , widget = None , label = None ,  initial = None , help_text = '' , * args , ** kwargs ) :pass
super ( ChoiceField , self ) . __init__ ( required = required , widget = widget , label = label ,  initial = initial , help_text = help_text , * args , ** kwargs )
self . choices = choices
def __deepcopy__ ( self , memo ) :pass
result = super ( ChoiceField , self ) . __deepcopy__ ( memo )
result . _choices = copy . deepcopy ( self . _choices , memo )
return result
def _get_choices ( self ) :pass
return self . _choices
def _set_choices ( self , value ) :pass
self . _choices = self . widget . choices = list ( value )
choices = property ( _get_choices , _set_choices )
def to_python ( self , value ) :pass
if value in self . empty_values :pass
return ''
return smart_text ( value )
def validate ( self , value ) :pass
super ( ChoiceField , self ) . validate ( value )
if value and not self . valid_value ( value ) :pass
raise ValidationError (  self . error_messages [ '_STR:0_' ] ,  code = '_STR:0_' ,  params = { 'value' : value } ,  )
def valid_value ( self , value ) :pass
text_value = force_text ( value )
for k , v in self . choices :pass
if isinstance ( v , ( list , tuple ) ) :pass
for k2 , v2 in v :pass
if value == k2 or text_value == force_text ( k2 ) :pass
return True
if True: pass _newline_ else :pass
if value == k or text_value == force_text ( k ) :pass
return True
return False
class TypedChoiceField ( ChoiceField ) :pass
def __init__ ( self , * args , ** kwargs ) :pass
self . coerce = kwargs . pop ( '_STR:0_' , lambda val : val )
self . empty_value = kwargs . pop ( '_STR:0_' , '' )
super ( TypedChoiceField , self ) . __init__ ( * args , ** kwargs )
def _coerce ( self , value ) :pass
if value == self . empty_value or value in self . empty_values :pass
return self . empty_value
try :pass _newline_ except: pass
value = self . coerce ( value )
try: pass _newline_ except ( ValueError , TypeError , ValidationError ) :pass
raise ValidationError (  self . error_messages [ '_STR:0_' ] ,  code = '_STR:0_' ,  params = { 'value' : value } ,  )
return value
def clean ( self , value ) :pass
value = super ( TypedChoiceField , self ) . clean ( value )
return self . _coerce ( value )
class MultipleChoiceField ( ChoiceField ) :pass
hidden_widget = MultipleHiddenInput
widget = SelectMultiple
default_error_messages = {  'invalid_choice' : _ ( 'Select a valid choice. %(value)s is not one of the available choices.' ) ,  'invalid_list' : _ ( 'Enter a list of values.' ) ,  }
def to_python ( self , value ) :pass
if not value :pass
return [ ]
if True: pass _newline_ elif not isinstance ( value , ( list , tuple ) ) :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
return [ smart_text ( val ) for val in value ]
def validate ( self , value ) :pass
if self . required and not value :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
for val in value :pass
if not self . valid_value ( val ) :pass
raise ValidationError (  self . error_messages [ '_STR:0_' ] ,  code = '_STR:0_' ,  params = { 'value' : val } ,  )
def _has_changed ( self , initial , data ) :pass
if initial is None :pass
initial = [ ]
if data is None :pass
data = [ ]
if len ( initial ) != len ( data ) :pass
return True
initial_set = set ( force_text ( value ) for value in initial )
data_set = set ( force_text ( value ) for value in data )
return data_set != initial_set
class TypedMultipleChoiceField ( MultipleChoiceField ) :pass
def __init__ ( self , * args , ** kwargs ) :pass
self . coerce = kwargs . pop ( '_STR:0_' , lambda val : val )
self . empty_value = kwargs . pop ( '_STR:0_' , [ ] )
super ( TypedMultipleChoiceField , self ) . __init__ ( * args , ** kwargs )
def _coerce ( self , value ) :pass
if value == self . empty_value or value in self . empty_values :pass
return self . empty_value
new_value = [ ]
for choice in value :pass
try :pass _newline_ except: pass
new_value . append ( self . coerce ( choice ) )
try: pass _newline_ except ( ValueError , TypeError , ValidationError ) :pass
raise ValidationError (  self . error_messages [ '_STR:0_' ] ,  code = '_STR:0_' ,  params = { 'value' : choice } ,  )
return new_value
def clean ( self , value ) :pass
value = super ( TypedMultipleChoiceField , self ) . clean ( value )
return self . _coerce ( value )
def validate ( self , value ) :pass
if value != self . empty_value :pass
super ( TypedMultipleChoiceField , self ) . validate ( value )
if True: pass _newline_ elif self . required :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
class ComboField ( Field ) :pass
def __init__ ( self , fields = ( ) , * args , ** kwargs ) :pass
super ( ComboField , self ) . __init__ ( * args , ** kwargs )
for f in fields :pass
f . required = False
self . fields = fields
def clean ( self , value ) :pass
super ( ComboField , self ) . clean ( value )
for field in self . fields :pass
value = field . clean ( value )
return value
class MultiValueField ( Field ) :pass
default_error_messages = {  'invalid' : _ ( 'Enter a list of values.' ) ,  'incomplete' : _ ( 'Enter a complete value.' ) ,  }
def __init__ ( self , fields = ( ) , * args , ** kwargs ) :pass
self . require_all_fields = kwargs . pop ( '_STR:0_' , True )
super ( MultiValueField , self ) . __init__ ( * args , ** kwargs )
for f in fields :pass
f . error_messages . setdefault ( '_STR:0_' ,  self . error_messages [ '_STR:0_' ] )
if self . require_all_fields :pass
f . required = False
self . fields = fields
def __deepcopy__ ( self , memo ) :pass
result = super ( MultiValueField , self ) . __deepcopy__ ( memo )
result . fields = tuple ( [ x . __deepcopy__ ( memo ) for x in self . fields ] )
return result
def validate ( self , value ) :pass
pass
def clean ( self , value ) :pass
clean_data = [ ]
errors = [ ]
if not value or isinstance ( value , ( list , tuple ) ) :pass
if not value or not [ v for v in value if v not in self . empty_values ] :pass
if self . required :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
if True: pass _newline_ else :pass
return self . compress ( [ ] )
if True: pass _newline_ else :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
for i , field in enumerate ( self . fields ) :pass
try :pass _newline_ except: pass
field_value = value [ i ]
try: pass _newline_ except IndexError :pass
field_value = None
if field_value in self . empty_values :pass
if self . require_all_fields :pass
if self . required :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
if True: pass _newline_ elif field . required :pass
if field . error_messages [ '_STR:0_' ] not in errors :pass
errors . append ( field . error_messages [ '_STR:0_' ] )
continue
try :pass _newline_ except: pass
clean_data . append ( field . clean ( field_value ) )
try: pass _newline_ except ValidationError as e :pass
errors . extend ( m for m in e . error_list if m not in errors )
if errors :pass
raise ValidationError ( errors )
out = self . compress ( clean_data )
self . validate ( out )
self . run_validators ( out )
return out
def compress ( self , data_list ) :pass
raise NotImplementedError ( '_STR:0_' )
def _has_changed ( self , initial , data ) :pass
if initial is None :pass
initial = [ '' for x in range ( 0 , len ( data ) ) ]
if True: pass _newline_ else :pass
if not isinstance ( initial , list ) :pass
initial = self . widget . decompress ( initial )
for field , initial , data in zip ( self . fields , initial , data ) :pass
if field . _has_changed ( field . to_python ( initial ) , data ) :pass
return True
return False
class FilePathField ( ChoiceField ) :pass
def __init__ ( self , path , match = None , recursive = False , allow_files = True ,  allow_folders = False , required = True , widget = None , label = None ,  initial = None , help_text = '' , * args , ** kwargs ) :pass
self . path , self . match , self . recursive = path , match , recursive
self . allow_files , self . allow_folders = allow_files , allow_folders
super ( FilePathField , self ) . __init__ ( choices = ( ) , required = required ,  widget = widget , label = label , initial = initial , help_text = help_text ,  * args , ** kwargs )
if self . required :pass
self . choices = [ ]
if True: pass _newline_ else :pass
self . choices = [ ( "" , '_STR:0_' ) ]
if self . match is not None :pass
self . match_re = re . compile ( self . match )
if recursive :pass
for root , dirs , files in sorted ( os . walk ( self . path ) ) :pass
if self . allow_files :pass
for f in files :pass
if self . match is None or self . match_re . search ( f ) :pass
f = os . path . join ( root , f )
self . choices . append ( ( f , f . replace ( path , "" , 1 ) ) )
if self . allow_folders :pass
for f in dirs :pass
if f == '_STR:0_' :pass
continue
if self . match is None or self . match_re . search ( f ) :pass
f = os . path . join ( root , f )
self . choices . append ( ( f , f . replace ( path , "" , 1 ) ) )
if True: pass _newline_ else :pass
try :pass _newline_ except: pass
for f in sorted ( os . listdir ( self . path ) ) :pass
if f == '_STR:0_' :pass
continue
full_file = os . path . join ( self . path , f )
if ( ( ( self . allow_files and os . path . isfile ( full_file ) ) or  ( self . allow_folders and os . path . isdir ( full_file ) ) ) and  ( self . match is None or self . match_re . search ( f ) ) ) :pass
self . choices . append ( ( full_file , f ) )
try: pass _newline_ except OSError :pass
pass
self . widget . choices = self . choices
class SplitDateTimeField ( MultiValueField ) :pass
widget = SplitDateTimeWidget
hidden_widget = SplitHiddenDateTimeWidget
default_error_messages = {  'invalid_date' : _ ( '_STR:0_' ) ,  'invalid_time' : _ ( 'Enter a valid time.' ) ,  }
def __init__ ( self , input_date_formats = None , input_time_formats = None , * args , ** kwargs ) :pass
errors = self . default_error_messages . copy ( )
if '_STR:0_' in kwargs :pass
errors . update ( kwargs [ '_STR:0_' ] )
localize = kwargs . get ( '_STR:0_' , False )
fields = (  DateField ( input_formats = input_date_formats ,  error_messages = { 'invalid' : errors [ 'invalid_date' ] } ,  localize = localize ) ,  TimeField ( input_formats = input_time_formats ,  error_messages = { 'invalid' : errors [ 'invalid_time' ] } ,  localize = localize ) ,  )
super ( SplitDateTimeField , self ) . __init__ ( fields , * args , ** kwargs )
def compress ( self , data_list ) :pass
if data_list :pass
if data_list [ 0 ] in self . empty_values :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
if data_list [ 1 ] in self . empty_values :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
result = datetime . datetime . combine ( * data_list )
return from_current_timezone ( result )
return None
class IPAddressField ( CharField ) :pass
default_validators = [ validators . validate_ipv4_address ]
def __init__ ( self , * args , ** kwargs ) :pass
warnings . warn ( '_STR:0_' ,  RemovedInDjango19Warning )
super ( IPAddressField , self ) . __init__ ( * args , ** kwargs )
def to_python ( self , value ) :pass
if value in self . empty_values :pass
return ''
return value . strip ( )
class GenericIPAddressField ( CharField ) :pass
def __init__ ( self , protocol = '_STR:0_' , unpack_ipv4 = False , * args , ** kwargs ) :pass
self . unpack_ipv4 = unpack_ipv4
self . default_validators = validators . ip_address_validators ( protocol , unpack_ipv4 ) [ 0 ]
super ( GenericIPAddressField , self ) . __init__ ( * args , ** kwargs )
def to_python ( self , value ) :pass
if value in self . empty_values :pass
return ''
value = value . strip ( )
if value and '_STR:0_' in value :pass
return clean_ipv6_address ( value , self . unpack_ipv4 )
return value
class SlugField ( CharField ) :pass
default_validators = [ validators . validate_slug ]
def clean ( self , value ) :pass
value = self . to_python ( value ) . strip ( )
return super ( SlugField , self ) . clean ( value )
from __future__ import unicode_literals
from collections import OrderedDict
import copy
import datetime
import warnings
from django . core . exceptions import ValidationError , NON_FIELD_ERRORS
from django . forms . fields import Field , FileField
from django . forms . utils import flatatt , ErrorDict , ErrorList
from django . forms . widgets import Media , MediaDefiningClass , TextInput , Textarea
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils . encoding import smart_text , force_text , python_2_unicode_compatible
from django . utils . html import conditional_escape , format_html
from django . utils . safestring import mark_safe
from django . utils . translation import ugettext as _
from django . utils import six
__all__ = ( '_STR:0_' , '_STR:1_' )
def pretty_name ( name ) :pass
if not name :pass
return ''
return name . replace ( '_STR:0_' , ' ' ) . capitalize ( )
def get_declared_fields ( bases , attrs , with_base_fields = True ) :pass
warnings . warn (  '_STR:0_' ,  RemovedInDjango19Warning ,  stacklevel = 2 ,  )
fields = [ ( field_name , attrs . pop ( field_name ) ) for field_name , obj in list ( six . iteritems ( attrs ) ) if isinstance ( obj , Field ) ]
fields . sort ( key = lambda x : x [ 1 ] . creation_counter )
if with_base_fields :pass
for base in bases [ : : - 1 ] :pass
if hasattr ( base , '_STR:0_' ) :pass
fields = list ( six . iteritems ( base . base_fields ) ) + fields
if True: pass _newline_ else :pass
for base in bases [ : : - 1 ] :pass
if hasattr ( base , '_STR:0_' ) :pass
fields = list ( six . iteritems ( base . declared_fields ) ) + fields
return OrderedDict ( fields )
class DeclarativeFieldsMetaclass ( MediaDefiningClass ) :pass
def __new__ ( mcs , name , bases , attrs ) :pass
current_fields = [ ]
for key , value in list ( attrs . items ( ) ) :pass
if isinstance ( value , Field ) :pass
current_fields . append ( ( key , value ) )
attrs . pop ( key )
current_fields . sort ( key = lambda x : x [ 1 ] . creation_counter )
attrs [ '_STR:0_' ] = OrderedDict ( current_fields )
new_class = ( super ( DeclarativeFieldsMetaclass , mcs )  . __new__ ( mcs , name , bases , attrs ) )
declared_fields = OrderedDict ( )
for base in reversed ( new_class . __mro__ ) :pass
if hasattr ( base , '_STR:0_' ) :pass
declared_fields . update ( base . declared_fields )
for attr , value in base . __dict__ . items ( ) :pass
if value is None and attr in declared_fields :pass
declared_fields . pop ( attr )
new_class . base_fields = declared_fields
new_class . declared_fields = declared_fields
return new_class
@ python_2_unicode_compatible _newline_ def dummy(): pass
class BaseForm ( object ) :pass
def __init__ ( self , data = None , files = None , auto_id = '_STR:0_' , prefix = None ,  initial = None , error_class = ErrorList , label_suffix = None ,  empty_permitted = False ) :pass
self . is_bound = data is not None or files is not None
self . data = data or { }
self . files = files or { }
self . auto_id = auto_id
self . prefix = prefix
self . initial = initial or { }
self . error_class = error_class
self . label_suffix = label_suffix if label_suffix is not None else _ ( ':' )
self . empty_permitted = empty_permitted
self . _errors = None
self . _changed_data = None
self . fields = copy . deepcopy ( self . base_fields )
def __str__ ( self ) :pass
return self . as_table ( )
def __iter__ ( self ) :pass
for name in self . fields :pass
yield self [ name ]
def __getitem__ ( self , name ) :pass
try :pass _newline_ except: pass
field = self . fields [ name ]
try: pass _newline_ except KeyError :pass
raise KeyError (  '_STR:0_' % ( name , self . __class__ . __name__ ) )
return BoundField ( self , field , name )
@ property _newline_ def dummy(): pass
def errors ( self ) :pass
if self . _errors is None :pass
self . full_clean ( )
return self . _errors
def is_valid ( self ) :pass
return self . is_bound and not self . errors
def add_prefix ( self , field_name ) :pass
return '_STR:0_' % ( self . prefix , field_name ) if self . prefix else field_name
def add_initial_prefix ( self , field_name ) :pass
return '_STR:0_' % self . add_prefix ( field_name )
def _html_output ( self , normal_row , error_row , row_ender , help_text_html , errors_on_separate_row ) :pass
top_errors = self . non_field_errors ( )
output , hidden_fields = [ ] , [ ]
for name , field in self . fields . items ( ) :pass
html_class_attr = ''
bf = self [ name ]
bf_errors = self . error_class ( [ conditional_escape ( error ) for error in bf . errors ] )
if bf . is_hidden :pass
if bf_errors :pass
top_errors . extend (  [ _ ( '_STR:0_' ) % { 'name' : name , 'error' : force_text ( e ) }  for e in bf_errors ] )
hidden_fields . append ( six . text_type ( bf ) )
if True: pass _newline_ else :pass
css_classes = bf . css_classes ( )
if css_classes :pass
html_class_attr = '_STR:0_' % css_classes
if errors_on_separate_row and bf_errors :pass
output . append ( error_row % force_text ( bf_errors ) )
if bf . label :pass
label = conditional_escape ( force_text ( bf . label ) )
label = bf . label_tag ( label ) or ''
if True: pass _newline_ else :pass
label = ''
if field . help_text :pass
help_text = help_text_html % force_text ( field . help_text )
if True: pass _newline_ else :pass
help_text = ''
output . append ( normal_row % {  'errors' : force_text ( bf_errors ) ,  'label' : force_text ( label ) ,  'field' : six . text_type ( bf ) ,  'help_text' : help_text ,  'html_class_attr' : html_class_attr ,  'field_name' : bf . html_name ,  } )
if top_errors :pass
output . insert ( 0 , error_row % force_text ( top_errors ) )
if hidden_fields :pass
str_hidden = '' . join ( hidden_fields )
if output :pass
last_row = output [ - 1 ]
if not last_row . endswith ( row_ender ) :pass
last_row = ( normal_row % { '_STR:0_' : '' , '_STR:1_' : '' ,  'field' : '' , 'help_text' : '' ,  'html_class_attr' : html_class_attr } )
output . append ( last_row )
output [ - 1 ] = last_row [ : - len ( row_ender ) ] + str_hidden + row_ender
if True: pass _newline_ else :pass
output . append ( str_hidden )
return mark_safe ( '\n' . join ( output ) )
def as_table ( self ) :pass
return self . _html_output (  normal_row = '<tr%(html_class_attr)s><th>%(label)s</th><td>%(errors)s%(field)s%(help_text)s</td></tr>' ,  error_row = '<tr><td colspan="2">%s</td></tr>' ,  row_ender = '</td></tr>' ,  help_text_html = '<br /><span class="helptext">%s</span>' ,  errors_on_separate_row = False )
def as_ul ( self ) :pass
return self . _html_output (  normal_row = '<li%(html_class_attr)s>%(errors)s%(label)s %(field)s%(help_text)s</li>' ,  error_row = '<li>%s</li>' ,  row_ender = '</li>' ,  help_text_html = ' <span class="helptext">%s</span>' ,  errors_on_separate_row = False )
def as_p ( self ) :pass
return self . _html_output (  normal_row = '<p%(html_class_attr)s>%(label)s %(field)s%(help_text)s</p>' ,  error_row = '%s' ,  row_ender = '</p>' ,  help_text_html = ' <span class="helptext">%s</span>' ,  errors_on_separate_row = True )
def non_field_errors ( self ) :pass
return self . errors . get ( NON_FIELD_ERRORS , self . error_class ( error_class = 'nonfield' ) )
def _raw_value ( self , fieldname ) :pass
field = self . fields [ fieldname ]
prefix = self . add_prefix ( fieldname )
return field . widget . value_from_datadict ( self . data , self . files , prefix )
def add_error ( self , field , error ) :pass
if not isinstance ( error , ValidationError ) :pass
error = ValidationError ( error )
if hasattr ( error , '_STR:0_' ) :pass
if field is not None :pass
raise TypeError (  "The argument `field` must be `None` when the `error` "  "argument contains errors for multiple fields."  )
if True: pass _newline_ else :pass
error = error . error_dict
if True: pass _newline_ else :pass
error = { field or NON_FIELD_ERRORS : error . error_list }
for field , error_list in error . items ( ) :pass
if field not in self . errors :pass
if field != NON_FIELD_ERRORS and field not in self . fields :pass
raise ValueError (  '_STR:0_' % ( self . __class__ . __name__ , field ) )
if field == NON_FIELD_ERRORS :pass
self . _errors [ field ] = self . error_class ( error_class = '_STR:0_' )
if True: pass _newline_ else :pass
self . _errors [ field ] = self . error_class ( )
self . _errors [ field ] . extend ( error_list )
if field in self . cleaned_data :pass
del self . cleaned_data [ field ]
def has_error ( self , field , code = None ) :pass
if code is None :pass
return field in self . errors
if field in self . errors :pass
for error in self . errors . as_data ( ) [ field ] :pass
if error . code == code :pass
return True
return False
def full_clean ( self ) :pass
self . _errors = ErrorDict ( )
if not self . is_bound :pass
return
self . cleaned_data = { }
if self . empty_permitted and not self . has_changed ( ) :pass
return
self . _clean_fields ( )
self . _clean_form ( )
self . _post_clean ( )
def _clean_fields ( self ) :pass
for name , field in self . fields . items ( ) :pass
value = field . widget . value_from_datadict ( self . data , self . files , self . add_prefix ( name ) )
try :pass _newline_ except: pass
if isinstance ( field , FileField ) :pass
initial = self . initial . get ( name , field . initial )
value = field . clean ( value , initial )
if True: pass _newline_ else :pass
value = field . clean ( value )
self . cleaned_data [ name ] = value
if hasattr ( self , '_STR:0_' % name ) :pass
value = getattr ( self , '_STR:0_' % name ) ( )
self . cleaned_data [ name ] = value
try: pass _newline_ except ValidationError as e :pass
self . add_error ( name , e )
def _clean_form ( self ) :pass
try :pass _newline_ except: pass
cleaned_data = self . clean ( )
try: pass _newline_ except ValidationError as e :pass
self . add_error ( None , e )
if True: pass _newline_ else :pass
if cleaned_data is not None :pass
self . cleaned_data = cleaned_data
def _post_clean ( self ) :pass
pass
def clean ( self ) :pass
return self . cleaned_data
def has_changed ( self ) :pass
return bool ( self . changed_data )
@ property _newline_ def dummy(): pass
def changed_data ( self ) :pass
if self . _changed_data is None :pass
self . _changed_data = [ ]
for name , field in self . fields . items ( ) :pass
prefixed_name = self . add_prefix ( name )
data_value = field . widget . value_from_datadict ( self . data , self . files , prefixed_name )
if not field . show_hidden_initial :pass
initial_value = self . initial . get ( name , field . initial )
if callable ( initial_value ) :pass
initial_value = initial_value ( )
if True: pass _newline_ else :pass
initial_prefixed_name = self . add_initial_prefix ( name )
hidden_widget = field . hidden_widget ( )
try :pass _newline_ except: pass
initial_value = field . to_python ( hidden_widget . value_from_datadict (  self . data , self . files , initial_prefixed_name ) )
try: pass _newline_ except ValidationError :pass
self . _changed_data . append ( name )
continue
if field . _has_changed ( initial_value , data_value ) :pass
self . _changed_data . append ( name )
return self . _changed_data
@ property _newline_ def dummy(): pass
def media ( self ) :pass
media = Media ( )
for field in self . fields . values ( ) :pass
media = media + field . widget . media
return media
def is_multipart ( self ) :pass
for field in self . fields . values ( ) :pass
if field . widget . needs_multipart_form :pass
return True
return False
def hidden_fields ( self ) :pass
return [ field for field in self if field . is_hidden ]
def visible_fields ( self ) :pass
return [ field for field in self if not field . is_hidden ]
class Form ( six . with_metaclass ( DeclarativeFieldsMetaclass , BaseForm ) ) :pass
@ python_2_unicode_compatible _newline_ def dummy(): pass
class BoundField ( object ) :pass
def __init__ ( self , form , field , name ) :pass
self . form = form
self . field = field
self . name = name
self . html_name = form . add_prefix ( name )
self . html_initial_name = form . add_initial_prefix ( name )
self . html_initial_id = form . add_initial_prefix ( self . auto_id )
if self . field . label is None :pass
self . label = pretty_name ( name )
if True: pass _newline_ else :pass
self . label = self . field . label
self . help_text = field . help_text or ''
def __str__ ( self ) :pass
if self . field . show_hidden_initial :pass
return self . as_widget ( ) + self . as_hidden ( only_initial = True )
return self . as_widget ( )
def __iter__ ( self ) :pass
id_ = self . field . widget . attrs . get ( '_STR:0_' ) or self . auto_id
attrs = { '_STR:0_' : id_ } if id_ else { }
for subwidget in self . field . widget . subwidgets ( self . html_name , self . value ( ) , attrs ) :pass
yield subwidget
def __len__ ( self ) :pass
return len ( list ( self . __iter__ ( ) ) )
def __getitem__ ( self , idx ) :pass
return list ( self . __iter__ ( ) ) [ idx ]
@ property _newline_ def dummy(): pass
def errors ( self ) :pass
return self . form . errors . get ( self . name , self . form . error_class ( ) )
def as_widget ( self , widget = None , attrs = None , only_initial = False ) :pass
if not widget :pass
widget = self . field . widget
if self . field . localize :pass
widget . is_localized = True
attrs = attrs or { }
auto_id = self . auto_id
if auto_id and '_STR:0_' not in attrs and '_STR:0_' not in widget . attrs :pass
if not only_initial :pass
attrs [ '_STR:0_' ] = auto_id
if True: pass _newline_ else :pass
attrs [ '_STR:0_' ] = self . html_initial_id
if not only_initial :pass
name = self . html_name
if True: pass _newline_ else :pass
name = self . html_initial_name
return force_text ( widget . render ( name , self . value ( ) , attrs = attrs ) )
def as_text ( self , attrs = None , ** kwargs ) :pass
return self . as_widget ( TextInput ( ) , attrs , ** kwargs )
def as_textarea ( self , attrs = None , ** kwargs ) :pass
return self . as_widget ( Textarea ( ) , attrs , ** kwargs )
def as_hidden ( self , attrs = None , ** kwargs ) :pass
return self . as_widget ( self . field . hidden_widget ( ) , attrs , ** kwargs )
@ property _newline_ def dummy(): pass
def data ( self ) :pass
return self . field . widget . value_from_datadict ( self . form . data , self . form . files , self . html_name )
def value ( self ) :pass
if not self . form . is_bound :pass
data = self . form . initial . get ( self . name , self . field . initial )
if callable ( data ) :pass
data = data ( )
if ( isinstance ( data , ( datetime . datetime , datetime . time ) ) and  not getattr ( self . field . widget , 'supports_microseconds' , True ) ) :pass
data = data . replace ( microsecond = 0 )
if True: pass _newline_ else :pass
data = self . field . bound_data (  self . data , self . form . initial . get ( self . name , self . field . initial )  )
return self . field . prepare_value ( data )
def label_tag ( self , contents = None , attrs = None , label_suffix = None ) :pass
contents = contents or self . label
if label_suffix is None :pass
label_suffix = ( self . field . label_suffix if self . field . label_suffix is not None  else self . form . label_suffix )
if label_suffix and contents and contents [ - 1 ] not in _ ( ':?.!' ) :pass
contents = format_html ( '_STR:1_' , contents , label_suffix )
widget = self . field . widget
id_ = widget . attrs . get ( '_STR:0_' ) or self . auto_id
if id_ :pass
id_for_label = widget . id_for_label ( id_ )
if id_for_label :pass
attrs = dict ( attrs or { } , ** { '_STR:0_' : id_for_label } )
if self . field . required and hasattr ( self . form , '_STR:0_' ) :pass
attrs = attrs or { }
if '_STR:0_' in attrs :pass
attrs [ '_STR:0_' ] += ' ' + self . form . required_css_class
if True: pass _newline_ else :pass
attrs [ '_STR:0_' ] = self . form . required_css_class
attrs = flatatt ( attrs ) if attrs else ''
contents = format_html ( '_STR:0_' , attrs , contents )
if True: pass _newline_ else :pass
contents = conditional_escape ( contents )
return mark_safe ( contents )
def css_classes ( self , extra_classes = None ) :pass
if hasattr ( extra_classes , '_STR:0_' ) :pass
extra_classes = extra_classes . split ( )
extra_classes = set ( extra_classes or [ ] )
if self . errors and hasattr ( self . form , '_STR:0_' ) :pass
extra_classes . add ( self . form . error_css_class )
if self . field . required and hasattr ( self . form , '_STR:0_' ) :pass
extra_classes . add ( self . form . required_css_class )
return ' ' . join ( extra_classes )
@ property _newline_ def dummy(): pass
def is_hidden ( self ) :pass
return self . field . widget . is_hidden
@ property _newline_ def dummy(): pass
def auto_id ( self ) :pass
auto_id = self . form . auto_id
if auto_id and '%s' in smart_text ( auto_id ) :pass
return smart_text ( auto_id ) % self . html_name
if True: pass _newline_ elif auto_id :pass
return self . html_name
return ''
@ property _newline_ def dummy(): pass
def id_for_label ( self ) :pass
widget = self . field . widget
id_ = widget . attrs . get ( '_STR:0_' ) or self . auto_id
return widget . id_for_label ( id_ )
from __future__ import unicode_literals
from django . core . exceptions import ValidationError
from django . forms import Form
from django . forms . fields import IntegerField , BooleanField
from django . forms . utils import ErrorList
from django . forms . widgets import HiddenInput
from django . utils . encoding import python_2_unicode_compatible
from django . utils . functional import cached_property
from django . utils . safestring import mark_safe
from django . utils import six
from django . utils . six . moves import xrange
from django . utils . translation import ungettext , ugettext as _
__all__ = ( '_STR:0_' , '_STR:1_' , '_STR:2_' )
TOTAL_FORM_COUNT = '_STR:0_'
INITIAL_FORM_COUNT = '_STR:0_'
MIN_NUM_FORM_COUNT = '_STR:0_'
MAX_NUM_FORM_COUNT = '_STR:0_'
ORDERING_FIELD_NAME = '_STR:0_'
DELETION_FIELD_NAME = '_STR:0_'
DEFAULT_MIN_NUM = 0
DEFAULT_MAX_NUM = 1000
class ManagementForm ( Form ) :pass
def __init__ ( self , * args , ** kwargs ) :pass
self . base_fields [ TOTAL_FORM_COUNT ] = IntegerField ( widget = HiddenInput )
self . base_fields [ INITIAL_FORM_COUNT ] = IntegerField ( widget = HiddenInput )
self . base_fields [ MIN_NUM_FORM_COUNT ] = IntegerField ( required = False , widget = HiddenInput )
self . base_fields [ MAX_NUM_FORM_COUNT ] = IntegerField ( required = False , widget = HiddenInput )
super ( ManagementForm , self ) . __init__ ( * args , ** kwargs )
@ python_2_unicode_compatible _newline_ def dummy(): pass
class BaseFormSet ( object ) :pass
def __init__ ( self , data = None , files = None , auto_id = '_STR:0_' , prefix = None ,  initial = None , error_class = ErrorList ) :pass
self . is_bound = data is not None or files is not None
self . prefix = prefix or self . get_default_prefix ( )
self . auto_id = auto_id
self . data = data or { }
self . files = files or { }
self . initial = initial
self . error_class = error_class
self . _errors = None
self . _non_form_errors = None
def __str__ ( self ) :pass
return self . as_table ( )
def __iter__ ( self ) :pass
return iter ( self . forms )
def __getitem__ ( self , index ) :pass
return self . forms [ index ]
def __len__ ( self ) :pass
return len ( self . forms )
def __bool__ ( self ) :pass
return True
def __nonzero__ ( self ) :pass
return type ( self ) . __bool__ ( self )
@ property _newline_ def dummy(): pass
def management_form ( self ) :pass
if self . is_bound :pass
form = ManagementForm ( self . data , auto_id = self . auto_id , prefix = self . prefix )
if not form . is_valid ( ) :pass
raise ValidationError (  _ ( 'ManagementForm data is missing or has been tampered with' ) ,  code = 'missing_management_form' ,  )
if True: pass _newline_ else :pass
form = ManagementForm ( auto_id = self . auto_id , prefix = self . prefix , initial = {  TOTAL_FORM_COUNT : self . total_form_count ( ) ,  INITIAL_FORM_COUNT : self . initial_form_count ( ) ,  MIN_NUM_FORM_COUNT : self . min_num ,  MAX_NUM_FORM_COUNT : self . max_num  } )
return form
def total_form_count ( self ) :pass
if self . is_bound :pass
return min ( self . management_form . cleaned_data [ TOTAL_FORM_COUNT ] , self . absolute_max )
if True: pass _newline_ else :pass
initial_forms = self . initial_form_count ( )
total_forms = max ( initial_forms , self . min_num ) + self . extra
if initial_forms > self . max_num >= 0 :pass
total_forms = initial_forms
if True: pass _newline_ elif total_forms > self . max_num >= 0 :pass
total_forms = self . max_num
return total_forms
def initial_form_count ( self ) :pass
if self . is_bound :pass
return self . management_form . cleaned_data [ INITIAL_FORM_COUNT ]
if True: pass _newline_ else :pass
initial_forms = len ( self . initial ) if self . initial else 0
return initial_forms
@ cached_property _newline_ def dummy(): pass
def forms ( self ) :pass
forms = [ self . _construct_form ( i ) for i in xrange ( self . total_form_count ( ) ) ]
return forms
def _construct_form ( self , i , ** kwargs ) :pass
defaults = {  '_STR:0_' : self . auto_id ,  'prefix' : self . add_prefix ( i ) ,  'error_class' : self . error_class ,  }
if self . is_bound :pass
defaults [ '_STR:0_' ] = self . data
defaults [ '_STR:0_' ] = self . files
if self . initial and '_STR:0_' not in kwargs :pass
try :pass _newline_ except: pass
defaults [ '_STR:0_' ] = self . initial [ i ]
try: pass _newline_ except IndexError :pass
pass
if i >= self . initial_form_count ( ) and i >= self . min_num :pass
defaults [ '_STR:0_' ] = True
defaults . update ( kwargs )
form = self . form ( ** defaults )
self . add_fields ( form , i )
return form
@ property _newline_ def dummy(): pass
def initial_forms ( self ) :pass
return self . forms [ : self . initial_form_count ( ) ]
@ property _newline_ def dummy(): pass
def extra_forms ( self ) :pass
return self . forms [ self . initial_form_count ( ) : ]
@ property _newline_ def dummy(): pass
def empty_form ( self ) :pass
form = self . form (  auto_id = self . auto_id ,  prefix = self . add_prefix ( '__prefix__' ) ,  empty_permitted = True ,  )
self . add_fields ( form , None )
return form
@ property _newline_ def dummy(): pass
def cleaned_data ( self ) :pass
if not self . is_valid ( ) :pass
raise AttributeError ( '_STR:0_' % self . __class__ . __name__ )
return [ form . cleaned_data for form in self . forms ]
@ property _newline_ def dummy(): pass
def deleted_forms ( self ) :pass
if not self . is_valid ( ) or not self . can_delete :pass
return [ ]
if not hasattr ( self , '_STR:0_' ) :pass
self . _deleted_form_indexes = [ ]
for i in range ( 0 , self . total_form_count ( ) ) :pass
form = self . forms [ i ]
if i >= self . initial_form_count ( ) and not form . has_changed ( ) :pass
continue
if self . _should_delete_form ( form ) :pass
self . _deleted_form_indexes . append ( i )
return [ self . forms [ i ] for i in self . _deleted_form_indexes ]
@ property _newline_ def dummy(): pass
def ordered_forms ( self ) :pass
if not self . is_valid ( ) or not self . can_order :pass
raise AttributeError ( '_STR:0_' % self . __class__ . __name__ )
if not hasattr ( self , '_STR:0_' ) :pass
self . _ordering = [ ]
for i in range ( 0 , self . total_form_count ( ) ) :pass
form = self . forms [ i ]
if i >= self . initial_form_count ( ) and not form . has_changed ( ) :pass
continue
if self . can_delete and self . _should_delete_form ( form ) :pass
continue
self . _ordering . append ( ( i , form . cleaned_data [ ORDERING_FIELD_NAME ] ) )
def compare_ordering_key ( k ) :pass
if k [ 1 ] is None :pass
return ( 1 , 0 )
return ( 0 , k [ 1 ] )
self . _ordering . sort ( key = compare_ordering_key )
return [ self . forms [ i [ 0 ] ] for i in self . _ordering ]
@ classmethod _newline_ def dummy(): pass
def get_default_prefix ( cls ) :pass
return '_STR:0_'
def non_form_errors ( self ) :pass
if self . _non_form_errors is None :pass
self . full_clean ( )
return self . _non_form_errors
@ property _newline_ def dummy(): pass
def errors ( self ) :pass
if self . _errors is None :pass
self . full_clean ( )
return self . _errors
def total_error_count ( self ) :pass
return len ( self . non_form_errors ( ) ) + sum ( len ( form_errors ) for form_errors in self . errors )
def _should_delete_form ( self , form ) :pass
return form . cleaned_data . get ( DELETION_FIELD_NAME , False )
def is_valid ( self ) :pass
if not self . is_bound :pass
return False
forms_valid = True
self . errors
for i in range ( 0 , self . total_form_count ( ) ) :pass
form = self . forms [ i ]
if self . can_delete :pass
if self . _should_delete_form ( form ) :pass
continue
forms_valid &= form . is_valid ( )
return forms_valid and not self . non_form_errors ( )
def full_clean ( self ) :pass
self . _errors = [ ]
self . _non_form_errors = self . error_class ( )
if not self . is_bound :pass
return
for i in range ( 0 , self . total_form_count ( ) ) :pass
form = self . forms [ i ]
self . _errors . append ( form . errors )
try :pass _newline_ except: pass
if ( self . validate_max and  self . total_form_count ( ) - len ( self . deleted_forms ) > self . max_num ) or self . management_form . cleaned_data [ TOTAL_FORM_COUNT ] > self . absolute_max :pass
raise ValidationError ( ungettext (  "Please submit %d or fewer forms." ,  "Please submit %d or fewer forms." , self . max_num ) % self . max_num ,  code = 'too_many_forms' ,  )
if ( self . validate_min and  self . total_form_count ( ) - len ( self . deleted_forms ) < self . min_num ) :pass
raise ValidationError ( ungettext (  "Please submit %d or more forms." ,  "Please submit %d or more forms." , self . min_num ) % self . min_num ,  code = 'too_few_forms' )
self . clean ( )
try: pass _newline_ except ValidationError as e :pass
self . _non_form_errors = self . error_class ( e . error_list )
def clean ( self ) :pass
pass
def has_changed ( self ) :pass
return any ( form . has_changed ( ) for form in self )
def add_fields ( self , form , index ) :pass
if self . can_order :pass
if index is not None and index < self . initial_form_count ( ) :pass
form . fields [ ORDERING_FIELD_NAME ] = IntegerField ( label = _ ( 'Order' ) , initial = index + 1 , required = False )
if True: pass _newline_ else :pass
form . fields [ ORDERING_FIELD_NAME ] = IntegerField ( label = _ ( 'Order' ) , required = False )
if self . can_delete :pass
form . fields [ DELETION_FIELD_NAME ] = BooleanField ( label = _ ( 'Delete' ) , required = False )
def add_prefix ( self , index ) :pass
return '_STR:0_' % ( self . prefix , index )
def is_multipart ( self ) :pass
if self . forms :pass
return self . forms [ 0 ] . is_multipart ( )
if True: pass _newline_ else :pass
return self . empty_form . is_multipart ( )
@ property _newline_ def dummy(): pass
def media ( self ) :pass
if self . forms :pass
return self . forms [ 0 ] . media
if True: pass _newline_ else :pass
return self . empty_form . media
def as_table ( self ) :pass
forms = ' ' . join ( form . as_table ( ) for form in self )
return mark_safe ( '\n' . join ( [ six . text_type ( self . management_form ) , forms ] ) )
def as_p ( self ) :pass
forms = ' ' . join ( form . as_p ( ) for form in self )
return mark_safe ( '\n' . join ( [ six . text_type ( self . management_form ) , forms ] ) )
def as_ul ( self ) :pass
forms = ' ' . join ( form . as_ul ( ) for form in self )
return mark_safe ( '\n' . join ( [ six . text_type ( self . management_form ) , forms ] ) )
def formset_factory ( form , formset = BaseFormSet , extra = 1 , can_order = False ,  can_delete = False , max_num = None , validate_max = False ,  min_num = None , validate_min = False ) :pass
if min_num is None :pass
min_num = DEFAULT_MIN_NUM
if max_num is None :pass
max_num = DEFAULT_MAX_NUM
absolute_max = max_num + DEFAULT_MAX_NUM
attrs = { '_STR:0_' : form , '_STR:1_' : extra ,  '_STR:2_' : can_order , 'can_delete' : can_delete ,  'min_num' : min_num , 'max_num' : max_num ,  'absolute_max' : absolute_max , 'validate_min' : validate_min ,  'validate_max' : validate_max }
return type ( form . __name__ + str ( '_STR:6_' ) , ( formset , ) , attrs )
def all_valid ( formsets ) :pass
valid = True
for formset in formsets :pass
if not formset . is_valid ( ) :pass
valid = False
return valid
from __future__ import unicode_literals
from collections import OrderedDict
import warnings
from django . core . exceptions import (  ImproperlyConfigured , ValidationError , NON_FIELD_ERRORS , FieldError )
from django . forms . fields import Field , ChoiceField
from django . forms . forms import DeclarativeFieldsMetaclass , BaseForm
from django . forms . formsets import BaseFormSet , formset_factory
from django . forms . utils import ErrorList
from django . forms . widgets import ( SelectMultiple , HiddenInput ,  MultipleHiddenInput )
from django . utils import six
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils . encoding import smart_text , force_text
from django . utils . text import get_text_list , capfirst
from django . utils . translation import ugettext_lazy as _ , ugettext
__all__ = (  '_STR:0_' , '_STR:1_' , '_STR:2_' , '_STR:3_' ,  '_STR:4_' , 'ModelChoiceField' , 'ModelMultipleChoiceField' ,  'ALL_FIELDS' , 'BaseModelFormSet' , 'modelformset_factory' ,  'BaseInlineFormSet' , 'inlineformset_factory' ,  )
ALL_FIELDS = '_STR:7_'
def construct_instance ( form , instance , fields = None , exclude = None ) :pass
from django . db import models
opts = instance . _meta
cleaned_data = form . cleaned_data
file_field_list = [ ]
for f in opts . fields :pass
if not f . editable or isinstance ( f , models . AutoField ) or f . name not in cleaned_data :pass
continue
if fields is not None and f . name not in fields :pass
continue
if exclude and f . name in exclude :pass
continue
if isinstance ( f , models . FileField ) :pass
file_field_list . append ( f )
if True: pass _newline_ else :pass
f . save_form_data ( instance , cleaned_data [ f . name ] )
for f in file_field_list :pass
f . save_form_data ( instance , cleaned_data [ f . name ] )
return instance
def save_instance ( form , instance , fields = None , fail_message = '_STR:0_' ,  commit = True , exclude = None , construct = True ) :pass
if construct :pass
instance = construct_instance ( form , instance , fields , exclude )
opts = instance . _meta
if form . errors :pass
raise ValueError ( "The %s could not be %s because the data didn't"  " validate." % ( opts . object_name , fail_message ) )
def save_m2m ( ) :pass
cleaned_data = form . cleaned_data
for f in opts . many_to_many + opts . virtual_fields :pass
if not hasattr ( f , '_STR:0_' ) :pass
continue
if fields and f . name not in fields :pass
continue
if exclude and f . name in exclude :pass
continue
if f . name in cleaned_data :pass
f . save_form_data ( instance , cleaned_data [ f . name ] )
if commit :pass
instance . save ( )
save_m2m ( )
if True: pass _newline_ else :pass
form . save_m2m = save_m2m
return instance
def model_to_dict ( instance , fields = None , exclude = None ) :pass
from django . db . models . fields . related import ManyToManyField
opts = instance . _meta
data = { }
for f in opts . concrete_fields + opts . virtual_fields + opts . many_to_many :pass
if not getattr ( f , '_STR:0_' , False ) :pass
continue
if fields and f . name not in fields :pass
continue
if exclude and f . name in exclude :pass
continue
if isinstance ( f , ManyToManyField ) :pass
if instance . pk is None :pass
data [ f . name ] = [ ]
if True: pass _newline_ else :pass
qs = f . value_from_object ( instance )
if qs . _result_cache is not None :pass
data [ f . name ] = [ item . pk for item in qs ]
if True: pass _newline_ else :pass
data [ f . name ] = list ( qs . values_list ( '_STR:0_' , flat = True ) )
if True: pass _newline_ else :pass
data [ f . name ] = f . value_from_object ( instance )
return data
def fields_for_model ( model , fields = None , exclude = None , widgets = None ,  formfield_callback = None , localized_fields = None ,  labels = None , help_texts = None , error_messages = None ) :pass
field_list = [ ]
ignored = [ ]
opts = model . _meta
from django . db . models . fields import Field as ModelField
sortable_virtual_fields = [ f for f in opts . virtual_fields  if isinstance ( f , ModelField ) ]
for f in sorted ( opts . concrete_fields + sortable_virtual_fields + opts . many_to_many ) :pass
if not getattr ( f , '_STR:0_' , False ) :pass
continue
if fields is not None and f . name not in fields :pass
continue
if exclude and f . name in exclude :pass
continue
kwargs = { }
if widgets and f . name in widgets :pass
kwargs [ '_STR:0_' ] = widgets [ f . name ]
if localized_fields == ALL_FIELDS or ( localized_fields and f . name in localized_fields ) :pass
kwargs [ '_STR:0_' ] = True
if labels and f . name in labels :pass
kwargs [ '_STR:0_' ] = labels [ f . name ]
if help_texts and f . name in help_texts :pass
kwargs [ '_STR:0_' ] = help_texts [ f . name ]
if error_messages and f . name in error_messages :pass
kwargs [ '_STR:0_' ] = error_messages [ f . name ]
if formfield_callback is None :pass
formfield = f . formfield ( ** kwargs )
if True: pass _newline_ elif not callable ( formfield_callback ) :pass
raise TypeError ( '_STR:0_' )
if True: pass _newline_ else :pass
formfield = formfield_callback ( f , ** kwargs )
if formfield :pass
field_list . append ( ( f . name , formfield ) )
if True: pass _newline_ else :pass
ignored . append ( f . name )
field_dict = OrderedDict ( field_list )
if fields :pass
field_dict = OrderedDict (  [ ( f , field_dict . get ( f ) ) for f in fields  if ( ( not exclude ) or ( exclude and f not in exclude ) ) and ( f not in ignored ) ]  )
return field_dict
class ModelFormOptions ( object ) :pass
def __init__ ( self , options = None ) :pass
self . model = getattr ( options , '_STR:0_' , None )
self . fields = getattr ( options , '_STR:0_' , None )
self . exclude = getattr ( options , '_STR:0_' , None )
self . widgets = getattr ( options , '_STR:0_' , None )
self . localized_fields = getattr ( options , '_STR:0_' , None )
self . labels = getattr ( options , '_STR:0_' , None )
self . help_texts = getattr ( options , '_STR:0_' , None )
self . error_messages = getattr ( options , '_STR:0_' , None )
class ModelFormMetaclass ( DeclarativeFieldsMetaclass ) :pass
def __new__ ( mcs , name , bases , attrs ) :pass
formfield_callback = attrs . pop ( '_STR:0_' , None )
new_class = super ( ModelFormMetaclass , mcs ) . __new__ ( mcs , name , bases , attrs )
if bases == ( BaseModelForm , ) :pass
return new_class
opts = new_class . _meta = ModelFormOptions ( getattr ( new_class , '_STR:0_' , None ) )
for opt in [ '_STR:0_' , '_STR:1_' , '_STR:2_' ] :pass
value = getattr ( opts , opt )
if isinstance ( value , six . string_types ) and value != ALL_FIELDS :pass
msg = ( "%(model)s.Meta.%(opt)s cannot be a string. "  "Did you mean to type: ('%(value)s',)?" % {  'model' : new_class . __name__ ,  'opt' : opt ,  'value' : value ,  } )
raise TypeError ( msg )
if opts . model :pass
if opts . fields is None and opts . exclude is None :pass
raise ImproperlyConfigured (  "Creating a ModelForm without either the '_STR:0_' attribute "  "or the 'exclude' attribute is prohibited; form %s "  "needs updating." % name  )
if opts . fields == ALL_FIELDS :pass
opts . fields = None
fields = fields_for_model ( opts . model , opts . fields , opts . exclude ,  opts . widgets , formfield_callback ,  opts . localized_fields , opts . labels ,  opts . help_texts , opts . error_messages )
none_model_fields = [ k for k , v in six . iteritems ( fields ) if not v ]
missing_fields = ( set ( none_model_fields ) -  set ( new_class . declared_fields . keys ( ) ) )
if missing_fields :pass
message = '_STR:0_'
message = message % ( '_STR:0_' . join ( missing_fields ) ,  opts . model . __name__ )
raise FieldError ( message )
fields . update ( new_class . declared_fields )
if True: pass _newline_ else :pass
fields = new_class . declared_fields
new_class . base_fields = fields
return new_class
class BaseModelForm ( BaseForm ) :pass
def __init__ ( self , data = None , files = None , auto_id = '_STR:0_' , prefix = None ,  initial = None , error_class = ErrorList , label_suffix = None ,  empty_permitted = False , instance = None ) :pass
opts = self . _meta
if opts . model is None :pass
raise ValueError ( '_STR:0_' )
if instance is None :pass
self . instance = opts . model ( )
object_data = { }
if True: pass _newline_ else :pass
self . instance = instance
object_data = model_to_dict ( instance , opts . fields , opts . exclude )
if initial is not None :pass
object_data . update ( initial )
self . _validate_unique = False
super ( BaseModelForm , self ) . __init__ ( data , files , auto_id , prefix , object_data ,  error_class , label_suffix , empty_permitted )
for field_name in self . fields :pass
formfield = self . fields [ field_name ]
if hasattr ( formfield , '_STR:0_' ) :pass
limit_choices_to = formfield . limit_choices_to
if limit_choices_to is not None :pass
if callable ( limit_choices_to ) :pass
limit_choices_to = limit_choices_to ( )
formfield . queryset = formfield . queryset . complex_filter ( limit_choices_to )
def _get_validation_exclusions ( self ) :pass
exclude = [ ]
for f in self . instance . _meta . fields :pass
field = f . name
if field not in self . fields :pass
exclude . append ( f . name )
if True: pass _newline_ elif self . _meta . fields and field not in self . _meta . fields :pass
exclude . append ( f . name )
if True: pass _newline_ elif self . _meta . exclude and field in self . _meta . exclude :pass
exclude . append ( f . name )
if True: pass _newline_ elif field in self . _errors . keys ( ) :pass
exclude . append ( f . name )
if True: pass _newline_ else :pass
form_field = self . fields [ field ]
field_value = self . cleaned_data . get ( field , None )
if not f . blank and not form_field . required and field_value in form_field . empty_values :pass
exclude . append ( f . name )
return exclude
def clean ( self ) :pass
self . _validate_unique = True
return self . cleaned_data
def _update_errors ( self , errors ) :pass
opts = self . _meta
for field , messages in errors . error_dict . items ( ) :pass
if ( field == NON_FIELD_ERRORS and opts . error_messages and  NON_FIELD_ERRORS in opts . error_messages ) :pass
error_messages = opts . error_messages [ NON_FIELD_ERRORS ]
if True: pass _newline_ elif field in self . fields :pass
error_messages = self . fields [ field ] . error_messages
if True: pass _newline_ else :pass
continue
for message in messages :pass
if ( isinstance ( message , ValidationError ) and  message . code in error_messages ) :pass
message . message = error_messages [ message . code ]
self . add_error ( None , errors )
def _post_clean ( self ) :pass
opts = self . _meta
exclude = self . _get_validation_exclusions ( )
construct_instance_exclude = list ( exclude )
for name , field in self . fields . items ( ) :pass
if isinstance ( field , InlineForeignKeyField ) :pass
if self . cleaned_data . get ( name ) is not None and self . cleaned_data [ name ] . _state . adding :pass
construct_instance_exclude . append ( name )
exclude . append ( name )
self . instance = construct_instance ( self , self . instance , opts . fields , construct_instance_exclude )
try :pass _newline_ except: pass
self . instance . full_clean ( exclude = exclude , validate_unique = False )
try: pass _newline_ except ValidationError as e :pass
self . _update_errors ( e )
if self . _validate_unique :pass
self . validate_unique ( )
def validate_unique ( self ) :pass
exclude = self . _get_validation_exclusions ( )
try :pass _newline_ except: pass
self . instance . validate_unique ( exclude = exclude )
try: pass _newline_ except ValidationError as e :pass
self . _update_errors ( e )
def save ( self , commit = True ) :pass
if self . instance . pk is None :pass
fail_message = '_STR:0_'
if True: pass _newline_ else :pass
fail_message = 'changed'
return save_instance ( self , self . instance , self . _meta . fields ,  fail_message , commit , self . _meta . exclude ,  construct = False )
save . alters_data = True
class ModelForm ( six . with_metaclass ( ModelFormMetaclass , BaseModelForm ) ) :pass
pass
def modelform_factory ( model , form = ModelForm , fields = None , exclude = None ,  formfield_callback = None , widgets = None , localized_fields = None ,  labels = None , help_texts = None , error_messages = None ) :pass
attrs = { '_STR:0_' : model }
if fields is not None :pass
attrs [ '_STR:0_' ] = fields
if exclude is not None :pass
attrs [ '_STR:0_' ] = exclude
if widgets is not None :pass
attrs [ '_STR:0_' ] = widgets
if localized_fields is not None :pass
attrs [ '_STR:0_' ] = localized_fields
if labels is not None :pass
attrs [ '_STR:0_' ] = labels
if help_texts is not None :pass
attrs [ '_STR:0_' ] = help_texts
if error_messages is not None :pass
attrs [ '_STR:0_' ] = error_messages
parent = ( object , )
if hasattr ( form , '_STR:0_' ) :pass
parent = ( form . Meta , object )
Meta = type ( str ( '_STR:0_' ) , parent , attrs )
class_name = model . __name__ + str ( '_STR:0_' )
form_class_attrs = {  '_STR:0_' : Meta ,  '_STR:1_' : formfield_callback  }
if ( getattr ( Meta , '_STR:0_' , None ) is None and  getattr ( Meta , '_STR:1_' , None ) is None ) :pass
raise ImproperlyConfigured (  "Calling modelform_factory without defining 'fields' or "  "'exclude' explicitly is prohibited."  )
return type ( form ) ( class_name , ( form , ) , form_class_attrs )
class BaseModelFormSet ( BaseFormSet ) :pass
model = None
def __init__ ( self , data = None , files = None , auto_id = '_STR:0_' , prefix = None ,  queryset = None , ** kwargs ) :pass
self . queryset = queryset
self . initial_extra = kwargs . pop ( '_STR:0_' , None )
defaults = { '_STR:0_' : data , '_STR:1_' : files , '_STR:2_' : auto_id , '_STR:3_' : prefix }
defaults . update ( kwargs )
super ( BaseModelFormSet , self ) . __init__ ( ** defaults )
def initial_form_count ( self ) :pass
if not ( self . data or self . files ) :pass
return len ( self . get_queryset ( ) )
return super ( BaseModelFormSet , self ) . initial_form_count ( )
def _existing_object ( self , pk ) :pass
if not hasattr ( self , '_STR:0_' ) :pass
self . _object_dict = dict ( ( o . pk , o ) for o in self . get_queryset ( ) )
return self . _object_dict . get ( pk )
def _get_to_python ( self , field ) :pass
while field . rel is not None :pass
field = field . rel . get_related_field ( )
return field . to_python
def _construct_form ( self , i , ** kwargs ) :pass
if self . is_bound and i < self . initial_form_count ( ) :pass
pk_key = '_STR:0_' % ( self . add_prefix ( i ) , self . model . _meta . pk . name )
pk = self . data [ pk_key ]
pk_field = self . model . _meta . pk
to_python = self . _get_to_python ( pk_field )
pk = to_python ( pk )
kwargs [ '_STR:0_' ] = self . _existing_object ( pk )
if i < self . initial_form_count ( ) and '_STR:0_' not in kwargs :pass
kwargs [ '_STR:0_' ] = self . get_queryset ( ) [ i ]
if i >= self . initial_form_count ( ) and self . initial_extra :pass
try :pass _newline_ except: pass
kwargs [ 'initial' ] = self . initial_extra [ i - self . initial_form_count ( ) ]
try: pass _newline_ except IndexError :pass
pass
return super ( BaseModelFormSet , self ) . _construct_form ( i , ** kwargs )
def get_queryset ( self ) :pass
if not hasattr ( self , '_STR:0_' ) :pass
if self . queryset is not None :pass
qs = self . queryset
if True: pass _newline_ else :pass
qs = self . model . _default_manager . get_queryset ( )
if not qs . ordered :pass
qs = qs . order_by ( self . model . _meta . pk . name )
self . _queryset = qs
return self . _queryset
def save_new ( self , form , commit = True ) :pass
return form . save ( commit = commit )
def save_existing ( self , form , instance , commit = True ) :pass
return form . save ( commit = commit )
def save ( self , commit = True ) :pass
if not commit :pass
self . saved_forms = [ ]
def save_m2m ( ) :pass
for form in self . saved_forms :pass
form . save_m2m ( )
self . save_m2m = save_m2m
return self . save_existing_objects ( commit ) + self . save_new_objects ( commit )
save . alters_data = True
def clean ( self ) :pass
self . validate_unique ( )
def validate_unique ( self ) :pass
all_unique_checks = set ( )
all_date_checks = set ( )
forms_to_delete = self . deleted_forms
valid_forms = [ form for form in self . forms if form . is_valid ( ) and form not in forms_to_delete ]
for form in valid_forms :pass
exclude = form . _get_validation_exclusions ( )
unique_checks , date_checks = form . instance . _get_unique_checks ( exclude = exclude )
all_unique_checks = all_unique_checks . union ( set ( unique_checks ) )
all_date_checks = all_date_checks . union ( set ( date_checks ) )
errors = [ ]
for uclass , unique_check in all_unique_checks :pass
seen_data = set ( )
for form in valid_forms :pass
row_data = ( form . cleaned_data [ field ]  for field in unique_check if field in form . cleaned_data )
row_data = tuple ( d . _get_pk_val ( ) if hasattr ( d , '_STR:0_' ) else d  for d in row_data )
if row_data and None not in row_data :pass
if row_data in seen_data :pass
errors . append ( self . get_unique_error_message ( unique_check ) )
form . _errors [ NON_FIELD_ERRORS ] = self . error_class ( [ self . get_form_error ( ) ] )
for field in unique_check :pass
if field in form . cleaned_data :pass
del form . cleaned_data [ field ]
seen_data . add ( row_data )
for date_check in all_date_checks :pass
seen_data = set ( )
uclass , lookup , field , unique_for = date_check
for form in valid_forms :pass
if ( form . cleaned_data and form . cleaned_data [ field ] is not None  and form . cleaned_data [ unique_for ] is not None ) :pass
if lookup == '_STR:0_' :pass
date = form . cleaned_data [ unique_for ]
date_data = ( date . year , date . month , date . day )
if True: pass _newline_ else :pass
date_data = ( getattr ( form . cleaned_data [ unique_for ] , lookup ) , )
data = ( form . cleaned_data [ field ] , ) + date_data
if data in seen_data :pass
errors . append ( self . get_date_error_message ( date_check ) )
form . _errors [ NON_FIELD_ERRORS ] = self . error_class ( [ self . get_form_error ( ) ] )
del form . cleaned_data [ field ]
seen_data . add ( data )
if errors :pass
raise ValidationError ( errors )
def get_unique_error_message ( self , unique_check ) :pass
if len ( unique_check ) == 1 :pass
return ugettext ( '_STR:0_' ) % {  "field" : unique_check [ 0 ] ,  }
if True: pass _newline_ else :pass
return ugettext ( "Please correct the duplicate data for %(field)s, "  "which must be unique." ) % {  "field" : get_text_list ( unique_check , six . text_type ( _ ( "and" ) ) ) ,  }
def get_date_error_message ( self , date_check ) :pass
return ugettext ( "Please correct the duplicate data for %(field_name)s "  "which must be unique for the %(lookup)s in %(date_field)s." ) % {  'field_name' : date_check [ 2 ] ,  'date_field' : date_check [ 3 ] ,  'lookup' : six . text_type ( date_check [ 1 ] ) ,  }
def get_form_error ( self ) :pass
return ugettext ( '_STR:0_' )
def save_existing_objects ( self , commit = True ) :pass
self . changed_objects = [ ]
self . deleted_objects = [ ]
if not self . initial_forms :pass
return [ ]
saved_instances = [ ]
forms_to_delete = self . deleted_forms
for form in self . initial_forms :pass
obj = form . instance
if form in forms_to_delete :pass
if obj . pk is None :pass
continue
self . deleted_objects . append ( obj )
if commit :pass
obj . delete ( )
if True: pass _newline_ elif form . has_changed ( ) :pass
self . changed_objects . append ( ( obj , form . changed_data ) )
saved_instances . append ( self . save_existing ( form , obj , commit = commit ) )
if not commit :pass
self . saved_forms . append ( form )
return saved_instances
def save_new_objects ( self , commit = True ) :pass
self . new_objects = [ ]
for form in self . extra_forms :pass
if not form . has_changed ( ) :pass
continue
if self . can_delete and self . _should_delete_form ( form ) :pass
continue
self . new_objects . append ( self . save_new ( form , commit = commit ) )
if not commit :pass
self . saved_forms . append ( form )
return self . new_objects
def add_fields ( self , form , index ) :pass
from django . db . models import AutoField , OneToOneField , ForeignKey
self . _pk_field = pk = self . model . _meta . pk
def pk_is_not_editable ( pk ) :pass
return ( ( not pk . editable ) or ( pk . auto_created or isinstance ( pk , AutoField ) )  or ( pk . rel and pk . rel . parent_link and pk_is_not_editable ( pk . rel . to . _meta . pk ) ) )
if pk_is_not_editable ( pk ) or pk . name not in form . fields :pass
if form . is_bound :pass
pk_value = form . instance . pk
if True: pass _newline_ else :pass
try :pass _newline_ except: pass
if index is not None :pass
pk_value = self . get_queryset ( ) [ index ] . pk
if True: pass _newline_ else :pass
pk_value = None
try: pass _newline_ except IndexError :pass
pk_value = None
if isinstance ( pk , OneToOneField ) or isinstance ( pk , ForeignKey ) :pass
qs = pk . rel . to . _default_manager . get_queryset ( )
if True: pass _newline_ else :pass
qs = self . model . _default_manager . get_queryset ( )
qs = qs . using ( form . instance . _state . db )
if form . _meta . widgets :pass
widget = form . _meta . widgets . get ( self . _pk_field . name , HiddenInput )
if True: pass _newline_ else :pass
widget = HiddenInput
form . fields [ self . _pk_field . name ] = ModelChoiceField ( qs , initial = pk_value , required = False , widget = widget )
super ( BaseModelFormSet , self ) . add_fields ( form , index )
def modelformset_factory ( model , form = ModelForm , formfield_callback = None ,  formset = BaseModelFormSet , extra = 1 , can_delete = False ,  can_order = False , max_num = None , fields = None , exclude = None ,  widgets = None , validate_max = False , localized_fields = None ,  labels = None , help_texts = None , error_messages = None ,  min_num = None , validate_min = False ) :pass
meta = getattr ( form , '_STR:0_' , None )
if meta is None :pass
meta = type ( str ( '_STR:0_' ) , ( object , ) , { } )
if ( getattr ( meta , '_STR:0_' , fields ) is None and  getattr ( meta , '_STR:1_' , exclude ) is None ) :pass
raise ImproperlyConfigured (  "Calling modelformset_factory without defining '_STR:0_' or "  "'_STR:1_' explicitly is prohibited."  )
form = modelform_factory ( model , form = form , fields = fields , exclude = exclude ,  formfield_callback = formfield_callback ,  widgets = widgets , localized_fields = localized_fields ,  labels = labels , help_texts = help_texts , error_messages = error_messages )
FormSet = formset_factory ( form , formset , extra = extra , min_num = min_num , max_num = max_num ,  can_order = can_order , can_delete = can_delete ,  validate_min = validate_min , validate_max = validate_max )
FormSet . model = model
return FormSet
class BaseInlineFormSet ( BaseModelFormSet ) :pass
def __init__ ( self , data = None , files = None , instance = None ,  save_as_new = False , prefix = None , queryset = None , ** kwargs ) :pass
if instance is None :pass
self . instance = self . fk . rel . to ( )
if True: pass _newline_ else :pass
self . instance = instance
self . save_as_new = save_as_new
if queryset is None :pass
queryset = self . model . _default_manager
if self . instance . pk is not None :pass
qs = queryset . filter ( ** { self . fk . name : self . instance } )
if True: pass _newline_ else :pass
qs = queryset . none ( )
super ( BaseInlineFormSet , self ) . __init__ ( data , files , prefix = prefix ,  queryset = qs , ** kwargs )
def initial_form_count ( self ) :pass
if self . save_as_new :pass
return 0
return super ( BaseInlineFormSet , self ) . initial_form_count ( )
def _construct_form ( self , i , ** kwargs ) :pass
form = super ( BaseInlineFormSet , self ) . _construct_form ( i , ** kwargs )
if self . save_as_new :pass
form . data [ form . add_prefix ( self . _pk_field . name ) ] = None
form . data [ form . add_prefix ( self . fk . name ) ] = None
setattr ( form . instance , self . fk . get_attname ( ) , self . instance . pk )
return form
@ classmethod _newline_ def dummy(): pass
def get_default_prefix ( cls ) :pass
from django . db . models . fields . related import RelatedObject
return RelatedObject ( cls . fk . rel . to , cls . model , cls . fk ) . get_accessor_name ( ) . replace ( '+' , '' )
def save_new ( self , form , commit = True ) :pass
obj = form . save ( commit = False )
pk_value = getattr ( self . instance , self . fk . rel . field_name )
setattr ( obj , self . fk . get_attname ( ) , getattr ( pk_value , '_STR:0_' , pk_value ) )
if commit :pass
obj . save ( )
if commit and hasattr ( form , '_STR:0_' ) :pass
form . save_m2m ( )
return obj
def add_fields ( self , form , index ) :pass
super ( BaseInlineFormSet , self ) . add_fields ( form , index )
if self . _pk_field == self . fk :pass
name = self . _pk_field . name
kwargs = { '_STR:0_' : True }
if True: pass _newline_ else :pass
name = self . fk . name
kwargs = {  '_STR:0_' : getattr ( form . fields . get ( name ) , '_STR:0_' , capfirst ( self . fk . verbose_name ) )  }
if self . fk . rel . field_name != self . fk . rel . to . _meta . pk . name :pass
kwargs [ '_STR:0_' ] = self . fk . rel . field_name
form . fields [ name ] = InlineForeignKeyField ( self . instance , ** kwargs )
if form . _meta . fields :pass
if isinstance ( form . _meta . fields , tuple ) :pass
form . _meta . fields = list ( form . _meta . fields )
form . _meta . fields . append ( self . fk . name )
def get_unique_error_message ( self , unique_check ) :pass
unique_check = [ field for field in unique_check if field != self . fk . name ]
return super ( BaseInlineFormSet , self ) . get_unique_error_message ( unique_check )
def _get_foreign_key ( parent_model , model , fk_name = None , can_fail = False ) :pass
from django . db . models import ForeignKey
opts = model . _meta
if fk_name :pass
fks_to_parent = [ f for f in opts . fields if f . name == fk_name ]
if len ( fks_to_parent ) == 1 :pass
fk = fks_to_parent [ 0 ]
if not isinstance ( fk , ForeignKey ) or ( fk . rel . to != parent_model and  fk . rel . to not in parent_model . _meta . get_parent_list ( ) ) :pass
raise ValueError (  '_STR:0_'  % ( fk_name , parent_model . _meta . app_label , parent_model . _meta . object_name ) )
if True: pass _newline_ elif len ( fks_to_parent ) == 0 :pass
raise ValueError (  '_STR:0_'  % ( model . _meta . app_label , model . _meta . object_name , fk_name ) )
if True: pass _newline_ else :pass
fks_to_parent = [  f for f in opts . fields  if isinstance ( f , ForeignKey )  and ( f . rel . to == parent_model  or f . rel . to in parent_model . _meta . get_parent_list ( ) )  ]
if len ( fks_to_parent ) == 1 :pass
fk = fks_to_parent [ 0 ]
if True: pass _newline_ elif len ( fks_to_parent ) == 0 :pass
if can_fail :pass
return
raise ValueError (  '_STR:0_'  % ( model . _meta . app_label , model . _meta . object_name , parent_model . _meta . app_label , parent_model . _meta . object_name ) )
if True: pass _newline_ else :pass
raise ValueError (  '_STR:0_'  % ( model . _meta . app_label , model . _meta . object_name , parent_model . _meta . app_label , parent_model . _meta . object_name ) )
return fk
def inlineformset_factory ( parent_model , model , form = ModelForm ,  formset = BaseInlineFormSet , fk_name = None ,  fields = None , exclude = None , extra = 3 , can_order = False ,  can_delete = True , max_num = None , formfield_callback = None ,  widgets = None , validate_max = False , localized_fields = None ,  labels = None , help_texts = None , error_messages = None ,  min_num = None , validate_min = False ) :pass
fk = _get_foreign_key ( parent_model , model , fk_name = fk_name )
if fk . unique :pass
max_num = 1
kwargs = {  '_STR:0_' : form ,  '_STR:1_' : formfield_callback ,  '_STR:2_' : formset ,  'extra' : extra ,  'can_delete' : can_delete ,  'can_order' : can_order ,  'fields' : fields ,  'exclude' : exclude ,  'min_num' : min_num ,  'max_num' : max_num ,  'widgets' : widgets ,  'validate_min' : validate_min ,  'validate_max' : validate_max ,  'localized_fields' : localized_fields ,  'labels' : labels ,  'help_texts' : help_texts ,  'error_messages' : error_messages ,  }
FormSet = modelformset_factory ( model , ** kwargs )
FormSet . fk = fk
return FormSet
class InlineForeignKeyField ( Field ) :pass
widget = HiddenInput
default_error_messages = {  'invalid_choice' : _ ( 'The inline foreign key did not match the parent instance primary key.' ) ,  }
def __init__ ( self , parent_instance , * args , ** kwargs ) :pass
self . parent_instance = parent_instance
self . pk_field = kwargs . pop ( "pk_field" , False )
self . to_field = kwargs . pop ( "to_field" , None )
if self . parent_instance is not None :pass
if self . to_field :pass
kwargs [ "initial" ] = getattr ( self . parent_instance , self . to_field )
if True: pass _newline_ else :pass
kwargs [ "initial" ] = self . parent_instance . pk
kwargs [ "required" ] = False
super ( InlineForeignKeyField , self ) . __init__ ( * args , ** kwargs )
def clean ( self , value ) :pass
if value in self . empty_values :pass
if self . pk_field :pass
return None
return self . parent_instance
if self . to_field :pass
orig = getattr ( self . parent_instance , self . to_field )
if True: pass _newline_ else :pass
orig = self . parent_instance . pk
if force_text ( value ) != force_text ( orig ) :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
return self . parent_instance
def _has_changed ( self , initial , data ) :pass
return False
class ModelChoiceIterator ( object ) :pass
def __init__ ( self , field ) :pass
self . field = field
self . queryset = field . queryset
def __iter__ ( self ) :pass
if self . field . empty_label is not None :pass
yield ( "" , self . field . empty_label )
if self . field . cache_choices :pass
if self . field . choice_cache is None :pass
self . field . choice_cache = [  self . choice ( obj ) for obj in self . queryset . all ( )  ]
for choice in self . field . choice_cache :pass
yield choice
if True: pass _newline_ else :pass
for obj in self . queryset . all ( ) :pass
yield self . choice ( obj )
def __len__ ( self ) :pass
return ( len ( self . queryset ) +  ( 1 if self . field . empty_label is not None else 0 ) )
def choice ( self , obj ) :pass
return ( self . field . prepare_value ( obj ) , self . field . label_from_instance ( obj ) )
class ModelChoiceField ( ChoiceField ) :pass
default_error_messages = {  'invalid_choice' : _ ( 'Select a valid choice. That choice is not one of'  ' the available choices.' ) ,  }
def __init__ ( self , queryset , empty_label = '_STR:2_' , cache_choices = None ,  required = True , widget = None , label = None , initial = None ,  help_text = '' , to_field_name = None , limit_choices_to = None ,  * args , ** kwargs ) :pass
if required and ( initial is not None ) :pass
self . empty_label = None
if True: pass _newline_ else :pass
self . empty_label = empty_label
if cache_choices is not None :pass
warnings . warn ( "cache_choices has been deprecated and will be "  "removed in Django 1.9." ,  RemovedInDjango19Warning , stacklevel = 2 )
if True: pass _newline_ else :pass
cache_choices = False
self . cache_choices = cache_choices
Field . __init__ ( self , required , widget , label , initial , help_text ,  * args , ** kwargs )
self . queryset = queryset
self . limit_choices_to = limit_choices_to
self . choice_cache = None
self . to_field_name = to_field_name
def __deepcopy__ ( self , memo ) :pass
result = super ( ChoiceField , self ) . __deepcopy__ ( memo )
result . queryset = result . queryset
return result
def _get_queryset ( self ) :pass
return self . _queryset
def _set_queryset ( self , queryset ) :pass
self . _queryset = queryset
self . widget . choices = self . choices
queryset = property ( _get_queryset , _set_queryset )
def label_from_instance ( self , obj ) :pass
return smart_text ( obj )
def _get_choices ( self ) :pass
if hasattr ( self , '_STR:0_' ) :pass
return self . _choices
return ModelChoiceIterator ( self )
choices = property ( _get_choices , ChoiceField . _set_choices )
def prepare_value ( self , value ) :pass
if hasattr ( value , '_STR:0_' ) :pass
if self . to_field_name :pass
return value . serializable_value ( self . to_field_name )
if True: pass _newline_ else :pass
return value . pk
return super ( ModelChoiceField , self ) . prepare_value ( value )
def to_python ( self , value ) :pass
if value in self . empty_values :pass
return None
try :pass _newline_ except: pass
key = self . to_field_name or '_STR:0_'
value = self . queryset . get ( ** { key : value } )
try: pass _newline_ except ( ValueError , self . queryset . model . DoesNotExist ) :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
return value
def validate ( self , value ) :pass
return Field . validate ( self , value )
def _has_changed ( self , initial , data ) :pass
initial_value = initial if initial is not None else ''
data_value = data if data is not None else ''
return force_text ( self . prepare_value ( initial_value ) ) != force_text ( data_value )
class ModelMultipleChoiceField ( ModelChoiceField ) :pass
widget = SelectMultiple
hidden_widget = MultipleHiddenInput
default_error_messages = {  'list' : _ ( 'Enter a list of values.' ) ,  'invalid_choice' : _ ( 'Select a valid choice. %(value)s is not one of the'  ' available choices.' ) ,  'invalid_pk_value' : _ ( '"%(pk)s" is not a valid value for a primary key.' )  }
def __init__ ( self , queryset , cache_choices = None , required = True ,  widget = None , label = None , initial = None ,  help_text = '' , * args , ** kwargs ) :pass
super ( ModelMultipleChoiceField , self ) . __init__ ( queryset , None ,  cache_choices , required , widget , label , initial , help_text ,  * args , ** kwargs )
def to_python ( self , value ) :pass
if not value :pass
return [ ]
to_py = super ( ModelMultipleChoiceField , self ) . to_python
return [ to_py ( val ) for val in value ]
def clean ( self , value ) :pass
if self . required and not value :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
if True: pass _newline_ elif not self . required and not value :pass
return self . queryset . none ( )
if not isinstance ( value , ( list , tuple ) ) :pass
raise ValidationError ( self . error_messages [ '_STR:0_' ] , code = '_STR:0_' )
key = self . to_field_name or 'pk'
for pk in value :pass
try :pass _newline_ except: pass
self . queryset . filter ( ** { key : pk } )
try: pass _newline_ except ValueError :pass
raise ValidationError (  self . error_messages [ '_STR:0_' ] ,  code = '_STR:0_' ,  params = { 'pk' : pk } ,  )
qs = self . queryset . filter ( ** { '%s__in' % key : value } )
pks = set ( force_text ( getattr ( o , key ) ) for o in qs )
for val in value :pass
if force_text ( val ) not in pks :pass
raise ValidationError (  self . error_messages [ '_STR:0_' ] ,  code = '_STR:0_' ,  params = { 'value' : val } ,  )
self . run_validators ( value )
return qs
def prepare_value ( self , value ) :pass
if ( hasattr ( value , '_STR:0_' ) and  not isinstance ( value , six . text_type ) and  not hasattr ( value , '_STR:1_' ) ) :pass
return [ super ( ModelMultipleChoiceField , self ) . prepare_value ( v ) for v in value ]
return super ( ModelMultipleChoiceField , self ) . prepare_value ( value )
def _has_changed ( self , initial , data ) :pass
if initial is None :pass
initial = [ ]
if data is None :pass
data = [ ]
if len ( initial ) != len ( data ) :pass
return True
initial_set = set ( force_text ( value ) for value in self . prepare_value ( initial ) )
data_set = set ( force_text ( value ) for value in data )
return data_set != initial_set
def modelform_defines_fields ( form_class ) :pass
return ( form_class is not None and (  hasattr ( form_class , '_STR:0_' ) and  ( form_class . _meta . fields is not None or  form_class . _meta . exclude is not None )  ) )
import warnings
from django . utils . deprecation import RemovedInDjango19Warning
warnings . warn (  '_STR:0_'  "Use django.forms.utils instead." , RemovedInDjango19Warning , stacklevel = 2 )
from django . forms . utils import *
from __future__ import unicode_literals
import json
import sys
try :pass _newline_ except: pass
from collections import UserList
try: pass _newline_ except ImportError :pass
from UserList import UserList
from django . conf import settings
from django . utils . encoding import force_text , python_2_unicode_compatible
from django . utils . html import format_html , format_html_join , escape
from django . utils import timezone
from django . utils . translation import ugettext_lazy as _
from django . utils import six
from django . core . exceptions import ValidationError
def flatatt ( attrs ) :pass
boolean_attrs = [ ]
for attr , value in list ( attrs . items ( ) ) :pass
if value is True :pass
boolean_attrs . append ( ( attr , ) )
del attrs [ attr ]
if True: pass _newline_ elif value is False :pass
del attrs [ attr ]
return (  format_html_join ( '' , '_STR:0_' , sorted ( attrs . items ( ) ) ) +  format_html_join ( '' , ' {0}' , sorted ( boolean_attrs ) )  )
@ python_2_unicode_compatible _newline_ def dummy(): pass
class ErrorDict ( dict ) :pass
def as_data ( self ) :pass
return { f : e . as_data ( ) for f , e in self . items ( ) }
def as_json ( self , escape_html = False ) :pass
return json . dumps ( { f : e . get_json_data ( escape_html ) for f , e in self . items ( ) } )
def as_ul ( self ) :pass
if not self :pass
return ''
return format_html (  '_STR:0_' ,  format_html_join ( '' , '<li>{0}{1}</li>' , ( ( k , force_text ( v ) ) for k , v in self . items ( ) ) )  )
def as_text ( self ) :pass
output = [ ]
for field , errors in self . items ( ) :pass
output . append ( '* %s' % field )
output . append ( '\n' . join ( '  * %s' % e for e in errors ) )
return '\n' . join ( output )
def __str__ ( self ) :pass
return self . as_ul ( )
@ python_2_unicode_compatible _newline_ def dummy(): pass
class ErrorList ( UserList , list ) :pass
def __init__ ( self , initlist = None , error_class = None ) :pass
super ( ErrorList , self ) . __init__ ( initlist )
if error_class is None :pass
self . error_class = '_STR:0_'
if True: pass _newline_ else :pass
self . error_class = 'errorlist {}' . format ( error_class )
def as_data ( self ) :pass
return ValidationError ( self . data ) . error_list
def get_json_data ( self , escape_html = False ) :pass
errors = [ ]
for error in self . as_data ( ) :pass
message = list ( error ) [ 0 ]
errors . append ( {  'message' : escape ( message ) if escape_html else message ,  'code' : error . code or '' ,  } )
return errors
def as_json ( self , escape_html = False ) :pass
return json . dumps ( self . get_json_data ( escape_html ) )
def as_ul ( self ) :pass
if not self . data :pass
return ''
return format_html (  '_STR:0_' ,  self . error_class ,  format_html_join ( '' , '<li>{0}</li>' , ( ( force_text ( e ) , ) for e in self ) )  )
def as_text ( self ) :pass
return '\n' . join ( '* %s' % e for e in self )
def __str__ ( self ) :pass
return self . as_ul ( )
def __repr__ ( self ) :pass
return repr ( list ( self ) )
def __contains__ ( self , item ) :pass
return item in list ( self )
def __eq__ ( self , other ) :pass
return list ( self ) == other
def __ne__ ( self , other ) :pass
return list ( self ) != other
def __getitem__ ( self , i ) :pass
error = self . data [ i ]
if isinstance ( error , ValidationError ) :pass
return list ( error ) [ 0 ]
return force_text ( error )
def from_current_timezone ( value ) :pass
if settings . USE_TZ and value is not None and timezone . is_naive ( value ) :pass
current_timezone = timezone . get_current_timezone ( )
try :pass _newline_ except: pass
return timezone . make_aware ( value , current_timezone )
try: pass _newline_ except Exception :pass
message = _ (  '%(datetime)s couldn\'t be interpreted '  'in time zone %(current_timezone)s; it '  'may be ambiguous or it may not exist.'  )
params = { '_STR:1_' : value , '_STR:2_' : current_timezone }
six . reraise ( ValidationError , ValidationError (  message ,  code = 'ambiguous_timezone' ,  params = params ,  ) , sys . exc_info ( ) [ 2 ] )
return value
def to_current_timezone ( value ) :pass
if settings . USE_TZ and value is not None and timezone . is_aware ( value ) :pass
current_timezone = timezone . get_current_timezone ( )
return timezone . make_naive ( value , current_timezone )
return value
from __future__ import unicode_literals
import copy
from itertools import chain
from django . conf import settings
from django . forms . utils import flatatt , to_current_timezone
from django . utils . datastructures import MultiValueDict , MergeDict
from django . utils . encoding import force_text , python_2_unicode_compatible
from django . utils . html import conditional_escape , format_html
from django . utils . translation import ugettext_lazy
from django . utils . safestring import mark_safe
from django . utils import formats , six
from django . utils . six . moves . urllib . parse import urljoin
__all__ = (  '_STR:0_' , '_STR:1_' , '_STR:2_' , '_STR:3_' ,  '_STR:4_' , '_STR:5_' , '_STR:6_' , 'PasswordInput' ,  'HiddenInput' , 'MultipleHiddenInput' , 'ClearableFileInput' ,  'FileInput' , 'DateInput' , 'DateTimeInput' , 'TimeInput' , 'Textarea' , 'CheckboxInput' ,  'Select' , 'NullBooleanSelect' , 'SelectMultiple' , 'RadioSelect' ,  'CheckboxSelectMultiple' , 'MultiWidget' ,  'SplitDateTimeWidget' , 'SplitHiddenDateTimeWidget' ,  )
MEDIA_TYPES = ( '_STR:18_' , '_STR:19_' )
@ python_2_unicode_compatible _newline_ def dummy(): pass
class Media ( object ) :pass
def __init__ ( self , media = None , ** kwargs ) :pass
if media :pass
media_attrs = media . __dict__
if True: pass _newline_ else :pass
media_attrs = kwargs
self . _css = { }
self . _js = [ ]
for name in MEDIA_TYPES :pass
getattr ( self , '_STR:0_' + name ) ( media_attrs . get ( name , None ) )
def __str__ ( self ) :pass
return self . render ( )
def render ( self ) :pass
return mark_safe ( '\n' . join ( chain ( * [ getattr ( self , '_STR:0_' + name ) ( ) for name in MEDIA_TYPES ] ) ) )
def render_js ( self ) :pass
return [ format_html ( '<script type="text/javascript" src="{0}"></script>' , self . absolute_path ( path ) ) for path in self . _js ]
def render_css ( self ) :pass
media = sorted ( self . _css . keys ( ) )
return chain ( * [  [ format_html ( '<link href="{0}" type="text/css" media="{1}" rel="stylesheet" />' , self . absolute_path ( path ) , medium )  for path in self . _css [ medium ] ]  for medium in media ] )
def absolute_path ( self , path , prefix = None ) :pass
if path . startswith ( ( '_STR:0_' , '_STR:1_' , '_STR:2_' ) ) :pass
return path
if prefix is None :pass
if settings . STATIC_URL is None :pass
prefix = settings . MEDIA_URL
if True: pass _newline_ else :pass
prefix = settings . STATIC_URL
return urljoin ( prefix , path )
def __getitem__ ( self , name ) :pass
if name in MEDIA_TYPES :pass
return Media ( ** { str ( name ) : getattr ( self , '_STR:0_' + name ) } )
raise KeyError ( '_STR:0_' % name )
def add_js ( self , data ) :pass
if data :pass
for path in data :pass
if path not in self . _js :pass
self . _js . append ( path )
def add_css ( self , data ) :pass
if data :pass
for medium , paths in data . items ( ) :pass
for path in paths :pass
if not self . _css . get ( medium ) or path not in self . _css [ medium ] :pass
self . _css . setdefault ( medium , [ ] ) . append ( path )
def __add__ ( self , other ) :pass
combined = Media ( )
for name in MEDIA_TYPES :pass
getattr ( combined , '_STR:0_' + name ) ( getattr ( self , '_' + name , None ) )
getattr ( combined , '_STR:1_' + name ) ( getattr ( other , '_STR:0_' + name , None ) )
return combined
def media_property ( cls ) :pass
def _media ( self ) :pass
sup_cls = super ( cls , self )
try :pass _newline_ except: pass
base = sup_cls . media
try: pass _newline_ except AttributeError :pass
base = Media ( )
definition = getattr ( cls , '_STR:0_' , None )
if definition :pass
extend = getattr ( definition , '_STR:0_' , True )
if extend :pass
if extend is True :pass
m = base
if True: pass _newline_ else :pass
m = Media ( )
for medium in extend :pass
m = m + base [ medium ]
return m + Media ( definition )
if True: pass _newline_ else :pass
return Media ( definition )
if True: pass _newline_ else :pass
return base
return property ( _media )
class MediaDefiningClass ( type ) :pass
def __new__ ( mcs , name , bases , attrs ) :pass
new_class = ( super ( MediaDefiningClass , mcs )  . __new__ ( mcs , name , bases , attrs ) )
if '_STR:0_' not in attrs :pass
new_class . media = media_property ( new_class )
return new_class
@ python_2_unicode_compatible _newline_ def dummy(): pass
class SubWidget ( object ) :pass
def __init__ ( self , parent_widget , name , value , attrs , choices ) :pass
self . parent_widget = parent_widget
self . name , self . value = name , value
self . attrs , self . choices = attrs , choices
def __str__ ( self ) :pass
args = [ self . name , self . value , self . attrs ]
if self . choices :pass
args . append ( self . choices )
return self . parent_widget . render ( * args )
class Widget ( six . with_metaclass ( MediaDefiningClass ) ) :pass
needs_multipart_form = False
is_localized = False
is_required = False
def __init__ ( self , attrs = None ) :pass
if attrs is not None :pass
self . attrs = attrs . copy ( )
if True: pass _newline_ else :pass
self . attrs = { }
def __deepcopy__ ( self , memo ) :pass
obj = copy . copy ( self )
obj . attrs = self . attrs . copy ( )
memo [ id ( self ) ] = obj
return obj
@ property _newline_ def dummy(): pass
def is_hidden ( self ) :pass
return self . input_type == '_STR:0_' if hasattr ( self , '_STR:1_' ) else False
def subwidgets ( self , name , value , attrs = None , choices = ( ) ) :pass
yield SubWidget ( self , name , value , attrs , choices )
def render ( self , name , value , attrs = None ) :pass
raise NotImplementedError ( '_STR:0_' )
def build_attrs ( self , extra_attrs = None , ** kwargs ) :pass
attrs = dict ( self . attrs , ** kwargs )
if extra_attrs :pass
attrs . update ( extra_attrs )
return attrs
def value_from_datadict ( self , data , files , name ) :pass
return data . get ( name , None )
def id_for_label ( self , id_ ) :pass
return id_
class Input ( Widget ) :pass
input_type = None
def _format_value ( self , value ) :pass
if self . is_localized :pass
return formats . localize_input ( value )
return value
def render ( self , name , value , attrs = None ) :pass
if value is None :pass
value = ''
final_attrs = self . build_attrs ( attrs , type = self . input_type , name = name )
if value != '' :pass
final_attrs [ 'value' ] = force_text ( self . _format_value ( value ) )
return format_html ( '_STR:1_' , flatatt ( final_attrs ) )
class TextInput ( Input ) :pass
input_type = '_STR:0_'
def __init__ ( self , attrs = None ) :pass
if attrs is not None :pass
self . input_type = attrs . pop ( '_STR:0_' , self . input_type )
super ( TextInput , self ) . __init__ ( attrs )
class NumberInput ( TextInput ) :pass
input_type = '_STR:0_'
class EmailInput ( TextInput ) :pass
input_type = '_STR:0_'
class URLInput ( TextInput ) :pass
input_type = '_STR:0_'
class PasswordInput ( TextInput ) :pass
input_type = '_STR:0_'
def __init__ ( self , attrs = None , render_value = False ) :pass
super ( PasswordInput , self ) . __init__ ( attrs )
self . render_value = render_value
def render ( self , name , value , attrs = None ) :pass
if not self . render_value :pass
value = None
return super ( PasswordInput , self ) . render ( name , value , attrs )
class HiddenInput ( Input ) :pass
input_type = '_STR:0_'
class MultipleHiddenInput ( HiddenInput ) :pass
def __init__ ( self , attrs = None , choices = ( ) ) :pass
super ( MultipleHiddenInput , self ) . __init__ ( attrs )
self . choices = choices
def render ( self , name , value , attrs = None , choices = ( ) ) :pass
if value is None :pass
value = [ ]
final_attrs = self . build_attrs ( attrs , type = self . input_type , name = name )
id_ = final_attrs . get ( '_STR:0_' , None )
inputs = [ ]
for i , v in enumerate ( value ) :pass
input_attrs = dict ( value = force_text ( v ) , ** final_attrs )
if id_ :pass
input_attrs [ '_STR:1_' ] = '_STR:0_' % ( id_ , i )
inputs . append ( format_html ( '_STR:0_' , flatatt ( input_attrs ) ) )
return mark_safe ( '\n' . join ( inputs ) )
def value_from_datadict ( self , data , files , name ) :pass
if isinstance ( data , ( MultiValueDict , MergeDict ) ) :pass
return data . getlist ( name )
return data . get ( name , None )
class FileInput ( Input ) :pass
input_type = '_STR:0_'
needs_multipart_form = True
def render ( self , name , value , attrs = None ) :pass
return super ( FileInput , self ) . render ( name , None , attrs = attrs )
def value_from_datadict ( self , data , files , name ) :pass
return files . get ( name , None )
FILE_INPUT_CONTRADICTION = object ( )
class ClearableFileInput ( FileInput ) :pass
initial_text = ugettext_lazy ( '_STR:0_' )
input_text = ugettext_lazy ( '_STR:0_' )
clear_checkbox_label = ugettext_lazy ( '_STR:0_' )
template_with_initial = '_STR:0_'
template_with_clear = '_STR:0_'
url_markup_template = '_STR:0_'
def clear_checkbox_name ( self , name ) :pass
return name + '_STR:0_'
def clear_checkbox_id ( self , name ) :pass
return name + '_STR:0_'
def render ( self , name , value , attrs = None ) :pass
substitutions = {  '_STR:0_' : self . initial_text ,  '_STR:1_' : self . input_text ,  'clear_template' : '' ,  'clear_checkbox_label' : self . clear_checkbox_label ,  }
template = '_STR:2_'
substitutions [ 'input' ] = super ( ClearableFileInput , self ) . render ( name , value , attrs )
if value and hasattr ( value , "url" ) :pass
template = self . template_with_initial
substitutions [ 'initial' ] = format_html ( self . url_markup_template ,  value . url ,  force_text ( value ) )
if not self . is_required :pass
checkbox_name = self . clear_checkbox_name ( name )
checkbox_id = self . clear_checkbox_id ( checkbox_name )
substitutions [ 'clear_checkbox_name' ] = conditional_escape ( checkbox_name )
substitutions [ 'clear_checkbox_id' ] = conditional_escape ( checkbox_id )
substitutions [ 'clear' ] = CheckboxInput ( ) . render ( checkbox_name , False , attrs = { 'id' : checkbox_id } )
substitutions [ '_STR:2_' ] = self . template_with_clear % substitutions
return mark_safe ( template % substitutions )
def value_from_datadict ( self , data , files , name ) :pass
upload = super ( ClearableFileInput , self ) . value_from_datadict ( data , files , name )
if not self . is_required and CheckboxInput ( ) . value_from_datadict (  data , files , self . clear_checkbox_name ( name ) ) :pass
if upload :pass
return FILE_INPUT_CONTRADICTION
return False
return upload
class Textarea ( Widget ) :pass
def __init__ ( self , attrs = None ) :pass
default_attrs = { '_STR:1_' : '_STR:0_' , '_STR:3_' : '_STR:2_' }
if attrs :pass
default_attrs . update ( attrs )
super ( Textarea , self ) . __init__ ( default_attrs )
def render ( self , name , value , attrs = None ) :pass
if value is None :pass
value = ''
final_attrs = self . build_attrs ( attrs , name = name )
return format_html ( '_STR:0_' ,  flatatt ( final_attrs ) ,  force_text ( value ) )
class DateTimeBaseInput ( TextInput ) :pass
format_key = ''
supports_microseconds = False
def __init__ ( self , attrs = None , format = None ) :pass
super ( DateTimeBaseInput , self ) . __init__ ( attrs )
self . format = format if format else None
def _format_value ( self , value ) :pass
return formats . localize_input ( value ,  self . format or formats . get_format ( self . format_key ) [ 0 ] )
class DateInput ( DateTimeBaseInput ) :pass
format_key = '_STR:0_'
class DateTimeInput ( DateTimeBaseInput ) :pass
format_key = '_STR:0_'
class TimeInput ( DateTimeBaseInput ) :pass
format_key = '_STR:0_'
def boolean_check ( v ) :pass
return not ( v is False or v is None or v == '' )
class CheckboxInput ( Widget ) :pass
def __init__ ( self , attrs = None , check_test = None ) :pass
super ( CheckboxInput , self ) . __init__ ( attrs )
self . check_test = boolean_check if check_test is None else check_test
def render ( self , name , value , attrs = None ) :pass
final_attrs = self . build_attrs ( attrs , type = '_STR:0_' , name = name )
if self . check_test ( value ) :pass
final_attrs [ '_STR:0_' ] = '_STR:0_'
if not ( value is True or value is False or value is None or value == '' ) :pass
final_attrs [ '_STR:0_' ] = force_text ( value )
return format_html ( '_STR:0_' , flatatt ( final_attrs ) )
def value_from_datadict ( self , data , files , name ) :pass
if name not in data :pass
return False
value = data . get ( name )
values = { '_STR:1_' : True , '_STR:0_' : False }
if isinstance ( value , six . string_types ) :pass
value = values . get ( value . lower ( ) , value )
return bool ( value )
class Select ( Widget ) :pass
allow_multiple_selected = False
def __init__ ( self , attrs = None , choices = ( ) ) :pass
super ( Select , self ) . __init__ ( attrs )
self . choices = list ( choices )
def render ( self , name , value , attrs = None , choices = ( ) ) :pass
if value is None :pass
value = ''
final_attrs = self . build_attrs ( attrs , name = name )
output = [ format_html ( '_STR:0_' , flatatt ( final_attrs ) ) ]
options = self . render_options ( choices , [ value ] )
if options :pass
output . append ( options )
output . append ( '_STR:0_' )
return mark_safe ( '\n' . join ( output ) )
def render_option ( self , selected_choices , option_value , option_label ) :pass
if option_value is None :pass
option_value = ''
option_value = force_text ( option_value )
if option_value in selected_choices :pass
selected_html = mark_safe ( '_STR:0_' )
if not self . allow_multiple_selected :pass
selected_choices . remove ( option_value )
if True: pass _newline_ else :pass
selected_html = ''
return format_html ( '_STR:0_' ,  option_value ,  selected_html ,  force_text ( option_label ) )
def render_options ( self , choices , selected_choices ) :pass
selected_choices = set ( force_text ( v ) for v in selected_choices )
output = [ ]
for option_value , option_label in chain ( self . choices , choices ) :pass
if isinstance ( option_label , ( list , tuple ) ) :pass
output . append ( format_html ( '_STR:0_' , force_text ( option_value ) ) )
for option in option_label :pass
output . append ( self . render_option ( selected_choices , * option ) )
output . append ( '_STR:0_' )
if True: pass _newline_ else :pass
output . append ( self . render_option ( selected_choices , option_value , option_label ) )
return '\n' . join ( output )
class NullBooleanSelect ( Select ) :pass
def __init__ ( self , attrs = None ) :pass
choices = ( ( '_STR:0_' , ugettext_lazy ( 'Unknown' ) ) ,  ( '2' , ugettext_lazy ( 'Yes' ) ) ,  ( '3' , ugettext_lazy ( 'No' ) ) )
super ( NullBooleanSelect , self ) . __init__ ( attrs , choices )
def render ( self , name , value , attrs = None , choices = ( ) ) :pass
try :pass _newline_ except: pass
value = { True : '_STR:0_' , False : '_STR:1_' , '_STR:0_' : '_STR:0_' , '_STR:1_' : '_STR:1_' } [ value ]
try: pass _newline_ except KeyError :pass
value = '_STR:0_'
return super ( NullBooleanSelect , self ) . render ( name , value , attrs , choices )
def value_from_datadict ( self , data , files , name ) :pass
value = data . get ( name , None )
return { '_STR:0_' : True ,  True : True ,  'True' : True ,  '3' : False ,  'False' : False ,  False : False } . get ( value , None )
class SelectMultiple ( Select ) :pass
allow_multiple_selected = True
def render ( self , name , value , attrs = None , choices = ( ) ) :pass
if value is None :pass
value = [ ]
final_attrs = self . build_attrs ( attrs , name = name )
output = [ format_html ( '<select multiple="multiple"{0}>' , flatatt ( final_attrs ) ) ]
options = self . render_options ( choices , value )
if options :pass
output . append ( options )
output . append ( '_STR:0_' )
return mark_safe ( '\n' . join ( output ) )
def value_from_datadict ( self , data , files , name ) :pass
if isinstance ( data , ( MultiValueDict , MergeDict ) ) :pass
return data . getlist ( name )
return data . get ( name , None )
@ python_2_unicode_compatible _newline_ def dummy(): pass
class ChoiceInput ( SubWidget ) :pass
input_type = None
def __init__ ( self , name , value , attrs , choice , index ) :pass
self . name = name
self . value = value
self . attrs = attrs
self . choice_value = force_text ( choice [ 0 ] )
self . choice_label = force_text ( choice [ 1 ] )
self . index = index
if '_STR:0_' in self . attrs :pass
self . attrs [ '_STR:1_' ] += "_%d" % self . index
def __str__ ( self ) :pass
return self . render ( )
def render ( self , name = None , value = None , attrs = None , choices = ( ) ) :pass
if self . id_for_label :pass
label_for = format_html ( '_STR:0_' , self . id_for_label )
if True: pass _newline_ else :pass
label_for = ''
return format_html ( '_STR:0_' , label_for , self . tag ( ) , self . choice_label )
def is_checked ( self ) :pass
return self . value == self . choice_value
def tag ( self ) :pass
final_attrs = dict ( self . attrs , type = self . input_type , name = self . name , value = self . choice_value )
if self . is_checked ( ) :pass
final_attrs [ '_STR:0_' ] = '_STR:0_'
return format_html ( '_STR:0_' , flatatt ( final_attrs ) )
@ property _newline_ def dummy(): pass
def id_for_label ( self ) :pass
return self . attrs . get ( '_STR:0_' , '' )
class RadioChoiceInput ( ChoiceInput ) :pass
input_type = '_STR:0_'
def __init__ ( self , * args , ** kwargs ) :pass
super ( RadioChoiceInput , self ) . __init__ ( * args , ** kwargs )
self . value = force_text ( self . value )
class CheckboxChoiceInput ( ChoiceInput ) :pass
input_type = '_STR:0_'
def __init__ ( self , * args , ** kwargs ) :pass
super ( CheckboxChoiceInput , self ) . __init__ ( * args , ** kwargs )
self . value = set ( force_text ( v ) for v in self . value )
def is_checked ( self ) :pass
return self . choice_value in self . value
@ python_2_unicode_compatible _newline_ def dummy(): pass
class ChoiceFieldRenderer ( object ) :pass
choice_input_class = None
outer_html = '_STR:0_'
inner_html = '_STR:0_'
def __init__ ( self , name , value , attrs , choices ) :pass
self . name = name
self . value = value
self . attrs = attrs
self . choices = choices
def __getitem__ ( self , idx ) :pass
choice = self . choices [ idx ]
return self . choice_input_class ( self . name , self . value , self . attrs . copy ( ) , choice , idx )
def __str__ ( self ) :pass
return self . render ( )
def render ( self ) :pass
id_ = self . attrs . get ( '_STR:0_' , None )
output = [ ]
for i , choice in enumerate ( self . choices ) :pass
choice_value , choice_label = choice
if isinstance ( choice_label , ( tuple , list ) ) :pass
attrs_plus = self . attrs . copy ( )
if id_ :pass
attrs_plus [ '_STR:1_' ] += '_{0}' . format ( i )
sub_ul_renderer = ChoiceFieldRenderer ( name = self . name ,  value = self . value ,  attrs = attrs_plus ,  choices = choice_label )
sub_ul_renderer . choice_input_class = self . choice_input_class
output . append ( format_html ( self . inner_html , choice_value = choice_value ,  sub_widgets = sub_ul_renderer . render ( ) ) )
if True: pass _newline_ else :pass
w = self . choice_input_class ( self . name , self . value ,  self . attrs . copy ( ) , choice , i )
output . append ( format_html ( self . inner_html ,  choice_value = force_text ( w ) , sub_widgets = '' ) )
return format_html ( self . outer_html ,  id_attr = format_html ( ' id="{0}"' , id_ ) if id_ else '' ,  content = mark_safe ( '\n' . join ( output ) ) )
class RadioFieldRenderer ( ChoiceFieldRenderer ) :pass
choice_input_class = RadioChoiceInput
class CheckboxFieldRenderer ( ChoiceFieldRenderer ) :pass
choice_input_class = CheckboxChoiceInput
class RendererMixin ( object ) :pass
renderer = None
_empty_value = None
def __init__ ( self , * args , ** kwargs ) :pass
renderer = kwargs . pop ( 'renderer' , None )
if renderer :pass
self . renderer = renderer
super ( RendererMixin , self ) . __init__ ( * args , ** kwargs )
def subwidgets ( self , name , value , attrs = None , choices = ( ) ) :pass
for widget in self . get_renderer ( name , value , attrs , choices ) :pass
yield widget
def get_renderer ( self , name , value , attrs = None , choices = ( ) ) :pass
if value is None :pass
value = self . _empty_value
final_attrs = self . build_attrs ( attrs )
choices = list ( chain ( self . choices , choices ) )
return self . renderer ( name , value , final_attrs , choices )
def render ( self , name , value , attrs = None , choices = ( ) ) :pass
return self . get_renderer ( name , value , attrs , choices ) . render ( )
def id_for_label ( self , id_ ) :pass
if id_ :pass
id_ += '_STR:0_'
return id_
class RadioSelect ( RendererMixin , Select ) :pass
renderer = RadioFieldRenderer
_empty_value = ''
class CheckboxSelectMultiple ( RendererMixin , SelectMultiple ) :pass
renderer = CheckboxFieldRenderer
_empty_value = [ ]
class MultiWidget ( Widget ) :pass
def __init__ ( self , widgets , attrs = None ) :pass
self . widgets = [ w ( ) if isinstance ( w , type ) else w for w in widgets ]
super ( MultiWidget , self ) . __init__ ( attrs )
@ property _newline_ def dummy(): pass
def is_hidden ( self ) :pass
return all ( w . is_hidden for w in self . widgets )
def render ( self , name , value , attrs = None ) :pass
if self . is_localized :pass
for widget in self . widgets :pass
widget . is_localized = self . is_localized
if not isinstance ( value , list ) :pass
value = self . decompress ( value )
output = [ ]
final_attrs = self . build_attrs ( attrs )
id_ = final_attrs . get ( '_STR:0_' , None )
for i , widget in enumerate ( self . widgets ) :pass
try :pass _newline_ except: pass
widget_value = value [ i ]
try: pass _newline_ except IndexError :pass
widget_value = None
if id_ :pass
final_attrs = dict ( final_attrs , id = '_STR:0_' % ( id_ , i ) )
output . append ( widget . render ( name + '_%s' % i , widget_value , final_attrs ) )
return mark_safe ( self . format_output ( output ) )
def id_for_label ( self , id_ ) :pass
if id_ :pass
id_ += '_STR:0_'
return id_
def value_from_datadict ( self , data , files , name ) :pass
return [ widget . value_from_datadict ( data , files , name + '_%s' % i ) for i , widget in enumerate ( self . widgets ) ]
def format_output ( self , rendered_widgets ) :pass
return '' . join ( rendered_widgets )
def decompress ( self , value ) :pass
raise NotImplementedError ( '_STR:0_' )
def _get_media ( self ) :pass
media = Media ( )
for w in self . widgets :pass
media = media + w . media
return media
media = property ( _get_media )
def __deepcopy__ ( self , memo ) :pass
obj = super ( MultiWidget , self ) . __deepcopy__ ( memo )
obj . widgets = copy . deepcopy ( self . widgets )
return obj
@ property _newline_ def dummy(): pass
def needs_multipart_form ( self ) :pass
return any ( w . needs_multipart_form for w in self . widgets )
class SplitDateTimeWidget ( MultiWidget ) :pass
supports_microseconds = False
def __init__ ( self , attrs = None , date_format = None , time_format = None ) :pass
widgets = ( DateInput ( attrs = attrs , format = date_format ) ,  TimeInput ( attrs = attrs , format = time_format ) )
super ( SplitDateTimeWidget , self ) . __init__ ( widgets , attrs )
def decompress ( self , value ) :pass
if value :pass
value = to_current_timezone ( value )
return [ value . date ( ) , value . time ( ) . replace ( microsecond = 0 ) ]
return [ None , None ]
class SplitHiddenDateTimeWidget ( SplitDateTimeWidget ) :pass
def __init__ ( self , attrs = None , date_format = None , time_format = None ) :pass
super ( SplitHiddenDateTimeWidget , self ) . __init__ ( attrs , date_format , time_format )
for widget in self . widgets :pass
widget . input_type = '_STR:0_'
from django . http . cookie import SimpleCookie , parse_cookie
from django . http . request import ( HttpRequest , QueryDict ,  RawPostDataException , UnreadablePostError , build_request_repr )
from django . http . response import ( HttpResponse , StreamingHttpResponse ,  HttpResponseRedirect , HttpResponsePermanentRedirect ,  HttpResponseNotModified , HttpResponseBadRequest , HttpResponseForbidden ,  HttpResponseNotFound , HttpResponseNotAllowed , HttpResponseGone ,  HttpResponseServerError , Http404 , BadHeaderError , JsonResponse )
from django . http . utils import fix_location_header , conditional_content_removal
__all__ = [  '_STR:0_' , '_STR:1_' , '_STR:2_' , '_STR:3_' ,  '_STR:4_' , 'UnreadablePostError' , 'build_request_repr' ,  'HttpResponse' , 'StreamingHttpResponse' , 'HttpResponseRedirect' ,  'HttpResponsePermanentRedirect' , 'HttpResponseNotModified' ,  'HttpResponseBadRequest' , 'HttpResponseForbidden' , 'HttpResponseNotFound' ,  'HttpResponseNotAllowed' , 'HttpResponseGone' , 'HttpResponseServerError' ,  'Http404' , 'BadHeaderError' , 'fix_location_header' , 'JsonResponse' ,  'conditional_content_removal' ,  ]
from __future__ import unicode_literals
from django . utils . encoding import force_str
from django . utils import six
from django . utils . six . moves import http_cookies
_cookie_encodes_correctly = http_cookies . SimpleCookie ( ) . value_encode ( '_STR:0_' ) == ( '_STR:0_' , '"\\073"' )
_tc = http_cookies . SimpleCookie ( )
try :pass _newline_ except: pass
_tc . load ( str ( '_STR:0_' ) )
_cookie_allows_colon_in_names = True
try: pass _newline_ except http_cookies . CookieError :pass
_cookie_allows_colon_in_names = False
if _cookie_encodes_correctly and _cookie_allows_colon_in_names :pass
SimpleCookie = http_cookies . SimpleCookie
if True: pass _newline_ else :pass
Morsel = http_cookies . Morsel
class SimpleCookie ( http_cookies . SimpleCookie ) :pass
if not _cookie_encodes_correctly :pass
def value_encode ( self , val ) :pass
val , encoded = super ( SimpleCookie , self ) . value_encode ( val )
encoded = encoded . replace ( ";" , '_STR:2_' ) . replace ( "," , '_STR:0_' )
if "\\" in encoded and not encoded . startswith ( '"' ) :pass
encoded = '"' + encoded + '"'
return val , encoded
if not _cookie_allows_colon_in_names :pass
def load ( self , rawdata ) :pass
self . bad_cookies = set ( )
if six . PY2 and isinstance ( rawdata , six . text_type ) :pass
rawdata = force_str ( rawdata )
super ( SimpleCookie , self ) . load ( rawdata )
for key in self . bad_cookies :pass
del self [ key ]
def _BaseCookie__set ( self , key , real_value , coded_value ) :pass
key = force_str ( key )
try :pass _newline_ except: pass
M = self . get ( key , Morsel ( ) )
M . set ( key , real_value , coded_value )
dict . __setitem__ ( self , key , M )
try: pass _newline_ except http_cookies . CookieError :pass
if not hasattr ( self , '_STR:0_' ) :pass
self . bad_cookies = set ( )
self . bad_cookies . add ( key )
dict . __setitem__ ( self , key , http_cookies . Morsel ( ) )
def parse_cookie ( cookie ) :pass
if cookie == '' :pass
return { }
if not isinstance ( cookie , http_cookies . BaseCookie ) :pass
try :pass _newline_ except: pass
c = SimpleCookie ( )
c . load ( cookie )
try: pass _newline_ except http_cookies . CookieError :pass
return { }
if True: pass _newline_ else :pass
c = cookie
cookiedict = { }
for key in c . keys ( ) :pass
cookiedict [ key ] = c . get ( key ) . value
return cookiedict
from __future__ import unicode_literals
import base64
import binascii
import cgi
import sys
from django . conf import settings
from django . core . exceptions import SuspiciousMultipartForm
from django . utils . datastructures import MultiValueDict
from django . utils . encoding import force_text
from django . utils import six
from django . utils . text import unescape_entities
from django . core . files . uploadhandler import StopUpload , SkipFile , StopFutureHandlers
__all__ = ( '_STR:0_' , '_STR:1_' , '_STR:2_' )
class MultiPartParserError ( Exception ) :pass
pass
class InputStreamExhausted ( Exception ) :pass
pass
RAW = '_STR:0_'
FILE = "file"
FIELD = "field"
_BASE64_DECODE_ERROR = TypeError if six . PY2 else binascii . Error
class MultiPartParser ( object ) :pass
def __init__ ( self , META , input_data , upload_handlers , encoding = None ) :pass
content_type = META . get ( '_STR:0_' , META . get ( 'CONTENT_TYPE' , '' ) )
if not content_type . startswith ( '_STR:1_' ) :pass
raise MultiPartParserError ( '_STR:0_' % content_type )
ctypes , opts = parse_header ( content_type . encode ( '_STR:0_' ) )
boundary = opts . get ( '_STR:0_' )
if not boundary or not cgi . valid_boundary ( boundary ) :pass
raise MultiPartParserError ( '_STR:0_' % boundary )
try :pass _newline_ except: pass
content_length = int ( META . get ( '_STR:0_' , META . get ( '_STR:1_' , 0 ) ) )
try: pass _newline_ except ( ValueError , TypeError ) :pass
content_length = 0
if content_length < 0 :pass
raise MultiPartParserError ( '_STR:0_' % content_length )
if isinstance ( boundary , six . text_type ) :pass
boundary = boundary . encode ( '_STR:0_' )
self . _boundary = boundary
self . _input_data = input_data
possible_sizes = [ x . chunk_size for x in upload_handlers if x . chunk_size ]
self . _chunk_size = min ( [ 2 ** 31 - 4 ] + possible_sizes )
self . _meta = META
self . _encoding = encoding or settings . DEFAULT_CHARSET
self . _content_length = content_length
self . _upload_handlers = upload_handlers
def parse ( self ) :pass
from django . http import QueryDict
encoding = self . _encoding
handlers = self . _upload_handlers
if self . _content_length == 0 :pass
return QueryDict ( '' , encoding = self . _encoding ) , MultiValueDict ( )
for handler in handlers :pass
result = handler . handle_raw_input ( self . _input_data ,  self . _meta ,  self . _content_length ,  self . _boundary ,  encoding )
if result is not None :pass
return result [ 0 ] , result [ 1 ]
self . _post = QueryDict ( '' , mutable = True )
self . _files = MultiValueDict ( )
stream = LazyStream ( ChunkIter ( self . _input_data , self . _chunk_size ) )
old_field_name = None
counters = [ 0 ] * len ( handlers )
try :pass _newline_ except: pass
for item_type , meta_data , field_stream in Parser ( stream , self . _boundary ) :pass
if old_field_name :pass
self . handle_file_complete ( old_field_name , counters )
old_field_name = None
try :pass _newline_ except: pass
disposition = meta_data [ '_STR:0_' ] [ 1 ]
field_name = disposition [ '_STR:0_' ] . strip ( )
try: pass _newline_ except ( KeyError , IndexError , AttributeError ) :pass
continue
transfer_encoding = meta_data . get ( '_STR:0_' )
if transfer_encoding is not None :pass
transfer_encoding = transfer_encoding [ 0 ] . strip ( )
field_name = force_text ( field_name , encoding , errors = '_STR:0_' )
if item_type == FIELD :pass
if transfer_encoding == '_STR:0_' :pass
raw_data = field_stream . read ( )
try :pass _newline_ except: pass
data = base64 . b64decode ( raw_data )
try: pass _newline_ except _BASE64_DECODE_ERROR :pass
data = raw_data
if True: pass _newline_ else :pass
data = field_stream . read ( )
self . _post . appendlist ( field_name ,  force_text ( data , encoding , errors = 'replace' ) )
if True: pass _newline_ elif item_type == FILE :pass
file_name = disposition . get ( '_STR:0_' )
if not file_name :pass
continue
file_name = force_text ( file_name , encoding , errors = '_STR:0_' )
file_name = self . IE_sanitize ( unescape_entities ( file_name ) )
content_type , content_type_extra = meta_data . get ( '_STR:0_' , ( '' , { } ) )
content_type = content_type . strip ( )
charset = content_type_extra . get ( '_STR:0_' )
try :pass _newline_ except: pass
content_length = int ( meta_data . get ( '_STR:0_' ) [ 0 ] )
try: pass _newline_ except ( IndexError , TypeError , ValueError ) :pass
content_length = None
counters = [ 0 ] * len ( handlers )
try :pass _newline_ except: pass
for handler in handlers :pass
try :pass _newline_ except: pass
handler . new_file ( field_name , file_name ,  content_type , content_length ,  charset , content_type_extra )
try: pass _newline_ except StopFutureHandlers :pass
break
for chunk in field_stream :pass
if transfer_encoding == '_STR:0_' :pass
over_bytes = len ( chunk ) % 4
if over_bytes :pass
over_chunk = field_stream . read ( 4 - over_bytes )
chunk += over_chunk
try :pass _newline_ except: pass
chunk = base64 . b64decode ( chunk )
try: pass _newline_ except Exception as e :pass
msg = '_STR:0_' % e
six . reraise ( MultiPartParserError , MultiPartParserError ( msg ) , sys . exc_info ( ) [ 2 ] )
for i , handler in enumerate ( handlers ) :pass
chunk_length = len ( chunk )
chunk = handler . receive_data_chunk ( chunk ,  counters [ i ] )
counters [ i ] += chunk_length
if chunk is None :pass
break
try: pass _newline_ except SkipFile :pass
self . _close_files ( )
exhaust ( field_stream )
if True: pass _newline_ else :pass
old_field_name = field_name
if True: pass _newline_ else :pass
exhaust ( stream )
try: pass _newline_ except StopUpload as e :pass
self . _close_files ( )
if not e . connection_reset :pass
exhaust ( self . _input_data )
if True: pass _newline_ else :pass
exhaust ( self . _input_data )
for handler in handlers :pass
retval = handler . upload_complete ( )
if retval :pass
break
return self . _post , self . _files
def handle_file_complete ( self , old_field_name , counters ) :pass
for i , handler in enumerate ( self . _upload_handlers ) :pass
file_obj = handler . file_complete ( counters [ i ] )
if file_obj :pass
self . _files . appendlist (  force_text ( old_field_name , self . _encoding , errors = '_STR:0_' ) ,  file_obj )
break
def IE_sanitize ( self , filename ) :pass
return filename and filename [ filename . rfind ( "\\" ) + 1 : ] . strip ( )
def _close_files ( self ) :pass
for handler in self . _upload_handlers :pass
if hasattr ( handler , '_STR:0_' ) :pass
handler . file . close ( )
class LazyStream ( six . Iterator ) :pass
def __init__ ( self , producer , length = None ) :pass
self . _producer = producer
self . _empty = False
self . _leftover = b''
self . length = length
self . position = 0
self . _remaining = length
self . _unget_history = [ ]
def tell ( self ) :pass
return self . position
def read ( self , size = None ) :pass
def parts ( ) :pass
remaining = self . _remaining if size is None else size
if remaining is None :pass
yield b'' . join ( self )
return
while remaining != 0 :pass
assert remaining > 0 , '_STR:0_'
chunk = next ( self )
emitting = chunk [ : remaining ]
self . unget ( chunk [ remaining : ] )
remaining -= len ( emitting )
yield emitting
out = b'' . join ( parts ( ) )
return out
def __next__ ( self ) :pass
if self . _leftover :pass
output = self . _leftover
self . _leftover = b''
if True: pass _newline_ else :pass
output = next ( self . _producer )
self . _unget_history = [ ]
self . position += len ( output )
return output
def close ( self ) :pass
self . _producer = [ ]
def __iter__ ( self ) :pass
return self
def unget ( self , bytes ) :pass
if not bytes :pass
return
self . _update_unget_history ( len ( bytes ) )
self . position -= len ( bytes )
self . _leftover = b'' . join ( [ bytes , self . _leftover ] )
def _update_unget_history ( self , num_bytes ) :pass
self . _unget_history = [ num_bytes ] + self . _unget_history [ : 49 ]
number_equal = len ( [ current_number for current_number in self . _unget_history  if current_number == num_bytes ] )
if number_equal > 40 :pass
raise SuspiciousMultipartForm (  '_STR:0_'  " normal uploaded files. Check for malicious upload activity;"  " if there is none, report this to the Django developers."  )
class ChunkIter ( six . Iterator ) :pass
def __init__ ( self , flo , chunk_size = 64 * 1024 ) :pass
self . flo = flo
self . chunk_size = chunk_size
def __next__ ( self ) :pass
try :pass _newline_ except: pass
data = self . flo . read ( self . chunk_size )
try: pass _newline_ except InputStreamExhausted :pass
raise StopIteration ( )
if data :pass
return data
if True: pass _newline_ else :pass
raise StopIteration ( )
def __iter__ ( self ) :pass
return self
class InterBoundaryIter ( six . Iterator ) :pass
def __init__ ( self , stream , boundary ) :pass
self . _stream = stream
self . _boundary = boundary
def __iter__ ( self ) :pass
return self
def __next__ ( self ) :pass
try :pass _newline_ except: pass
return LazyStream ( BoundaryIter ( self . _stream , self . _boundary ) )
try: pass _newline_ except InputStreamExhausted :pass
raise StopIteration ( )
class BoundaryIter ( six . Iterator ) :pass
def __init__ ( self , stream , boundary ) :pass
self . _stream = stream
self . _boundary = boundary
self . _done = False
self . _rollback = len ( boundary ) + 6
unused_char = self . _stream . read ( 1 )
if not unused_char :pass
raise InputStreamExhausted ( )
self . _stream . unget ( unused_char )
def __iter__ ( self ) :pass
return self
def __next__ ( self ) :pass
if self . _done :pass
raise StopIteration ( )
stream = self . _stream
rollback = self . _rollback
bytes_read = 0
chunks = [ ]
for bytes in stream :pass
bytes_read += len ( bytes )
chunks . append ( bytes )
if bytes_read > rollback :pass
break
if not bytes :pass
break
if True: pass _newline_ else :pass
self . _done = True
if not chunks :pass
raise StopIteration ( )
chunk = b'' . join ( chunks )
boundary = self . _find_boundary ( chunk , len ( chunk ) < self . _rollback )
if boundary :pass
end , next = boundary
stream . unget ( chunk [ next : ] )
self . _done = True
return chunk [ : end ]
if True: pass _newline_ else :pass
if not chunk [ : - rollback ] :pass
self . _done = True
return chunk
if True: pass _newline_ else :pass
stream . unget ( chunk [ - rollback : ] )
return chunk [ : - rollback ]
def _find_boundary ( self , data , eof = False ) :pass
index = data . find ( self . _boundary )
if index < 0 :pass
return None
if True: pass _newline_ else :pass
end = index
next = index + len ( self . _boundary )
last = max ( 0 , end - 1 )
if data [ last : last + 1 ] == b'\n' :pass
end -= 1
last = max ( 0 , end - 1 )
if data [ last : last + 1 ] == b'\r' :pass
end -= 1
return end , next
def exhaust ( stream_or_iterable ) :pass
iterator = None
try :pass _newline_ except: pass
iterator = iter ( stream_or_iterable )
try: pass _newline_ except TypeError :pass
iterator = ChunkIter ( stream_or_iterable , 16384 )
if iterator is None :pass
raise MultiPartParserError ( '_STR:0_' )
for __ in iterator :pass
pass
def parse_boundary_stream ( stream , max_header_size ) :pass
chunk = stream . read ( max_header_size )
header_end = chunk . find ( b'_STR:0_' )
def _parse_header ( line ) :pass
main_value_pair , params = parse_header ( line )
try :pass _newline_ except: pass
name , value = main_value_pair . split ( '_STR:0_' , 1 )
try: pass _newline_ except ValueError :pass
raise ValueError ( '_STR:0_' % line )
return name , ( value , params )
if header_end == - 1 :pass
stream . unget ( chunk )
return ( RAW , { } , stream )
header = chunk [ : header_end ]
stream . unget ( chunk [ header_end + 4 : ] )
TYPE = RAW
outdict = { }
for line in header . split ( b'_STR:0_' ) :pass
try :pass _newline_ except: pass
name , ( value , params ) = _parse_header ( line )
try: pass _newline_ except ValueError :pass
continue
if name == '_STR:0_' :pass
TYPE = FIELD
if params . get ( '_STR:0_' ) :pass
TYPE = FILE
outdict [ name ] = value , params
if TYPE == RAW :pass
stream . unget ( chunk )
return ( TYPE , outdict , stream )
class Parser ( object ) :pass
def __init__ ( self , stream , boundary ) :pass
self . _stream = stream
self . _separator = b'_STR:0_' + boundary
def __iter__ ( self ) :pass
boundarystream = InterBoundaryIter ( self . _stream , self . _separator )
for sub_stream in boundarystream :pass
yield parse_boundary_stream ( sub_stream , 1024 )
def parse_header ( line ) :pass
plist = _parse_header_params ( b'_STR:0_' + line )
key = plist . pop ( 0 ) . lower ( ) . decode ( '_STR:0_' )
pdict = { }
for p in plist :pass
i = p . find ( b'_STR:0_' )
if i >= 0 :pass
name = p [ : i ] . strip ( ) . lower ( ) . decode ( 'ascii' )
value = p [ i + 1 : ] . strip ( )
if len ( value ) >= 2 and value [ : 1 ] == value [ - 1 : ] == b'"' :pass
value = value [ 1 : - 1 ]
value = value . replace ( b'\\\\' , b'\\' ) . replace ( b'\\"' , b'"' )
pdict [ name ] = value
return key , pdict
def _parse_header_params ( s ) :pass
plist = [ ]
while s [ : 1 ] == b'_STR:0_' :pass
s = s [ 1 : ]
end = s . find ( b'_STR:0_' )
while end > 0 and s . count ( b'"' , 0 , end ) % 2 :pass
end = s . find ( b'_STR:0_' , end + 1 )
if end < 0 :pass
end = len ( s )
f = s [ : end ]
plist . append ( f . strip ( ) )
s = s [ end : ]
return plist
from __future__ import unicode_literals
import copy
import os
import re
import sys
from io import BytesIO
from itertools import chain
from pprint import pformat
from django . conf import settings
from django . core import signing
from django . core . exceptions import DisallowedHost , ImproperlyConfigured
from django . core . files import uploadhandler
from django . http . multipartparser import MultiPartParser , MultiPartParserError
from django . utils import six
from django . utils . datastructures import MultiValueDict , ImmutableList
from django . utils . encoding import force_bytes , force_text , force_str , iri_to_uri
from django . utils . six . moves . urllib . parse import parse_qsl , urlencode , quote , urljoin , urlsplit
RAISE_ERROR = object ( )
absolute_http_url_re = re . compile ( r'_STR:0_' , re . I )
host_validation_re = re . compile ( r'_STR:0_' )
class UnreadablePostError ( IOError ) :pass
pass
class RawPostDataException ( Exception ) :pass
pass
class HttpRequest ( object ) :pass
_encoding = None
_upload_handlers = [ ]
def __init__ ( self ) :pass
self . GET = QueryDict ( mutable = True )
self . POST = QueryDict ( mutable = True )
self . COOKIES = { }
self . META = { }
self . FILES = MultiValueDict ( )
self . path = ''
self . path_info = ''
self . method = None
self . resolver_match = None
self . _post_parse_error = False
def __repr__ ( self ) :pass
return build_request_repr ( self )
def get_host ( self ) :pass
if settings . USE_X_FORWARDED_HOST and (  '_STR:0_' in self . META ) :pass
host = self . META [ '_STR:0_' ]
if True: pass _newline_ elif '_STR:0_' in self . META :pass
host = self . META [ '_STR:0_' ]
if True: pass _newline_ else :pass
host = self . META [ '_STR:0_' ]
server_port = str ( self . META [ 'SERVER_PORT' ] )
if server_port != ( '_STR:0_' if self . is_secure ( ) else '80' ) :pass
host = '%s:%s' % ( host , server_port )
if settings . DEBUG :pass
return host
domain , port = split_domain_port ( host )
if domain and validate_host ( domain , settings . ALLOWED_HOSTS ) :pass
return host
if True: pass _newline_ else :pass
msg = '_STR:0_' % host
if domain :pass
msg += '_STR:0_' % domain
if True: pass _newline_ else :pass
msg += '_STR:0_'
raise DisallowedHost ( msg )
def get_full_path ( self ) :pass
return '%s%s' % ( self . path , ( '?' + iri_to_uri ( self . META . get ( '_STR:0_' , '' ) ) ) if self . META . get ( '_STR:0_' , '' ) else '' )
def get_signed_cookie ( self , key , default = RAISE_ERROR , salt = '' , max_age = None ) :pass
try :pass _newline_ except: pass
cookie_value = self . COOKIES [ key ]
try: pass _newline_ except KeyError :pass
if default is not RAISE_ERROR :pass
return default
if True: pass _newline_ else :pass
raise
try :pass _newline_ except: pass
value = signing . get_cookie_signer ( salt = key + salt ) . unsign (  cookie_value , max_age = max_age )
try: pass _newline_ except signing . BadSignature :pass
if default is not RAISE_ERROR :pass
return default
if True: pass _newline_ else :pass
raise
return value
def build_absolute_uri ( self , location = None ) :pass
if location is None :pass
location = '//%s' % self . get_full_path ( )
bits = urlsplit ( location )
if not ( bits . scheme and bits . netloc ) :pass
current_uri = '_STR:0_' . format ( scheme = self . scheme ,  host = self . get_host ( ) ,  path = self . path )
location = urljoin ( current_uri , location )
return iri_to_uri ( location )
def _get_scheme ( self ) :pass
return '_STR:0_' if os . environ . get ( '_STR:1_' ) == "on" else '_STR:3_'
@ property _newline_ def dummy(): pass
def scheme ( self ) :pass
if settings . SECURE_PROXY_SSL_HEADER :pass
try :pass _newline_ except: pass
header , value = settings . SECURE_PROXY_SSL_HEADER
try: pass _newline_ except ValueError :pass
raise ImproperlyConfigured ( '_STR:0_' )
if self . META . get ( header , None ) == value :pass
return '_STR:0_'
return self . _get_scheme ( )
def is_secure ( self ) :pass
return self . scheme == '_STR:0_'
def is_ajax ( self ) :pass
return self . META . get ( '_STR:0_' ) == '_STR:1_'
@ property _newline_ def dummy(): pass
def encoding ( self ) :pass
return self . _encoding
@ encoding . setter _newline_ def dummy(): pass
def encoding ( self , val ) :pass
self . _encoding = val
if hasattr ( self , '_STR:0_' ) :pass
del self . _get
if hasattr ( self , '_STR:0_' ) :pass
del self . _post
def _initialize_handlers ( self ) :pass
self . _upload_handlers = [ uploadhandler . load_handler ( handler , self )  for handler in settings . FILE_UPLOAD_HANDLERS ]
@ property _newline_ def dummy(): pass
def upload_handlers ( self ) :pass
if not self . _upload_handlers :pass
self . _initialize_handlers ( )
return self . _upload_handlers
@ upload_handlers . setter _newline_ def dummy(): pass
def upload_handlers ( self , upload_handlers ) :pass
if hasattr ( self , '_STR:0_' ) :pass
raise AttributeError ( '_STR:0_' )
self . _upload_handlers = upload_handlers
def parse_file_upload ( self , META , post_data ) :pass
self . upload_handlers = ImmutableList (  self . upload_handlers ,  warning = "You cannot alter upload handlers after the upload has been processed."  )
parser = MultiPartParser ( META , post_data , self . upload_handlers , self . encoding )
return parser . parse ( )
@ property _newline_ def dummy(): pass
def body ( self ) :pass
if not hasattr ( self , '_STR:0_' ) :pass
if self . _read_started :pass
raise RawPostDataException ( '_STR:0_' )
try :pass _newline_ except: pass
self . _body = self . read ( )
try: pass _newline_ except IOError as e :pass
six . reraise ( UnreadablePostError , UnreadablePostError ( * e . args ) , sys . exc_info ( ) [ 2 ] )
self . _stream = BytesIO ( self . _body )
return self . _body
def _mark_post_parse_error ( self ) :pass
self . _post = QueryDict ( '' )
self . _files = MultiValueDict ( )
self . _post_parse_error = True
def _load_post_and_files ( self ) :pass
if self . method != '_STR:0_' :pass
self . _post , self . _files = QueryDict ( '' , encoding = self . _encoding ) , MultiValueDict ( )
return
if self . _read_started and not hasattr ( self , '_STR:0_' ) :pass
self . _mark_post_parse_error ( )
return
if self . META . get ( '_STR:0_' , '' ) . startswith ( '_STR:1_' ) :pass
if hasattr ( self , '_STR:0_' ) :pass
data = BytesIO ( self . _body )
if True: pass _newline_ else :pass
data = self
try :pass _newline_ except: pass
self . _post , self . _files = self . parse_file_upload ( self . META , data )
try: pass _newline_ except MultiPartParserError :pass
self . _mark_post_parse_error ( )
raise
if True: pass _newline_ elif self . META . get ( '_STR:0_' , '' ) . startswith ( '_STR:1_' ) :pass
self . _post , self . _files = QueryDict ( self . body , encoding = self . _encoding ) , MultiValueDict ( )
if True: pass _newline_ else :pass
self . _post , self . _files = QueryDict ( '' , encoding = self . _encoding ) , MultiValueDict ( )
def close ( self ) :pass
if hasattr ( self , '_STR:0_' ) :pass
for f in chain . from_iterable ( l [ 1 ] for l in self . _files . lists ( ) ) :pass
f . close ( )
def read ( self , * args , ** kwargs ) :pass
self . _read_started = True
try :pass _newline_ except: pass
return self . _stream . read ( * args , ** kwargs )
try: pass _newline_ except IOError as e :pass
six . reraise ( UnreadablePostError , UnreadablePostError ( * e . args ) , sys . exc_info ( ) [ 2 ] )
def readline ( self , * args , ** kwargs ) :pass
self . _read_started = True
try :pass _newline_ except: pass
return self . _stream . readline ( * args , ** kwargs )
try: pass _newline_ except IOError as e :pass
six . reraise ( UnreadablePostError , UnreadablePostError ( * e . args ) , sys . exc_info ( ) [ 2 ] )
def xreadlines ( self ) :pass
while True :pass
buf = self . readline ( )
if not buf :pass
break
yield buf
__iter__ = xreadlines
def readlines ( self ) :pass
return list ( iter ( self ) )
class QueryDict ( MultiValueDict ) :pass
_mutable = True
_encoding = None
def __init__ ( self , query_string = None , mutable = False , encoding = None ) :pass
super ( QueryDict , self ) . __init__ ( )
if not encoding :pass
encoding = settings . DEFAULT_CHARSET
self . encoding = encoding
if six . PY3 :pass
if isinstance ( query_string , bytes ) :pass
query_string = query_string . decode ( )
for key , value in parse_qsl ( query_string or '' ,  keep_blank_values = True ,  encoding = encoding ) :pass
self . appendlist ( key , value )
if True: pass _newline_ else :pass
for key , value in parse_qsl ( query_string or '' ,  keep_blank_values = True ) :pass
self . appendlist ( force_text ( key , encoding , errors = 'replace' ) ,  force_text ( value , encoding , errors = 'replace' ) )
self . _mutable = mutable
@ property _newline_ def dummy(): pass
def encoding ( self ) :pass
if self . _encoding is None :pass
self . _encoding = settings . DEFAULT_CHARSET
return self . _encoding
@ encoding . setter _newline_ def dummy(): pass
def encoding ( self , value ) :pass
self . _encoding = value
def _assert_mutable ( self ) :pass
if not self . _mutable :pass
raise AttributeError ( '_STR:0_' )
def __setitem__ ( self , key , value ) :pass
self . _assert_mutable ( )
key = bytes_to_text ( key , self . encoding )
value = bytes_to_text ( value , self . encoding )
super ( QueryDict , self ) . __setitem__ ( key , value )
def __delitem__ ( self , key ) :pass
self . _assert_mutable ( )
super ( QueryDict , self ) . __delitem__ ( key )
def __copy__ ( self ) :pass
result = self . __class__ ( '' , mutable = True , encoding = self . encoding )
for key , value in six . iterlists ( self ) :pass
result . setlist ( key , value )
return result
def __deepcopy__ ( self , memo ) :pass
result = self . __class__ ( '' , mutable = True , encoding = self . encoding )
memo [ id ( self ) ] = result
for key , value in six . iterlists ( self ) :pass
result . setlist ( copy . deepcopy ( key , memo ) , copy . deepcopy ( value , memo ) )
return result
def setlist ( self , key , list_ ) :pass
self . _assert_mutable ( )
key = bytes_to_text ( key , self . encoding )
list_ = [ bytes_to_text ( elt , self . encoding ) for elt in list_ ]
super ( QueryDict , self ) . setlist ( key , list_ )
def setlistdefault ( self , key , default_list = None ) :pass
self . _assert_mutable ( )
return super ( QueryDict , self ) . setlistdefault ( key , default_list )
def appendlist ( self , key , value ) :pass
self . _assert_mutable ( )
key = bytes_to_text ( key , self . encoding )
value = bytes_to_text ( value , self . encoding )
super ( QueryDict , self ) . appendlist ( key , value )
def pop ( self , key , * args ) :pass
self . _assert_mutable ( )
return super ( QueryDict , self ) . pop ( key , * args )
def popitem ( self ) :pass
self . _assert_mutable ( )
return super ( QueryDict , self ) . popitem ( )
def clear ( self ) :pass
self . _assert_mutable ( )
super ( QueryDict , self ) . clear ( )
def setdefault ( self , key , default = None ) :pass
self . _assert_mutable ( )
key = bytes_to_text ( key , self . encoding )
default = bytes_to_text ( default , self . encoding )
return super ( QueryDict , self ) . setdefault ( key , default )
def copy ( self ) :pass
return self . __deepcopy__ ( { } )
def urlencode ( self , safe = None ) :pass
output = [ ]
if safe :pass
safe = force_bytes ( safe , self . encoding )
encode = lambda k , v : '_STR:0_' % ( ( quote ( k , safe ) , quote ( v , safe ) ) )
if True: pass _newline_ else :pass
encode = lambda k , v : urlencode ( { k : v } )
for k , list_ in self . lists ( ) :pass
k = force_bytes ( k , self . encoding )
output . extend ( [ encode ( k , force_bytes ( v , self . encoding ) )  for v in list_ ] )
return '_STR:0_' . join ( output )
def build_request_repr ( request , path_override = None , GET_override = None ,  POST_override = None , COOKIES_override = None ,  META_override = None ) :pass
try :pass _newline_ except: pass
get = ( pformat ( GET_override )  if GET_override is not None  else pformat ( request . GET ) )
try: pass _newline_ except Exception :pass
get = '_STR:0_'
if request . _post_parse_error :pass
post = '_STR:0_'
if True: pass _newline_ else :pass
try :pass _newline_ except: pass
post = ( pformat ( POST_override )  if POST_override is not None  else pformat ( request . POST ) )
try: pass _newline_ except Exception :pass
post = '_STR:0_'
try :pass _newline_ except: pass
cookies = ( pformat ( COOKIES_override )  if COOKIES_override is not None  else pformat ( request . COOKIES ) )
try: pass _newline_ except Exception :pass
cookies = '_STR:0_'
try :pass _newline_ except: pass
meta = ( pformat ( META_override )  if META_override is not None  else pformat ( request . META ) )
try: pass _newline_ except Exception :pass
meta = '_STR:0_'
path = path_override if path_override is not None else request . path
return force_str ( '_STR:0_' %  ( request . __class__ . __name__ ,  path ,  six . text_type ( get ) ,  six . text_type ( post ) ,  six . text_type ( cookies ) ,  six . text_type ( meta ) ) )
def bytes_to_text ( s , encoding ) :pass
if isinstance ( s , bytes ) :pass
return six . text_type ( s , encoding , '_STR:0_' )
if True: pass _newline_ else :pass
return s
def split_domain_port ( host ) :pass
host = host . lower ( )
if not host_validation_re . match ( host ) :pass
return '' , ''
if host [ - 1 ] == '_STR:0_' :pass
return host , ''
bits = host . rsplit ( '_STR:0_' , 1 )
if len ( bits ) == 2 :pass
return tuple ( bits )
return bits [ 0 ] , ''
def validate_host ( host , allowed_hosts ) :pass
host = host [ : - 1 ] if host . endswith ( '_STR:0_' ) else host
for pattern in allowed_hosts :pass
pattern = pattern . lower ( )
match = (  pattern == '_STR:0_' or  pattern . startswith ( '_STR:1_' ) and (  host . endswith ( pattern ) or host == pattern [ 1 : ]  ) or  pattern == host  )
if match :pass
return True
return False
from __future__ import unicode_literals
import datetime
import json
import sys
import time
from email . header import Header
from django . conf import settings
from django . core import signals
from django . core import signing
from django . core . exceptions import DisallowedRedirect
from django . core . serializers . json import DjangoJSONEncoder
from django . http . cookie import SimpleCookie
from django . utils import six , timezone
from django . utils . encoding import force_bytes , force_text , iri_to_uri
from django . utils . http import cookie_date
from django . utils . six . moves import map
from django . utils . six . moves . urllib . parse import urlparse
REASON_PHRASES = {  100 : '_STR:0_' ,  101 : '_STR:1_' ,  102 : 'PROCESSING' ,  200 : 'OK' ,  201 : 'CREATED' ,  202 : 'ACCEPTED' ,  203 : 'NON-AUTHORITATIVE INFORMATION' ,  204 : 'NO CONTENT' ,  205 : 'RESET CONTENT' ,  206 : 'PARTIAL CONTENT' ,  207 : 'MULTI-STATUS' ,  208 : 'ALREADY REPORTED' ,  226 : 'IM USED' ,  300 : 'MULTIPLE CHOICES' ,  301 : 'MOVED PERMANENTLY' ,  302 : 'FOUND' ,  303 : 'SEE OTHER' ,  304 : 'NOT MODIFIED' ,  305 : 'USE PROXY' ,  306 : 'RESERVED' ,  307 : 'TEMPORARY REDIRECT' ,  308 : 'PERMANENT REDIRECT' ,  400 : 'BAD REQUEST' ,  401 : 'UNAUTHORIZED' ,  402 : 'PAYMENT REQUIRED' ,  403 : 'FORBIDDEN' ,  404 : 'NOT FOUND' ,  405 : 'METHOD NOT ALLOWED' ,  406 : 'NOT ACCEPTABLE' ,  407 : 'PROXY AUTHENTICATION REQUIRED' ,  408 : 'REQUEST TIMEOUT' ,  409 : 'CONFLICT' ,  410 : 'GONE' ,  411 : 'LENGTH REQUIRED' ,  412 : 'PRECONDITION FAILED' ,  413 : 'REQUEST ENTITY TOO LARGE' ,  414 : 'REQUEST-URI TOO LONG' ,  415 : 'UNSUPPORTED MEDIA TYPE' ,  416 : 'REQUESTED RANGE NOT SATISFIABLE' ,  417 : 'EXPECTATION FAILED' ,  418 : "I'M A TEAPOT" ,  422 : 'UNPROCESSABLE ENTITY' ,  423 : 'LOCKED' ,  424 : 'FAILED DEPENDENCY' ,  426 : 'UPGRADE REQUIRED' ,  428 : 'PRECONDITION REQUIRED' ,  429 : 'TOO MANY REQUESTS' ,  431 : 'REQUEST HEADER FIELDS TOO LARGE' ,  500 : 'INTERNAL SERVER ERROR' ,  501 : 'NOT IMPLEMENTED' ,  502 : 'BAD GATEWAY' ,  503 : 'SERVICE UNAVAILABLE' ,  504 : 'GATEWAY TIMEOUT' ,  505 : 'HTTP VERSION NOT SUPPORTED' ,  506 : 'VARIANT ALSO NEGOTIATES' ,  507 : 'INSUFFICIENT STORAGE' ,  508 : 'LOOP DETECTED' ,  510 : 'NOT EXTENDED' ,  511 : 'NETWORK AUTHENTICATION REQUIRED' ,  }
class BadHeaderError ( ValueError ) :pass
pass
class HttpResponseBase ( six . Iterator ) :pass
status_code = 200
reason_phrase = None
def __init__ ( self , content_type = None , status = None , reason = None ) :pass
self . _headers = { }
self . _charset = settings . DEFAULT_CHARSET
self . _closable_objects = [ ]
self . _handler_class = None
if not content_type :pass
content_type = '_STR:0_' % ( settings . DEFAULT_CONTENT_TYPE ,  self . _charset )
self . cookies = SimpleCookie ( )
if status is not None :pass
self . status_code = status
if reason is not None :pass
self . reason_phrase = reason
if True: pass _newline_ elif self . reason_phrase is None :pass
self . reason_phrase = REASON_PHRASES . get ( self . status_code ,  'UNKNOWN STATUS CODE' )
self [ '_STR:1_' ] = content_type
def serialize_headers ( self ) :pass
def to_bytes ( val , encoding ) :pass
return val if isinstance ( val , bytes ) else val . encode ( encoding )
headers = [  ( b': ' . join ( [ to_bytes ( key , 'ascii' ) , to_bytes ( value , 'latin-1' ) ] ) )  for key , value in self . _headers . values ( )  ]
return b'_STR:3_' . join ( headers )
if six . PY3 :pass
__bytes__ = serialize_headers
if True: pass _newline_ else :pass
__str__ = serialize_headers
def _convert_to_charset ( self , value , charset , mime_encode = False ) :pass
if not isinstance ( value , ( bytes , six . text_type ) ) :pass
value = str ( value )
try :pass _newline_ except: pass
if six . PY3 :pass
if isinstance ( value , str ) :pass
value . encode ( charset )
if True: pass _newline_ else :pass
value = value . decode ( charset )
if True: pass _newline_ else :pass
if isinstance ( value , str ) :pass
value . decode ( charset )
if True: pass _newline_ else :pass
value = value . encode ( charset )
try: pass _newline_ except UnicodeError as e :pass
if mime_encode :pass
value = str ( Header ( value , '_STR:0_' , maxlinelen = sys . maxsize ) . encode ( ) )
if True: pass _newline_ else :pass
e . reason += '_STR:0_' % charset
raise
if str ( '_STR:0_' ) in value or str ( '_STR:1_' ) in value :pass
raise BadHeaderError ( '_STR:0_' % value )
return value
def __setitem__ ( self , header , value ) :pass
header = self . _convert_to_charset ( header , '_STR:0_' )
value = self . _convert_to_charset ( value , '_STR:0_' , mime_encode = True )
self . _headers [ header . lower ( ) ] = ( header , value )
def __delitem__ ( self , header ) :pass
try :pass _newline_ except: pass
del self . _headers [ header . lower ( ) ]
try: pass _newline_ except KeyError :pass
pass
def __getitem__ ( self , header ) :pass
return self . _headers [ header . lower ( ) ] [ 1 ]
def __getstate__ ( self ) :pass
state = self . __dict__ . copy ( )
state [ '_STR:0_' ] = str ( state [ '_STR:0_' ] )
return state
def __setstate__ ( self , state ) :pass
self . __dict__ . update ( state )
self . cookies = SimpleCookie ( self . cookies )
def has_header ( self , header ) :pass
return header . lower ( ) in self . _headers
__contains__ = has_header
def items ( self ) :pass
return self . _headers . values ( )
def get ( self , header , alternate = None ) :pass
return self . _headers . get ( header . lower ( ) , ( None , alternate ) ) [ 1 ]
def set_cookie ( self , key , value = '' , max_age = None , expires = None , path = '/' ,  domain = None , secure = False , httponly = False ) :pass
self . cookies [ key ] = value
if expires is not None :pass
if isinstance ( expires , datetime . datetime ) :pass
if timezone . is_aware ( expires ) :pass
expires = timezone . make_naive ( expires , timezone . utc )
delta = expires - expires . utcnow ( )
delta = delta + datetime . timedelta ( seconds = 1 )
expires = None
max_age = max ( 0 , delta . days * 86400 + delta . seconds )
if True: pass _newline_ else :pass
self . cookies [ key ] [ '_STR:0_' ] = expires
if max_age is not None :pass
self . cookies [ key ] [ '_STR:0_' ] = max_age
if not expires :pass
self . cookies [ key ] [ 'expires' ] = cookie_date ( time . time ( ) +  max_age )
if path is not None :pass
self . cookies [ key ] [ '_STR:0_' ] = path
if domain is not None :pass
self . cookies [ key ] [ '_STR:0_' ] = domain
if secure :pass
self . cookies [ key ] [ '_STR:0_' ] = True
if httponly :pass
self . cookies [ key ] [ '_STR:0_' ] = True
def set_signed_cookie ( self , key , value , salt = '' , ** kwargs ) :pass
value = signing . get_cookie_signer ( salt = key + salt ) . sign ( value )
return self . set_cookie ( key , value , ** kwargs )
def delete_cookie ( self , key , path = '_STR:0_' , domain = None ) :pass
self . set_cookie ( key , max_age = 0 , path = path , domain = domain ,  expires = 'Thu, 01-Jan-1970 00:00:00 GMT' )
def make_bytes ( self , value ) :pass
if self . has_header ( '_STR:0_' ) :pass
return bytes ( value )
if isinstance ( value , bytes ) :pass
return bytes ( value )
if isinstance ( value , six . text_type ) :pass
return bytes ( value . encode ( self . _charset ) )
return force_bytes ( value , self . _charset )
def close ( self ) :pass
for closable in self . _closable_objects :pass
try :pass _newline_ except: pass
closable . close ( )
try: pass _newline_ except Exception :pass
pass
signals . request_finished . send ( sender = self . _handler_class )
def write ( self , content ) :pass
raise Exception ( '_STR:0_' % self . __class__ . __name__ )
def flush ( self ) :pass
pass
def tell ( self ) :pass
raise Exception ( '_STR:0_' % self . __class__ . __name__ )
class HttpResponse ( HttpResponseBase ) :pass
streaming = False
def __init__ ( self , content = b'' , * args , ** kwargs ) :pass
super ( HttpResponse , self ) . __init__ ( * args , ** kwargs )
self . content = content
def serialize ( self ) :pass
return self . serialize_headers ( ) + b'_STR:0_' + self . content
if six . PY3 :pass
__bytes__ = serialize
if True: pass _newline_ else :pass
__str__ = serialize
@ property _newline_ def dummy(): pass
def content ( self ) :pass
return b'' . join ( self . _container )
@ content . setter _newline_ def dummy(): pass
def content ( self , value ) :pass
if hasattr ( value , '_STR:0_' ) and not isinstance ( value , ( bytes , six . string_types ) ) :pass
if hasattr ( value , '_STR:0_' ) :pass
self . _closable_objects . append ( value )
value = b'' . join ( self . make_bytes ( chunk ) for chunk in value )
if True: pass _newline_ else :pass
value = self . make_bytes ( value )
self . _container = [ value ]
def __iter__ ( self ) :pass
return iter ( self . _container )
def write ( self , content ) :pass
self . _container . append ( self . make_bytes ( content ) )
def tell ( self ) :pass
return len ( self . content )
class StreamingHttpResponse ( HttpResponseBase ) :pass
streaming = True
def __init__ ( self , streaming_content = ( ) , * args , ** kwargs ) :pass
super ( StreamingHttpResponse , self ) . __init__ ( * args , ** kwargs )
self . streaming_content = streaming_content
@ property _newline_ def dummy(): pass
def content ( self ) :pass
raise AttributeError ( '_STR:0_'  "Use `streaming_content` instead." % self . __class__ . __name__ )
@ property _newline_ def dummy(): pass
def streaming_content ( self ) :pass
return map ( self . make_bytes , self . _iterator )
@ streaming_content . setter _newline_ def dummy(): pass
def streaming_content ( self , value ) :pass
self . _iterator = iter ( value )
if hasattr ( value , '_STR:0_' ) :pass
self . _closable_objects . append ( value )
def __iter__ ( self ) :pass
return self . streaming_content
class HttpResponseRedirectBase ( HttpResponse ) :pass
allowed_schemes = [ '_STR:0_' , '_STR:1_' , '_STR:2_' ]
def __init__ ( self , redirect_to , * args , ** kwargs ) :pass
parsed = urlparse ( force_text ( redirect_to ) )
if parsed . scheme and parsed . scheme not in self . allowed_schemes :pass
raise DisallowedRedirect ( '_STR:0_' % parsed . scheme )
super ( HttpResponseRedirectBase , self ) . __init__ ( * args , ** kwargs )
self [ '_STR:0_' ] = iri_to_uri ( redirect_to )
url = property ( lambda self : self [ '_STR:0_' ] )
class HttpResponseRedirect ( HttpResponseRedirectBase ) :pass
status_code = 302
class HttpResponsePermanentRedirect ( HttpResponseRedirectBase ) :pass
status_code = 301
class HttpResponseNotModified ( HttpResponse ) :pass
status_code = 304
def __init__ ( self , * args , ** kwargs ) :pass
super ( HttpResponseNotModified , self ) . __init__ ( * args , ** kwargs )
del self [ '_STR:0_' ]
@ HttpResponse . content . setter _newline_ def dummy(): pass
def content ( self , value ) :pass
if value :pass
raise AttributeError ( '_STR:0_' )
self . _container = [ ]
class HttpResponseBadRequest ( HttpResponse ) :pass
status_code = 400
class HttpResponseNotFound ( HttpResponse ) :pass
status_code = 404
class HttpResponseForbidden ( HttpResponse ) :pass
status_code = 403
class HttpResponseNotAllowed ( HttpResponse ) :pass
status_code = 405
def __init__ ( self , permitted_methods , * args , ** kwargs ) :pass
super ( HttpResponseNotAllowed , self ) . __init__ ( * args , ** kwargs )
self [ '_STR:1_' ] = '_STR:0_' . join ( permitted_methods )
class HttpResponseGone ( HttpResponse ) :pass
status_code = 410
class HttpResponseServerError ( HttpResponse ) :pass
status_code = 500
class Http404 ( Exception ) :pass
pass
class JsonResponse ( HttpResponse ) :pass
def __init__ ( self , data , encoder = DjangoJSONEncoder , safe = True , ** kwargs ) :pass
if safe and not isinstance ( data , dict ) :pass
raise TypeError ( 'In order to allow non-dict objects to be '  'serialized set the safe parameter to False' )
kwargs . setdefault ( '_STR:0_' , '_STR:1_' )
data = json . dumps ( data , cls = encoder )
super ( JsonResponse , self ) . __init__ ( content = data , ** kwargs )
def fix_location_header ( request , response ) :pass
if '_STR:0_' in response and request . get_host ( ) :pass
response [ '_STR:0_' ] = request . build_absolute_uri ( response [ '_STR:0_' ] )
return response
def conditional_content_removal ( request , response ) :pass
if 100 <= response . status_code < 200 or response . status_code in ( 204 , 304 ) :pass
if response . streaming :pass
response . streaming_content = [ ]
if True: pass _newline_ else :pass
response . content = b''
response [ '_STR:1_' ] = '_STR:0_'
if request . method == '_STR:0_' :pass
if response . streaming :pass
response . streaming_content = [ ]
if True: pass _newline_ else :pass
response . content = b''
return response
from django . template . base import ( ALLOWED_VARIABLE_CHARS , BLOCK_TAG_END ,  BLOCK_TAG_START , COMMENT_TAG_END , COMMENT_TAG_START ,  FILTER_ARGUMENT_SEPARATOR , FILTER_SEPARATOR , SINGLE_BRACE_END ,  SINGLE_BRACE_START , TOKEN_BLOCK , TOKEN_COMMENT , TOKEN_TEXT , TOKEN_VAR ,  TRANSLATOR_COMMENT_MARK , UNKNOWN_SOURCE , VARIABLE_ATTRIBUTE_SEPARATOR ,  VARIABLE_TAG_END , VARIABLE_TAG_START , filter_re , tag_re )
from django . template . base import ( ContextPopException , InvalidTemplateLibrary ,  TemplateDoesNotExist , TemplateEncodingError , TemplateSyntaxError ,  VariableDoesNotExist )
from django . template . base import ( Context , FilterExpression , Lexer , Node ,  NodeList , Parser , RequestContext , Origin , StringOrigin , Template ,  TextNode , Token , TokenParser , Variable , VariableNode , constant_string ,  filter_raw_string )
from django . template . base import ( compile_string , resolve_variable ,  unescape_string_literal , generic_tag_compiler )
from django . template . base import ( Library , add_to_builtins , builtins ,  get_library , get_templatetags_modules , get_text_list , import_library ,  libraries )
__all__ = ( '_STR:0_' , '_STR:1_' , '_STR:2_' , '_STR:3_' )
from __future__ import unicode_literals
import re
from functools import partial
from importlib import import_module
from inspect import getargspec , getcallargs
import warnings
from django . apps import apps
from django . conf import settings
from django . template . context import ( BaseContext , Context , RequestContext ,  ContextPopException )
from django . utils . deprecation import RemovedInDjango20Warning
from django . utils . itercompat import is_iterable
from django . utils . text import ( smart_split , unescape_string_literal ,  get_text_list )
from django . utils . encoding import force_str , force_text
from django . utils . translation import ugettext_lazy , pgettext_lazy
from django . utils . safestring import ( SafeData , EscapeData , mark_safe ,  mark_for_escaping )
from django . utils . formats import localize
from django . utils . html import escape
from django . utils . module_loading import module_has_submodule
from django . utils import six
from django . utils . timezone import template_localtime
from django . utils . encoding import python_2_unicode_compatible
TOKEN_TEXT = 0
TOKEN_VAR = 1
TOKEN_BLOCK = 2
TOKEN_COMMENT = 3
TOKEN_MAPPING = {  TOKEN_TEXT : '_STR:0_' ,  TOKEN_VAR : '_STR:1_' ,  TOKEN_BLOCK : '_STR:2_' ,  TOKEN_COMMENT : 'Comment' ,  }
FILTER_SEPARATOR = '_STR:1_'
FILTER_ARGUMENT_SEPARATOR = '_STR:0_'
VARIABLE_ATTRIBUTE_SEPARATOR = '_STR:0_'
BLOCK_TAG_START = '_STR:0_'
BLOCK_TAG_END = '_STR:0_'
VARIABLE_TAG_START = '_STR:0_'
VARIABLE_TAG_END = '_STR:0_'
COMMENT_TAG_START = '_STR:0_'
COMMENT_TAG_END = '_STR:0_'
TRANSLATOR_COMMENT_MARK = '_STR:0_'
SINGLE_BRACE_START = '_STR:0_'
SINGLE_BRACE_END = '_STR:0_'
ALLOWED_VARIABLE_CHARS = ( 'abcdefghijklmnopqrstuvwxyz'  'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.' )
UNKNOWN_SOURCE = '_STR:0_'
tag_re = ( re . compile ( '_STR:0_' %  ( re . escape ( BLOCK_TAG_START ) , re . escape ( BLOCK_TAG_END ) ,  re . escape ( VARIABLE_TAG_START ) , re . escape ( VARIABLE_TAG_END ) ,  re . escape ( COMMENT_TAG_START ) , re . escape ( COMMENT_TAG_END ) ) ) )
libraries = { }
builtins = [ ]
invalid_var_format_string = None
class TemplateSyntaxError ( Exception ) :pass
pass
class TemplateDoesNotExist ( Exception ) :pass
pass
class TemplateEncodingError ( Exception ) :pass
pass
@ python_2_unicode_compatible _newline_ def dummy(): pass
class VariableDoesNotExist ( Exception ) :pass
def __init__ ( self , msg , params = ( ) ) :pass
self . msg = msg
self . params = params
def __str__ ( self ) :pass
return self . msg % tuple ( force_text ( p , errors = 'replace' ) for p in self . params )
class InvalidTemplateLibrary ( Exception ) :pass
pass
class Origin ( object ) :pass
def __init__ ( self , name ) :pass
self . name = name
def reload ( self ) :pass
raise NotImplementedError ( '_STR:0_' )
def __str__ ( self ) :pass
return self . name
class StringOrigin ( Origin ) :pass
def __init__ ( self , source ) :pass
super ( StringOrigin , self ) . __init__ ( UNKNOWN_SOURCE )
self . source = source
def reload ( self ) :pass
return self . source
class Template ( object ) :pass
def __init__ ( self , template_string , origin = None , name = None ) :pass
try :pass _newline_ except: pass
template_string = force_text ( template_string )
try: pass _newline_ except UnicodeDecodeError :pass
raise TemplateEncodingError ( "Templates can only be constructed "  "from unicode or UTF-8 strings." )
if settings . TEMPLATE_DEBUG and origin is None :pass
origin = StringOrigin ( template_string )
self . nodelist = compile_string ( template_string , origin )
self . name = name
self . origin = origin
def __iter__ ( self ) :pass
for node in self . nodelist :pass
for subnode in node :pass
yield subnode
def _render ( self , context ) :pass
return self . nodelist . render ( context )
def render ( self , context ) :pass
context . render_context . push ( )
try :pass _newline_ except: pass
return self . _render ( context )
try: pass _newline_ finally :pass
context . render_context . pop ( )
def compile_string ( template_string , origin ) :pass
if settings . TEMPLATE_DEBUG :pass
from django . template . debug import DebugLexer , DebugParser
lexer_class , parser_class = DebugLexer , DebugParser
if True: pass _newline_ else :pass
lexer_class , parser_class = Lexer , Parser
lexer = lexer_class ( template_string , origin )
parser = parser_class ( lexer . tokenize ( ) )
return parser . parse ( )
class Token ( object ) :pass
def __init__ ( self , token_type , contents ) :pass
self . token_type , self . contents = token_type , contents
self . lineno = None
def __str__ ( self ) :pass
token_name = TOKEN_MAPPING [ self . token_type ]
return ( '_STR:0_' %  ( token_name , self . contents [ : 20 ] . replace ( '\n' , '' ) ) )
def split_contents ( self ) :pass
split = [ ]
bits = iter ( smart_split ( self . contents ) )
for bit in bits :pass
if bit . startswith ( '_STR:0_' ) or bit . startswith ( '_STR:1_' ) :pass
sentinal = bit [ 2 ] + '_STR:0_'
trans_bit = [ bit ]
while not bit . endswith ( sentinal ) :pass
bit = next ( bits )
trans_bit . append ( bit )
bit = ' ' . join ( trans_bit )
split . append ( bit )
return split
class Lexer ( object ) :pass
def __init__ ( self , template_string , origin ) :pass
self . template_string = template_string
self . origin = origin
self . lineno = 1
self . verbatim = False
def tokenize ( self ) :pass
in_tag = False
result = [ ]
for bit in tag_re . split ( self . template_string ) :pass
if bit :pass
result . append ( self . create_token ( bit , in_tag ) )
in_tag = not in_tag
return result
def create_token ( self , token_string , in_tag ) :pass
if in_tag and token_string . startswith ( BLOCK_TAG_START ) :pass
block_content = token_string [ 2 : - 2 ] . strip ( )
if self . verbatim and block_content == self . verbatim :pass
self . verbatim = False
if in_tag and not self . verbatim :pass
if token_string . startswith ( VARIABLE_TAG_START ) :pass
token = Token ( TOKEN_VAR , token_string [ 2 : - 2 ] . strip ( ) )
if True: pass _newline_ elif token_string . startswith ( BLOCK_TAG_START ) :pass
if block_content [ : 9 ] in ( '_STR:0_' , '_STR:1_' ) :pass
self . verbatim = 'end%s' % block_content
token = Token ( TOKEN_BLOCK , block_content )
if True: pass _newline_ elif token_string . startswith ( COMMENT_TAG_START ) :pass
content = ''
if token_string . find ( TRANSLATOR_COMMENT_MARK ) :pass
content = token_string [ 2 : - 2 ] . strip ( )
token = Token ( TOKEN_COMMENT , content )
if True: pass _newline_ else :pass
token = Token ( TOKEN_TEXT , token_string )
token . lineno = self . lineno
self . lineno += token_string . count ( '_STR:0_' )
return token
class Parser ( object ) :pass
def __init__ ( self , tokens ) :pass
self . tokens = tokens
self . tags = { }
self . filters = { }
for lib in builtins :pass
self . add_library ( lib )
def parse ( self , parse_until = None ) :pass
if parse_until is None :pass
parse_until = [ ]
nodelist = self . create_nodelist ( )
while self . tokens :pass
token = self . next_token ( )
if token . token_type == 0 :pass
self . extend_nodelist ( nodelist , TextNode ( token . contents ) , token )
if True: pass _newline_ elif token . token_type == 1 :pass
if not token . contents :pass
self . empty_variable ( token )
try :pass _newline_ except: pass
filter_expression = self . compile_filter ( token . contents )
try: pass _newline_ except TemplateSyntaxError as e :pass
if not self . compile_filter_error ( token , e ) :pass
raise
var_node = self . create_variable_node ( filter_expression )
self . extend_nodelist ( nodelist , var_node , token )
if True: pass _newline_ elif token . token_type == 2 :pass
try :pass _newline_ except: pass
command = token . contents . split ( ) [ 0 ]
try: pass _newline_ except IndexError :pass
self . empty_block_tag ( token )
if command in parse_until :pass
self . prepend_token ( token )
return nodelist
self . enter_command ( command , token )
try :pass _newline_ except: pass
compile_func = self . tags [ command ]
try: pass _newline_ except KeyError :pass
self . invalid_block_tag ( token , command , parse_until )
try :pass _newline_ except: pass
compiled_result = compile_func ( self , token )
try: pass _newline_ except TemplateSyntaxError as e :pass
if not self . compile_function_error ( token , e ) :pass
raise
self . extend_nodelist ( nodelist , compiled_result , token )
self . exit_command ( )
if parse_until :pass
self . unclosed_block_tag ( parse_until )
return nodelist
def skip_past ( self , endtag ) :pass
while self . tokens :pass
token = self . next_token ( )
if token . token_type == TOKEN_BLOCK and token . contents == endtag :pass
return
self . unclosed_block_tag ( [ endtag ] )
def create_variable_node ( self , filter_expression ) :pass
return VariableNode ( filter_expression )
def create_nodelist ( self ) :pass
return NodeList ( )
def extend_nodelist ( self , nodelist , node , token ) :pass
if node . must_be_first and nodelist :pass
try :pass _newline_ except: pass
if nodelist . contains_nontext :pass
raise AttributeError
try: pass _newline_ except AttributeError :pass
raise TemplateSyntaxError ( "%r must be the first tag "  "in the template." % node )
if isinstance ( nodelist , NodeList ) and not isinstance ( node , TextNode ) :pass
nodelist . contains_nontext = True
nodelist . append ( node )
def enter_command ( self , command , token ) :pass
pass
def exit_command ( self ) :pass
pass
def error ( self , token , msg ) :pass
return TemplateSyntaxError ( msg )
def empty_variable ( self , token ) :pass
raise self . error ( token , '_STR:0_' )
def empty_block_tag ( self , token ) :pass
raise self . error ( token , '_STR:0_' )
def invalid_block_tag ( self , token , command , parse_until = None ) :pass
if parse_until :pass
raise self . error ( token , '_STR:0_' %  ( command , get_text_list ( [ "'%s'" % p for p in parse_until ] ) ) )
raise self . error ( token , '_STR:0_' % command )
def unclosed_block_tag ( self , parse_until ) :pass
raise self . error ( None , '_STR:0_' % ', ' . join ( parse_until ) )
def compile_filter_error ( self , token , e ) :pass
pass
def compile_function_error ( self , token , e ) :pass
pass
def next_token ( self ) :pass
return self . tokens . pop ( 0 )
def prepend_token ( self , token ) :pass
self . tokens . insert ( 0 , token )
def delete_first_token ( self ) :pass
del self . tokens [ 0 ]
def add_library ( self , lib ) :pass
self . tags . update ( lib . tags )
self . filters . update ( lib . filters )
def compile_filter ( self , token ) :pass
return FilterExpression ( token , self )
def find_filter ( self , filter_name ) :pass
if filter_name in self . filters :pass
return self . filters [ filter_name ]
if True: pass _newline_ else :pass
raise TemplateSyntaxError ( '_STR:0_' % filter_name )
class TokenParser ( object ) :pass
def __init__ ( self , subject ) :pass
self . subject = subject
self . pointer = 0
self . backout = [ ]
self . tagname = self . tag ( )
def top ( self ) :pass
raise NotImplementedError ( '_STR:0_' )
def more ( self ) :pass
return self . pointer < len ( self . subject )
def back ( self ) :pass
if not len ( self . backout ) :pass
raise TemplateSyntaxError ( "back called without some previous "  "parsing" )
self . pointer = self . backout . pop ( )
def tag ( self ) :pass
subject = self . subject
i = self . pointer
if i >= len ( subject ) :pass
raise TemplateSyntaxError ( "expected another tag, found "  "end of string: %s" % subject )
p = i
while i < len ( subject ) and subject [ i ] not in ( ' ' , '\t' ) :pass
i += 1
s = subject [ p : i ]
while i < len ( subject ) and subject [ i ] in ( ' ' , '\t' ) :pass
i += 1
self . backout . append ( self . pointer )
self . pointer = i
return s
def value ( self ) :pass
subject = self . subject
i = self . pointer
def next_space_index ( subject , i ) :pass
while i < len ( subject ) and subject [ i ] not in ( ' ' , '\t' ) :pass
if subject [ i ] in ( '_STR:0_' , '_STR:1_' ) :pass
c = subject [ i ]
i += 1
while i < len ( subject ) and subject [ i ] != c :pass
i += 1
if i >= len ( subject ) :pass
raise TemplateSyntaxError ( "Searching for value. "  "Unexpected end of string in column %d: %s" %  ( i , subject ) )
i += 1
return i
if i >= len ( subject ) :pass
raise TemplateSyntaxError ( "Searching for value. Expected another "  "value but found end of string: %s" %  subject )
if subject [ i ] in ( '_STR:0_' , '_STR:1_' ) :pass
p = i
i += 1
while i < len ( subject ) and subject [ i ] != subject [ p ] :pass
i += 1
if i >= len ( subject ) :pass
raise TemplateSyntaxError ( "Searching for value. Unexpected "  "end of string in column %d: %s" %  ( i , subject ) )
i += 1
i = next_space_index ( subject , i )
res = subject [ p : i ]
while i < len ( subject ) and subject [ i ] in ( ' ' , '\t' ) :pass
i += 1
self . backout . append ( self . pointer )
self . pointer = i
return res
if True: pass _newline_ else :pass
p = i
i = next_space_index ( subject , i )
s = subject [ p : i ]
while i < len ( subject ) and subject [ i ] in ( ' ' , '\t' ) :pass
i += 1
self . backout . append ( self . pointer )
self . pointer = i
return s
constant_string = r""" (?:%(i18n_open)s%(strdq)s%(i18n_close)s| %(i18n_open)s%(strsq)s%(i18n_close)s| %(strdq)s| %(strsq)s) """ % {  'strdq' : r'"[^"\\]*(?:\\.[^"\\]*)*"' ,  'strsq' : r"'[^'\\]*(?:\\.[^'\\]*)*'" ,  'i18n_open' : re . escape ( "_(" ) ,  'i18n_close' : re . escape ( ")" ) ,  }
constant_string = constant_string . replace ( "\n" , "" )
filter_raw_string = r""" ^(?P<constant>%(constant)s)| ^(?P<var>[%(var_chars)s]+|%(num)s)|  (?:\s*%(filter_sep)s\s*      (?P<filter_name>\w+)          (?:%(arg_sep)s              (?:               (?P<constant_arg>%(constant)s)|               (?P<var_arg>[%(var_chars)s]+|%(num)s)              )          )?  )""" % {  'constant' : constant_string ,  'num' : r'[-+\.]?\d[\d\.e]*' ,  'var_chars' : "\w\." ,  'filter_sep' : re . escape ( FILTER_SEPARATOR ) ,  'arg_sep' : re . escape ( FILTER_ARGUMENT_SEPARATOR ) ,  }
filter_re = re . compile ( filter_raw_string , re . UNICODE | re . VERBOSE )
class FilterExpression ( object ) :pass
def __init__ ( self , token , parser ) :pass
self . token = token
matches = filter_re . finditer ( token )
var_obj = None
filters = [ ]
upto = 0
for match in matches :pass
start = match . start ( )
if upto != start :pass
raise TemplateSyntaxError ( "Could not parse some characters: "  "%s|%s|%s" %  ( token [ : upto ] , token [ upto : start ] ,  token [ start : ] ) )
if var_obj is None :pass
var , constant = match . group ( '_STR:0_' , '_STR:1_' )
if constant :pass
try :pass _newline_ except: pass
var_obj = Variable ( constant ) . resolve ( { } )
try: pass _newline_ except VariableDoesNotExist :pass
var_obj = None
if True: pass _newline_ elif var is None :pass
raise TemplateSyntaxError ( "Could not find variable at "  "start of %s." % token )
if True: pass _newline_ else :pass
var_obj = Variable ( var )
if True: pass _newline_ else :pass
filter_name = match . group ( '_STR:0_' )
args = [ ]
constant_arg , var_arg = match . group ( '_STR:0_' , '_STR:1_' )
if constant_arg :pass
args . append ( ( False , Variable ( constant_arg ) . resolve ( { } ) ) )
if True: pass _newline_ elif var_arg :pass
args . append ( ( True , Variable ( var_arg ) ) )
filter_func = parser . find_filter ( filter_name )
self . args_check ( filter_name , filter_func , args )
filters . append ( ( filter_func , args ) )
upto = match . end ( )
if upto != len ( token ) :pass
raise TemplateSyntaxError ( "Could not parse the remainder: '%s' "  "from '%s'" % ( token [ upto : ] , token ) )
self . filters = filters
self . var = var_obj
def resolve ( self , context , ignore_failures = False ) :pass
if isinstance ( self . var , Variable ) :pass
try :pass _newline_ except: pass
obj = self . var . resolve ( context )
try: pass _newline_ except VariableDoesNotExist :pass
if ignore_failures :pass
obj = None
if True: pass _newline_ else :pass
if settings . TEMPLATE_STRING_IF_INVALID :pass
global invalid_var_format_string
if invalid_var_format_string is None :pass
invalid_var_format_string = '%s' in settings . TEMPLATE_STRING_IF_INVALID
if invalid_var_format_string :pass
return settings . TEMPLATE_STRING_IF_INVALID % self . var
return settings . TEMPLATE_STRING_IF_INVALID
if True: pass _newline_ else :pass
obj = settings . TEMPLATE_STRING_IF_INVALID
if True: pass _newline_ else :pass
obj = self . var
for func , args in self . filters :pass
arg_vals = [ ]
for lookup , arg in args :pass
if not lookup :pass
arg_vals . append ( mark_safe ( arg ) )
if True: pass _newline_ else :pass
arg_vals . append ( arg . resolve ( context ) )
if getattr ( func , '_STR:0_' , False ) :pass
obj = template_localtime ( obj , context . use_tz )
if getattr ( func , '_STR:0_' , False ) :pass
new_obj = func ( obj , autoescape = context . autoescape , * arg_vals )
if True: pass _newline_ else :pass
new_obj = func ( obj , * arg_vals )
if getattr ( func , '_STR:0_' , False ) and isinstance ( obj , SafeData ) :pass
obj = mark_safe ( new_obj )
if True: pass _newline_ elif isinstance ( obj , EscapeData ) :pass
obj = mark_for_escaping ( new_obj )
if True: pass _newline_ else :pass
obj = new_obj
return obj
def args_check ( name , func , provided ) :pass
provided = list ( provided )
plen = len ( provided ) + 1
func = getattr ( func , '_STR:0_' , func )
args , varargs , varkw , defaults = getargspec ( func )
alen = len ( args )
dlen = len ( defaults or [ ] )
if plen < ( alen - dlen ) or plen > alen :pass
raise TemplateSyntaxError ( '_STR:0_' %  ( name , alen - dlen , plen ) )
return True
args_check = staticmethod ( args_check )
def __str__ ( self ) :pass
return self . token
def resolve_variable ( path , context ) :pass
warnings . warn ( "resolve_variable() is deprecated. Use django.template."  "Variable(path).resolve(context) instead" ,  RemovedInDjango20Warning , stacklevel = 2 )
return Variable ( path ) . resolve ( context )
class Variable ( object ) :pass
def __init__ ( self , var ) :pass
self . var = var
self . literal = None
self . lookups = None
self . translate = False
self . message_context = None
if not isinstance ( var , six . string_types ) :pass
raise TypeError (  '_STR:0_' % type ( var ) )
try :pass _newline_ except: pass
self . literal = float ( var )
if '_STR:0_' not in var and '_STR:1_' not in var . lower ( ) :pass
self . literal = int ( self . literal )
if var . endswith ( '_STR:0_' ) :pass
raise ValueError
try: pass _newline_ except ValueError :pass
if var . startswith ( '_STR:0_' ) and var . endswith ( '_STR:1_' ) :pass
self . translate = True
var = var [ 2 : - 1 ]
try :pass _newline_ except: pass
self . literal = mark_safe ( unescape_string_literal ( var ) )
try: pass _newline_ except ValueError :pass
if var . find ( VARIABLE_ATTRIBUTE_SEPARATOR + '_STR:0_' ) > - 1 or var [ 0 ] == '_STR:0_' :pass
raise TemplateSyntaxError ( "Variables and attributes may "  "not begin with underscores: '%s'" %  var )
self . lookups = tuple ( var . split ( VARIABLE_ATTRIBUTE_SEPARATOR ) )
def resolve ( self , context ) :pass
if self . lookups is not None :pass
value = self . _resolve_lookup ( context )
if True: pass _newline_ else :pass
value = self . literal
if self . translate :pass
if self . message_context :pass
return pgettext_lazy ( self . message_context , value )
if True: pass _newline_ else :pass
return ugettext_lazy ( value )
return value
def __repr__ ( self ) :pass
return '_STR:0_' % ( self . __class__ . __name__ , self . var )
def __str__ ( self ) :pass
return self . var
def _resolve_lookup ( self , context ) :pass
current = context
try :pass _newline_ except: pass
for bit in self . lookups :pass
try :pass _newline_ except: pass
current = current [ bit ]
try: pass _newline_ except ( TypeError , AttributeError , KeyError , ValueError ) :pass
try :pass _newline_ except: pass
if isinstance ( current , BaseContext ) and getattr ( type ( current ) , bit ) :pass
raise AttributeError
current = getattr ( current , bit )
try: pass _newline_ except ( TypeError , AttributeError ) :pass
try :pass _newline_ except: pass
current = current [ int ( bit ) ]
try: pass _newline_ except ( IndexError ,  ValueError ,  KeyError ,  TypeError ) :pass
raise VariableDoesNotExist ( "Failed lookup for key "  "[%s] in %r" ,  ( bit , current ) )
if callable ( current ) :pass
if getattr ( current , '_STR:0_' , False ) :pass
pass
if True: pass _newline_ elif getattr ( current , '_STR:0_' , False ) :pass
current = settings . TEMPLATE_STRING_IF_INVALID
if True: pass _newline_ else :pass
try :pass _newline_ except: pass
current = current ( )
try: pass _newline_ except TypeError :pass
try :pass _newline_ except: pass
getcallargs ( current )
try: pass _newline_ except TypeError :pass
current = settings . TEMPLATE_STRING_IF_INVALID
if True: pass _newline_ else :pass
raise
try: pass _newline_ except Exception as e :pass
if getattr ( e , '_STR:0_' , False ) :pass
current = settings . TEMPLATE_STRING_IF_INVALID
if True: pass _newline_ else :pass
raise
return current
class Node ( object ) :pass
must_be_first = False
child_nodelists = ( '_STR:0_' , )
def render ( self , context ) :pass
pass
def __iter__ ( self ) :pass
yield self
def get_nodes_by_type ( self , nodetype ) :pass
nodes = [ ]
if isinstance ( self , nodetype ) :pass
nodes . append ( self )
for attr in self . child_nodelists :pass
nodelist = getattr ( self , attr , None )
if nodelist :pass
nodes . extend ( nodelist . get_nodes_by_type ( nodetype ) )
return nodes
class NodeList ( list ) :pass
contains_nontext = False
def render ( self , context ) :pass
bits = [ ]
for node in self :pass
if isinstance ( node , Node ) :pass
bit = self . render_node ( node , context )
if True: pass _newline_ else :pass
bit = node
bits . append ( force_text ( bit ) )
return mark_safe ( '' . join ( bits ) )
def get_nodes_by_type ( self , nodetype ) :pass
nodes = [ ]
for node in self :pass
nodes . extend ( node . get_nodes_by_type ( nodetype ) )
return nodes
def render_node ( self , node , context ) :pass
return node . render ( context )
class TextNode ( Node ) :pass
def __init__ ( self , s ) :pass
self . s = s
def __repr__ ( self ) :pass
return force_str ( '_STR:0_' % self . s [ : 25 ] , 'ascii' ,  errors = 'replace' )
def render ( self , context ) :pass
return self . s
def render_value_in_context ( value , context ) :pass
value = template_localtime ( value , use_tz = context . use_tz )
value = localize ( value , use_l10n = context . use_l10n )
value = force_text ( value )
if ( ( context . autoescape and not isinstance ( value , SafeData ) ) or  isinstance ( value , EscapeData ) ) :pass
return escape ( value )
if True: pass _newline_ else :pass
return value
class VariableNode ( Node ) :pass
def __init__ ( self , filter_expression ) :pass
self . filter_expression = filter_expression
def __repr__ ( self ) :pass
return '_STR:0_' % self . filter_expression
def render ( self , context ) :pass
try :pass _newline_ except: pass
output = self . filter_expression . resolve ( context )
try: pass _newline_ except UnicodeDecodeError :pass
return ''
return render_value_in_context ( output , context )
kwarg_re = re . compile ( r'_STR:0_' )
def token_kwargs ( bits , parser , support_legacy = False ) :pass
if not bits :pass
return { }
match = kwarg_re . match ( bits [ 0 ] )
kwarg_format = match and match . group ( 1 )
if not kwarg_format :pass
if not support_legacy :pass
return { }
if len ( bits ) < 3 or bits [ 1 ] != '_STR:0_' :pass
return { }
kwargs = { }
while bits :pass
if kwarg_format :pass
match = kwarg_re . match ( bits [ 0 ] )
if not match or not match . group ( 1 ) :pass
return kwargs
key , value = match . groups ( )
del bits [ : 1 ]
if True: pass _newline_ else :pass
if len ( bits ) < 3 or bits [ 1 ] != '_STR:0_' :pass
return kwargs
key , value = bits [ 2 ] , bits [ 0 ]
del bits [ : 3 ]
kwargs [ key ] = parser . compile_filter ( value )
if bits and not kwarg_format :pass
if bits [ 0 ] != '_STR:0_' :pass
return kwargs
del bits [ : 1 ]
return kwargs
def parse_bits ( parser , bits , params , varargs , varkw , defaults ,  takes_context , name ) :pass
if takes_context :pass
if params [ 0 ] == '_STR:0_' :pass
params = params [ 1 : ]
if True: pass _newline_ else :pass
raise TemplateSyntaxError (  "'%s' is decorated with takes_context=True so it must "  "have a first argument of 'context'" % name )
args = [ ]
kwargs = { }
unhandled_params = list ( params )
for bit in bits :pass
kwarg = token_kwargs ( [ bit ] , parser )
if kwarg :pass
param , value = list ( six . iteritems ( kwarg ) ) [ 0 ]
if param not in params and varkw is None :pass
raise TemplateSyntaxError (  '_STR:0_' %  ( name , param ) )
if True: pass _newline_ elif param in kwargs :pass
raise TemplateSyntaxError (  '_STR:0_' %  ( name , param ) )
if True: pass _newline_ else :pass
kwargs [ str ( param ) ] = value
if param in unhandled_params :pass
unhandled_params . remove ( param )
if True: pass _newline_ else :pass
if kwargs :pass
raise TemplateSyntaxError (  "'%s' received some positional argument(s) after some "  "keyword argument(s)" % name )
if True: pass _newline_ else :pass
args . append ( parser . compile_filter ( bit ) )
try :pass _newline_ except: pass
unhandled_params . pop ( 0 )
try: pass _newline_ except IndexError :pass
if varargs is None :pass
raise TemplateSyntaxError (  '_STR:0_' %  name )
if defaults is not None :pass
unhandled_params = unhandled_params [ : - len ( defaults ) ]
if unhandled_params :pass
raise TemplateSyntaxError (  "'%s' did not receive value(s) for the argument(s): %s" %  ( name , ", " . join ( "'%s'" % p for p in unhandled_params ) ) )
return args , kwargs
def generic_tag_compiler ( parser , token , params , varargs , varkw , defaults ,  name , takes_context , node_class ) :pass
bits = token . split_contents ( ) [ 1 : ]
args , kwargs = parse_bits ( parser , bits , params , varargs , varkw ,  defaults , takes_context , name )
return node_class ( takes_context , args , kwargs )
class TagHelperNode ( Node ) :pass
def __init__ ( self , takes_context , args , kwargs ) :pass
self . takes_context = takes_context
self . args = args
self . kwargs = kwargs
def get_resolved_arguments ( self , context ) :pass
resolved_args = [ var . resolve ( context ) for var in self . args ]
if self . takes_context :pass
resolved_args = [ context ] + resolved_args
resolved_kwargs = dict ( ( k , v . resolve ( context ) ) for k , v in self . kwargs . items ( ) )
return resolved_args , resolved_kwargs
class Library ( object ) :pass
def __init__ ( self ) :pass
self . filters = { }
self . tags = { }
def tag ( self , name = None , compile_function = None ) :pass
if name is None and compile_function is None :pass
return self . tag_function
if True: pass _newline_ elif name is not None and compile_function is None :pass
if callable ( name ) :pass
return self . tag_function ( name )
if True: pass _newline_ else :pass
def dec ( func ) :pass
return self . tag ( name , func )
return dec
if True: pass _newline_ elif name is not None and compile_function is not None :pass
self . tags [ name ] = compile_function
return compile_function
if True: pass _newline_ else :pass
raise InvalidTemplateLibrary ( "Unsupported arguments to "  "Library.tag: (%r, %r)" , ( name , compile_function ) )
def tag_function ( self , func ) :pass
self . tags [ getattr ( func , '_STR:0_' , func ) . __name__ ] = func
return func
def filter ( self , name = None , filter_func = None , ** flags ) :pass
if name is None and filter_func is None :pass
def dec ( func ) :pass
return self . filter_function ( func , ** flags )
return dec
if True: pass _newline_ elif name is not None and filter_func is None :pass
if callable ( name ) :pass
return self . filter_function ( name , ** flags )
if True: pass _newline_ else :pass
def dec ( func ) :pass
return self . filter ( name , func , ** flags )
return dec
if True: pass _newline_ elif name is not None and filter_func is not None :pass
self . filters [ name ] = filter_func
for attr in ( '_STR:0_' , '_STR:1_' , '_STR:2_' ) :pass
if attr in flags :pass
value = flags [ attr ]
setattr ( filter_func , attr , value )
if hasattr ( filter_func , '_STR:0_' ) :pass
setattr ( filter_func . _decorated_function , attr , value )
filter_func . _filter_name = name
return filter_func
if True: pass _newline_ else :pass
raise InvalidTemplateLibrary ( "Unsupported arguments to "  "Library.filter: (%r, %r)" , ( name , filter_func ) )
def filter_function ( self , func , ** flags ) :pass
name = getattr ( func , '_STR:0_' , func ) . __name__
return self . filter ( name , func , ** flags )
def simple_tag ( self , func = None , takes_context = None , name = None ) :pass
def dec ( func ) :pass
params , varargs , varkw , defaults = getargspec ( func )
class SimpleNode ( TagHelperNode ) :pass
def render ( self , context ) :pass
resolved_args , resolved_kwargs = self . get_resolved_arguments ( context )
return func ( * resolved_args , ** resolved_kwargs )
function_name = ( name or  getattr ( func , '_STR:0_' , func ) . __name__ )
compile_func = partial ( generic_tag_compiler ,  params = params , varargs = varargs , varkw = varkw ,  defaults = defaults , name = function_name ,  takes_context = takes_context , node_class = SimpleNode )
compile_func . __doc__ = func . __doc__
self . tag ( function_name , compile_func )
return func
if func is None :pass
return dec
if True: pass _newline_ elif callable ( func ) :pass
return dec ( func )
if True: pass _newline_ else :pass
raise TemplateSyntaxError ( '_STR:0_' )
def assignment_tag ( self , func = None , takes_context = None , name = None ) :pass
def dec ( func ) :pass
params , varargs , varkw , defaults = getargspec ( func )
class AssignmentNode ( TagHelperNode ) :pass
def __init__ ( self , takes_context , args , kwargs , target_var ) :pass
super ( AssignmentNode , self ) . __init__ ( takes_context , args , kwargs )
self . target_var = target_var
def render ( self , context ) :pass
resolved_args , resolved_kwargs = self . get_resolved_arguments ( context )
context [ self . target_var ] = func ( * resolved_args , ** resolved_kwargs )
return ''
function_name = ( name or  getattr ( func , '_STR:0_' , func ) . __name__ )
def compile_func ( parser , token ) :pass
bits = token . split_contents ( ) [ 1 : ]
if len ( bits ) < 2 or bits [ - 2 ] != '_STR:0_' :pass
raise TemplateSyntaxError (  "'%s' tag takes at least 2 arguments and the "  "second last argument must be 'as'" % function_name )
target_var = bits [ - 1 ]
bits = bits [ : - 2 ]
args , kwargs = parse_bits ( parser , bits , params ,  varargs , varkw , defaults , takes_context , function_name )
return AssignmentNode ( takes_context , args , kwargs , target_var )
compile_func . __doc__ = func . __doc__
self . tag ( function_name , compile_func )
return func
if func is None :pass
return dec
if True: pass _newline_ elif callable ( func ) :pass
return dec ( func )
if True: pass _newline_ else :pass
raise TemplateSyntaxError ( '_STR:0_' )
def inclusion_tag ( self , file_name , context_class = Context , takes_context = False , name = None ) :pass
def dec ( func ) :pass
params , varargs , varkw , defaults = getargspec ( func )
class InclusionNode ( TagHelperNode ) :pass
def render ( self , context ) :pass
resolved_args , resolved_kwargs = self . get_resolved_arguments ( context )
_dict = func ( * resolved_args , ** resolved_kwargs )
if not getattr ( self , '_STR:0_' , False ) :pass
from django . template . loader import get_template , select_template
if isinstance ( file_name , Template ) :pass
t = file_name
if True: pass _newline_ elif not isinstance ( file_name , six . string_types ) and is_iterable ( file_name ) :pass
t = select_template ( file_name )
if True: pass _newline_ else :pass
t = get_template ( file_name )
self . nodelist = t . nodelist
new_context = context_class ( _dict , ** {  'autoescape' : context . autoescape ,  'current_app' : context . current_app ,  'use_l10n' : context . use_l10n ,  'use_tz' : context . use_tz ,  } )
csrf_token = context . get ( '_STR:4_' , None )
if csrf_token is not None :pass
new_context [ '_STR:0_' ] = csrf_token
return self . nodelist . render ( new_context )
function_name = ( name or  getattr ( func , '_STR:0_' , func ) . __name__ )
compile_func = partial ( generic_tag_compiler ,  params = params , varargs = varargs , varkw = varkw ,  defaults = defaults , name = function_name ,  takes_context = takes_context , node_class = InclusionNode )
compile_func . __doc__ = func . __doc__
self . tag ( function_name , compile_func )
return func
return dec
def is_library_missing ( name ) :pass
path , module = name . rsplit ( '_STR:0_' , 1 )
try :pass _newline_ except: pass
package = import_module ( path )
return not module_has_submodule ( package , module )
try: pass _newline_ except ImportError :pass
return is_library_missing ( path )
def import_library ( taglib_module ) :pass
try :pass _newline_ except: pass
mod = import_module ( taglib_module )
try: pass _newline_ except ImportError as e :pass
if is_library_missing ( taglib_module ) :pass
return None
if True: pass _newline_ else :pass
raise InvalidTemplateLibrary ( '_STR:0_' %  ( taglib_module , e ) )
try :pass _newline_ except: pass
return mod . register
try: pass _newline_ except AttributeError :pass
raise InvalidTemplateLibrary ( "Template library %s does not have "  "a variable named 'register'" %  taglib_module )
templatetags_modules = [ ]
def get_templatetags_modules ( ) :pass
global templatetags_modules
if not templatetags_modules :pass
_templatetags_modules = [ ]
templatetags_modules_candidates = [ '_STR:0_' ]
templatetags_modules_candidates += [ '_STR:0_' % app_config . name  for app_config in apps . get_app_configs ( ) ]
for templatetag_module in templatetags_modules_candidates :pass
try :pass _newline_ except: pass
import_module ( templatetag_module )
_templatetags_modules . append ( templatetag_module )
try: pass _newline_ except ImportError :pass
continue
templatetags_modules = _templatetags_modules
return templatetags_modules
def get_library ( library_name ) :pass
lib = libraries . get ( library_name , None )
if not lib :pass
templatetags_modules = get_templatetags_modules ( )
tried_modules = [ ]
for module in templatetags_modules :pass
taglib_module = '_STR:0_' % ( module , library_name )
tried_modules . append ( taglib_module )
lib = import_library ( taglib_module )
if lib :pass
libraries [ library_name ] = lib
break
if not lib :pass
raise InvalidTemplateLibrary ( "Template library %s not found, "  "tried %s" %  ( library_name ,  ',' . join ( tried_modules ) ) )
return lib
def add_to_builtins ( module ) :pass
builtins . append ( import_library ( module ) )
add_to_builtins ( '_STR:0_' )
add_to_builtins ( '_STR:0_' )
add_to_builtins ( '_STR:0_' )
from copy import copy
from django . utils . module_loading import import_string
_standard_context_processors = None
_builtin_context_processors = ( '_STR:0_' , )
class ContextPopException ( Exception ) :pass
pass
class ContextDict ( dict ) :pass
def __init__ ( self , context , * args , ** kwargs ) :pass
super ( ContextDict , self ) . __init__ ( * args , ** kwargs )
context . dicts . append ( self )
self . context = context
def __enter__ ( self ) :pass
return self
def __exit__ ( self , * args , ** kwargs ) :pass
self . context . pop ( )
class BaseContext ( object ) :pass
def __init__ ( self , dict_ = None ) :pass
self . _reset_dicts ( dict_ )
def _reset_dicts ( self , value = None ) :pass
builtins = { '_STR:0_' : True , '_STR:1_' : False , '_STR:2_' : None }
self . dicts = [ builtins ]
if value is not None :pass
self . dicts . append ( value )
def __copy__ ( self ) :pass
duplicate = copy ( super ( BaseContext , self ) )
duplicate . dicts = self . dicts [ : ]
return duplicate
def __repr__ ( self ) :pass
return repr ( self . dicts )
def __iter__ ( self ) :pass
for d in reversed ( self . dicts ) :pass
yield d
def push ( self , * args , ** kwargs ) :pass
return ContextDict ( self , * args , ** kwargs )
def pop ( self ) :pass
if len ( self . dicts ) == 1 :pass
raise ContextPopException
return self . dicts . pop ( )
def __setitem__ ( self , key , value ) :pass
self . dicts [ - 1 ] [ key ] = value
def __getitem__ ( self , key ) :pass
for d in reversed ( self . dicts ) :pass
if key in d :pass
return d [ key ]
raise KeyError ( key )
def __delitem__ ( self , key ) :pass
del self . dicts [ - 1 ] [ key ]
def has_key ( self , key ) :pass
for d in self . dicts :pass
if key in d :pass
return True
return False
def __contains__ ( self , key ) :pass
return self . has_key ( key )
def get ( self , key , otherwise = None ) :pass
for d in reversed ( self . dicts ) :pass
if key in d :pass
return d [ key ]
return otherwise
def new ( self , values = None ) :pass
new_context = copy ( self )
new_context . _reset_dicts ( values )
return new_context
def flatten ( self ) :pass
flat = { }
for d in self . dicts :pass
flat . update ( d )
return flat
def __eq__ ( self , other ) :pass
if isinstance ( other , BaseContext ) :pass
return self . flatten ( ) == other . flatten ( )
return False
class Context ( BaseContext ) :pass
def __init__ ( self , dict_ = None , autoescape = True , current_app = None ,  use_l10n = None , use_tz = None ) :pass
self . autoescape = autoescape
self . current_app = current_app
self . use_l10n = use_l10n
self . use_tz = use_tz
self . render_context = RenderContext ( )
super ( Context , self ) . __init__ ( dict_ )
def __copy__ ( self ) :pass
duplicate = super ( Context , self ) . __copy__ ( )
duplicate . render_context = copy ( self . render_context )
return duplicate
def update ( self , other_dict ) :pass
if not hasattr ( other_dict , '_STR:0_' ) :pass
raise TypeError ( '_STR:0_' )
self . dicts . append ( other_dict )
return other_dict
class RenderContext ( BaseContext ) :pass
def __iter__ ( self ) :pass
for d in self . dicts [ - 1 ] :pass
yield d
def has_key ( self , key ) :pass
return key in self . dicts [ - 1 ]
def get ( self , key , otherwise = None ) :pass
return self . dicts [ - 1 ] . get ( key , otherwise )
def __getitem__ ( self , key ) :pass
return self . dicts [ - 1 ] [ key ]
def get_standard_processors ( ) :pass
from django . conf import settings
global _standard_context_processors
if _standard_context_processors is None :pass
processors = [ ]
collect = [ ]
collect . extend ( _builtin_context_processors )
collect . extend ( settings . TEMPLATE_CONTEXT_PROCESSORS )
for path in collect :pass
func = import_string ( path )
processors . append ( func )
_standard_context_processors = tuple ( processors )
return _standard_context_processors
class RequestContext ( Context ) :pass
def __init__ ( self , request , dict_ = None , processors = None , current_app = None ,  use_l10n = None , use_tz = None ) :pass
Context . __init__ ( self , dict_ , current_app = current_app ,  use_l10n = use_l10n , use_tz = use_tz )
if processors is None :pass
processors = ( )
if True: pass _newline_ else :pass
processors = tuple ( processors )
updates = dict ( )
for processor in get_standard_processors ( ) + processors :pass
updates . update ( processor ( request ) )
self . update ( updates )
from django . template . base import Lexer , Parser , tag_re , NodeList , VariableNode , TemplateSyntaxError
from django . utils . encoding import force_text
from django . utils . html import escape
from django . utils . safestring import SafeData , EscapeData
from django . utils . formats import localize
from django . utils . timezone import template_localtime
class DebugLexer ( Lexer ) :pass
def __init__ ( self , template_string , origin ) :pass
super ( DebugLexer , self ) . __init__ ( template_string , origin )
def tokenize ( self ) :pass
result , upto = [ ] , 0
for match in tag_re . finditer ( self . template_string ) :pass
start , end = match . span ( )
if start > upto :pass
result . append ( self . create_token ( self . template_string [ upto : start ] , ( upto , start ) , False ) )
upto = start
result . append ( self . create_token ( self . template_string [ start : end ] , ( start , end ) , True ) )
upto = end
last_bit = self . template_string [ upto : ]
if last_bit :pass
result . append ( self . create_token ( last_bit , ( upto , upto + len ( last_bit ) ) , False ) )
return result
def create_token ( self , token_string , source , in_tag ) :pass
token = super ( DebugLexer , self ) . create_token ( token_string , in_tag )
token . source = self . origin , source
return token
class DebugParser ( Parser ) :pass
def __init__ ( self , lexer ) :pass
super ( DebugParser , self ) . __init__ ( lexer )
self . command_stack = [ ]
def enter_command ( self , command , token ) :pass
self . command_stack . append ( ( command , token . source ) )
def exit_command ( self ) :pass
self . command_stack . pop ( )
def error ( self , token , msg ) :pass
return self . source_error ( token . source , msg )
def source_error ( self , source , msg ) :pass
e = TemplateSyntaxError ( msg )
e . django_template_source = source
return e
def create_nodelist ( self ) :pass
return DebugNodeList ( )
def create_variable_node ( self , contents ) :pass
return DebugVariableNode ( contents )
def extend_nodelist ( self , nodelist , node , token ) :pass
node . source = token . source
super ( DebugParser , self ) . extend_nodelist ( nodelist , node , token )
def unclosed_block_tag ( self , parse_until ) :pass
command , source = self . command_stack . pop ( )
msg = '_STR:0_' % ( command , ', ' . join ( parse_until ) )
raise self . source_error ( source , msg )
def compile_filter_error ( self , token , e ) :pass
if not hasattr ( e , '_STR:0_' ) :pass
e . django_template_source = token . source
def compile_function_error ( self , token , e ) :pass
if not hasattr ( e , '_STR:0_' ) :pass
e . django_template_source = token . source
class DebugNodeList ( NodeList ) :pass
def render_node ( self , node , context ) :pass
try :pass _newline_ except: pass
return node . render ( context )
try: pass _newline_ except Exception as e :pass
if not hasattr ( e , '_STR:0_' ) :pass
e . django_template_source = node . source
raise
class DebugVariableNode ( VariableNode ) :pass
def render ( self , context ) :pass
try :pass _newline_ except: pass
output = self . filter_expression . resolve ( context )
output = template_localtime ( output , use_tz = context . use_tz )
output = localize ( output , use_l10n = context . use_l10n )
output = force_text ( output )
try: pass _newline_ except UnicodeDecodeError :pass
return ''
try: pass _newline_ except Exception as e :pass
if not hasattr ( e , '_STR:0_' ) :pass
e . django_template_source = self . source
raise
if ( context . autoescape and not isinstance ( output , SafeData ) ) or isinstance ( output , EscapeData ) :pass
return escape ( output )
if True: pass _newline_ else :pass
return output
from __future__ import unicode_literals
import re
import random as random_module
from decimal import Decimal , InvalidOperation , Context , ROUND_HALF_UP
from functools import wraps
from pprint import pformat
from django . template . base import Variable , Library , VariableDoesNotExist
from django . conf import settings
from django . utils import formats
from django . utils . dateformat import format , time_format
from django . utils . encoding import force_text , iri_to_uri
from django . utils . html import ( conditional_escape , escapejs ,  escape , urlize as _urlize , linebreaks , strip_tags , avoid_wrapping ,  remove_tags )
from django . utils . http import urlquote
from django . utils . text import Truncator , wrap , phone2numeric
from django . utils . safestring import mark_safe , SafeData , mark_for_escaping
from django . utils import six
from django . utils . timesince import timesince , timeuntil
from django . utils . translation import ugettext , ungettext
from django . utils . text import normalize_newlines , slugify as _slugify
register = Library ( )
def stringfilter ( func ) :pass
def _dec ( * args , ** kwargs ) :pass
if args :pass
args = list ( args )
args [ 0 ] = force_text ( args [ 0 ] )
if ( isinstance ( args [ 0 ] , SafeData ) and  getattr ( _dec . _decorated_function , '_STR:0_' , False ) ) :pass
return mark_safe ( func ( * args , ** kwargs ) )
return func ( * args , ** kwargs )
_dec . _decorated_function = getattr ( func , '_STR:0_' , func )
return wraps ( func ) ( _dec )
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def addslashes ( value ) :pass
return value . replace ( '\\' , '\\\\' ) . replace ( '"' , '\\"' ) . replace ( "'" , "\\'" )
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def capfirst ( value ) :pass
return value and value [ 0 ] . upper ( ) + value [ 1 : ]
@ register . filter ( '_STR:0_' ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def escapejs_filter ( value ) :pass
return escapejs ( value )
pos_inf = 1e200 * 1e200
neg_inf = - 1e200 * 1e200
nan = ( 1e200 * 1e200 ) // ( 1e200 * 1e200 )
special_floats = [ str ( pos_inf ) , str ( neg_inf ) , str ( nan ) ]
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
def floatformat ( text , arg = - 1 ) :pass
try :pass _newline_ except: pass
input_val = force_text ( text )
d = Decimal ( input_val )
try: pass _newline_ except UnicodeEncodeError :pass
return ''
try: pass _newline_ except InvalidOperation :pass
if input_val in special_floats :pass
return input_val
try :pass _newline_ except: pass
d = Decimal ( force_text ( float ( text ) ) )
try: pass _newline_ except ( ValueError , InvalidOperation , TypeError , UnicodeEncodeError ) :pass
return ''
try :pass _newline_ except: pass
p = int ( arg )
try: pass _newline_ except ValueError :pass
return input_val
try :pass _newline_ except: pass
m = int ( d ) - d
try: pass _newline_ except ( ValueError , OverflowError , InvalidOperation ) :pass
return input_val
if not m and p < 0 :pass
return mark_safe ( formats . number_format ( '%d' % ( int ( d ) ) , 0 ) )
if p == 0 :pass
exp = Decimal ( 1 )
if True: pass _newline_ else :pass
exp = Decimal ( '_STR:0_' ) / ( Decimal ( 10 ) ** abs ( p ) )
try :pass _newline_ except: pass
tupl = d . as_tuple ( )
units = len ( tupl [ 1 ] ) - tupl [ 2 ]
prec = abs ( p ) + units + 1
sign , digits , exponent = d . quantize ( exp , ROUND_HALF_UP ,  Context ( prec = prec ) ) . as_tuple ( )
digits = [ six . text_type ( digit ) for digit in reversed ( digits ) ]
while len ( digits ) <= abs ( exponent ) :pass
digits . append ( '_STR:0_' )
digits . insert ( - exponent , '_STR:0_' )
if sign :pass
digits . append ( '_STR:0_' )
number = '' . join ( reversed ( digits ) )
return mark_safe ( formats . number_format ( number , abs ( p ) ) )
try: pass _newline_ except InvalidOperation :pass
return input_val
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def iriencode ( value ) :pass
return force_text ( iri_to_uri ( value ) )
@ register . filter ( is_safe = True , needs_autoescape = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def linenumbers ( value , autoescape = None ) :pass
lines = value . split ( '\n' )
width = six . text_type ( len ( six . text_type ( len ( lines ) ) ) )
if not autoescape or isinstance ( value , SafeData ) :pass
for i , line in enumerate ( lines ) :pass
lines [ i ] = ( "%0" + width + '_STR:1_' ) % ( i + 1 , line )
if True: pass _newline_ else :pass
for i , line in enumerate ( lines ) :pass
lines [ i ] = ( "%0" + width + '_STR:1_' ) % ( i + 1 , escape ( line ) )
return mark_safe ( '\n' . join ( lines ) )
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def lower ( value ) :pass
return value . lower ( )
@ register . filter ( is_safe = False ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def make_list ( value ) :pass
return list ( value )
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def slugify ( value ) :pass
return _slugify ( value )
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
def stringformat ( value , arg ) :pass
try :pass _newline_ except: pass
return ( "%" + six . text_type ( arg ) ) % value
try: pass _newline_ except ( ValueError , TypeError ) :pass
return ""
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def title ( value ) :pass
t = re . sub ( '_STR:0_' , lambda m : m . group ( 0 ) . lower ( ) , value . title ( ) )
return re . sub ( '_STR:0_' , lambda m : m . group ( 0 ) . lower ( ) , t )
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def truncatechars ( value , arg ) :pass
try :pass _newline_ except: pass
length = int ( arg )
try: pass _newline_ except ValueError :pass
return value
return Truncator ( value ) . chars ( length )
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def truncatechars_html ( value , arg ) :pass
try :pass _newline_ except: pass
length = int ( arg )
try: pass _newline_ except ValueError :pass
return value
return Truncator ( value ) . chars ( length , html = True )
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def truncatewords ( value , arg ) :pass
try :pass _newline_ except: pass
length = int ( arg )
try: pass _newline_ except ValueError :pass
return value
return Truncator ( value ) . words ( length , truncate = ' ...' )
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def truncatewords_html ( value , arg ) :pass
try :pass _newline_ except: pass
length = int ( arg )
try: pass _newline_ except ValueError :pass
return value
return Truncator ( value ) . words ( length , html = True , truncate = ' ...' )
@ register . filter ( is_safe = False ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def upper ( value ) :pass
return value . upper ( )
@ register . filter ( is_safe = False ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def urlencode ( value , safe = None ) :pass
kwargs = { }
if safe is not None :pass
kwargs [ '_STR:0_' ] = safe
return urlquote ( value , ** kwargs )
@ register . filter ( is_safe = True , needs_autoescape = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def urlize ( value , autoescape = None ) :pass
return mark_safe ( _urlize ( value , nofollow = True , autoescape = autoescape ) )
@ register . filter ( is_safe = True , needs_autoescape = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def urlizetrunc ( value , limit , autoescape = None ) :pass
return mark_safe ( _urlize ( value , trim_url_limit = int ( limit ) , nofollow = True ,  autoescape = autoescape ) )
@ register . filter ( is_safe = False ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def wordcount ( value ) :pass
return len ( value . split ( ) )
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def wordwrap ( value , arg ) :pass
return wrap ( value , int ( arg ) )
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def ljust ( value , arg ) :pass
return value . ljust ( int ( arg ) )
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def rjust ( value , arg ) :pass
return value . rjust ( int ( arg ) )
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def center ( value , arg ) :pass
return value . center ( int ( arg ) )
@ register . filter _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def cut ( value , arg ) :pass
safe = isinstance ( value , SafeData )
value = value . replace ( arg , '' )
if safe and arg != '_STR:0_' :pass
return mark_safe ( value )
return value
@ register . filter ( '_STR:0_' , is_safe = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def escape_filter ( value ) :pass
return mark_for_escaping ( value )
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def force_escape ( value ) :pass
return escape ( value )
@ register . filter ( "linebreaks" , is_safe = True , needs_autoescape = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def linebreaks_filter ( value , autoescape = None ) :pass
autoescape = autoescape and not isinstance ( value , SafeData )
return mark_safe ( linebreaks ( value , autoescape ) )
@ register . filter ( is_safe = True , needs_autoescape = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def linebreaksbr ( value , autoescape = None ) :pass
autoescape = autoescape and not isinstance ( value , SafeData )
value = normalize_newlines ( value )
if autoescape :pass
value = escape ( value )
return mark_safe ( value . replace ( '\n' , '_STR:0_' ) )
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def safe ( value ) :pass
return mark_safe ( value )
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
def safeseq ( value ) :pass
return [ mark_safe ( force_text ( obj ) ) for obj in value ]
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def removetags ( value , tags ) :pass
return remove_tags ( value , tags )
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
@ stringfilter _newline_ def dummy(): pass
def striptags ( value ) :pass
return strip_tags ( value )
@ register . filter ( is_safe = False ) _newline_ def dummy(): pass
def dictsort ( value , arg ) :pass
try :pass _newline_ except: pass
return sorted ( value , key = Variable ( arg ) . resolve )
try: pass _newline_ except ( TypeError , VariableDoesNotExist ) :pass
return ''
@ register . filter ( is_safe = False ) _newline_ def dummy(): pass
def dictsortreversed ( value , arg ) :pass
try :pass _newline_ except: pass
return sorted ( value , key = Variable ( arg ) . resolve , reverse = True )
try: pass _newline_ except ( TypeError , VariableDoesNotExist ) :pass
return ''
@ register . filter ( is_safe = False ) _newline_ def dummy(): pass
def first ( value ) :pass
try :pass _newline_ except: pass
return value [ 0 ]
try: pass _newline_ except IndexError :pass
return ''
@ register . filter ( is_safe = True , needs_autoescape = True ) _newline_ def dummy(): pass
def join ( value , arg , autoescape = None ) :pass
value = map ( force_text , value )
if autoescape :pass
value = [ conditional_escape ( v ) for v in value ]
try :pass _newline_ except: pass
data = conditional_escape ( arg ) . join ( value )
try: pass _newline_ except AttributeError :pass
return value
return mark_safe ( data )
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
def last ( value ) :pass
try :pass _newline_ except: pass
return value [ - 1 ]
try: pass _newline_ except IndexError :pass
return ''
@ register . filter ( is_safe = False ) _newline_ def dummy(): pass
def length ( value ) :pass
try :pass _newline_ except: pass
return len ( value )
try: pass _newline_ except ( ValueError , TypeError ) :pass
return 0
@ register . filter ( is_safe = False ) _newline_ def dummy(): pass
def length_is ( value , arg ) :pass
try :pass _newline_ except: pass
return len ( value ) == int ( arg )
try: pass _newline_ except ( ValueError , TypeError ) :pass
return ''
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
def random ( value ) :pass
return random_module . choice ( value )
@ register . filter ( '_STR:0_' , is_safe = True ) _newline_ def dummy(): pass
def slice_filter ( value , arg ) :pass
try :pass _newline_ except: pass
bits = [ ]
for x in arg . split ( '_STR:0_' ) :pass
if len ( x ) == 0 :pass
bits . append ( None )
if True: pass _newline_ else :pass
bits . append ( int ( x ) )
return value [ slice ( * bits ) ]
try: pass _newline_ except ( ValueError , TypeError ) :pass
return value
@ register . filter ( is_safe = True , needs_autoescape = True ) _newline_ def dummy(): pass
def unordered_list ( value , autoescape = None ) :pass
if autoescape :pass
escaper = conditional_escape
if True: pass _newline_ else :pass
escaper = lambda x : x
def convert_old_style_list ( list_ ) :pass
if not isinstance ( list_ , ( tuple , list ) ) or len ( list_ ) != 2 :pass
return list_ , False
first_item , second_item = list_
if second_item == [ ] :pass
return [ first_item ] , True
try :pass _newline_ except: pass
iter ( second_item )
try: pass _newline_ except TypeError :pass
return list_ , False
old_style_list = True
new_second_item = [ ]
for sublist in second_item :pass
item , old_style_list = convert_old_style_list ( sublist )
if not old_style_list :pass
break
new_second_item . extend ( item )
if old_style_list :pass
second_item = new_second_item
return [ first_item , second_item ] , old_style_list
def _helper ( list_ , tabs = 1 ) :pass
indent = '\t' * tabs
output = [ ]
list_length = len ( list_ )
i = 0
while i < list_length :pass
title = list_ [ i ]
sublist = ''
sublist_item = None
if isinstance ( title , ( list , tuple ) ) :pass
sublist_item = title
title = ''
if True: pass _newline_ elif i < list_length - 1 :pass
next_item = list_ [ i + 1 ]
if next_item and isinstance ( next_item , ( list , tuple ) ) :pass
sublist_item = next_item
i += 1
if sublist_item :pass
sublist = _helper ( sublist_item , tabs + 1 )
sublist = '_STR:0_' % ( indent , sublist ,  indent , indent )
output . append ( '_STR:0_' % ( indent ,  escaper ( force_text ( title ) ) , sublist ) )
i += 1
return '\n' . join ( output )
value , converted = convert_old_style_list ( value )
return mark_safe ( _helper ( value ) )
@ register . filter ( is_safe = False ) _newline_ def dummy(): pass
def add ( value , arg ) :pass
try :pass _newline_ except: pass
return int ( value ) + int ( arg )
try: pass _newline_ except ( ValueError , TypeError ) :pass
try :pass _newline_ except: pass
return value + arg
try: pass _newline_ except Exception :pass
return ''
@ register . filter ( is_safe = False ) _newline_ def dummy(): pass
def get_digit ( value , arg ) :pass
try :pass _newline_ except: pass
arg = int ( arg )
value = int ( value )
try: pass _newline_ except ValueError :pass
return value
if arg < 1 :pass
return value
try :pass _newline_ except: pass
return int ( str ( value ) [ - arg ] )
try: pass _newline_ except IndexError :pass
return 0
@ register . filter ( expects_localtime = True , is_safe = False ) _newline_ def dummy(): pass
def date ( value , arg = None ) :pass
if value in ( None , '' ) :pass
return ''
if arg is None :pass
arg = settings . DATE_FORMAT
try :pass _newline_ except: pass
return formats . date_format ( value , arg )
try: pass _newline_ except AttributeError :pass
try :pass _newline_ except: pass
return format ( value , arg )
try: pass _newline_ except AttributeError :pass
return ''
@ register . filter ( expects_localtime = True , is_safe = False ) _newline_ def dummy(): pass
def time ( value , arg = None ) :pass
if value in ( None , '' ) :pass
return ''
if arg is None :pass
arg = settings . TIME_FORMAT
try :pass _newline_ except: pass
return formats . time_format ( value , arg )
try: pass _newline_ except AttributeError :pass
try :pass _newline_ except: pass
return time_format ( value , arg )
try: pass _newline_ except AttributeError :pass
return ''
@ register . filter ( '_STR:0_' , is_safe = False ) _newline_ def dummy(): pass
def timesince_filter ( value , arg = None ) :pass
if not value :pass
return ''
try :pass _newline_ except: pass
if arg :pass
return timesince ( value , arg )
return timesince ( value )
try: pass _newline_ except ( ValueError , TypeError ) :pass
return ''
@ register . filter ( '_STR:0_' , is_safe = False ) _newline_ def dummy(): pass
def timeuntil_filter ( value , arg = None ) :pass
if not value :pass
return ''
try :pass _newline_ except: pass
return timeuntil ( value , arg )
try: pass _newline_ except ( ValueError , TypeError ) :pass
return ''
@ register . filter ( is_safe = False ) _newline_ def dummy(): pass
def default ( value , arg ) :pass
return value or arg
@ register . filter ( is_safe = False ) _newline_ def dummy(): pass
def default_if_none ( value , arg ) :pass
if value is None :pass
return arg
return value
@ register . filter ( is_safe = False ) _newline_ def dummy(): pass
def divisibleby ( value , arg ) :pass
return int ( value ) % int ( arg ) == 0
@ register . filter ( is_safe = False ) _newline_ def dummy(): pass
def yesno ( value , arg = None ) :pass
if arg is None :pass
arg = ugettext ( '_STR:0_' )
bits = arg . split ( '_STR:0_' )
if len ( bits ) < 2 :pass
return value
try :pass _newline_ except: pass
yes , no , maybe = bits
try: pass _newline_ except ValueError :pass
yes , no , maybe = bits [ 0 ] , bits [ 1 ] , bits [ 1 ]
if value is None :pass
return maybe
if value :pass
return yes
return no
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
def filesizeformat ( bytes ) :pass
try :pass _newline_ except: pass
bytes = float ( bytes )
try: pass _newline_ except ( TypeError , ValueError , UnicodeDecodeError ) :pass
value = ungettext ( '_STR:0_' , '_STR:1_' , 0 ) % { 'size' : 0 }
return avoid_wrapping ( value )
filesize_number_format = lambda value : formats . number_format ( round ( value , 1 ) , 1 )
KB = 1 << 10
MB = 1 << 20
GB = 1 << 30
TB = 1 << 40
PB = 1 << 50
if bytes < KB :pass
value = ungettext ( '_STR:0_' , '_STR:1_' , bytes ) % { 'size' : bytes }
if True: pass _newline_ elif bytes < MB :pass
value = ugettext ( '_STR:0_' ) % filesize_number_format ( bytes / KB )
if True: pass _newline_ elif bytes < GB :pass
value = ugettext ( '_STR:0_' ) % filesize_number_format ( bytes / MB )
if True: pass _newline_ elif bytes < TB :pass
value = ugettext ( '_STR:0_' ) % filesize_number_format ( bytes / GB )
if True: pass _newline_ elif bytes < PB :pass
value = ugettext ( '_STR:0_' ) % filesize_number_format ( bytes / TB )
if True: pass _newline_ else :pass
value = ugettext ( '_STR:0_' ) % filesize_number_format ( bytes / PB )
return avoid_wrapping ( value )
@ register . filter ( is_safe = False ) _newline_ def dummy(): pass
def pluralize ( value , arg = '_STR:0_' ) :pass
if '_STR:0_' not in arg :pass
arg = '_STR:0_' + arg
bits = arg . split ( '_STR:0_' )
if len ( bits ) > 2 :pass
return ''
singular_suffix , plural_suffix = bits [ : 2 ]
try :pass _newline_ except: pass
if float ( value ) != 1 :pass
return plural_suffix
try: pass _newline_ except ValueError :pass
pass
try: pass _newline_ except TypeError :pass
try :pass _newline_ except: pass
if len ( value ) != 1 :pass
return plural_suffix
try: pass _newline_ except TypeError :pass
pass
return singular_suffix
@ register . filter ( '_STR:0_' , is_safe = True ) _newline_ def dummy(): pass
def phone2numeric_filter ( value ) :pass
return phone2numeric ( value )
@ register . filter ( is_safe = True ) _newline_ def dummy(): pass
def pprint ( value ) :pass
try :pass _newline_ except: pass
return pformat ( value )
try: pass _newline_ except Exception as e :pass
return '_STR:0_' % force_text ( e , errors = "replace" )
from __future__ import unicode_literals
import os
import sys
import re
from datetime import datetime
from itertools import groupby , cycle as itertools_cycle
import warnings
from django . conf import settings
from django . template . base import ( Node , NodeList , Template , Context , Library ,  TemplateSyntaxError , VariableDoesNotExist , InvalidTemplateLibrary ,  BLOCK_TAG_START , BLOCK_TAG_END , VARIABLE_TAG_START , VARIABLE_TAG_END ,  SINGLE_BRACE_START , SINGLE_BRACE_END , COMMENT_TAG_START , COMMENT_TAG_END ,  VARIABLE_ATTRIBUTE_SEPARATOR , get_library , token_kwargs , kwarg_re ,  render_value_in_context )
from django . template . smartif import IfParser , Literal
from django . template . defaultfilters import date
from django . utils . deprecation import RemovedInDjango20Warning
from django . utils . encoding import force_text , smart_text
from django . utils . safestring import mark_safe
from django . utils . html import format_html
from django . utils import six
from django . utils import timezone
register = Library ( )
class AutoEscapeControlNode ( Node ) :pass
def __init__ ( self , setting , nodelist ) :pass
self . setting , self . nodelist = setting , nodelist
def render ( self , context ) :pass
old_setting = context . autoescape
context . autoescape = self . setting
output = self . nodelist . render ( context )
context . autoescape = old_setting
if self . setting :pass
return mark_safe ( output )
if True: pass _newline_ else :pass
return output
class CommentNode ( Node ) :pass
def render ( self , context ) :pass
return ''
class CsrfTokenNode ( Node ) :pass
def render ( self , context ) :pass
csrf_token = context . get ( '_STR:0_' , None )
if csrf_token :pass
if csrf_token == '_STR:0_' :pass
return format_html ( "" )
if True: pass _newline_ else :pass
return format_html ( '_STR:0_' , csrf_token )
if True: pass _newline_ else :pass
if settings . DEBUG :pass
warnings . warn ( '_STR:0_' )
return ''
class CycleNode ( Node ) :pass
def __init__ ( self , cyclevars , variable_name = None , silent = False ) :pass
self . cyclevars = cyclevars
self . variable_name = variable_name
self . silent = silent
def render ( self , context ) :pass
if self not in context . render_context :pass
context . render_context [ self ] = itertools_cycle ( self . cyclevars )
cycle_iter = context . render_context [ self ]
value = next ( cycle_iter ) . resolve ( context )
if self . variable_name :pass
context [ self . variable_name ] = value
if self . silent :pass
return ''
return render_value_in_context ( value , context )
class DebugNode ( Node ) :pass
def render ( self , context ) :pass
from pprint import pformat
output = [ pformat ( val ) for val in context ]
output . append ( '\n\n' )
output . append ( pformat ( sys . modules ) )
return '' . join ( output )
class FilterNode ( Node ) :pass
def __init__ ( self , filter_expr , nodelist ) :pass
self . filter_expr , self . nodelist = filter_expr , nodelist
def render ( self , context ) :pass
output = self . nodelist . render ( context )
with context . push ( var = output ) :pass
return self . filter_expr . resolve ( context )
class FirstOfNode ( Node ) :pass
def __init__ ( self , variables ) :pass
self . vars = variables
def render ( self , context ) :pass
for var in self . vars :pass
value = var . resolve ( context , True )
if value :pass
return render_value_in_context ( value , context )
return ''
class ForNode ( Node ) :pass
child_nodelists = ( '_STR:0_' , '_STR:1_' )
def __init__ ( self , loopvars , sequence , is_reversed , nodelist_loop , nodelist_empty = None ) :pass
self . loopvars , self . sequence = loopvars , sequence
self . is_reversed = is_reversed
self . nodelist_loop = nodelist_loop
if nodelist_empty is None :pass
self . nodelist_empty = NodeList ( )
if True: pass _newline_ else :pass
self . nodelist_empty = nodelist_empty
def __repr__ ( self ) :pass
reversed_text = '_STR:0_' if self . is_reversed else ''
return '_STR:0_' % ( ', ' . join ( self . loopvars ) , self . sequence , len ( self . nodelist_loop ) ,  reversed_text )
def __iter__ ( self ) :pass
for node in self . nodelist_loop :pass
yield node
for node in self . nodelist_empty :pass
yield node
def render ( self , context ) :pass
if '_STR:0_' in context :pass
parentloop = context [ '_STR:0_' ]
if True: pass _newline_ else :pass
parentloop = { }
with context . push ( ) :pass
try :pass _newline_ except: pass
values = self . sequence . resolve ( context , True )
try: pass _newline_ except VariableDoesNotExist :pass
values = [ ]
if values is None :pass
values = [ ]
if not hasattr ( values , '_STR:0_' ) :pass
values = list ( values )
len_values = len ( values )
if len_values < 1 :pass
return self . nodelist_empty . render ( context )
nodelist = [ ]
if self . is_reversed :pass
values = reversed ( values )
num_loopvars = len ( self . loopvars )
unpack = num_loopvars > 1
loop_dict = context [ '_STR:0_' ] = { '_STR:1_' : parentloop }
for i , item in enumerate ( values ) :pass
loop_dict [ '_STR:0_' ] = i
loop_dict [ '_STR:0_' ] = i + 1
loop_dict [ '_STR:0_' ] = len_values - i
loop_dict [ 'revcounter0' ] = len_values - i - 1
loop_dict [ '_STR:0_' ] = ( i == 0 )
loop_dict [ '_STR:0_' ] = ( i == len_values - 1 )
pop_context = False
if unpack :pass
if not isinstance ( item , ( list , tuple ) ) :pass
len_item = 1
if True: pass _newline_ else :pass
len_item = len ( item )
if num_loopvars != len_item :pass
warnings . warn (  "Need {0} values to unpack in for loop; got {1}. "  "This will raise an exception in Django 2.0."  . format ( num_loopvars , len_item ) ,  RemovedInDjango20Warning )
try :pass _newline_ except: pass
unpacked_vars = dict ( zip ( self . loopvars , item ) )
try: pass _newline_ except TypeError :pass
pass
if True: pass _newline_ else :pass
pop_context = True
context . update ( unpacked_vars )
if True: pass _newline_ else :pass
context [ self . loopvars [ 0 ] ] = item
if settings . TEMPLATE_DEBUG :pass
for node in self . nodelist_loop :pass
try :pass _newline_ except: pass
nodelist . append ( node . render ( context ) )
try: pass _newline_ except Exception as e :pass
if not hasattr ( e , '_STR:0_' ) :pass
e . django_template_source = node . source
raise
if True: pass _newline_ else :pass
for node in self . nodelist_loop :pass
nodelist . append ( node . render ( context ) )
if pop_context :pass
context . pop ( )
return mark_safe ( '' . join ( force_text ( n ) for n in nodelist ) )
class IfChangedNode ( Node ) :pass
child_nodelists = ( '_STR:0_' , '_STR:1_' )
def __init__ ( self , nodelist_true , nodelist_false , * varlist ) :pass
self . nodelist_true , self . nodelist_false = nodelist_true , nodelist_false
self . _varlist = varlist
def render ( self , context ) :pass
state_frame = self . _get_context_stack_frame ( context )
if self not in state_frame :pass
state_frame [ self ] = None
nodelist_true_output = None
try :pass _newline_ except: pass
if self . _varlist :pass
compare_to = [ var . resolve ( context , True ) for var in self . _varlist ]
if True: pass _newline_ else :pass
compare_to = nodelist_true_output = self . nodelist_true . render ( context )
try: pass _newline_ except VariableDoesNotExist :pass
compare_to = None
if compare_to != state_frame [ self ] :pass
state_frame [ self ] = compare_to
return nodelist_true_output or self . nodelist_true . render ( context )
if True: pass _newline_ elif self . nodelist_false :pass
return self . nodelist_false . render ( context )
return ''
def _get_context_stack_frame ( self , context ) :pass
if '_STR:0_' in context :pass
return context [ '_STR:0_' ]
if True: pass _newline_ else :pass
return context . render_context
class IfEqualNode ( Node ) :pass
child_nodelists = ( '_STR:0_' , '_STR:1_' )
def __init__ ( self , var1 , var2 , nodelist_true , nodelist_false , negate ) :pass
self . var1 , self . var2 = var1 , var2
self . nodelist_true , self . nodelist_false = nodelist_true , nodelist_false
self . negate = negate
def __repr__ ( self ) :pass
return '_STR:0_'
def render ( self , context ) :pass
val1 = self . var1 . resolve ( context , True )
val2 = self . var2 . resolve ( context , True )
if ( self . negate and val1 != val2 ) or ( not self . negate and val1 == val2 ) :pass
return self . nodelist_true . render ( context )
return self . nodelist_false . render ( context )
class IfNode ( Node ) :pass
def __init__ ( self , conditions_nodelists ) :pass
self . conditions_nodelists = conditions_nodelists
def __repr__ ( self ) :pass
return '_STR:0_'
def __iter__ ( self ) :pass
for _ , nodelist in self . conditions_nodelists :pass
for node in nodelist :pass
yield node
@ property _newline_ def dummy(): pass
def nodelist ( self ) :pass
return NodeList ( node for _ , nodelist in self . conditions_nodelists for node in nodelist )
def render ( self , context ) :pass
for condition , nodelist in self . conditions_nodelists :pass
if condition is not None :pass
try :pass _newline_ except: pass
match = condition . eval ( context )
try: pass _newline_ except VariableDoesNotExist :pass
match = None
if True: pass _newline_ else :pass
match = True
if match :pass
return nodelist . render ( context )
return ''
class RegroupNode ( Node ) :pass
def __init__ ( self , target , expression , var_name ) :pass
self . target , self . expression = target , expression
self . var_name = var_name
def resolve_expression ( self , obj , context ) :pass
context [ self . var_name ] = obj
return self . expression . resolve ( context , True )
def render ( self , context ) :pass
obj_list = self . target . resolve ( context , True )
if obj_list is None :pass
context [ self . var_name ] = [ ]
return ''
context [ self . var_name ] = [  { 'grouper' : key , 'list' : list ( val ) }  for key , val in  groupby ( obj_list , lambda obj : self . resolve_expression ( obj , context ) )  ]
return ''
def include_is_allowed ( filepath ) :pass
filepath = os . path . abspath ( filepath )
for root in settings . ALLOWED_INCLUDE_ROOTS :pass
if filepath . startswith ( root ) :pass
return True
return False
class SsiNode ( Node ) :pass
def __init__ ( self , filepath , parsed ) :pass
self . filepath = filepath
self . parsed = parsed
def render ( self , context ) :pass
filepath = self . filepath . resolve ( context )
if not include_is_allowed ( filepath ) :pass
if settings . DEBUG :pass
return '_STR:0_'
if True: pass _newline_ else :pass
return ''
try :pass _newline_ except: pass
with open ( filepath , 'r' ) as fp :pass
output = fp . read ( )
try: pass _newline_ except IOError :pass
output = ''
if self . parsed :pass
try :pass _newline_ except: pass
t = Template ( output , name = filepath )
return t . render ( context )
try: pass _newline_ except TemplateSyntaxError as e :pass
if settings . DEBUG :pass
return '_STR:0_' % e
if True: pass _newline_ else :pass
return ''
return output
class LoadNode ( Node ) :pass
def render ( self , context ) :pass
return ''
class NowNode ( Node ) :pass
def __init__ ( self , format_string ) :pass
self . format_string = format_string
def render ( self , context ) :pass
tzinfo = timezone . get_current_timezone ( ) if settings . USE_TZ else None
return date ( datetime . now ( tz = tzinfo ) , self . format_string )
class SpacelessNode ( Node ) :pass
def __init__ ( self , nodelist ) :pass
self . nodelist = nodelist
def render ( self , context ) :pass
from django . utils . html import strip_spaces_between_tags
return strip_spaces_between_tags ( self . nodelist . render ( context ) . strip ( ) )
class TemplateTagNode ( Node ) :pass
mapping = { '_STR:0_' : BLOCK_TAG_START ,  '_STR:1_' : BLOCK_TAG_END ,  'openvariable' : VARIABLE_TAG_START ,  'closevariable' : VARIABLE_TAG_END ,  'openbrace' : SINGLE_BRACE_START ,  'closebrace' : SINGLE_BRACE_END ,  'opencomment' : COMMENT_TAG_START ,  'closecomment' : COMMENT_TAG_END ,  }
def __init__ ( self , tagtype ) :pass
self . tagtype = tagtype
def render ( self , context ) :pass
return self . mapping . get ( self . tagtype , '' )
class URLNode ( Node ) :pass
def __init__ ( self , view_name , args , kwargs , asvar ) :pass
self . view_name = view_name
self . args = args
self . kwargs = kwargs
self . asvar = asvar
def render ( self , context ) :pass
from django . core . urlresolvers import reverse , NoReverseMatch
args = [ arg . resolve ( context ) for arg in self . args ]
kwargs = dict ( ( smart_text ( k , 'ascii' ) , v . resolve ( context ) )  for k , v in self . kwargs . items ( ) )
view_name = self . view_name . resolve ( context )
url = ''
try :pass _newline_ except: pass
url = reverse ( view_name , args = args , kwargs = kwargs , current_app = context . current_app )
try: pass _newline_ except NoReverseMatch :pass
exc_info = sys . exc_info ( )
if settings . SETTINGS_MODULE :pass
project_name = settings . SETTINGS_MODULE . split ( '_STR:0_' ) [ 0 ]
try :pass _newline_ except: pass
url = reverse ( project_name + '_STR:0_' + view_name ,  args = args , kwargs = kwargs ,  current_app = context . current_app )
try: pass _newline_ except NoReverseMatch :pass
if self . asvar is None :pass
six . reraise ( * exc_info )
if True: pass _newline_ else :pass
if self . asvar is None :pass
raise
if self . asvar :pass
context [ self . asvar ] = url
return ''
if True: pass _newline_ else :pass
return url
class VerbatimNode ( Node ) :pass
def __init__ ( self , content ) :pass
self . content = content
def render ( self , context ) :pass
return self . content
class WidthRatioNode ( Node ) :pass
def __init__ ( self , val_expr , max_expr , max_width , asvar = None ) :pass
self . val_expr = val_expr
self . max_expr = max_expr
self . max_width = max_width
self . asvar = asvar
def render ( self , context ) :pass
try :pass _newline_ except: pass
value = self . val_expr . resolve ( context )
max_value = self . max_expr . resolve ( context )
max_width = int ( self . max_width . resolve ( context ) )
try: pass _newline_ except VariableDoesNotExist :pass
return ''
try: pass _newline_ except ( ValueError , TypeError ) :pass
raise TemplateSyntaxError ( '_STR:0_' )
try :pass _newline_ except: pass
value = float ( value )
max_value = float ( max_value )
ratio = ( value / max_value ) * max_width
result = str ( int ( round ( ratio ) ) )
try: pass _newline_ except ZeroDivisionError :pass
return '_STR:0_'
try: pass _newline_ except ( ValueError , TypeError , OverflowError ) :pass
return ''
if self . asvar :pass
context [ self . asvar ] = result
return ''
if True: pass _newline_ else :pass
return result
class WithNode ( Node ) :pass
def __init__ ( self , var , name , nodelist , extra_context = None ) :pass
self . nodelist = nodelist
self . extra_context = extra_context or { }
if name :pass
self . extra_context [ name ] = var
def __repr__ ( self ) :pass
return '_STR:0_'
def render ( self , context ) :pass
values = dict ( ( key , val . resolve ( context ) ) for key , val in  six . iteritems ( self . extra_context ) )
with context . push ( ** values ) :pass
return self . nodelist . render ( context )
@ register . tag _newline_ def dummy(): pass
def autoescape ( parser , token ) :pass
args = token . contents . split ( )
if len ( args ) != 2 :pass
raise TemplateSyntaxError ( '_STR:0_' )
arg = args [ 1 ]
if arg not in ( '_STR:0_' , '_STR:1_' ) :pass
raise TemplateSyntaxError ( '_STR:0_' )
nodelist = parser . parse ( ( '_STR:0_' , ) )
parser . delete_first_token ( )
return AutoEscapeControlNode ( ( arg == '_STR:0_' ) , nodelist )
@ register . tag _newline_ def dummy(): pass
def comment ( parser , token ) :pass
parser . skip_past ( '_STR:0_' )
return CommentNode ( )
@ register . tag _newline_ def dummy(): pass
def cycle ( parser , token ) :pass
args = token . split_contents ( )
if len ( args ) < 2 :pass
raise TemplateSyntaxError ( '_STR:0_' )
if '_STR:0_' in args [ 1 ] :pass
args [ 1 : 2 ] = [ '"%s"' % arg for arg in args [ 1 ] . split ( "," ) ]
if len ( args ) == 2 :pass
name = args [ 1 ]
if not hasattr ( parser , '_STR:0_' ) :pass
raise TemplateSyntaxError ( '_STR:0_' % name )
if name not in parser . _namedCycleNodes :pass
raise TemplateSyntaxError ( '_STR:0_' % name )
return parser . _namedCycleNodes [ name ]
as_form = False
if len ( args ) > 4 :pass
if args [ - 3 ] == "as" :pass
if args [ - 1 ] != '_STR:0_' :pass
raise TemplateSyntaxError ( '_STR:0_' % args [ - 1 ] )
as_form = True
silent = True
args = args [ : - 1 ]
if True: pass _newline_ elif args [ - 2 ] == "as" :pass
as_form = True
silent = False
if as_form :pass
name = args [ - 1 ]
values = [ parser . compile_filter ( arg ) for arg in args [ 1 : - 2 ] ]
node = CycleNode ( values , name , silent = silent )
if not hasattr ( parser , '_STR:0_' ) :pass
parser . _namedCycleNodes = { }
parser . _namedCycleNodes [ name ] = node
if True: pass _newline_ else :pass
values = [ parser . compile_filter ( arg ) for arg in args [ 1 : ] ]
node = CycleNode ( values )
return node
@ register . tag _newline_ def dummy(): pass
def csrf_token ( parser , token ) :pass
return CsrfTokenNode ( )
@ register . tag _newline_ def dummy(): pass
def debug ( parser , token ) :pass
return DebugNode ( )
@ register . tag ( '_STR:0_' ) _newline_ def dummy(): pass
def do_filter ( parser , token ) :pass
_ , rest = token . contents . split ( None , 1 )
filter_expr = parser . compile_filter ( '_STR:0_' % ( rest ) )
for func , unused in filter_expr . filters :pass
filter_name = getattr ( func , '_STR:0_' , None )
if filter_name in ( '_STR:0_' , '_STR:1_' ) :pass
raise TemplateSyntaxError ( '_STR:0_' % filter_name )
nodelist = parser . parse ( ( '_STR:0_' , ) )
parser . delete_first_token ( )
return FilterNode ( filter_expr , nodelist )
@ register . tag _newline_ def dummy(): pass
def firstof ( parser , token ) :pass
bits = token . split_contents ( ) [ 1 : ]
if len ( bits ) < 1 :pass
raise TemplateSyntaxError ( '_STR:0_' )
return FirstOfNode ( [ parser . compile_filter ( bit ) for bit in bits ] )
@ register . tag ( '_STR:0_' ) _newline_ def dummy(): pass
def do_for ( parser , token ) :pass
bits = token . split_contents ( )
if len ( bits ) < 4 :pass
raise TemplateSyntaxError ( "'for' statements should have at least four"  " words: %s" % token . contents )
is_reversed = bits [ - 1 ] == '_STR:0_'
in_index = - 3 if is_reversed else - 2
if bits [ in_index ] != '_STR:0_' :pass
raise TemplateSyntaxError ( "'for' statements should use the format"  " 'for x in y': %s" % token . contents )
loopvars = re . split ( r'_STR:0_' , ' ' . join ( bits [ 1 : in_index ] ) )
for var in loopvars :pass
if not var or ' ' in var :pass
raise TemplateSyntaxError ( "'for' tag received an invalid argument:"  " %s" % token . contents )
sequence = parser . compile_filter ( bits [ in_index + 1 ] )
nodelist_loop = parser . parse ( ( '_STR:0_' , '_STR:1_' , ) )
token = parser . next_token ( )
if token . contents == '_STR:0_' :pass
nodelist_empty = parser . parse ( ( '_STR:0_' , ) )
parser . delete_first_token ( )
if True: pass _newline_ else :pass
nodelist_empty = None
return ForNode ( loopvars , sequence , is_reversed , nodelist_loop , nodelist_empty )
def do_ifequal ( parser , token , negate ) :pass
bits = list ( token . split_contents ( ) )
if len ( bits ) != 3 :pass
raise TemplateSyntaxError ( '_STR:0_' % bits [ 0 ] )
end_tag = '_STR:1_' + bits [ 0 ]
nodelist_loop = parser . parse ( ( '_STR:0_' , end_tag ) )
token = parser . next_token ( )
if token . contents == '_STR:0_' :pass
nodelist_false = parser . parse ( ( end_tag , ) )
parser . delete_first_token ( )
if True: pass _newline_ else :pass
nodelist_false = NodeList ( )
val1 = parser . compile_filter ( bits [ 1 ] )
val2 = parser . compile_filter ( bits [ 2 ] )
return IfEqualNode ( val1 , val2 , nodelist_true , nodelist_false , negate )
@ register . tag _newline_ def dummy(): pass
def ifequal ( parser , token ) :pass
return do_ifequal ( parser , token , False )
@ register . tag _newline_ def dummy(): pass
def ifnotequal ( parser , token ) :pass
return do_ifequal ( parser , token , True )
class TemplateLiteral ( Literal ) :pass
def __init__ ( self , value , text ) :pass
self . value = value
self . text = text
def display ( self ) :pass
return self . text
def eval ( self , context ) :pass
return self . value . resolve ( context , ignore_failures = True )
class TemplateIfParser ( IfParser ) :pass
error_class = TemplateSyntaxError
def __init__ ( self , parser , * args , ** kwargs ) :pass
self . template_parser = parser
super ( TemplateIfParser , self ) . __init__ ( * args , ** kwargs )
def create_var ( self , value ) :pass
return TemplateLiteral ( self . template_parser . compile_filter ( value ) , value )
@ register . tag ( '_STR:0_' ) _newline_ def dummy(): pass
def do_if ( parser , token ) :pass
bits = token . split_contents ( ) [ 1 : ]
condition = TemplateIfParser ( parser , bits ) . parse ( )
nodelist = parser . parse ( ( '_STR:0_' , '_STR:1_' , '_STR:2_' ) )
conditions_nodelists = [ ( condition , nodelist ) ]
token = parser . next_token ( )
while token . contents . startswith ( '_STR:0_' ) :pass
bits = token . split_contents ( ) [ 1 : ]
condition = TemplateIfParser ( parser , bits ) . parse ( )
nodelist = parser . parse ( ( '_STR:0_' , '_STR:1_' , '_STR:2_' ) )
conditions_nodelists . append ( ( condition , nodelist ) )
token = parser . next_token ( )
if token . contents == '_STR:0_' :pass
nodelist = parser . parse ( ( '_STR:0_' , ) )
conditions_nodelists . append ( ( None , nodelist ) )
token = parser . next_token ( )
assert token . contents == '_STR:0_'
return IfNode ( conditions_nodelists )
@ register . tag _newline_ def dummy(): pass
def ifchanged ( parser , token ) :pass
bits = token . split_contents ( )
nodelist_true = parser . parse ( ( '_STR:0_' , 'endifchanged' ) )
token = parser . next_token ( )
if token . contents == '_STR:0_' :pass
nodelist_false = parser . parse ( ( '_STR:0_' , ) )
parser . delete_first_token ( )
if True: pass _newline_ else :pass
nodelist_false = NodeList ( )
values = [ parser . compile_filter ( bit ) for bit in bits [ 1 : ] ]
return IfChangedNode ( nodelist_true , nodelist_false , * values )
@ register . tag _newline_ def dummy(): pass
def ssi ( parser , token ) :pass
bits = token . split_contents ( )
parsed = False
if len ( bits ) not in ( 2 , 3 ) :pass
raise TemplateSyntaxError ( "'ssi' tag takes one argument: the path to"  " the file to be included" )
if len ( bits ) == 3 :pass
if bits [ 2 ] == '_STR:0_' :pass
parsed = True
if True: pass _newline_ else :pass
raise TemplateSyntaxError ( "Second (optional) argument to %s tag"  " must be 'parsed'" % bits [ 0 ] )
filepath = parser . compile_filter ( bits [ 1 ] )
return SsiNode ( filepath , parsed )
@ register . tag _newline_ def dummy(): pass
def load ( parser , token ) :pass
bits = token . contents . split ( )
if len ( bits ) >= 4 and bits [ - 2 ] == "from" :pass
try :pass _newline_ except: pass
taglib = bits [ - 1 ]
lib = get_library ( taglib )
try: pass _newline_ except InvalidTemplateLibrary as e :pass
raise TemplateSyntaxError ( '_STR:0_' %  ( taglib , e ) )
if True: pass _newline_ else :pass
temp_lib = Library ( )
for name in bits [ 1 : - 2 ] :pass
if name in lib . tags :pass
temp_lib . tags [ name ] = lib . tags [ name ]
if name in lib . filters :pass
temp_lib . filters [ name ] = lib . filters [ name ]
if True: pass _newline_ elif name in lib . filters :pass
temp_lib . filters [ name ] = lib . filters [ name ]
if True: pass _newline_ else :pass
raise TemplateSyntaxError ( '_STR:0_' %  ( name , taglib ) )
parser . add_library ( temp_lib )
if True: pass _newline_ else :pass
for taglib in bits [ 1 : ] :pass
try :pass _newline_ except: pass
lib = get_library ( taglib )
parser . add_library ( lib )
try: pass _newline_ except InvalidTemplateLibrary as e :pass
raise TemplateSyntaxError ( '_STR:0_' %  ( taglib , e ) )
return LoadNode ( )
@ register . tag _newline_ def dummy(): pass
def now ( parser , token ) :pass
bits = token . split_contents ( )
if len ( bits ) != 2 :pass
raise TemplateSyntaxError ( '_STR:0_' )
format_string = bits [ 1 ] [ 1 : - 1 ]
return NowNode ( format_string )
@ register . tag _newline_ def dummy(): pass
def regroup ( parser , token ) :pass
bits = token . split_contents ( )
if len ( bits ) != 6 :pass
raise TemplateSyntaxError ( '_STR:0_' )
target = parser . compile_filter ( bits [ 1 ] )
if bits [ 2 ] != '_STR:0_' :pass
raise TemplateSyntaxError ( '_STR:0_' )
if bits [ 4 ] != '_STR:0_' :pass
raise TemplateSyntaxError ( "next-to-last argument to 'regroup' tag must"  " be 'as'" )
var_name = bits [ 5 ]
expression = parser . compile_filter ( var_name +  VARIABLE_ATTRIBUTE_SEPARATOR +  bits [ 3 ] )
return RegroupNode ( target , expression , var_name )
@ register . tag _newline_ def dummy(): pass
def spaceless ( parser , token ) :pass
nodelist = parser . parse ( ( '_STR:0_' , ) )
parser . delete_first_token ( )
return SpacelessNode ( nodelist )
@ register . tag _newline_ def dummy(): pass
def templatetag ( parser , token ) :pass
bits = token . contents . split ( )
if len ( bits ) != 2 :pass
raise TemplateSyntaxError ( '_STR:0_' )
tag = bits [ 1 ]
if tag not in TemplateTagNode . mapping :pass
raise TemplateSyntaxError ( "Invalid templatetag argument: '%s'."  " Must be one of: %s" %  ( tag , list ( TemplateTagNode . mapping ) ) )
return TemplateTagNode ( tag )
@ register . tag _newline_ def dummy(): pass
def url ( parser , token ) :pass
bits = token . split_contents ( )
if len ( bits ) < 2 :pass
raise TemplateSyntaxError ( "'%s' takes at least one argument"  " (path to a view)" % bits [ 0 ] )
viewname = parser . compile_filter ( bits [ 1 ] )
args = [ ]
kwargs = { }
asvar = None
bits = bits [ 2 : ]
if len ( bits ) >= 2 and bits [ - 2 ] == '_STR:0_' :pass
asvar = bits [ - 1 ]
bits = bits [ : - 2 ]
if len ( bits ) :pass
for bit in bits :pass
match = kwarg_re . match ( bit )
if not match :pass
raise TemplateSyntaxError ( '_STR:0_' )
name , value = match . groups ( )
if name :pass
kwargs [ name ] = parser . compile_filter ( value )
if True: pass _newline_ else :pass
args . append ( parser . compile_filter ( value ) )
return URLNode ( viewname , args , kwargs , asvar )
@ register . tag _newline_ def dummy(): pass
def verbatim ( parser , token ) :pass
nodelist = parser . parse ( ( '_STR:0_' , ) )
parser . delete_first_token ( )
return VerbatimNode ( nodelist . render ( Context ( ) ) )
@ register . tag _newline_ def dummy(): pass
def widthratio ( parser , token ) :pass
bits = token . split_contents ( )
if len ( bits ) == 4 :pass
tag , this_value_expr , max_value_expr , max_width = bits
asvar = None
if True: pass _newline_ elif len ( bits ) == 6 :pass
tag , this_value_expr , max_value_expr , max_width , as_ , asvar = bits
if as_ != '_STR:0_' :pass
raise TemplateSyntaxError ( '_STR:0_' )
if True: pass _newline_ else :pass
raise TemplateSyntaxError ( '_STR:0_' )
return WidthRatioNode ( parser . compile_filter ( this_value_expr ) ,  parser . compile_filter ( max_value_expr ) ,  parser . compile_filter ( max_width ) ,  asvar = asvar )
@ register . tag ( '_STR:0_' ) _newline_ def dummy(): pass
def do_with ( parser , token ) :pass
bits = token . split_contents ( )
remaining_bits = bits [ 1 : ]
extra_context = token_kwargs ( remaining_bits , parser , support_legacy = True )
if not extra_context :pass
raise TemplateSyntaxError ( "%r expected at least one variable "  "assignment" % bits [ 0 ] )
if remaining_bits :pass
raise TemplateSyntaxError ( '_STR:0_' %  ( bits [ 0 ] , remaining_bits [ 0 ] ) )
nodelist = parser . parse ( ( '_STR:0_' , ) )
parser . delete_first_token ( )
return WithNode ( None , None , nodelist , extra_context = extra_context )
from django . core . exceptions import ImproperlyConfigured
from django . template . base import Origin , Template , Context , TemplateDoesNotExist
from django . conf import settings
from django . utils . module_loading import import_string
from django . utils import six
template_source_loaders = None
class BaseLoader ( object ) :pass
is_usable = False
def __init__ ( self , * args , ** kwargs ) :pass
pass
def __call__ ( self , template_name , template_dirs = None ) :pass
return self . load_template ( template_name , template_dirs )
def load_template ( self , template_name , template_dirs = None ) :pass
source , display_name = self . load_template_source ( template_name , template_dirs )
origin = make_origin ( display_name , self . load_template_source , template_name , template_dirs )
try :pass _newline_ except: pass
template = get_template_from_string ( source , origin , template_name )
return template , None
try: pass _newline_ except TemplateDoesNotExist :pass
return source , display_name
def load_template_source ( self , template_name , template_dirs = None ) :pass
raise NotImplementedError ( '_STR:0_' )
def reset ( self ) :pass
pass
class LoaderOrigin ( Origin ) :pass
def __init__ ( self , display_name , loader , name , dirs ) :pass
super ( LoaderOrigin , self ) . __init__ ( display_name )
self . loader , self . loadname , self . dirs = loader , name , dirs
def reload ( self ) :pass
return self . loader ( self . loadname , self . dirs ) [ 0 ]
def make_origin ( display_name , loader , name , dirs ) :pass
if settings . TEMPLATE_DEBUG and display_name :pass
return LoaderOrigin ( display_name , loader , name , dirs )
if True: pass _newline_ else :pass
return None
def find_template_loader ( loader ) :pass
if isinstance ( loader , ( tuple , list ) ) :pass
loader , args = loader [ 0 ] , loader [ 1 : ]
if True: pass _newline_ else :pass
args = [ ]
if isinstance ( loader , six . string_types ) :pass
TemplateLoader = import_string ( loader )
if hasattr ( TemplateLoader , '_STR:0_' ) :pass
func = TemplateLoader ( * args )
if True: pass _newline_ else :pass
if args :pass
raise ImproperlyConfigured ( "Error importing template source loader %s - can't pass arguments to function-based loader." % loader )
func = TemplateLoader
if not func . is_usable :pass
import warnings
warnings . warn ( "Your TEMPLATE_LOADERS setting includes %r, but your Python installation doesn't support that type of template loading. Consider removing that line from TEMPLATE_LOADERS." % loader )
return None
if True: pass _newline_ else :pass
return func
if True: pass _newline_ else :pass
raise ImproperlyConfigured ( '_STR:0_' )
def find_template ( name , dirs = None ) :pass
global template_source_loaders
if template_source_loaders is None :pass
loaders = [ ]
for loader_name in settings . TEMPLATE_LOADERS :pass
loader = find_template_loader ( loader_name )
if loader is not None :pass
loaders . append ( loader )
template_source_loaders = tuple ( loaders )
for loader in template_source_loaders :pass
try :pass _newline_ except: pass
source , display_name = loader ( name , dirs )
return ( source , make_origin ( display_name , loader , name , dirs ) )
try: pass _newline_ except TemplateDoesNotExist :pass
pass
raise TemplateDoesNotExist ( name )
def get_template ( template_name , dirs = None ) :pass
template , origin = find_template ( template_name , dirs )
if not hasattr ( template , '_STR:0_' ) :pass
template = get_template_from_string ( template , origin , template_name )
return template
def get_template_from_string ( source , origin = None , name = None ) :pass
return Template ( source , origin , name )
def render_to_string ( template_name , dictionary = None , context_instance = None ,  dirs = None ) :pass
if isinstance ( template_name , ( list , tuple ) ) :pass
t = select_template ( template_name , dirs )
if True: pass _newline_ else :pass
t = get_template ( template_name , dirs )
if not context_instance :pass
return t . render ( Context ( dictionary ) )
if not dictionary :pass
return t . render ( context_instance )
with context_instance . push ( dictionary ) :pass
return t . render ( context_instance )
def select_template ( template_name_list , dirs = None ) :pass
if not template_name_list :pass
raise TemplateDoesNotExist ( '_STR:0_' )
not_found = [ ]
for template_name in template_name_list :pass
try :pass _newline_ except: pass
return get_template ( template_name , dirs )
try: pass _newline_ except TemplateDoesNotExist as e :pass
if e . args [ 0 ] not in not_found :pass
not_found . append ( e . args [ 0 ] )
continue
raise TemplateDoesNotExist ( '_STR:0_' . join ( not_found ) )
from collections import defaultdict
from django . conf import settings
from django . template . base import TemplateSyntaxError , Library , Node , TextNode , token_kwargs , Variable
from django . template . loader import get_template
from django . utils . safestring import mark_safe
from django . utils import six
register = Library ( )
BLOCK_CONTEXT_KEY = '_STR:0_'
class ExtendsError ( Exception ) :pass
pass
class BlockContext ( object ) :pass
def __init__ ( self ) :pass
self . blocks = defaultdict ( list )
def add_blocks ( self , blocks ) :pass
for name , block in six . iteritems ( blocks ) :pass
self . blocks [ name ] . insert ( 0 , block )
def pop ( self , name ) :pass
try :pass _newline_ except: pass
return self . blocks [ name ] . pop ( )
try: pass _newline_ except IndexError :pass
return None
def push ( self , name , block ) :pass
self . blocks [ name ] . append ( block )
def get_block ( self , name ) :pass
try :pass _newline_ except: pass
return self . blocks [ name ] [ - 1 ]
try: pass _newline_ except IndexError :pass
return None
class BlockNode ( Node ) :pass
def __init__ ( self , name , nodelist , parent = None ) :pass
self . name , self . nodelist , self . parent = name , nodelist , parent
def __repr__ ( self ) :pass
return '_STR:0_' % ( self . name , self . nodelist )
def render ( self , context ) :pass
block_context = context . render_context . get ( BLOCK_CONTEXT_KEY )
with context . push ( ) :pass
if block_context is None :pass
context [ '_STR:0_' ] = self
result = self . nodelist . render ( context )
if True: pass _newline_ else :pass
push = block = block_context . pop ( self . name )
if block is None :pass
block = self
block = type ( self ) ( block . name , block . nodelist )
block . context = context
context [ '_STR:0_' ] = block
result = block . nodelist . render ( context )
if push is not None :pass
block_context . push ( self . name , push )
return result
def super ( self ) :pass
render_context = self . context . render_context
if ( BLOCK_CONTEXT_KEY in render_context and  render_context [ BLOCK_CONTEXT_KEY ] . get_block ( self . name ) is not None ) :pass
return mark_safe ( self . render ( self . context ) )
return ''
class ExtendsNode ( Node ) :pass
must_be_first = True
def __init__ ( self , nodelist , parent_name , template_dirs = None ) :pass
self . nodelist = nodelist
self . parent_name = parent_name
self . template_dirs = template_dirs
self . blocks = dict ( ( n . name , n ) for n in nodelist . get_nodes_by_type ( BlockNode ) )
def __repr__ ( self ) :pass
return '_STR:0_' % self . parent_name . token
def get_parent ( self , context ) :pass
parent = self . parent_name . resolve ( context )
if not parent :pass
error_msg = '_STR:0_' % parent
if self . parent_name . filters or isinstance ( self . parent_name . var , Variable ) :pass
error_msg += '_STR:0_' % self . parent_name . token
raise TemplateSyntaxError ( error_msg )
if hasattr ( parent , '_STR:0_' ) :pass
return parent
return get_template ( parent )
def render ( self , context ) :pass
compiled_parent = self . get_parent ( context )
if BLOCK_CONTEXT_KEY not in context . render_context :pass
context . render_context [ BLOCK_CONTEXT_KEY ] = BlockContext ( )
block_context = context . render_context [ BLOCK_CONTEXT_KEY ]
block_context . add_blocks ( self . blocks )
for node in compiled_parent . nodelist :pass
if not isinstance ( node , TextNode ) :pass
if not isinstance ( node , ExtendsNode ) :pass
blocks = dict ( ( n . name , n ) for n in  compiled_parent . nodelist . get_nodes_by_type ( BlockNode ) )
block_context . add_blocks ( blocks )
break
return compiled_parent . _render ( context )
class IncludeNode ( Node ) :pass
def __init__ ( self , template , * args , ** kwargs ) :pass
self . template = template
self . extra_context = kwargs . pop ( '_STR:0_' , { } )
self . isolated_context = kwargs . pop ( '_STR:0_' , False )
super ( IncludeNode , self ) . __init__ ( * args , ** kwargs )
def render ( self , context ) :pass
try :pass _newline_ except: pass
template = self . template . resolve ( context )
if not callable ( getattr ( template , '_STR:0_' , None ) ) :pass
template = get_template ( template )
values = {  name : var . resolve ( context )  for name , var in six . iteritems ( self . extra_context )  }
if self . isolated_context :pass
return template . render ( context . new ( values ) )
with context . push ( ** values ) :pass
return template . render ( context )
try: pass _newline_ except Exception :pass
if settings . TEMPLATE_DEBUG :pass
raise
return ''
@ register . tag ( '_STR:0_' ) _newline_ def dummy(): pass
def do_block ( parser , token ) :pass
bits = token . contents . split ( )
if len ( bits ) != 2 :pass
raise TemplateSyntaxError ( '_STR:0_' % bits [ 0 ] )
block_name = bits [ 1 ]
try :pass _newline_ except: pass
if block_name in parser . __loaded_blocks :pass
raise TemplateSyntaxError ( '_STR:0_' % ( bits [ 0 ] , block_name ) )
parser . __loaded_blocks . append ( block_name )
try: pass _newline_ except AttributeError :pass
parser . __loaded_blocks = [ block_name ]
nodelist = parser . parse ( ( '_STR:0_' , ) )
endblock = parser . next_token ( )
acceptable_endblocks = ( '_STR:0_' , '_STR:1_' % block_name )
if endblock . contents not in acceptable_endblocks :pass
parser . invalid_block_tag ( endblock , '_STR:0_' , acceptable_endblocks )
return BlockNode ( block_name , nodelist )
@ register . tag ( '_STR:0_' ) _newline_ def dummy(): pass
def do_extends ( parser , token ) :pass
bits = token . split_contents ( )
if len ( bits ) != 2 :pass
raise TemplateSyntaxError ( '_STR:0_' % bits [ 0 ] )
parent_name = parser . compile_filter ( bits [ 1 ] )
nodelist = parser . parse ( )
if nodelist . get_nodes_by_type ( ExtendsNode ) :pass
raise TemplateSyntaxError ( '_STR:0_' % bits [ 0 ] )
return ExtendsNode ( nodelist , parent_name )
@ register . tag ( '_STR:0_' ) _newline_ def dummy(): pass
def do_include ( parser , token ) :pass
bits = token . split_contents ( )
if len ( bits ) < 2 :pass
raise TemplateSyntaxError ( '_STR:0_' % bits [ 0 ] )
options = { }
remaining_bits = bits [ 2 : ]
while remaining_bits :pass
option = remaining_bits . pop ( 0 )
if option in options :pass
raise TemplateSyntaxError ( 'The %r option was specified more '  'than once.' % option )
if option == '_STR:1_' :pass
value = token_kwargs ( remaining_bits , parser , support_legacy = False )
if not value :pass
raise TemplateSyntaxError ( '"with" in %r tag needs at least '  'one keyword argument.' % bits [ 0 ] )
if True: pass _newline_ elif option == '_STR:0_' :pass
value = True
if True: pass _newline_ else :pass
raise TemplateSyntaxError ( '_STR:0_' %  ( bits [ 0 ] , option ) )
options [ option ] = value
isolated_context = options . get ( '_STR:0_' , False )
namemap = options . get ( 'with' , { } )
return IncludeNode ( parser . compile_filter ( bits [ 1 ] ) , extra_context = namemap ,  isolated_context = isolated_context )
import os
import sys
from django . apps import apps
from django . conf import settings
from django . template . base import TemplateDoesNotExist
from django . template . loader import BaseLoader
from django . utils . _os import safe_join
from django . utils import six
def calculate_app_template_dirs ( ) :pass
if six . PY2 :pass
fs_encoding = sys . getfilesystemencoding ( ) or sys . getdefaultencoding ( )
app_template_dirs = [ ]
for app_config in apps . get_app_configs ( ) :pass
if not app_config . path :pass
continue
template_dir = os . path . join ( app_config . path , '_STR:0_' )
if os . path . isdir ( template_dir ) :pass
if six . PY2 :pass
template_dir = template_dir . decode ( fs_encoding )
app_template_dirs . append ( template_dir )
return tuple ( app_template_dirs )
app_template_dirs = calculate_app_template_dirs ( )
class Loader ( BaseLoader ) :pass
is_usable = True
def get_template_sources ( self , template_name , template_dirs = None ) :pass
if not template_dirs :pass
template_dirs = app_template_dirs
for template_dir in template_dirs :pass
try :pass _newline_ except: pass
yield safe_join ( template_dir , template_name )
try: pass _newline_ except UnicodeDecodeError :pass
raise
try: pass _newline_ except ValueError :pass
pass
def load_template_source ( self , template_name , template_dirs = None ) :pass
for filepath in self . get_template_sources ( template_name , template_dirs ) :pass
try :pass _newline_ except: pass
with open ( filepath , 'rb' ) as fp :pass
return ( fp . read ( ) . decode ( settings . FILE_CHARSET ) , filepath )
try: pass _newline_ except IOError :pass
pass
raise TemplateDoesNotExist ( template_name )
import hashlib
from django . template . base import TemplateDoesNotExist
from django . template . loader import BaseLoader , get_template_from_string , find_template_loader , make_origin
from django . utils . encoding import force_bytes
class Loader ( BaseLoader ) :pass
is_usable = True
def __init__ ( self , loaders ) :pass
self . template_cache = { }
self . find_template_cache = { }
self . _loaders = loaders
self . _cached_loaders = [ ]
@ property _newline_ def dummy(): pass
def loaders ( self ) :pass
if not self . _cached_loaders :pass
cached_loaders = [ ]
for loader in self . _loaders :pass
cached_loaders . append ( find_template_loader ( loader ) )
self . _cached_loaders = cached_loaders
return self . _cached_loaders
def cache_key ( self , template_name , template_dirs ) :pass
if template_dirs :pass
return '-' . join ( [ template_name , hashlib . sha1 ( force_bytes ( '_STR:0_' . join ( template_dirs ) ) ) . hexdigest ( ) ] )
if True: pass _newline_ else :pass
return template_name
def find_template ( self , name , dirs = None ) :pass
key = self . cache_key ( name , dirs )
try :pass _newline_ except: pass
result = self . find_template_cache [ key ]
try: pass _newline_ except KeyError :pass
result = None
for loader in self . loaders :pass
try :pass _newline_ except: pass
template , display_name = loader ( name , dirs )
try: pass _newline_ except TemplateDoesNotExist :pass
pass
if True: pass _newline_ else :pass
result = ( template , make_origin ( display_name , loader , name , dirs ) )
break
self . find_template_cache [ key ] = result
if result :pass
return result
if True: pass _newline_ else :pass
self . template_cache [ key ] = TemplateDoesNotExist
raise TemplateDoesNotExist ( name )
def load_template ( self , template_name , template_dirs = None ) :pass
key = self . cache_key ( template_name , template_dirs )
template_tuple = self . template_cache . get ( key )
if template_tuple is TemplateDoesNotExist :pass
raise TemplateDoesNotExist
if True: pass _newline_ elif template_tuple is None :pass
template , origin = self . find_template ( template_name , template_dirs )
if not hasattr ( template , '_STR:0_' ) :pass
try :pass _newline_ except: pass
template = get_template_from_string ( template , origin , template_name )
try: pass _newline_ except TemplateDoesNotExist :pass
self . template_cache [ key ] = ( template , origin )
self . template_cache [ key ] = ( template , None )
return self . template_cache [ key ]
def reset ( self ) :pass
self . template_cache . clear ( )
self . find_template_cache . clear ( )
from __future__ import unicode_literals
try :pass _newline_ except: pass
from pkg_resources import resource_string
try: pass _newline_ except ImportError :pass
resource_string = None
from django . apps import apps
from django . conf import settings
from django . template . base import TemplateDoesNotExist
from django . template . loader import BaseLoader
from django . utils import six
class Loader ( BaseLoader ) :pass
is_usable = resource_string is not None
def load_template_source ( self , template_name , template_dirs = None ) :pass
if resource_string is not None :pass
pkg_name = '_STR:0_' + template_name
for app_config in apps . get_app_configs ( ) :pass
try :pass _newline_ except: pass
resource = resource_string ( app_config . name , pkg_name )
try: pass _newline_ except Exception :pass
continue
if six . PY2 :pass
resource = resource . decode ( settings . FILE_CHARSET )
return ( resource , '_STR:0_' % ( app_config . name , pkg_name ) )
raise TemplateDoesNotExist ( template_name )
from django . conf import settings
from django . template . base import TemplateDoesNotExist
from django . template . loader import BaseLoader
from django . utils . _os import safe_join
class Loader ( BaseLoader ) :pass
is_usable = True
def get_template_sources ( self , template_name , template_dirs = None ) :pass
if not template_dirs :pass
template_dirs = settings . TEMPLATE_DIRS
for template_dir in template_dirs :pass
try :pass _newline_ except: pass
yield safe_join ( template_dir , template_name )
try: pass _newline_ except UnicodeDecodeError :pass
raise
try: pass _newline_ except ValueError :pass
pass
def load_template_source ( self , template_name , template_dirs = None ) :pass
tried = [ ]
for filepath in self . get_template_sources ( template_name , template_dirs ) :pass
try :pass _newline_ except: pass
with open ( filepath , 'rb' ) as fp :pass
return ( fp . read ( ) . decode ( settings . FILE_CHARSET ) , filepath )
try: pass _newline_ except IOError :pass
tried . append ( filepath )
if tried :pass
error_msg = '_STR:0_' % tried
if True: pass _newline_ else :pass
error_msg = '_STR:0_'
raise TemplateDoesNotExist ( error_msg )
load_template_source . is_usable = True
from django . http import HttpResponse
from django . template import loader , Context , RequestContext
from django . utils import six
class ContentNotRenderedError ( Exception ) :pass
pass
class SimpleTemplateResponse ( HttpResponse ) :pass
rendering_attrs = [ '_STR:0_' , '_STR:1_' , '_STR:2_' ]
def __init__ ( self , template , context = None , content_type = None , status = None ) :pass
self . template_name = template
self . context_data = context
self . _post_render_callbacks = [ ]
super ( SimpleTemplateResponse , self ) . __init__ ( '' , content_type , status )
self . _is_rendered = False
def __getstate__ ( self ) :pass
obj_dict = super ( SimpleTemplateResponse , self ) . __getstate__ ( )
if not self . _is_rendered :pass
raise ContentNotRenderedError ( 'The response content must be '  'rendered before it can be pickled.' )
for attr in self . rendering_attrs :pass
if attr in obj_dict :pass
del obj_dict [ attr ]
return obj_dict
def resolve_template ( self , template ) :pass
if isinstance ( template , ( list , tuple ) ) :pass
return loader . select_template ( template )
if True: pass _newline_ elif isinstance ( template , six . string_types ) :pass
return loader . get_template ( template )
if True: pass _newline_ else :pass
return template
def resolve_context ( self , context ) :pass
if isinstance ( context , Context ) :pass
return context
if True: pass _newline_ else :pass
return Context ( context )
@ property _newline_ def dummy(): pass
def rendered_content ( self ) :pass
template = self . resolve_template ( self . template_name )
context = self . resolve_context ( self . context_data )
content = template . render ( context )
return content
def add_post_render_callback ( self , callback ) :pass
if self . _is_rendered :pass
callback ( self )
if True: pass _newline_ else :pass
self . _post_render_callbacks . append ( callback )
def render ( self ) :pass
retval = self
if not self . _is_rendered :pass
self . content = self . rendered_content
for post_callback in self . _post_render_callbacks :pass
newretval = post_callback ( retval )
if newretval is not None :pass
retval = newretval
return retval
@ property _newline_ def dummy(): pass
def is_rendered ( self ) :pass
return self . _is_rendered
def __iter__ ( self ) :pass
if not self . _is_rendered :pass
raise ContentNotRenderedError ( 'The response content must be '  'rendered before it can be iterated over.' )
return super ( SimpleTemplateResponse , self ) . __iter__ ( )
@ property _newline_ def dummy(): pass
def content ( self ) :pass
if not self . _is_rendered :pass
raise ContentNotRenderedError ( 'The response content must be '  'rendered before it can be accessed.' )
return super ( SimpleTemplateResponse , self ) . content
@ content . setter _newline_ def dummy(): pass
def content ( self , value ) :pass
HttpResponse . content . fset ( self , value )
self . _is_rendered = True
class TemplateResponse ( SimpleTemplateResponse ) :pass
rendering_attrs = SimpleTemplateResponse . rendering_attrs + [ '_STR:0_' , '_STR:1_' ]
def __init__ ( self , request , template , context = None , content_type = None ,  status = None , current_app = None ) :pass
self . _request = request
self . _current_app = current_app
super ( TemplateResponse , self ) . __init__ (  template , context , content_type , status )
def resolve_context ( self , context ) :pass
if isinstance ( context , Context ) :pass
return context
return RequestContext ( self . _request , context , current_app = self . _current_app )
class TokenBase ( object ) :pass
id = None
value = None
first = second = None
def nud ( self , parser ) :pass
raise parser . error_class (  '_STR:0_' % self . id  )
def led ( self , left , parser ) :pass
raise parser . error_class (  '_STR:0_' % self . id  )
def display ( self ) :pass
return self . id
def __repr__ ( self ) :pass
out = [ str ( x ) for x in [ self . id , self . first , self . second ] if x is not None ]
return "(" + " " . join ( out ) + ")"
def infix ( bp , func ) :pass
class Operator ( TokenBase ) :pass
lbp = bp
def led ( self , left , parser ) :pass
self . first = left
self . second = parser . expression ( bp )
return self
def eval ( self , context ) :pass
try :pass _newline_ except: pass
return func ( context , self . first , self . second )
try: pass _newline_ except Exception :pass
return False
return Operator
def prefix ( bp , func ) :pass
class Operator ( TokenBase ) :pass
lbp = bp
def nud ( self , parser ) :pass
self . first = parser . expression ( bp )
self . second = None
return self
def eval ( self , context ) :pass
try :pass _newline_ except: pass
return func ( context , self . first )
try: pass _newline_ except Exception :pass
return False
return Operator
OPERATORS = {  'or' : infix ( 6 , lambda context , x , y : x . eval ( context ) or y . eval ( context ) ) ,  'and' : infix ( 7 , lambda context , x , y : x . eval ( context ) and y . eval ( context ) ) ,  'not' : prefix ( 8 , lambda context , x : not x . eval ( context ) ) ,  'in' : infix ( 9 , lambda context , x , y : x . eval ( context ) in y . eval ( context ) ) ,  'not in' : infix ( 9 , lambda context , x , y : x . eval ( context ) not in y . eval ( context ) ) ,  '=' : infix ( 10 , lambda context , x , y : x . eval ( context ) == y . eval ( context ) ) ,  '==' : infix ( 10 , lambda context , x , y : x . eval ( context ) == y . eval ( context ) ) ,  '!=' : infix ( 10 , lambda context , x , y : x . eval ( context ) != y . eval ( context ) ) ,  '>' : infix ( 10 , lambda context , x , y : x . eval ( context ) > y . eval ( context ) ) ,  '>=' : infix ( 10 , lambda context , x , y : x . eval ( context ) >= y . eval ( context ) ) ,  '<' : infix ( 10 , lambda context , x , y : x . eval ( context ) < y . eval ( context ) ) ,  '<=' : infix ( 10 , lambda context , x , y : x . eval ( context ) <= y . eval ( context ) ) ,  }
for key , op in OPERATORS . items ( ) :pass
op . id = key
class Literal ( TokenBase ) :pass
id = '_STR:0_'
lbp = 0
def __init__ ( self , value ) :pass
self . value = value
def display ( self ) :pass
return repr ( self . value )
def nud ( self , parser ) :pass
return self
def eval ( self , context ) :pass
return self . value
def __repr__ ( self ) :pass
return '_STR:0_' % ( self . id , self . value )
class EndToken ( TokenBase ) :pass
lbp = 0
def nud ( self , parser ) :pass
raise parser . error_class ( '_STR:0_' )
EndToken = EndToken ( )
class IfParser ( object ) :pass
error_class = ValueError
def __init__ ( self , tokens ) :pass
l = len ( tokens )
mapped_tokens = [ ]
i = 0
while i < l :pass
token = tokens [ i ]
if token == '_STR:0_' and i + 1 < l and tokens [ i + 1 ] == "in" :pass
token = '_STR:1_'
i += 1
mapped_tokens . append ( self . translate_token ( token ) )
i += 1
self . tokens = mapped_tokens
self . pos = 0
self . current_token = self . next_token ( )
def translate_token ( self , token ) :pass
try :pass _newline_ except: pass
op = OPERATORS [ token ]
try: pass _newline_ except ( KeyError , TypeError ) :pass
return self . create_var ( token )
if True: pass _newline_ else :pass
return op ( )
def next_token ( self ) :pass
if self . pos >= len ( self . tokens ) :pass
return EndToken
if True: pass _newline_ else :pass
retval = self . tokens [ self . pos ]
self . pos += 1
return retval
def parse ( self ) :pass
retval = self . expression ( )
if self . current_token is not EndToken :pass
raise self . error_class ( "Unused '%s' at end of if expression." %  self . current_token . display ( ) )
return retval
def expression ( self , rbp = 0 ) :pass
t = self . current_token
self . current_token = self . next_token ( )
left = t . nud ( self )
while rbp < self . current_token . lbp :pass
t = self . current_token
self . current_token = self . next_token ( )
left = t . led ( left , self )
return left
def create_var ( self , value ) :pass
return Literal ( value )
from __future__ import unicode_literals
from lib2to3 import fixer_base
from lib2to3 . fixer_util import find_indentation , Name , syms , touch_import
from lib2to3 . pgen2 import token
from lib2to3 . pytree import Leaf , Node
class FixUnicode ( fixer_base . BaseFix ) :pass
BM_compatible = True
PATTERN = """     classdef< 'class' any+ ':'               suite< any*                      funcdef< 'def' unifunc='__unicode__'                               parameters< '(' NAME ')' > any+ >                      any* > >     """
def transform ( self , node , results ) :pass
unifunc = results [ '_STR:0_' ]
strfunc = Name ( '_STR:0_' , prefix = unifunc . prefix )
unifunc . replace ( strfunc )
klass = node . clone ( )
klass . prefix = '\n' + find_indentation ( node )
decorator = Node ( syms . decorator , [ Leaf ( token . AT , "@" ) , Name ( 'python_2_unicode_compatible' ) ] )
decorated = Node ( syms . decorated , [ decorator , klass ] , prefix = node . prefix )
node . replace ( decorated )
touch_import ( '_STR:0_' , '_STR:1_' , decorated )
import os
import stat
import sys
import tempfile
from os . path import join , normcase , normpath , abspath , isabs , sep , dirname
from django . utils . encoding import force_text
from django . utils import six
try :pass _newline_ except: pass
WindowsError = WindowsError
try: pass _newline_ except NameError :pass
class WindowsError ( Exception ) :pass
pass
if six . PY2 :pass
fs_encoding = sys . getfilesystemencoding ( ) or sys . getdefaultencoding ( )
if six . PY3 or os . name == '_STR:0_' :pass
abspathu = abspath
if True: pass _newline_ else :pass
def abspathu ( path ) :pass
if not isabs ( path ) :pass
path = join ( os . getcwdu ( ) , path )
return normpath ( path )
def upath ( path ) :pass
if six . PY2 and not isinstance ( path , six . text_type ) :pass
return path . decode ( fs_encoding )
return path
def npath ( path ) :pass
if six . PY2 and not isinstance ( path , bytes ) :pass
return path . encode ( fs_encoding )
return path
def safe_join ( base , * paths ) :pass
base = force_text ( base )
paths = [ force_text ( p ) for p in paths ]
final_path = abspathu ( join ( base , * paths ) )
base_path = abspathu ( base )
if ( not normcase ( final_path ) . startswith ( normcase ( base_path + sep ) ) and  normcase ( final_path ) != normcase ( base_path ) and  dirname ( normcase ( base_path ) ) != normcase ( base_path ) ) :pass
raise ValueError ( 'The joined path (%s) is located outside of the base '  'path component (%s)' % ( final_path , base_path ) )
return final_path
def rmtree_errorhandler ( func , path , exc_info ) :pass
exctype , value = exc_info [ : 2 ]
if exctype is not WindowsError or '_STR:0_' not in str ( value ) :pass
raise
if ( ( os . stat ( path ) . st_mode & stat . S_IREAD ) != stat . S_IREAD ) :pass
raise
os . chmod ( path , stat . S_IWRITE )
func ( path )
def symlinks_supported ( ) :pass
tmpdir = tempfile . mkdtemp ( )
original_path = os . path . join ( tmpdir , '_STR:0_' )
symlink_path = os . path . join ( tmpdir , '_STR:0_' )
os . makedirs ( original_path )
try :pass _newline_ except: pass
os . symlink ( original_path , symlink_path )
supported = True
try: pass _newline_ except ( OSError , NotImplementedError , AttributeError ) :pass
supported = False
if True: pass _newline_ else :pass
os . remove ( symlink_path )
try: pass _newline_ finally :pass
os . rmdir ( original_path )
os . rmdir ( tmpdir )
return supported
import os
import shutil
import tarfile
import zipfile
from django . utils import six
class ArchiveException ( Exception ) :pass
class UnrecognizedArchiveFormat ( ArchiveException ) :pass
def extract ( path , to_path = '' ) :pass
with Archive ( path ) as archive :pass
archive . extract ( to_path )
class Archive ( object ) :pass
def __init__ ( self , file ) :pass
self . _archive = self . _archive_cls ( file ) ( file )
@ staticmethod _newline_ def dummy(): pass
def _archive_cls ( file ) :pass
cls = None
if isinstance ( file , six . string_types ) :pass
filename = file
if True: pass _newline_ else :pass
try :pass _newline_ except: pass
filename = file . name
try: pass _newline_ except AttributeError :pass
raise UnrecognizedArchiveFormat (  '_STR:0_' )
base , tail_ext = os . path . splitext ( filename . lower ( ) )
cls = extension_map . get ( tail_ext )
if not cls :pass
base , ext = os . path . splitext ( base )
cls = extension_map . get ( ext )
if not cls :pass
raise UnrecognizedArchiveFormat (  '_STR:0_' % filename )
return cls
def __enter__ ( self ) :pass
return self
def __exit__ ( self , exc_type , exc_value , traceback ) :pass
self . close ( )
def extract ( self , to_path = '' ) :pass
self . _archive . extract ( to_path )
def list ( self ) :pass
self . _archive . list ( )
def close ( self ) :pass
self . _archive . close ( )
class BaseArchive ( object ) :pass
def split_leading_dir ( self , path ) :pass
path = str ( path )
path = path . lstrip ( '_STR:0_' ) . lstrip ( '\\' )
if '_STR:0_' in path and ( ( '\\' in path and path . find ( '_STR:0_' ) < path . find ( '\\' ) )  or '\\' not in path ) :pass
return path . split ( '/' , 1 )
if True: pass _newline_ elif '\\' in path :pass
return path . split ( '\\' , 1 )
if True: pass _newline_ else :pass
return path , ''
def has_leading_dir ( self , paths ) :pass
common_prefix = None
for path in paths :pass
prefix , rest = self . split_leading_dir ( path )
if not prefix :pass
return False
if True: pass _newline_ elif common_prefix is None :pass
common_prefix = prefix
if True: pass _newline_ elif prefix != common_prefix :pass
return False
return True
def extract ( self ) :pass
raise NotImplementedError ( '_STR:0_' )
def list ( self ) :pass
raise NotImplementedError ( '_STR:0_' )
class TarArchive ( BaseArchive ) :pass
def __init__ ( self , file ) :pass
self . _archive = tarfile . open ( file )
def list ( self , * args , ** kwargs ) :pass
self . _archive . list ( * args , ** kwargs )
def extract ( self , to_path ) :pass
members = [ member for member in self . _archive . getmembers ( )  if member . name != 'pax_global_header' ]
leading = self . has_leading_dir ( x . name for x in members )
for member in members :pass
name = member . name
if leading :pass
name = self . split_leading_dir ( name ) [ 1 ]
filename = os . path . join ( to_path , name )
if member . isdir ( ) :pass
if filename and not os . path . exists ( filename ) :pass
os . makedirs ( filename )
if True: pass _newline_ else :pass
try :pass _newline_ except: pass
extracted = self . _archive . extractfile ( member )
try: pass _newline_ except ( KeyError , AttributeError ) as exc :pass
print ( '_STR:0_' %  ( name , member . name , exc ) )
if True: pass _newline_ else :pass
dirname = os . path . dirname ( filename )
if dirname and not os . path . exists ( dirname ) :pass
os . makedirs ( dirname )
with open ( filename , 'wb' ) as outfile :pass
shutil . copyfileobj ( extracted , outfile )
try: pass _newline_ finally :pass
if extracted :pass
extracted . close ( )
def close ( self ) :pass
self . _archive . close ( )
class ZipArchive ( BaseArchive ) :pass
def __init__ ( self , file ) :pass
self . _archive = zipfile . ZipFile ( file )
def list ( self , * args , ** kwargs ) :pass
self . _archive . printdir ( * args , ** kwargs )
def extract ( self , to_path ) :pass
namelist = self . _archive . namelist ( )
leading = self . has_leading_dir ( namelist )
for name in namelist :pass
data = self . _archive . read ( name )
if leading :pass
name = self . split_leading_dir ( name ) [ 1 ]
filename = os . path . join ( to_path , name )
dirname = os . path . dirname ( filename )
if dirname and not os . path . exists ( dirname ) :pass
os . makedirs ( dirname )
if filename . endswith ( ( '_STR:0_' , '\\' ) ) :pass
if not os . path . exists ( filename ) :pass
os . makedirs ( filename )
if True: pass _newline_ else :pass
with open ( filename , 'wb' ) as outfile :pass
outfile . write ( data )
def close ( self ) :pass
self . _archive . close ( )
extension_map = {  '_STR:0_' : TarArchive ,  '_STR:1_' : TarArchive ,  '_STR:2_' : TarArchive ,  '.tgz' : TarArchive ,  '.tz2' : TarArchive ,  '.zip' : ZipArchive ,  }
from __future__ import absolute_import
import os
import signal
import sys
import time
import traceback
from django . apps import apps
from django . conf import settings
from django . core . signals import request_finished
try :pass _newline_ except: pass
from django . utils . six . moves import _thread as thread
try: pass _newline_ except ImportError :pass
from django . utils . six . moves import _dummy_thread as thread
try :pass _newline_ except: pass
import threading
try: pass _newline_ except ImportError :pass
pass
try :pass _newline_ except: pass
import termios
try: pass _newline_ except ImportError :pass
termios = None
USE_INOTIFY = False
try :pass _newline_ except: pass
import pyinotify
fd = pyinotify . INotifyWrapper . create ( ) . inotify_init ( )
if fd >= 0 :pass
USE_INOTIFY = True
os . close ( fd )
try: pass _newline_ except ImportError :pass
pass
RUN_RELOADER = True
FILE_MODIFIED = 1
I18N_MODIFIED = 2
_mtimes = { }
_win = ( sys . platform == '_STR:0_' )
_error_files = [ ]
_cached_modules = set ( )
_cached_filenames = [ ]
def gen_filenames ( only_new = False ) :pass
global _cached_modules , _cached_filenames
module_values = set ( sys . modules . values ( ) )
if _cached_modules == module_values :pass
if only_new :pass
return [ ]
if True: pass _newline_ else :pass
return _cached_filenames
new_modules = module_values - _cached_modules
new_filenames = [ filename . __file__ for filename in new_modules  if hasattr ( filename , '_STR:0_' ) ]
if not _cached_filenames and settings . USE_I18N :pass
basedirs = [ os . path . join ( os . path . dirname ( os . path . dirname ( __file__ ) ) ,  '_STR:0_' , '_STR:1_' ) ,  '_STR:1_' ]
for app_config in reversed ( list ( apps . get_app_configs ( ) ) ) :pass
basedirs . append ( os . path . join ( app_config . path , '_STR:0_' ) )
basedirs . extend ( settings . LOCALE_PATHS )
basedirs = [ os . path . abspath ( basedir ) for basedir in basedirs  if os . path . isdir ( basedir ) ]
for basedir in basedirs :pass
for dirpath , dirnames , locale_filenames in os . walk ( basedir ) :pass
for filename in locale_filenames :pass
if filename . endswith ( '_STR:0_' ) :pass
new_filenames . append ( os . path . join ( dirpath , filename ) )
if only_new :pass
filelist = new_filenames
if True: pass _newline_ else :pass
filelist = _cached_filenames + new_filenames + _error_files
filenames = [ ]
for filename in filelist :pass
if not filename :pass
continue
if filename . endswith ( '_STR:0_' ) or filename . endswith ( '_STR:1_' ) :pass
filename = filename [ : - 1 ]
if filename . endswith ( '_STR:0_' ) :pass
filename = filename [ : - 9 ] + '_STR:0_'
if os . path . exists ( filename ) :pass
filenames . append ( filename )
_cached_modules = _cached_modules . union ( new_modules )
_cached_filenames += new_filenames
return filenames
def reset_translations ( ) :pass
import gettext
from django . utils . translation import trans_real
gettext . _translations = { }
trans_real . _translations = { }
trans_real . _default = None
trans_real . _active = threading . local ( )
def inotify_code_changed ( ) :pass
class EventHandler ( pyinotify . ProcessEvent ) :pass
modified_code = None
def process_default ( self , event ) :pass
if event . path . endswith ( '_STR:0_' ) :pass
EventHandler . modified_code = I18N_MODIFIED
if True: pass _newline_ else :pass
EventHandler . modified_code = FILE_MODIFIED
wm = pyinotify . WatchManager ( )
notifier = pyinotify . Notifier ( wm , EventHandler ( ) )
def update_watch ( sender = None , ** kwargs ) :pass
if sender and getattr ( sender , '_STR:0_' , False ) :pass
return
mask = (  pyinotify . IN_MODIFY |  pyinotify . IN_DELETE |  pyinotify . IN_ATTRIB |  pyinotify . IN_MOVED_FROM |  pyinotify . IN_MOVED_TO |  pyinotify . IN_CREATE  )
for path in gen_filenames ( only_new = True ) :pass
wm . add_watch ( path , mask )
request_finished . connect ( update_watch )
update_watch ( )
notifier . check_events ( timeout = None )
notifier . read_events ( )
notifier . process_events ( )
notifier . stop ( )
return EventHandler . modified_code
def code_changed ( ) :pass
global _mtimes , _win
for filename in gen_filenames ( ) :pass
stat = os . stat ( filename )
mtime = stat . st_mtime
if _win :pass
mtime -= stat . st_ctime
if filename not in _mtimes :pass
_mtimes [ filename ] = mtime
continue
if mtime != _mtimes [ filename ] :pass
_mtimes = { }
try :pass _newline_ except: pass
del _error_files [ _error_files . index ( filename ) ]
try: pass _newline_ except ValueError :pass
pass
return I18N_MODIFIED if filename . endswith ( '_STR:0_' ) else FILE_MODIFIED
return False
def check_errors ( fn ) :pass
def wrapper ( * args , ** kwargs ) :pass
try :pass _newline_ except: pass
fn ( * args , ** kwargs )
try: pass _newline_ except ( ImportError , IndentationError , NameError , SyntaxError ,  TypeError , AttributeError ) :pass
et , ev , tb = sys . exc_info ( )
if getattr ( ev , '_STR:0_' , None ) is None :pass
filename = traceback . extract_tb ( tb ) [ - 1 ] [ 0 ]
if True: pass _newline_ else :pass
filename = ev . filename
if filename not in _error_files :pass
_error_files . append ( filename )
raise
return wrapper
def ensure_echo_on ( ) :pass
if termios :pass
fd = sys . stdin
if fd . isatty ( ) :pass
attr_list = termios . tcgetattr ( fd )
if not attr_list [ 3 ] & termios . ECHO :pass
attr_list [ 3 ] |= termios . ECHO
if hasattr ( signal , '_STR:0_' ) :pass
old_handler = signal . signal ( signal . SIGTTOU , signal . SIG_IGN )
if True: pass _newline_ else :pass
old_handler = None
termios . tcsetattr ( fd , termios . TCSANOW , attr_list )
if old_handler is not None :pass
signal . signal ( signal . SIGTTOU , old_handler )
def reloader_thread ( ) :pass
ensure_echo_on ( )
if USE_INOTIFY :pass
fn = inotify_code_changed
if True: pass _newline_ else :pass
fn = code_changed
while RUN_RELOADER :pass
change = fn ( )
if change == FILE_MODIFIED :pass
sys . exit ( 3 )
if True: pass _newline_ elif change == I18N_MODIFIED :pass
reset_translations ( )
time . sleep ( 1 )
def restart_with_reloader ( ) :pass
while True :pass
args = [ sys . executable ] + [ '_STR:0_' % o for o in sys . warnoptions ] + sys . argv
if sys . platform == '_STR:0_' :pass
args = [ '"%s"' % arg for arg in args ]
new_environ = os . environ . copy ( )
new_environ [ '_STR:0_' ] = '_STR:1_'
exit_code = os . spawnve ( os . P_WAIT , sys . executable , args , new_environ )
if exit_code != 3 :pass
return exit_code
def python_reloader ( main_func , args , kwargs ) :pass
if os . environ . get ( '_STR:0_' ) == '_STR:1_' :pass
thread . start_new_thread ( main_func , args , kwargs )
try :pass _newline_ except: pass
reloader_thread ( )
try: pass _newline_ except KeyboardInterrupt :pass
pass
if True: pass _newline_ else :pass
try :pass _newline_ except: pass
exit_code = restart_with_reloader ( )
if exit_code < 0 :pass
os . kill ( os . getpid ( ) , - exit_code )
if True: pass _newline_ else :pass
sys . exit ( exit_code )
try: pass _newline_ except KeyboardInterrupt :pass
pass
def jython_reloader ( main_func , args , kwargs ) :pass
from _systemrestart import SystemRestart
thread . start_new_thread ( main_func , args )
while True :pass
if code_changed ( ) :pass
raise SystemRestart
time . sleep ( 1 )
def main ( main_func , args = None , kwargs = None ) :pass
if args is None :pass
args = ( )
if kwargs is None :pass
kwargs = { }
if sys . platform . startswith ( '_STR:0_' ) :pass
reloader = jython_reloader
if True: pass _newline_ else :pass
reloader = python_reloader
wrapped_main_func = check_errors ( main_func )
reloader ( wrapped_main_func , args , kwargs )
BASE2_ALPHABET = '_STR:0_'
BASE16_ALPHABET = '_STR:0_'
BASE56_ALPHABET = '_STR:0_'
BASE36_ALPHABET = '_STR:0_'
BASE62_ALPHABET = '_STR:0_'
BASE64_ALPHABET = BASE62_ALPHABET + '_STR:0_'
class BaseConverter ( object ) :pass
decimal_digits = '_STR:0_'
def __init__ ( self , digits , sign = '_STR:0_' ) :pass
self . sign = sign
self . digits = digits
if sign in self . digits :pass
raise ValueError ( '_STR:0_' )
def __repr__ ( self ) :pass
return '_STR:0_' % ( len ( self . digits ) , self . digits )
def encode ( self , i ) :pass
neg , value = self . convert ( i , self . decimal_digits , self . digits , '_STR:0_' )
if neg :pass
return self . sign + value
return value
def decode ( self , s ) :pass
neg , value = self . convert ( s , self . digits , self . decimal_digits , self . sign )
if neg :pass
value = '_STR:0_' + value
return int ( value )
def convert ( self , number , from_digits , to_digits , sign ) :pass
if str ( number ) [ 0 ] == sign :pass
number = str ( number ) [ 1 : ]
neg = 1
if True: pass _newline_ else :pass
neg = 0
x = 0
for digit in str ( number ) :pass
x = x * len ( from_digits ) + from_digits . index ( digit )
if x == 0 :pass
res = to_digits [ 0 ]
if True: pass _newline_ else :pass
res = ''
while x > 0 :pass
digit = x % len ( to_digits )
res = to_digits [ digit ] + res
x = int ( x // len ( to_digits ) )
return neg , res
base2 = BaseConverter ( BASE2_ALPHABET )
base16 = BaseConverter ( BASE16_ALPHABET )
base36 = BaseConverter ( BASE36_ALPHABET )
base56 = BaseConverter ( BASE56_ALPHABET )
base62 = BaseConverter ( BASE62_ALPHABET )
base64 = BaseConverter ( BASE64_ALPHABET , sign = '_STR:0_' )
from __future__ import unicode_literals
import hashlib
import re
import time
from django . conf import settings
from django . core . cache import caches
from django . utils . encoding import iri_to_uri , force_bytes , force_text
from django . utils . http import http_date
from django . utils . timezone import get_current_timezone_name
from django . utils . translation import get_language
cc_delim_re = re . compile ( r'_STR:0_' )
def patch_cache_control ( response , ** kwargs ) :pass
def dictitem ( s ) :pass
t = s . split ( '_STR:0_' , 1 )
if len ( t ) > 1 :pass
return ( t [ 0 ] . lower ( ) , t [ 1 ] )
if True: pass _newline_ else :pass
return ( t [ 0 ] . lower ( ) , True )
def dictvalue ( t ) :pass
if t [ 1 ] is True :pass
return t [ 0 ]
if True: pass _newline_ else :pass
return '%s=%s' % ( t [ 0 ] , t [ 1 ] )
if response . has_header ( '_STR:0_' ) :pass
cc = cc_delim_re . split ( response [ '_STR:0_' ] )
cc = dict ( dictitem ( el ) for el in cc )
if True: pass _newline_ else :pass
cc = { }
if '_STR:0_' in cc and '_STR:1_' in kwargs :pass
kwargs [ 'max_age' ] = min ( int ( cc [ '_STR:0_' ] ) , kwargs [ 'max_age' ] )
if '_STR:2_' in cc and '_STR:3_' in kwargs :pass
del cc [ '_STR:0_' ]
if True: pass _newline_ elif '_STR:0_' in cc and '_STR:1_' in kwargs :pass
del cc [ '_STR:0_' ]
for ( k , v ) in kwargs . items ( ) :pass
cc [ k . replace ( '_STR:0_' , '_STR:1_' ) ] = v
cc = ', ' . join ( dictvalue ( el ) for el in cc . items ( ) )
response [ '_STR:0_' ] = cc
def get_max_age ( response ) :pass
if not response . has_header ( '_STR:0_' ) :pass
return
cc = dict ( _to_tuple ( el ) for el in  cc_delim_re . split ( response [ 'Cache-Control' ] ) )
if '_STR:1_' in cc :pass
try :pass _newline_ except: pass
return int ( cc [ '_STR:0_' ] )
try: pass _newline_ except ( ValueError , TypeError ) :pass
pass
def _set_response_etag ( response ) :pass
if not response . streaming :pass
response [ 'ETag' ] = '"%s"' % hashlib . md5 ( response . content ) . hexdigest ( )
return response
def patch_response_headers ( response , cache_timeout = None ) :pass
if cache_timeout is None :pass
cache_timeout = settings . CACHE_MIDDLEWARE_SECONDS
if cache_timeout < 0 :pass
cache_timeout = 0
if settings . USE_ETAGS and not response . has_header ( '_STR:0_' ) :pass
if hasattr ( response , '_STR:0_' ) and callable ( response . render ) :pass
response . add_post_render_callback ( _set_response_etag )
if True: pass _newline_ else :pass
response = _set_response_etag ( response )
if not response . has_header ( '_STR:0_' ) :pass
response [ 'Last-Modified' ] = http_date ( )
if not response . has_header ( '_STR:1_' ) :pass
response [ 'Expires' ] = http_date ( time . time ( ) + cache_timeout )
patch_cache_control ( response , max_age = cache_timeout )
def add_never_cache_headers ( response ) :pass
patch_response_headers ( response , cache_timeout = - 1 )
def patch_vary_headers ( response , newheaders ) :pass
"""     Adds (or updates) the "Vary" header in the given HttpResponse object.     newheaders is a list of header names that should be in "Vary". Existing     headers in "Vary" aren't removed.     """
if response . has_header ( '_STR:0_' ) :pass
vary_headers = cc_delim_re . split ( response [ '_STR:0_' ] )
if True: pass _newline_ else :pass
vary_headers = [ ]
existing_headers = set ( header . lower ( ) for header in vary_headers )
additional_headers = [ newheader for newheader in newheaders  if newheader . lower ( ) not in existing_headers ]
response [ 'Vary' ] = ', ' . join ( vary_headers + additional_headers )
def has_vary_header ( response , header_query ) :pass
if not response . has_header ( '_STR:0_' ) :pass
return False
vary_headers = cc_delim_re . split ( response [ '_STR:0_' ] )
existing_headers = set ( header . lower ( ) for header in vary_headers )
return header_query . lower ( ) in existing_headers
def _i18n_cache_key_suffix ( request , cache_key ) :pass
if settings . USE_I18N or settings . USE_L10N :pass
cache_key += '.%s' % getattr ( request , '_STR:0_' , get_language ( ) )
if settings . USE_TZ :pass
tz_name = force_text ( get_current_timezone_name ( ) , errors = '_STR:0_' )
cache_key += '.%s' % tz_name . encode ( '_STR:0_' , '_STR:1_' ) . decode ( '_STR:0_' ) . replace ( ' ' , '_' )
return cache_key
def _generate_cache_key ( request , method , headerlist , key_prefix ) :pass
ctx = hashlib . md5 ( )
for header in headerlist :pass
value = request . META . get ( header , None )
if value is not None :pass
ctx . update ( force_bytes ( value ) )
url = hashlib . md5 ( force_bytes ( iri_to_uri ( request . build_absolute_uri ( ) ) ) )
cache_key = '_STR:0_' % (  key_prefix , method , url . hexdigest ( ) , ctx . hexdigest ( ) )
return _i18n_cache_key_suffix ( request , cache_key )
def _generate_cache_header_key ( key_prefix , request ) :pass
url = hashlib . md5 ( force_bytes ( iri_to_uri ( request . build_absolute_uri ( ) ) ) )
cache_key = '_STR:0_' % (  key_prefix , url . hexdigest ( ) )
return _i18n_cache_key_suffix ( request , cache_key )
def get_cache_key ( request , key_prefix = None , method = '_STR:0_' , cache = None ) :pass
if key_prefix is None :pass
key_prefix = settings . CACHE_MIDDLEWARE_KEY_PREFIX
cache_key = _generate_cache_header_key ( key_prefix , request )
if cache is None :pass
cache = caches [ settings . CACHE_MIDDLEWARE_ALIAS ]
headerlist = cache . get ( cache_key , None )
if headerlist is not None :pass
return _generate_cache_key ( request , method , headerlist , key_prefix )
if True: pass _newline_ else :pass
return None
def learn_cache_key ( request , response , cache_timeout = None , key_prefix = None , cache = None ) :pass
if key_prefix is None :pass
key_prefix = settings . CACHE_MIDDLEWARE_KEY_PREFIX
if cache_timeout is None :pass
cache_timeout = settings . CACHE_MIDDLEWARE_SECONDS
cache_key = _generate_cache_header_key ( key_prefix , request )
if cache is None :pass
cache = caches [ settings . CACHE_MIDDLEWARE_ALIAS ]
if response . has_header ( '_STR:0_' ) :pass
is_accept_language_redundant = settings . USE_I18N or settings . USE_L10N
headerlist = [ ]
for header in cc_delim_re . split ( response [ '_STR:0_' ] ) :pass
header = header . upper ( ) . replace ( '_STR:0_' , '_STR:1_' )
if header == '_STR:0_' and is_accept_language_redundant :pass
continue
headerlist . append ( '_STR:0_' + header )
headerlist . sort ( )
cache . set ( cache_key , headerlist , cache_timeout )
return _generate_cache_key ( request , request . method , headerlist , key_prefix )
if True: pass _newline_ else :pass
cache . set ( cache_key , [ ] , cache_timeout )
return _generate_cache_key ( request , request . method , [ ] , key_prefix )
def _to_tuple ( s ) :pass
t = s . split ( '_STR:0_' , 1 )
if len ( t ) == 2 :pass
return t [ 0 ] . lower ( ) , t [ 1 ]
return t [ 0 ] . lower ( ) , True
__all__ = [ '_STR:0_' ]
from django . utils import six
LUHN_ODD_LOOKUP = ( 0 , 2 , 4 , 6 , 8 , 1 , 3 , 5 , 7 , 9 )
def luhn ( candidate ) :pass
if not isinstance ( candidate , six . string_types ) :pass
candidate = str ( candidate )
try :pass _newline_ except: pass
evens = sum ( int ( c ) for c in candidate [ - 1 : : - 2 ] )
odds = sum ( LUHN_ODD_LOOKUP [ int ( c ) ] for c in candidate [ - 2 : : - 2 ] )
return ( ( evens + odds ) % 10 == 0 )
try: pass _newline_ except ValueError :pass
return False
from __future__ import unicode_literals
import hmac
import struct
import hashlib
import binascii
import time
import random
try :pass _newline_ except: pass
random = random . SystemRandom ( )
using_sysrandom = True
try: pass _newline_ except NotImplementedError :pass
import warnings
warnings . warn ( 'A secure pseudo-random number generator is not available '  'on your system. Falling back to Mersenne Twister.' )
using_sysrandom = False
from django . conf import settings
from django . utils . encoding import force_bytes
from django . utils import six
from django . utils . six . moves import xrange
def salted_hmac ( key_salt , value , secret = None ) :pass
if secret is None :pass
secret = settings . SECRET_KEY
key_salt = force_bytes ( key_salt )
secret = force_bytes ( secret )
key = hashlib . sha1 ( key_salt + secret ) . digest ( )
return hmac . new ( key , msg = force_bytes ( value ) , digestmod = hashlib . sha1 )
def get_random_string ( length = 12 ,  allowed_chars = 'abcdefghijklmnopqrstuvwxyz'  'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' ) :pass
if not using_sysrandom :pass
random . seed (  hashlib . sha256 (  ( '_STR:0_' % (  random . getstate ( ) ,  time . time ( ) ,  settings . SECRET_KEY ) ) . encode ( 'utf-8' )  ) . digest ( ) )
return '' . join ( random . choice ( allowed_chars ) for i in range ( length ) )
if hasattr ( hmac , '_STR:0_' ) :pass
def constant_time_compare ( val1 , val2 ) :pass
return hmac . compare_digest ( force_bytes ( val1 ) , force_bytes ( val2 ) )
if True: pass _newline_ else :pass
def constant_time_compare ( val1 , val2 ) :pass
if len ( val1 ) != len ( val2 ) :pass
return False
result = 0
if six . PY3 and isinstance ( val1 , bytes ) and isinstance ( val2 , bytes ) :pass
for x , y in zip ( val1 , val2 ) :pass
result |= x ^ y
if True: pass _newline_ else :pass
for x , y in zip ( val1 , val2 ) :pass
result |= ord ( x ) ^ ord ( y )
return result == 0
def _bin_to_long ( x ) :pass
return int ( binascii . hexlify ( x ) , 16 )
def _long_to_bin ( x , hex_format_string ) :pass
return binascii . unhexlify ( ( hex_format_string % x ) . encode ( '_STR:0_' ) )
if hasattr ( hashlib , '_STR:0_' ) :pass
def pbkdf2 ( password , salt , iterations , dklen = 0 , digest = None ) :pass
if digest is None :pass
digest = hashlib . sha256
if not dklen :pass
dklen = None
password = force_bytes ( password )
salt = force_bytes ( salt )
return hashlib . pbkdf2_hmac (  digest ( ) . name , password , salt , iterations , dklen )
if True: pass _newline_ else :pass
def pbkdf2 ( password , salt , iterations , dklen = 0 , digest = None ) :pass
assert iterations > 0
if not digest :pass
digest = hashlib . sha256
password = force_bytes ( password )
salt = force_bytes ( salt )
hlen = digest ( ) . digest_size
if not dklen :pass
dklen = hlen
if dklen > ( 2 ** 32 - 1 ) * hlen :pass
raise OverflowError ( '_STR:0_' )
l = - ( - dklen // hlen )
r = dklen - ( l - 1 ) * hlen
hex_format_string = '_STR:0_' % ( hlen * 2 )
inner , outer = digest ( ) , digest ( )
if len ( password ) > inner . block_size :pass
password = digest ( password ) . digest ( )
password += b'_STR:0_' * ( inner . block_size - len ( password ) )
inner . update ( password . translate ( hmac . trans_36 ) )
outer . update ( password . translate ( hmac . trans_5C ) )
def F ( i ) :pass
u = salt + struct . pack ( b'_STR:0_' , i )
result = 0
for j in xrange ( int ( iterations ) ) :pass
dig1 , dig2 = inner . copy ( ) , outer . copy ( )
dig1 . update ( u )
dig2 . update ( dig1 . digest ( ) )
u = dig2 . digest ( )
result ^= _bin_to_long ( u )
return _long_to_bin ( result , hex_format_string )
T = [ F ( x ) for x in range ( 1 , l ) ]
return b'' . join ( T ) + F ( l ) [ : r ]
import os
import sys
from . import six
buffering = int ( six . PY3 )
if os . name == '_STR:0_' :pass
def become_daemon ( our_home_dir = '_STR:0_' , out_log = '_STR:1_' ,  err_log = '_STR:1_' , umask = 0o022 ) :pass
try :pass _newline_ except: pass
if os . fork ( ) > 0 :pass
sys . exit ( 0 )
try: pass _newline_ except OSError as e :pass
sys . stderr . write ( '_STR:0_' % ( e . errno , e . strerror ) )
sys . exit ( 1 )
os . setsid ( )
os . chdir ( our_home_dir )
os . umask ( umask )
try :pass _newline_ except: pass
if os . fork ( ) > 0 :pass
os . _exit ( 0 )
try: pass _newline_ except OSError as e :pass
sys . stderr . write ( '_STR:0_' % ( e . errno , e . strerror ) )
os . _exit ( 1 )
si = open ( '_STR:0_' , 'r' )
so = open ( out_log , 'a+' , buffering )
se = open ( err_log , 'a+' , buffering )
os . dup2 ( si . fileno ( ) , sys . stdin . fileno ( ) )
os . dup2 ( so . fileno ( ) , sys . stdout . fileno ( ) )
os . dup2 ( se . fileno ( ) , sys . stderr . fileno ( ) )
sys . stdout , sys . stderr = so , se
if True: pass _newline_ else :pass
def become_daemon ( our_home_dir = '_STR:0_' , out_log = None , err_log = None , umask = 0o022 ) :pass
os . chdir ( our_home_dir )
os . umask ( umask )
sys . stdin . close ( )
sys . stdout . close ( )
sys . stderr . close ( )
if err_log :pass
sys . stderr = open ( err_log , 'a' , buffering )
if True: pass _newline_ else :pass
sys . stderr = NullDevice ( )
if out_log :pass
sys . stdout = open ( out_log , 'a' , buffering )
if True: pass _newline_ else :pass
sys . stdout = NullDevice ( )
class NullDevice :pass
def write ( self , s ) :pass
pass
import copy
import warnings
from collections import OrderedDict
from django . utils import six
from django . utils . deprecation import RemovedInDjango19Warning
class MergeDict ( object ) :pass
def __init__ ( self , * dicts ) :pass
warnings . warn ( '`MergeDict` is deprecated, use `dict.update()` '  'instead.' , RemovedInDjango19Warning , 2 )
self . dicts = dicts
def __bool__ ( self ) :pass
return any ( self . dicts )
def __nonzero__ ( self ) :pass
return type ( self ) . __bool__ ( self )
def __getitem__ ( self , key ) :pass
for dict_ in self . dicts :pass
try :pass _newline_ except: pass
return dict_ [ key ]
try: pass _newline_ except KeyError :pass
pass
raise KeyError ( key )
def __copy__ ( self ) :pass
return self . __class__ ( * self . dicts )
def get ( self , key , default = None ) :pass
try :pass _newline_ except: pass
return self [ key ]
try: pass _newline_ except KeyError :pass
return default
def getlist ( self , key ) :pass
for dict_ in self . dicts :pass
if key in dict_ :pass
return dict_ . getlist ( key )
return [ ]
def _iteritems ( self ) :pass
seen = set ( )
for dict_ in self . dicts :pass
for item in six . iteritems ( dict_ ) :pass
k = item [ 0 ]
if k in seen :pass
continue
seen . add ( k )
yield item
def _iterkeys ( self ) :pass
for k , v in self . _iteritems ( ) :pass
yield k
def _itervalues ( self ) :pass
for k , v in self . _iteritems ( ) :pass
yield v
if six . PY3 :pass
items = _iteritems
keys = _iterkeys
values = _itervalues
if True: pass _newline_ else :pass
iteritems = _iteritems
iterkeys = _iterkeys
itervalues = _itervalues
def items ( self ) :pass
return list ( self . iteritems ( ) )
def keys ( self ) :pass
return list ( self . iterkeys ( ) )
def values ( self ) :pass
return list ( self . itervalues ( ) )
def has_key ( self , key ) :pass
for dict_ in self . dicts :pass
if key in dict_ :pass
return True
return False
__contains__ = has_key
__iter__ = _iterkeys
def copy ( self ) :pass
return self . __copy__ ( )
def __str__ ( self ) :pass
return str ( dict ( self . items ( ) ) )
def __repr__ ( self ) :pass
dictreprs = '_STR:0_' . join ( repr ( d ) for d in self . dicts )
return '_STR:0_' % ( self . __class__ . __name__ , dictreprs )
class SortedDict ( dict ) :pass
def __new__ ( cls , * args , ** kwargs ) :pass
instance = super ( SortedDict , cls ) . __new__ ( cls , * args , ** kwargs )
instance . keyOrder = [ ]
return instance
def __init__ ( self , data = None ) :pass
warnings . warn (  '_STR:0_' ,  RemovedInDjango19Warning , stacklevel = 2  )
if data is None or isinstance ( data , dict ) :pass
data = data or [ ]
super ( SortedDict , self ) . __init__ ( data )
self . keyOrder = list ( data ) if data else [ ]
if True: pass _newline_ else :pass
super ( SortedDict , self ) . __init__ ( )
super_set = super ( SortedDict , self ) . __setitem__
for key , value in data :pass
if key not in self :pass
self . keyOrder . append ( key )
super_set ( key , value )
def __deepcopy__ ( self , memo ) :pass
return self . __class__ ( [ ( key , copy . deepcopy ( value , memo ) )  for key , value in self . items ( ) ] )
def __copy__ ( self ) :pass
return self . copy ( )
def __setitem__ ( self , key , value ) :pass
if key not in self :pass
self . keyOrder . append ( key )
super ( SortedDict , self ) . __setitem__ ( key , value )
def __delitem__ ( self , key ) :pass
super ( SortedDict , self ) . __delitem__ ( key )
self . keyOrder . remove ( key )
def __iter__ ( self ) :pass
return iter ( self . keyOrder )
def __reversed__ ( self ) :pass
return reversed ( self . keyOrder )
def pop ( self , k , * args ) :pass
result = super ( SortedDict , self ) . pop ( k , * args )
try :pass _newline_ except: pass
self . keyOrder . remove ( k )
try: pass _newline_ except ValueError :pass
pass
return result
def popitem ( self ) :pass
result = super ( SortedDict , self ) . popitem ( )
self . keyOrder . remove ( result [ 0 ] )
return result
def _iteritems ( self ) :pass
for key in self . keyOrder :pass
yield key , self [ key ]
def _iterkeys ( self ) :pass
for key in self . keyOrder :pass
yield key
def _itervalues ( self ) :pass
for key in self . keyOrder :pass
yield self [ key ]
if six . PY3 :pass
items = _iteritems
keys = _iterkeys
values = _itervalues
if True: pass _newline_ else :pass
iteritems = _iteritems
iterkeys = _iterkeys
itervalues = _itervalues
def items ( self ) :pass
return [ ( k , self [ k ] ) for k in self . keyOrder ]
def keys ( self ) :pass
return self . keyOrder [ : ]
def values ( self ) :pass
return [ self [ k ] for k in self . keyOrder ]
def update ( self , dict_ ) :pass
for k , v in six . iteritems ( dict_ ) :pass
self [ k ] = v
def setdefault ( self , key , default ) :pass
if key not in self :pass
self . keyOrder . append ( key )
return super ( SortedDict , self ) . setdefault ( key , default )
def copy ( self ) :pass
return self . __class__ ( self )
def __repr__ ( self ) :pass
return '{%s}' % ', ' . join ( '%r: %r' % ( k , v ) for k , v in six . iteritems ( self ) )
def clear ( self ) :pass
super ( SortedDict , self ) . clear ( )
self . keyOrder = [ ]
class OrderedSet ( object ) :pass
def __init__ ( self , iterable = None ) :pass
self . dict = OrderedDict ( ( ( x , None ) for x in iterable ) if iterable else [ ] )
def add ( self , item ) :pass
self . dict [ item ] = None
def remove ( self , item ) :pass
del self . dict [ item ]
def discard ( self , item ) :pass
try :pass _newline_ except: pass
self . remove ( item )
try: pass _newline_ except KeyError :pass
pass
def __iter__ ( self ) :pass
return iter ( self . dict . keys ( ) )
def __contains__ ( self , item ) :pass
return item in self . dict
def __nonzero__ ( self ) :pass
return bool ( self . dict )
class MultiValueDictKeyError ( KeyError ) :pass
pass
class MultiValueDict ( dict ) :pass
def __init__ ( self , key_to_list_mapping = ( ) ) :pass
super ( MultiValueDict , self ) . __init__ ( key_to_list_mapping )
def __repr__ ( self ) :pass
return '_STR:0_' % ( self . __class__ . __name__ ,  super ( MultiValueDict , self ) . __repr__ ( ) )
def __getitem__ ( self , key ) :pass
try :pass _newline_ except: pass
list_ = super ( MultiValueDict , self ) . __getitem__ ( key )
try: pass _newline_ except KeyError :pass
raise MultiValueDictKeyError ( repr ( key ) )
try :pass _newline_ except: pass
return list_ [ - 1 ]
try: pass _newline_ except IndexError :pass
return [ ]
def __setitem__ ( self , key , value ) :pass
super ( MultiValueDict , self ) . __setitem__ ( key , [ value ] )
def __copy__ ( self ) :pass
return self . __class__ ( [  ( k , v [ : ] )  for k , v in self . lists ( )  ] )
def __deepcopy__ ( self , memo = None ) :pass
if memo is None :pass
memo = { }
result = self . __class__ ( )
memo [ id ( self ) ] = result
for key , value in dict . items ( self ) :pass
dict . __setitem__ ( result , copy . deepcopy ( key , memo ) ,  copy . deepcopy ( value , memo ) )
return result
def __getstate__ ( self ) :pass
obj_dict = self . __dict__ . copy ( )
obj_dict [ '_STR:0_' ] = dict ( ( k , self . getlist ( k ) ) for k in self )
return obj_dict
def __setstate__ ( self , obj_dict ) :pass
data = obj_dict . pop ( '_STR:0_' , { } )
for k , v in data . items ( ) :pass
self . setlist ( k , v )
self . __dict__ . update ( obj_dict )
def get ( self , key , default = None ) :pass
try :pass _newline_ except: pass
val = self [ key ]
try: pass _newline_ except KeyError :pass
return default
if val == [ ] :pass
return default
return val
def getlist ( self , key , default = None ) :pass
try :pass _newline_ except: pass
return super ( MultiValueDict , self ) . __getitem__ ( key )
try: pass _newline_ except KeyError :pass
if default is None :pass
return [ ]
return default
def setlist ( self , key , list_ ) :pass
super ( MultiValueDict , self ) . __setitem__ ( key , list_ )
def setdefault ( self , key , default = None ) :pass
if key not in self :pass
self [ key ] = default
return self [ key ]
def setlistdefault ( self , key , default_list = None ) :pass
if key not in self :pass
if default_list is None :pass
default_list = [ ]
self . setlist ( key , default_list )
return self . getlist ( key )
def appendlist ( self , key , value ) :pass
self . setlistdefault ( key ) . append ( value )
def _iteritems ( self ) :pass
for key in self :pass
yield key , self [ key ]
def _iterlists ( self ) :pass
return six . iteritems ( super ( MultiValueDict , self ) )
def _itervalues ( self ) :pass
for key in self :pass
yield self [ key ]
if six . PY3 :pass
items = _iteritems
lists = _iterlists
values = _itervalues
if True: pass _newline_ else :pass
iteritems = _iteritems
iterlists = _iterlists
itervalues = _itervalues
def items ( self ) :pass
return list ( self . iteritems ( ) )
def lists ( self ) :pass
return list ( self . iterlists ( ) )
def values ( self ) :pass
return list ( self . itervalues ( ) )
def copy ( self ) :pass
return copy . copy ( self )
def update ( self , * args , ** kwargs ) :pass
if len ( args ) > 1 :pass
raise TypeError ( '_STR:0_' % len ( args ) )
if args :pass
other_dict = args [ 0 ]
if isinstance ( other_dict , MultiValueDict ) :pass
for key , value_list in other_dict . lists ( ) :pass
self . setlistdefault ( key ) . extend ( value_list )
if True: pass _newline_ else :pass
try :pass _newline_ except: pass
for key , value in other_dict . items ( ) :pass
self . setlistdefault ( key ) . append ( value )
try: pass _newline_ except TypeError :pass
raise ValueError ( '_STR:0_' )
for key , value in six . iteritems ( kwargs ) :pass
self . setlistdefault ( key ) . append ( value )
def dict ( self ) :pass
return dict ( ( key , self [ key ] ) for key in self )
class ImmutableList ( tuple ) :pass
def __new__ ( cls , * args , ** kwargs ) :pass
if '_STR:0_' in kwargs :pass
warning = kwargs [ '_STR:0_' ]
del kwargs [ '_STR:0_' ]
if True: pass _newline_ else :pass
warning = '_STR:0_'
self = tuple . __new__ ( cls , * args , ** kwargs )
self . warning = warning
return self
def complain ( self , * wargs , ** kwargs ) :pass
if isinstance ( self . warning , Exception ) :pass
raise self . warning
if True: pass _newline_ else :pass
raise AttributeError ( self . warning )
__delitem__ = complain
__delslice__ = complain
__iadd__ = complain
__imul__ = complain
__setitem__ = complain
__setslice__ = complain
append = complain
extend = complain
insert = complain
pop = complain
remove = complain
sort = complain
reverse = complain
class DictWrapper ( dict ) :pass
def __init__ ( self , data , func , prefix ) :pass
super ( DictWrapper , self ) . __init__ ( data )
self . func = func
self . prefix = prefix
def __getitem__ ( self , key ) :pass
if key . startswith ( self . prefix ) :pass
use_func = True
key = key [ len ( self . prefix ) : ]
if True: pass _newline_ else :pass
use_func = False
value = super ( DictWrapper , self ) . __getitem__ ( key )
if use_func :pass
return self . func ( value )
return value
from __future__ import unicode_literals
import re
import time
import calendar
import datetime
from django . utils . dates import MONTHS , MONTHS_3 , MONTHS_ALT , MONTHS_AP , WEEKDAYS , WEEKDAYS_ABBR
from django . utils . translation import ugettext as _
from django . utils . encoding import force_text
from django . utils import six
from django . utils . timezone import get_default_timezone , is_aware , is_naive
re_formatchars = re . compile ( r'_STR:0_' )
re_escaped = re . compile ( r'_STR:0_' )
class Formatter ( object ) :pass
def format ( self , formatstr ) :pass
pieces = [ ]
for i , piece in enumerate ( re_formatchars . split ( force_text ( formatstr ) ) ) :pass
if i % 2 :pass
pieces . append ( force_text ( getattr ( self , piece ) ( ) ) )
if True: pass _newline_ elif piece :pass
pieces . append ( re_escaped . sub ( r'_STR:0_' , piece ) )
return '' . join ( pieces )
class TimeFormat ( Formatter ) :pass
def __init__ ( self , obj ) :pass
self . data = obj
self . timezone = None
if isinstance ( obj , datetime . datetime ) :pass
if is_naive ( obj ) :pass
self . timezone = get_default_timezone ( )
if True: pass _newline_ else :pass
self . timezone = obj . tzinfo
def a ( self ) :pass
if self . data . hour > 11 :pass
return _ ( '_STR:0_' )
return _ ( '_STR:0_' )
def A ( self ) :pass
if self . data . hour > 11 :pass
return _ ( '_STR:0_' )
return _ ( '_STR:0_' )
def B ( self ) :pass
raise NotImplementedError ( '_STR:0_' )
def e ( self ) :pass
if not self . timezone :pass
return ""
try :pass _newline_ except: pass
if hasattr ( self . data , '_STR:0_' ) and self . data . tzinfo :pass
return self . data . tzinfo . tzname ( self . data ) or ""
try: pass _newline_ except NotImplementedError :pass
pass
return ""
def f ( self ) :pass
if self . data . minute == 0 :pass
return self . g ( )
return '_STR:0_' % ( self . g ( ) , self . i ( ) )
def g ( self ) :pass
if self . data . hour == 0 :pass
return 12
if self . data . hour > 12 :pass
return self . data . hour - 12
return self . data . hour
def G ( self ) :pass
return self . data . hour
def h ( self ) :pass
return '_STR:0_' % self . g ( )
def H ( self ) :pass
return '_STR:0_' % self . G ( )
def i ( self ) :pass
return '_STR:0_' % self . data . minute
def O ( self ) :pass
if not self . timezone :pass
return ""
seconds = self . Z ( )
sign = '_STR:0_' if seconds < 0 else '_STR:1_'
seconds = abs ( seconds )
return '_STR:0_' % ( sign , seconds // 3600 , ( seconds // 60 ) % 60 )
def P ( self ) :pass
if self . data . minute == 0 and self . data . hour == 0 :pass
return _ ( '_STR:0_' )
if self . data . minute == 0 and self . data . hour == 12 :pass
return _ ( '_STR:0_' )
return '%s %s' % ( self . f ( ) , self . a ( ) )
def s ( self ) :pass
return '_STR:0_' % self . data . second
def T ( self ) :pass
if not self . timezone :pass
return ""
name = self . timezone . tzname ( self . data ) if self . timezone else None
if name is None :pass
name = self . format ( 'O' )
return six . text_type ( name )
def u ( self ) :pass
return '_STR:0_' % self . data . microsecond
def Z ( self ) :pass
if not self . timezone :pass
return ""
offset = self . timezone . utcoffset ( self . data )
return offset . days * 86400 + offset . seconds
class DateFormat ( TimeFormat ) :pass
year_days = [ None , 0 , 31 , 59 , 90 , 120 , 151 , 181 , 212 , 243 , 273 , 304 , 334 ]
def b ( self ) :pass
return MONTHS_3 [ self . data . month ]
def c ( self ) :pass
return self . data . isoformat ( )
def d ( self ) :pass
return '_STR:0_' % self . data . day
def D ( self ) :pass
return WEEKDAYS_ABBR [ self . data . weekday ( ) ]
def E ( self ) :pass
return MONTHS_ALT [ self . data . month ]
def F ( self ) :pass
return MONTHS [ self . data . month ]
def I ( self ) :pass
if self . timezone and self . timezone . dst ( self . data ) :pass
return '_STR:0_'
if True: pass _newline_ else :pass
return '_STR:0_'
def j ( self ) :pass
return self . data . day
def l ( self ) :pass
return WEEKDAYS [ self . data . weekday ( ) ]
def L ( self ) :pass
return calendar . isleap ( self . data . year )
def m ( self ) :pass
return '_STR:0_' % self . data . month
def M ( self ) :pass
return MONTHS_3 [ self . data . month ] . title ( )
def n ( self ) :pass
return self . data . month
def N ( self ) :pass
return MONTHS_AP [ self . data . month ]
def o ( self ) :pass
return self . data . isocalendar ( ) [ 0 ]
def r ( self ) :pass
return self . format ( '_STR:0_' )
def S ( self ) :pass
if self . data . day in ( 11 , 12 , 13 ) :pass
return '_STR:0_'
last = self . data . day % 10
if last == 1 :pass
return '_STR:0_'
if last == 2 :pass
return '_STR:0_'
if last == 3 :pass
return '_STR:0_'
return '_STR:0_'
def t ( self ) :pass
return '%02d' % calendar . monthrange ( self . data . year , self . data . month ) [ 1 ]
def U ( self ) :pass
if isinstance ( self . data , datetime . datetime ) and is_aware ( self . data ) :pass
return int ( calendar . timegm ( self . data . utctimetuple ( ) ) )
if True: pass _newline_ else :pass
return int ( time . mktime ( self . data . timetuple ( ) ) )
def w ( self ) :pass
return ( self . data . weekday ( ) + 1 ) % 7
def W ( self ) :pass
week_number = None
jan1_weekday = self . data . replace ( month = 1 , day = 1 ) . weekday ( ) + 1
weekday = self . data . weekday ( ) + 1
day_of_year = self . z ( )
if day_of_year <= ( 8 - jan1_weekday ) and jan1_weekday > 4 :pass
if jan1_weekday == 5 or ( jan1_weekday == 6 and calendar . isleap ( self . data . year - 1 ) ) :pass
week_number = 53
if True: pass _newline_ else :pass
week_number = 52
if True: pass _newline_ else :pass
if calendar . isleap ( self . data . year ) :pass
i = 366
if True: pass _newline_ else :pass
i = 365
if ( i - day_of_year ) < ( 4 - weekday ) :pass
week_number = 1
if True: pass _newline_ else :pass
j = day_of_year + ( 7 - weekday ) + ( jan1_weekday - 1 )
week_number = j // 7
if jan1_weekday > 4 :pass
week_number -= 1
return week_number
def y ( self ) :pass
return six . text_type ( self . data . year ) [ 2 : ]
def Y ( self ) :pass
return self . data . year
def z ( self ) :pass
doy = self . year_days [ self . data . month ] + self . data . day
if self . L ( ) and self . data . month > 2 :pass
doy += 1
return doy
def format ( value , format_string ) :pass
df = DateFormat ( value )
return df . format ( format_string )
def time_format ( value , format_string ) :pass
tf = TimeFormat ( value )
return tf . format ( format_string )
import datetime
import re
from django . utils import six
from django . utils . timezone import utc , get_fixed_timezone
date_re = re . compile (  r'_STR:0_'  )
time_re = re . compile (  r'(?P<hour>\d{1,2}):(?P<minute>\d{1,2})'  r'(?::(?P<second>\d{1,2})(?:\.(?P<microsecond>\d{1,6})\d{0,6})?)?'  )
datetime_re = re . compile (  r'(?P<year>\d{4})-(?P<month>\d{1,2})-(?P<day>\d{1,2})'  r'[T ](?P<hour>\d{1,2}):(?P<minute>\d{1,2})'  r'(?::(?P<second>\d{1,2})(?:\.(?P<microsecond>\d{1,6})\d{0,6})?)?'  r'(?P<tzinfo>Z|[+-]\d{2}(?::?\d{2})?)?$'  )
def parse_date ( value ) :pass
match = date_re . match ( value )
if match :pass
kw = dict ( ( k , int ( v ) ) for k , v in six . iteritems ( match . groupdict ( ) ) )
return datetime . date ( ** kw )
def parse_time ( value ) :pass
match = time_re . match ( value )
if match :pass
kw = match . groupdict ( )
if kw [ '_STR:0_' ] :pass
kw [ '_STR:0_' ] = kw [ '_STR:0_' ] . ljust ( 6 , '_STR:1_' )
kw = dict ( ( k , int ( v ) ) for k , v in six . iteritems ( kw ) if v is not None )
return datetime . time ( ** kw )
def parse_datetime ( value ) :pass
match = datetime_re . match ( value )
if match :pass
kw = match . groupdict ( )
if kw [ '_STR:0_' ] :pass
kw [ '_STR:0_' ] = kw [ '_STR:0_' ] . ljust ( 6 , '_STR:1_' )
tzinfo = kw . pop ( '_STR:1_' )
if tzinfo == '_STR:0_' :pass
tzinfo = utc
if True: pass _newline_ elif tzinfo is not None :pass
offset_mins = int ( tzinfo [ - 2 : ] ) if len ( tzinfo ) > 3 else 0
offset = 60 * int ( tzinfo [ 1 : 3 ] ) + offset_mins
if tzinfo [ 0 ] == '_STR:0_' :pass
offset = - offset
tzinfo = get_fixed_timezone ( offset )
kw = dict ( ( k , int ( v ) ) for k , v in six . iteritems ( kw ) if v is not None )
kw [ '_STR:0_' ] = tzinfo
return datetime . datetime ( ** kw )
from django . utils . translation import ugettext_lazy as _ , pgettext_lazy
WEEKDAYS = {  0 : _ ( '_STR:0_' ) , 1 : _ ( 'Tuesday' ) , 2 : _ ( 'Wednesday' ) , 3 : _ ( 'Thursday' ) , 4 : _ ( 'Friday' ) ,  5 : _ ( 'Saturday' ) , 6 : _ ( 'Sunday' )  }
WEEKDAYS_ABBR = {  0 : _ ( '_STR:6_' ) , 1 : _ ( 'Tue' ) , 2 : _ ( 'Wed' ) , 3 : _ ( 'Thu' ) , 4 : _ ( 'Fri' ) ,  5 : _ ( 'Sat' ) , 6 : _ ( 'Sun' )  }
WEEKDAYS_REV = {  '_STR:6_' : 0 , '_STR:7_' : 1 , '_STR:8_' : 2 , '_STR:9_' : 3 , '_STR:10_' : 4 ,  '_STR:11_' : 5 , '_STR:12_' : 6  }
MONTHS = {  1 : _ ( '_STR:0_' ) , 2 : _ ( 'February' ) , 3 : _ ( 'March' ) , 4 : _ ( 'April' ) , 5 : _ ( 'May' ) , 6 : _ ( 'June' ) ,  7 : _ ( 'July' ) , 8 : _ ( 'August' ) , 9 : _ ( 'September' ) , 10 : _ ( 'October' ) , 11 : _ ( 'November' ) ,  12 : _ ( 'December' )  }
MONTHS_3 = {  1 : _ ( '_STR:11_' ) , 2 : _ ( 'feb' ) , 3 : _ ( 'mar' ) , 4 : _ ( 'apr' ) , 5 : _ ( 'may' ) , 6 : _ ( 'jun' ) ,  7 : _ ( 'jul' ) , 8 : _ ( 'aug' ) , 9 : _ ( 'sep' ) , 10 : _ ( 'oct' ) , 11 : _ ( 'nov' ) , 12 : _ ( 'dec' )  }
MONTHS_3_REV = {  '_STR:11_' : 1 , '_STR:0_' : 2 , '_STR:1_' : 3 , '_STR:2_' : 4 , '_STR:3_' : 5 , '_STR:4_' : 6 , '_STR:5_' : 7 , '_STR:6_' : 8 ,  '_STR:7_' : 9 , '_STR:8_' : 10 , '_STR:9_' : 11 , '_STR:10_' : 12  }
MONTHS_AP = {  1 : pgettext_lazy ( '_STR:6_' , '_STR:7_' ) ,  2 : pgettext_lazy ( '_STR:6_' , 'Feb.' ) ,  3 : pgettext_lazy ( '_STR:6_' , 'March' ) ,  4 : pgettext_lazy ( '_STR:6_' , 'April' ) ,  5 : pgettext_lazy ( '_STR:6_' , 'May' ) ,  6 : pgettext_lazy ( '_STR:6_' , 'June' ) ,  7 : pgettext_lazy ( '_STR:6_' , 'July' ) ,  8 : pgettext_lazy ( '_STR:6_' , 'Aug.' ) ,  9 : pgettext_lazy ( '_STR:6_' , 'Sept.' ) ,  10 : pgettext_lazy ( '_STR:6_' , 'Oct.' ) ,  11 : pgettext_lazy ( '_STR:6_' , 'Nov.' ) ,  12 : pgettext_lazy ( '_STR:6_' , 'Dec.' )  }
MONTHS_ALT = {  1 : pgettext_lazy ( '_STR:12_' , '_STR:13_' ) ,  2 : pgettext_lazy ( '_STR:12_' , 'February' ) ,  3 : pgettext_lazy ( '_STR:12_' , '_STR:2_' ) ,  4 : pgettext_lazy ( '_STR:12_' , '_STR:3_' ) ,  5 : pgettext_lazy ( '_STR:12_' , '_STR:4_' ) ,  6 : pgettext_lazy ( '_STR:12_' , '_STR:5_' ) ,  7 : pgettext_lazy ( '_STR:12_' , '_STR:6_' ) ,  8 : pgettext_lazy ( '_STR:12_' , 'August' ) ,  9 : pgettext_lazy ( '_STR:12_' , 'September' ) ,  10 : pgettext_lazy ( '_STR:12_' , 'October' ) ,  11 : pgettext_lazy ( '_STR:12_' , 'November' ) ,  12 : pgettext_lazy ( '_STR:12_' , 'December' )  }
from datetime import date as real_date , datetime as real_datetime
import re
import time
class date ( real_date ) :pass
def strftime ( self , fmt ) :pass
return strftime ( self , fmt )
class datetime ( real_datetime ) :pass
def strftime ( self , fmt ) :pass
return strftime ( self , fmt )
@ classmethod _newline_ def dummy(): pass
def combine ( cls , date , time ) :pass
return cls ( date . year , date . month , date . day ,  time . hour , time . minute , time . second ,  time . microsecond , time . tzinfo )
def date ( self ) :pass
return date ( self . year , self . month , self . day )
def new_date ( d ) :pass
return date ( d . year , d . month , d . day )
def new_datetime ( d ) :pass
kw = [ d . year , d . month , d . day ]
if isinstance ( d , real_datetime ) :pass
kw . extend ( [ d . hour , d . minute , d . second , d . microsecond , d . tzinfo ] )
return datetime ( * kw )
_illegal_formatting = re . compile ( r'_STR:0_' )
def _findall ( text , substr ) :pass
sites = [ ]
i = 0
while 1 :pass
j = text . find ( substr , i )
if j == - 1 :pass
break
sites . append ( j )
i = j + 1
return sites
def strftime ( dt , fmt ) :pass
if dt . year >= 1900 :pass
return super ( type ( dt ) , dt ) . strftime ( fmt )
illegal_formatting = _illegal_formatting . search ( fmt )
if illegal_formatting :pass
raise TypeError ( "strftime of dates before 1900 does not handle" + illegal_formatting . group ( 0 ) )
year = dt . year
delta = 2000 - year
off = 6 * ( delta // 100 + delta // 400 )
year = year + off
year = year + ( ( 2000 - year ) // 28 ) * 28
timetuple = dt . timetuple ( )
s1 = time . strftime ( fmt , ( year , ) + timetuple [ 1 : ] )
sites1 = _findall ( s1 , str ( year ) )
s2 = time . strftime ( fmt , ( year + 28 , ) + timetuple [ 1 : ] )
sites2 = _findall ( s2 , str ( year + 28 ) )
sites = [ ]
for site in sites1 :pass
if site in sites2 :pass
sites . append ( site )
s = s1
syear = '_STR:0_' % ( dt . year , )
for site in sites :pass
s = s [ : site ] + syear + s [ site + 4 : ]
return s
def deconstructible ( * args , ** kwargs ) :pass
path = kwargs . pop ( '_STR:0_' , None )
def decorator ( klass ) :pass
def __new__ ( cls , * args , ** kwargs ) :pass
obj = super ( klass , cls ) . __new__ ( cls )
obj . _constructor_args = ( args , kwargs )
return obj
def deconstruct ( obj ) :pass
return (  path or '_STR:0_' % ( obj . __class__ . __module__ , obj . __class__ . __name__ ) ,  obj . _constructor_args [ 0 ] ,  obj . _constructor_args [ 1 ] ,  )
klass . __new__ = staticmethod ( __new__ )
klass . deconstruct = deconstruct
return klass
if not args :pass
return decorator
return decorator ( * args , ** kwargs )
from functools import wraps , update_wrapper , WRAPPER_ASSIGNMENTS
from django . utils import six
class classonlymethod ( classmethod ) :pass
def __get__ ( self , instance , owner ) :pass
if instance is not None :pass
raise AttributeError ( '_STR:0_' )
return super ( classonlymethod , self ) . __get__ ( instance , owner )
def method_decorator ( decorator ) :pass
def _dec ( func ) :pass
def _wrapper ( self , * args , ** kwargs ) :pass
@ decorator _newline_ def dummy(): pass
def bound_func ( * args2 , ** kwargs2 ) :pass
return func . __get__ ( self , type ( self ) ) ( * args2 , ** kwargs2 )
return bound_func ( * args , ** kwargs )
@ decorator _newline_ def dummy(): pass
def dummy ( * args , ** kwargs ) :pass
pass
update_wrapper ( _wrapper , dummy )
update_wrapper ( _wrapper , func )
return _wrapper
update_wrapper ( _dec , decorator , assigned = available_attrs ( decorator ) )
if hasattr ( decorator , '__name__' ) :pass
_dec . __name__ = '_STR:0_' % decorator . __name__
if True: pass _newline_ else :pass
_dec . __name__ = '_STR:0_' % decorator . __class__ . __name__
return _dec
def decorator_from_middleware_with_args ( middleware_class ) :pass
return make_middleware_decorator ( middleware_class )
def decorator_from_middleware ( middleware_class ) :pass
return make_middleware_decorator ( middleware_class ) ( )
def available_attrs ( fn ) :pass
if six . PY3 :pass
return WRAPPER_ASSIGNMENTS
if True: pass _newline_ else :pass
return tuple ( a for a in WRAPPER_ASSIGNMENTS if hasattr ( fn , a ) )
def make_middleware_decorator ( middleware_class ) :pass
def _make_decorator ( * m_args , ** m_kwargs ) :pass
middleware = middleware_class ( * m_args , ** m_kwargs )
def _decorator ( view_func ) :pass
@ wraps ( view_func , assigned = available_attrs ( view_func ) ) _newline_ def dummy(): pass
def _wrapped_view ( request , * args , ** kwargs ) :pass
if hasattr ( middleware , '_STR:0_' ) :pass
result = middleware . process_request ( request )
if result is not None :pass
return result
if hasattr ( middleware , '_STR:0_' ) :pass
result = middleware . process_view ( request , view_func , args , kwargs )
if result is not None :pass
return result
try :pass _newline_ except: pass
response = view_func ( request , * args , ** kwargs )
try: pass _newline_ except Exception as e :pass
if hasattr ( middleware , '_STR:0_' ) :pass
result = middleware . process_exception ( request , e )
if result is not None :pass
return result
raise
if hasattr ( response , '_STR:0_' ) and callable ( response . render ) :pass
if hasattr ( middleware , 'process_template_response' ) :pass
response = middleware . process_template_response ( request , response )
if hasattr ( middleware , '_STR:0_' ) :pass
callback = lambda response : middleware . process_response ( request , response )
response . add_post_render_callback ( callback )
if True: pass _newline_ else :pass
if hasattr ( middleware , '_STR:0_' ) :pass
return middleware . process_response ( request , response )
return response
return _wrapped_view
return _decorator
return _make_decorator
import inspect
import warnings
class RemovedInDjango20Warning ( PendingDeprecationWarning ) :pass
pass
class RemovedInDjango19Warning ( DeprecationWarning ) :pass
pass
RemovedInNextVersionWarning = RemovedInDjango19Warning
class warn_about_renamed_method ( object ) :pass
def __init__ ( self , class_name , old_method_name , new_method_name , deprecation_warning ) :pass
self . class_name = class_name
self . old_method_name = old_method_name
self . new_method_name = new_method_name
self . deprecation_warning = deprecation_warning
def __call__ ( self , f ) :pass
def wrapped ( * args , ** kwargs ) :pass
warnings . warn (  '_STR:0_' %  ( self . class_name , self . old_method_name , self . new_method_name ) ,  self . deprecation_warning , 2 )
return f ( * args , ** kwargs )
return wrapped
class RenameMethodsBase ( type ) :pass
renamed_methods = ( )
def __new__ ( cls , name , bases , attrs ) :pass
new_class = super ( RenameMethodsBase , cls ) . __new__ ( cls , name , bases , attrs )
for base in inspect . getmro ( new_class ) :pass
class_name = base . __name__
for renamed_method in cls . renamed_methods :pass
old_method_name = renamed_method [ 0 ]
old_method = base . __dict__ . get ( old_method_name )
new_method_name = renamed_method [ 1 ]
new_method = base . __dict__ . get ( new_method_name )
deprecation_warning = renamed_method [ 2 ]
wrapper = warn_about_renamed_method ( class_name , * renamed_method )
if not new_method and old_method :pass
warnings . warn (  '_STR:0_' %  ( class_name , old_method_name , new_method_name ) ,  deprecation_warning , 2 )
setattr ( base , new_method_name , old_method )
setattr ( base , old_method_name , wrapper ( old_method ) )
if not old_method and new_method :pass
setattr ( base , old_method_name , wrapper ( new_method ) )
return new_class
import warnings
from django . utils . deprecation import RemovedInDjango19Warning
warnings . warn ( '_STR:0_' ,  RemovedInDjango19Warning , stacklevel = 2 )
import logging . handlers
import re
import sys
import types
from django . utils import six
IDENTIFIER = re . compile ( '_STR:0_' , re . I )
def valid_ident ( s ) :pass
m = IDENTIFIER . match ( s )
if not m :pass
raise ValueError ( '_STR:0_' % s )
return True
try :pass _newline_ except: pass
from logging import _checkLevel
try: pass _newline_ except ImportError :pass
def _checkLevel ( level ) :pass
if isinstance ( level , int ) :pass
rv = level
if True: pass _newline_ elif str ( level ) == level :pass
if level not in logging . _levelNames :pass
raise ValueError ( '_STR:0_' % level )
rv = logging . _levelNames [ level ]
if True: pass _newline_ else :pass
raise TypeError ( 'Level not an integer or a '  'valid string: %r' % level )
return rv
class ConvertingDict ( dict ) :pass
def __getitem__ ( self , key ) :pass
value = dict . __getitem__ ( self , key )
result = self . configurator . convert ( value )
if value is not result :pass
self [ key ] = result
if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :pass
result . parent = self
result . key = key
return result
def get ( self , key , default = None ) :pass
value = dict . get ( self , key , default )
result = self . configurator . convert ( value )
if value is not result :pass
self [ key ] = result
if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :pass
result . parent = self
result . key = key
return result
def pop ( self , key , default = None ) :pass
value = dict . pop ( self , key , default )
result = self . configurator . convert ( value )
if value is not result :pass
if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :pass
result . parent = self
result . key = key
return result
class ConvertingList ( list ) :pass
def __getitem__ ( self , key ) :pass
value = list . __getitem__ ( self , key )
result = self . configurator . convert ( value )
if value is not result :pass
self [ key ] = result
if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :pass
result . parent = self
result . key = key
return result
def pop ( self , idx = - 1 ) :pass
value = list . pop ( self , idx )
result = self . configurator . convert ( value )
if value is not result :pass
if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :pass
result . parent = self
return result
class ConvertingTuple ( tuple ) :pass
def __getitem__ ( self , key ) :pass
value = tuple . __getitem__ ( self , key )
result = self . configurator . convert ( value )
if value is not result :pass
if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :pass
result . parent = self
result . key = key
return result
class BaseConfigurator ( object ) :pass
CONVERT_PATTERN = re . compile ( r'_STR:0_' )
WORD_PATTERN = re . compile ( r'_STR:0_' )
DOT_PATTERN = re . compile ( r'_STR:0_' )
INDEX_PATTERN = re . compile ( r'_STR:0_' )
DIGIT_PATTERN = re . compile ( r'_STR:0_' )
value_converters = {  '_STR:1_' : '_STR:0_' ,  '_STR:3_' : '_STR:2_' ,  }
importer = __import__
def __init__ ( self , config ) :pass
self . config = ConvertingDict ( config )
self . config . configurator = self
def resolve ( self , s ) :pass
name = s . split ( '_STR:0_' )
used = name . pop ( 0 )
try :pass _newline_ except: pass
found = self . importer ( used )
for frag in name :pass
used += '_STR:0_' + frag
try :pass _newline_ except: pass
found = getattr ( found , frag )
try: pass _newline_ except AttributeError :pass
self . importer ( used )
found = getattr ( found , frag )
return found
try: pass _newline_ except ImportError :pass
e , tb = sys . exc_info ( ) [ 1 : ]
v = ValueError ( '_STR:0_' % ( s , e ) )
v . __cause__ , v . __traceback__ = e , tb
raise v
def ext_convert ( self , value ) :pass
return self . resolve ( value )
def cfg_convert ( self , value ) :pass
rest = value
m = self . WORD_PATTERN . match ( rest )
if m is None :pass
raise ValueError ( '_STR:0_' % value )
if True: pass _newline_ else :pass
rest = rest [ m . end ( ) : ]
d = self . config [ m . groups ( ) [ 0 ] ]
while rest :pass
m = self . DOT_PATTERN . match ( rest )
if m :pass
d = d [ m . groups ( ) [ 0 ] ]
if True: pass _newline_ else :pass
m = self . INDEX_PATTERN . match ( rest )
if m :pass
idx = m . groups ( ) [ 0 ]
if not self . DIGIT_PATTERN . match ( idx ) :pass
d = d [ idx ]
if True: pass _newline_ else :pass
try :pass _newline_ except: pass
n = int ( idx )
d = d [ n ]
try: pass _newline_ except TypeError :pass
d = d [ idx ]
if m :pass
rest = rest [ m . end ( ) : ]
if True: pass _newline_ else :pass
raise ValueError ( 'Unable to convert '  '%r at %r' % ( value , rest ) )
return d
def convert ( self , value ) :pass
if not isinstance ( value , ConvertingDict ) and isinstance ( value , dict ) :pass
value = ConvertingDict ( value )
value . configurator = self
if True: pass _newline_ elif not isinstance ( value , ConvertingList ) and isinstance ( value , list ) :pass
value = ConvertingList ( value )
value . configurator = self
if True: pass _newline_ elif not isinstance ( value , ConvertingTuple ) and isinstance ( value , tuple ) :pass
value = ConvertingTuple ( value )
value . configurator = self
if True: pass _newline_ elif isinstance ( value , six . string_types ) :pass
m = self . CONVERT_PATTERN . match ( value )
if m :pass
d = m . groupdict ( )
prefix = d [ '_STR:0_' ]
converter = self . value_converters . get ( prefix , None )
if converter :pass
suffix = d [ '_STR:0_' ]
converter = getattr ( self , converter )
value = converter ( suffix )
return value
def configure_custom ( self , config ) :pass
c = config . pop ( '_STR:0_' )
if not hasattr ( c , '_STR:0_' ) and hasattr ( types , '_STR:1_' ) and type ( c ) != types . ClassType :pass
c = self . resolve ( c )
props = config . pop ( '_STR:0_' , None )
kwargs = dict ( ( k , config [ k ] ) for k in config if valid_ident ( k ) )
result = c ( ** kwargs )
if props :pass
for name , value in props . items ( ) :pass
setattr ( result , name , value )
return result
def as_tuple ( self , value ) :pass
if isinstance ( value , list ) :pass
value = tuple ( value )
return value
class DictConfigurator ( BaseConfigurator ) :pass
def configure ( self ) :pass
config = self . config
if '_STR:0_' not in config :pass
raise ValueError ( '_STR:0_' )
if config [ '_STR:0_' ] != 1 :pass
raise ValueError ( '_STR:0_' % config [ '_STR:1_' ] )
incremental = config . pop ( '_STR:0_' , False )
EMPTY_DICT = { }
logging . _acquireLock ( )
try :pass _newline_ except: pass
if incremental :pass
handlers = config . get ( '_STR:0_' , EMPTY_DICT )
if sys . version_info [ : 2 ] == ( 2 , 7 ) :pass
for name in handlers :pass
if name not in logging . _handlers :pass
raise ValueError ( 'No handler found with '  'name %r' % name )
if True: pass _newline_ else :pass
try :pass _newline_ except: pass
handler = logging . _handlers [ name ]
handler_config = handlers [ name ]
level = handler_config . get ( '_STR:0_' , None )
if level :pass
handler . setLevel ( _checkLevel ( level ) )
try: pass _newline_ except StandardError as e :pass
raise ValueError ( 'Unable to configure handler '  '%r: %s' % ( name , e ) )
loggers = config . get ( '_STR:0_' , EMPTY_DICT )
for name in loggers :pass
try :pass _newline_ except: pass
self . configure_logger ( name , loggers [ name ] , True )
try: pass _newline_ except StandardError as e :pass
raise ValueError ( 'Unable to configure logger '  '%r: %s' % ( name , e ) )
root = config . get ( '_STR:0_' , None )
if root :pass
try :pass _newline_ except: pass
self . configure_root ( root , True )
try: pass _newline_ except StandardError as e :pass
raise ValueError ( 'Unable to configure root '  'logger: %s' % e )
if True: pass _newline_ else :pass
disable_existing = config . pop ( '_STR:0_' , True )
logging . _handlers . clear ( )
del logging . _handlerList [ : ]
formatters = config . get ( '_STR:0_' , EMPTY_DICT )
for name in formatters :pass
try :pass _newline_ except: pass
formatters [ name ] = self . configure_formatter (  formatters [ name ] )
try: pass _newline_ except StandardError as e :pass
raise ValueError ( 'Unable to configure '  'formatter %r: %s' % ( name , e ) )
filters = config . get ( '_STR:0_' , EMPTY_DICT )
for name in filters :pass
try :pass _newline_ except: pass
filters [ name ] = self . configure_filter ( filters [ name ] )
try: pass _newline_ except StandardError as e :pass
raise ValueError ( 'Unable to configure '  'filter %r: %s' % ( name , e ) )
handlers = config . get ( '_STR:0_' , EMPTY_DICT )
for name in sorted ( handlers ) :pass
try :pass _newline_ except: pass
handler = self . configure_handler ( handlers [ name ] )
handler . name = name
handlers [ name ] = handler
try: pass _newline_ except StandardError as e :pass
raise ValueError ( 'Unable to configure handler '  '%r: %s' % ( name , e ) )
root = logging . root
existing = list ( root . manager . loggerDict )
existing . sort ( )
child_loggers = [ ]
loggers = config . get ( '_STR:0_' , EMPTY_DICT )
for name in loggers :pass
if name in existing :pass
i = existing . index ( name )
prefixed = name + "."
pflen = len ( prefixed )
num_existing = len ( existing )
i = i + 1
while ( i < num_existing ) and ( existing [ i ] [ : pflen ] == prefixed ) :pass
child_loggers . append ( existing [ i ] )
i = i + 1
existing . remove ( name )
try :pass _newline_ except: pass
self . configure_logger ( name , loggers [ name ] )
try: pass _newline_ except StandardError as e :pass
raise ValueError ( 'Unable to configure logger '  '%r: %s' % ( name , e ) )
for log in existing :pass
logger = root . manager . loggerDict [ log ]
if log in child_loggers :pass
logger . level = logging . NOTSET
logger . handlers = [ ]
logger . propagate = True
if True: pass _newline_ elif disable_existing :pass
logger . disabled = True
root = config . get ( '_STR:0_' , None )
if root :pass
try :pass _newline_ except: pass
self . configure_root ( root )
try: pass _newline_ except StandardError as e :pass
raise ValueError ( 'Unable to configure root '  'logger: %s' % e )
try: pass _newline_ finally :pass
logging . _releaseLock ( )
def configure_formatter ( self , config ) :pass
if '_STR:0_' in config :pass
factory = config [ '_STR:0_' ]
try :pass _newline_ except: pass
result = self . configure_custom ( config )
try: pass _newline_ except TypeError as te :pass
if '_STR:0_' not in str ( te ) :pass
raise
config [ '_STR:1_' ] = config . pop ( '_STR:0_' )
config [ '_STR:0_' ] = factory
result = self . configure_custom ( config )
if True: pass _newline_ else :pass
fmt = config . get ( '_STR:0_' , None )
dfmt = config . get ( '_STR:0_' , None )
result = logging . Formatter ( fmt , dfmt )
return result
def configure_filter ( self , config ) :pass
if '_STR:0_' in config :pass
result = self . configure_custom ( config )
if True: pass _newline_ else :pass
name = config . get ( '_STR:0_' , '' )
result = logging . Filter ( name )
return result
def add_filters ( self , filterer , filters ) :pass
for f in filters :pass
try :pass _newline_ except: pass
filterer . addFilter ( self . config [ '_STR:0_' ] [ f ] )
try: pass _newline_ except StandardError as e :pass
raise ValueError ( '_STR:0_' % ( f , e ) )
def configure_handler ( self , config ) :pass
formatter = config . pop ( '_STR:0_' , None )
if formatter :pass
try :pass _newline_ except: pass
formatter = self . config [ '_STR:0_' ] [ formatter ]
try: pass _newline_ except StandardError as e :pass
raise ValueError ( 'Unable to set formatter '  '%r: %s' % ( formatter , e ) )
level = config . pop ( '_STR:0_' , None )
filters = config . pop ( 'filters' , None )
if '_STR:0_' in config :pass
c = config . pop ( '_STR:0_' )
if not hasattr ( c , '_STR:0_' ) and hasattr ( types , '_STR:1_' ) and type ( c ) != types . ClassType :pass
c = self . resolve ( c )
factory = c
if True: pass _newline_ else :pass
klass = self . resolve ( config . pop ( '_STR:0_' ) )
if issubclass ( klass , logging . handlers . MemoryHandler ) and '_STR:0_' in config :pass
try :pass _newline_ except: pass
config [ '_STR:0_' ] = self . config [ 'handlers' ] [ config [ '_STR:0_' ] ]
try: pass _newline_ except StandardError as e :pass
raise ValueError ( 'Unable to set target handler '  '%r: %s' % ( config [ 'target' ] , e ) )
if True: pass _newline_ elif issubclass ( klass , logging . handlers . SMTPHandler ) and '_STR:1_' in config :pass
config [ '_STR:0_' ] = self . as_tuple ( config [ '_STR:0_' ] )
if True: pass _newline_ elif issubclass ( klass , logging . handlers . SysLogHandler ) and '_STR:1_' in config :pass
config [ '_STR:0_' ] = self . as_tuple ( config [ '_STR:0_' ] )
factory = klass
kwargs = dict ( ( k , config [ k ] ) for k in config if valid_ident ( k ) )
try :pass _newline_ except: pass
result = factory ( ** kwargs )
try: pass _newline_ except TypeError as te :pass
if '_STR:0_' not in str ( te ) :pass
raise
kwargs [ '_STR:1_' ] = kwargs . pop ( '_STR:0_' )
result = factory ( ** kwargs )
if formatter :pass
result . setFormatter ( formatter )
if level is not None :pass
result . setLevel ( _checkLevel ( level ) )
if filters :pass
self . add_filters ( result , filters )
return result
def add_handlers ( self , logger , handlers ) :pass
for h in handlers :pass
try :pass _newline_ except: pass
logger . addHandler ( self . config [ '_STR:0_' ] [ h ] )
try: pass _newline_ except StandardError as e :pass
raise ValueError ( '_STR:0_' % ( h , e ) )
def common_logger_config ( self , logger , config , incremental = False ) :pass
level = config . get ( '_STR:0_' , None )
if level is not None :pass
logger . setLevel ( _checkLevel ( level ) )
if not incremental :pass
for h in logger . handlers [ : ] :pass
logger . removeHandler ( h )
handlers = config . get ( '_STR:0_' , None )
if handlers :pass
self . add_handlers ( logger , handlers )
filters = config . get ( '_STR:0_' , None )
if filters :pass
self . add_filters ( logger , filters )
def configure_logger ( self , name , config , incremental = False ) :pass
logger = logging . getLogger ( name )
self . common_logger_config ( logger , config , incremental )
propagate = config . get ( '_STR:0_' , None )
if propagate is not None :pass
logger . propagate = propagate
def configure_root ( self , config , incremental = False ) :pass
root = logging . getLogger ( )
self . common_logger_config ( root , config , incremental )
dictConfigClass = DictConfigurator
def dictConfig ( config ) :pass
dictConfigClass ( config ) . configure ( )
from __future__ import unicode_literals
import codecs
import datetime
from decimal import Decimal
import locale
from django . utils . functional import Promise
from django . utils import six
from django . utils . six . moves . urllib . parse import quote
class DjangoUnicodeDecodeError ( UnicodeDecodeError ) :pass
def __init__ ( self , obj , * args ) :pass
self . obj = obj
UnicodeDecodeError . __init__ ( self , * args )
def __str__ ( self ) :pass
original = UnicodeDecodeError . __str__ ( self )
return '_STR:0_' % ( original , self . obj ,  type ( self . obj ) )
def python_2_unicode_compatible ( klass ) :pass
if six . PY2 :pass
if '_STR:0_' not in klass . __dict__ :pass
raise ValueError ( "@python_2_unicode_compatible cannot be applied "  "to %s because it doesn't define __str__()." %  klass . __name__ )
klass . __unicode__ = klass . __str__
klass . __str__ = lambda self : self . __unicode__ ( ) . encode ( 'utf-8' )
return klass
def smart_text ( s , encoding = '_STR:0_' , strings_only = False , errors = '_STR:1_' ) :pass
if isinstance ( s , Promise ) :pass
return s
return force_text ( s , encoding , strings_only , errors )
_PROTECTED_TYPES = six . integer_types + ( type ( None ) , float , Decimal ,  datetime . datetime , datetime . date , datetime . time )
def is_protected_type ( obj ) :pass
return isinstance ( obj , _PROTECTED_TYPES )
def force_text ( s , encoding = '_STR:0_' , strings_only = False , errors = '_STR:1_' ) :pass
if isinstance ( s , six . text_type ) :pass
return s
if strings_only and is_protected_type ( s ) :pass
return s
try :pass _newline_ except: pass
if not isinstance ( s , six . string_types ) :pass
if six . PY3 :pass
if isinstance ( s , bytes ) :pass
s = six . text_type ( s , encoding , errors )
if True: pass _newline_ else :pass
s = six . text_type ( s )
if True: pass _newline_ elif hasattr ( s , '_STR:0_' ) :pass
s = six . text_type ( s )
if True: pass _newline_ else :pass
s = six . text_type ( bytes ( s ) , encoding , errors )
if True: pass _newline_ else :pass
s = s . decode ( encoding , errors )
try: pass _newline_ except UnicodeDecodeError as e :pass
if not isinstance ( s , Exception ) :pass
raise DjangoUnicodeDecodeError ( s , * e . args )
if True: pass _newline_ else :pass
s = ' ' . join ( [ force_text ( arg , encoding , strings_only ,  errors ) for arg in s ] )
return s
def smart_bytes ( s , encoding = '_STR:0_' , strings_only = False , errors = '_STR:1_' ) :pass
if isinstance ( s , Promise ) :pass
return s
return force_bytes ( s , encoding , strings_only , errors )
def force_bytes ( s , encoding = '_STR:0_' , strings_only = False , errors = '_STR:1_' ) :pass
if isinstance ( s , bytes ) :pass
if encoding == '_STR:0_' :pass
return s
if True: pass _newline_ else :pass
return s . decode ( '_STR:0_' , errors ) . encode ( encoding , errors )
if strings_only and is_protected_type ( s ) :pass
return s
if isinstance ( s , six . memoryview ) :pass
return bytes ( s )
if isinstance ( s , Promise ) :pass
return six . text_type ( s ) . encode ( encoding , errors )
if not isinstance ( s , six . string_types ) :pass
try :pass _newline_ except: pass
if six . PY3 :pass
return six . text_type ( s ) . encode ( encoding )
if True: pass _newline_ else :pass
return bytes ( s )
try: pass _newline_ except UnicodeEncodeError :pass
if isinstance ( s , Exception ) :pass
return b' ' . join ( [ force_bytes ( arg , encoding , strings_only ,  errors ) for arg in s ] )
return six . text_type ( s ) . encode ( encoding , errors )
if True: pass _newline_ else :pass
return s . encode ( encoding , errors )
if six . PY3 :pass
smart_str = smart_text
force_str = force_text
if True: pass _newline_ else :pass
smart_str = smart_bytes
force_str = force_bytes
smart_unicode = smart_text
force_unicode = force_text
def iri_to_uri ( iri ) :pass
if iri is None :pass
return iri
return quote ( force_bytes ( iri ) , safe = b"/#%[]=:;$&()+,!?*@'~" )
def filepath_to_uri ( path ) :pass
if path is None :pass
return path
return quote ( force_bytes ( path ) . replace ( b"\\" , b"/" ) , safe = b"/~!*()'" )
def get_system_encoding ( ) :pass
try :pass _newline_ except: pass
encoding = locale . getdefaultlocale ( ) [ 1 ] or 'ascii'
codecs . lookup ( encoding )
try: pass _newline_ except Exception :pass
encoding = '_STR:0_'
return encoding
DEFAULT_LOCALE_ENCODING = get_system_encoding ( )
from __future__ import unicode_literals
import datetime
from django . utils . xmlutils import SimplerXMLGenerator
from django . utils . encoding import force_text , iri_to_uri
from django . utils import datetime_safe
from django . utils import six
from django . utils . six import StringIO
from django . utils . six . moves . urllib . parse import urlparse
from django . utils . timezone import is_aware
def rfc2822_date ( date ) :pass
months = ( '_STR:0_' , '_STR:1_' , '_STR:2_' , '_STR:3_' , '_STR:4_' , '_STR:5_' , '_STR:6_' , '_STR:7_' , '_STR:8_' , '_STR:9_' , '_STR:10_' , '_STR:11_' , )
days = ( '_STR:0_' , '_STR:1_' , '_STR:2_' , '_STR:3_' , '_STR:4_' , '_STR:5_' , '_STR:6_' )
date = datetime_safe . new_datetime ( date )
dow = days [ date . weekday ( ) ]
month = months [ date . month - 1 ]
time_str = date . strftime ( '_STR:0_' % ( dow , month ) )
if six . PY2 :pass
time_str = time_str . decode ( '_STR:0_' )
if is_aware ( date ) :pass
offset = date . tzinfo . utcoffset ( date )
timezone = ( offset . days * 24 * 60 ) + ( offset . seconds // 60 )
hour , minute = divmod ( timezone , 60 )
return time_str + '_STR:0_' % ( hour , minute )
if True: pass _newline_ else :pass
return time_str + '_STR:0_'
def rfc3339_date ( date ) :pass
date = datetime_safe . new_datetime ( date )
time_str = date . strftime ( '_STR:0_' )
if six . PY2 :pass
time_str = time_str . decode ( '_STR:0_' )
if is_aware ( date ) :pass
offset = date . tzinfo . utcoffset ( date )
timezone = ( offset . days * 24 * 60 ) + ( offset . seconds // 60 )
hour , minute = divmod ( timezone , 60 )
return time_str + '_STR:0_' % ( hour , minute )
if True: pass _newline_ else :pass
return time_str + '_STR:0_'
def get_tag_uri ( url , date ) :pass
bits = urlparse ( url )
d = ''
if date is not None :pass
d = ',%s' % datetime_safe . new_datetime ( date ) . strftime ( '%Y-%m-%d' )
return '_STR:2_' % ( bits . hostname , d , bits . path , bits . fragment )
class SyndicationFeed ( object ) :pass
def __init__ ( self , title , link , description , language = None , author_email = None ,  author_name = None , author_link = None , subtitle = None , categories = None ,  feed_url = None , feed_copyright = None , feed_guid = None , ttl = None , ** kwargs ) :pass
to_unicode = lambda s : force_text ( s , strings_only = True )
if categories :pass
categories = [ force_text ( c ) for c in categories ]
if ttl is not None :pass
ttl = force_text ( ttl )
self . feed = {  '_STR:0_' : to_unicode ( title ) ,  'link' : iri_to_uri ( link ) ,  'description' : to_unicode ( description ) ,  'language' : to_unicode ( language ) ,  'author_email' : to_unicode ( author_email ) ,  'author_name' : to_unicode ( author_name ) ,  'author_link' : iri_to_uri ( author_link ) ,  'subtitle' : to_unicode ( subtitle ) ,  'categories' : categories or ( ) ,  'feed_url' : iri_to_uri ( feed_url ) ,  'feed_copyright' : to_unicode ( feed_copyright ) ,  'id' : feed_guid or link ,  'ttl' : ttl ,  }
self . feed . update ( kwargs )
self . items = [ ]
def add_item ( self , title , link , description , author_email = None ,  author_name = None , author_link = None , pubdate = None , comments = None ,  unique_id = None , unique_id_is_permalink = None , enclosure = None ,  categories = ( ) , item_copyright = None , ttl = None , updateddate = None , ** kwargs ) :pass
to_unicode = lambda s : force_text ( s , strings_only = True )
if categories :pass
categories = [ ( c ) for c in categories ]
if ttl is not None :pass
ttl = force_text ( ttl )
item = {  '_STR:0_' : to_unicode ( title ) ,  'link' : iri_to_uri ( link ) ,  'description' : to_unicode ( description ) ,  'author_email' : to_unicode ( author_email ) ,  'author_name' : to_unicode ( author_name ) ,  'author_link' : iri_to_uri ( author_link ) ,  'pubdate' : pubdate ,  'updateddate' : updateddate ,  'comments' : to_unicode ( comments ) ,  'unique_id' : to_unicode ( unique_id ) ,  'unique_id_is_permalink' : unique_id_is_permalink ,  'enclosure' : enclosure ,  'categories' : categories or ( ) ,  'item_copyright' : to_unicode ( item_copyright ) ,  'ttl' : ttl ,  }
item . update ( kwargs )
self . items . append ( item )
def num_items ( self ) :pass
return len ( self . items )
def root_attributes ( self ) :pass
return { }
def add_root_elements ( self , handler ) :pass
pass
def item_attributes ( self , item ) :pass
return { }
def add_item_elements ( self , handler , item ) :pass
pass
def write ( self , outfile , encoding ) :pass
raise NotImplementedError ( '_STR:0_' )
def writeString ( self , encoding ) :pass
s = StringIO ( )
self . write ( s , encoding )
return s . getvalue ( )
def latest_post_date ( self ) :pass
latest_date = None
date_keys = ( '_STR:0_' , '_STR:1_' )
for item in self . items :pass
for date_key in date_keys :pass
item_date = item . get ( date_key )
if item_date :pass
if latest_date is None or item_date > latest_date :pass
latest_date = item_date
return latest_date or datetime . datetime . now ( )
class Enclosure ( object ) :pass
def __init__ ( self , url , length , mime_type ) :pass
self . length , self . mime_type = length , mime_type
self . url = iri_to_uri ( url )
class RssFeed ( SyndicationFeed ) :pass
mime_type = '_STR:0_'
def write ( self , outfile , encoding ) :pass
handler = SimplerXMLGenerator ( outfile , encoding )
handler . startDocument ( )
handler . startElement ( '_STR:0_' , self . rss_attributes ( ) )
handler . startElement ( '_STR:0_' , self . root_attributes ( ) )
self . add_root_elements ( handler )
self . write_items ( handler )
self . endChannelElement ( handler )
handler . endElement ( "rss" )
def rss_attributes ( self ) :pass
return { '_STR:0_' : self . _version ,  '_STR:2_' : '_STR:1_' }
def write_items ( self , handler ) :pass
for item in self . items :pass
handler . startElement ( 'item' , self . item_attributes ( item ) )
self . add_item_elements ( handler , item )
handler . endElement ( "item" )
def add_root_elements ( self , handler ) :pass
handler . addQuickElement ( "title" , self . feed [ '_STR:0_' ] )
handler . addQuickElement ( "link" , self . feed [ '_STR:0_' ] )
handler . addQuickElement ( "description" , self . feed [ '_STR:0_' ] )
if self . feed [ '_STR:0_' ] is not None :pass
handler . addQuickElement ( "atom:link" , None ,  { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
if self . feed [ '_STR:2_' ] is not None :pass
handler . addQuickElement ( "language" , self . feed [ '_STR:0_' ] )
for cat in self . feed [ '_STR:0_' ] :pass
handler . addQuickElement ( '_STR:0_' , cat )
if self . feed [ '_STR:0_' ] is not None :pass
handler . addQuickElement ( "copyright" , self . feed [ '_STR:1_' ] )
handler . addQuickElement ( "lastBuildDate" , rfc2822_date ( self . latest_post_date ( ) ) )
if self . feed [ '_STR:0_' ] is not None :pass
handler . addQuickElement ( "ttl" , self . feed [ '_STR:0_' ] )
def endChannelElement ( self , handler ) :pass
handler . endElement ( "channel" )
class RssUserland091Feed ( RssFeed ) :pass
_version = '_STR:0_'
def add_item_elements ( self , handler , item ) :pass
handler . addQuickElement ( "title" , item [ '_STR:0_' ] )
handler . addQuickElement ( "link" , item [ '_STR:0_' ] )
if item [ '_STR:0_' ] is not None :pass
handler . addQuickElement ( "description" , item [ '_STR:0_' ] )
class Rss201rev2Feed ( RssFeed ) :pass
_version = '_STR:0_'
def add_item_elements ( self , handler , item ) :pass
handler . addQuickElement ( "title" , item [ '_STR:0_' ] )
handler . addQuickElement ( "link" , item [ '_STR:0_' ] )
if item [ '_STR:0_' ] is not None :pass
handler . addQuickElement ( "description" , item [ '_STR:0_' ] )
if item [ '_STR:0_' ] and item [ '_STR:1_' ] :pass
handler . addQuickElement ( '_STR:0_' , '_STR:1_' %  ( item [ 'author_email' ] , item [ 'author_name' ] ) )
if True: pass _newline_ elif item [ '_STR:2_' ] :pass
handler . addQuickElement ( "author" , item [ "author_email" ] )
if True: pass _newline_ elif item [ '_STR:0_' ] :pass
handler . addQuickElement ( "dc:creator" , item [ "author_name" ] , { "xmlns:dc" : "http://purl.org/dc/elements/1.1/" } )
if item [ '_STR:3_' ] is not None :pass
handler . addQuickElement ( "pubDate" , rfc2822_date ( item [ 'pubdate' ] ) )
if item [ '_STR:1_' ] is not None :pass
handler . addQuickElement ( "comments" , item [ '_STR:0_' ] )
if item [ '_STR:0_' ] is not None :pass
guid_attrs = { }
if isinstance ( item . get ( '_STR:0_' ) , bool ) :pass
guid_attrs [ 'isPermaLink' ] = str (  item [ '_STR:0_' ] ) . lower ( )
handler . addQuickElement ( "guid" , item [ '_STR:2_' ] , guid_attrs )
if item [ '_STR:0_' ] is not None :pass
handler . addQuickElement ( "ttl" , item [ '_STR:0_' ] )
if item [ '_STR:0_' ] is not None :pass
handler . addQuickElement ( "enclosure" , '' ,  { "url" : item [ 'enclosure' ] . url , "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
for cat in item [ '_STR:4_' ] :pass
handler . addQuickElement ( "category" , cat )
class Atom1Feed ( SyndicationFeed ) :pass
mime_type = '_STR:0_'
ns = '_STR:0_'
def write ( self , outfile , encoding ) :pass
handler = SimplerXMLGenerator ( outfile , encoding )
handler . startDocument ( )
handler . startElement ( '_STR:0_' , self . root_attributes ( ) )
self . add_root_elements ( handler )
self . write_items ( handler )
handler . endElement ( "feed" )
def root_attributes ( self ) :pass
if self . feed [ '_STR:0_' ] is not None :pass
return { "xmlns" : self . ns , '_STR:1_' : self . feed [ '_STR:0_' ] }
if True: pass _newline_ else :pass
return { '_STR:0_' : self . ns }
def add_root_elements ( self , handler ) :pass
handler . addQuickElement ( "title" , self . feed [ '_STR:0_' ] )
handler . addQuickElement ( "link" , "" , { "rel" : "alternate" , "href" : self . feed [ '_STR:0_' ] } )
if self . feed [ '_STR:4_' ] is not None :pass
handler . addQuickElement ( "link" , "" , { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
handler . addQuickElement ( "id" , self . feed [ 'id' ] )
handler . addQuickElement ( "updated" , rfc3339_date ( self . latest_post_date ( ) ) )
if self . feed [ '_STR:0_' ] is not None :pass
handler . startElement ( "author" , { } )
handler . addQuickElement ( "name" , self . feed [ '_STR:1_' ] )
if self . feed [ '_STR:0_' ] is not None :pass
handler . addQuickElement ( "email" , self . feed [ '_STR:1_' ] )
if self . feed [ '_STR:0_' ] is not None :pass
handler . addQuickElement ( "uri" , self . feed [ '_STR:1_' ] )
handler . endElement ( "author" )
if self . feed [ '_STR:0_' ] is not None :pass
handler . addQuickElement ( "subtitle" , self . feed [ '_STR:0_' ] )
for cat in self . feed [ '_STR:0_' ] :pass
handler . addQuickElement ( "category" , "" , { "term" : cat } )
if self . feed [ '_STR:1_' ] is not None :pass
handler . addQuickElement ( "rights" , self . feed [ '_STR:1_' ] )
def write_items ( self , handler ) :pass
for item in self . items :pass
handler . startElement ( "entry" , self . item_attributes ( item ) )
self . add_item_elements ( handler , item )
handler . endElement ( "entry" )
def add_item_elements ( self , handler , item ) :pass
handler . addQuickElement ( "title" , item [ '_STR:0_' ] )
handler . addQuickElement ( "link" , "" , { "href" : item [ '_STR:0_' ] , "rel" : "alternate" } )
if item [ '_STR:4_' ] is not None :pass
handler . addQuickElement ( '_STR:0_' , rfc3339_date ( item [ 'pubdate' ] ) )
if item [ '_STR:1_' ] is not None :pass
handler . addQuickElement ( '_STR:0_' , rfc3339_date ( item [ 'updateddate' ] ) )
if item [ '_STR:1_' ] is not None :pass
handler . startElement ( "author" , { } )
handler . addQuickElement ( "name" , item [ '_STR:1_' ] )
if item [ '_STR:0_' ] is not None :pass
handler . addQuickElement ( "email" , item [ '_STR:1_' ] )
if item [ '_STR:0_' ] is not None :pass
handler . addQuickElement ( "uri" , item [ '_STR:1_' ] )
handler . endElement ( "author" )
if item [ '_STR:0_' ] is not None :pass
unique_id = item [ '_STR:0_' ]
if True: pass _newline_ else :pass
unique_id = get_tag_uri ( item [ '_STR:0_' ] , item [ '_STR:1_' ] )
handler . addQuickElement ( "id" , unique_id )
if item [ '_STR:0_' ] is not None :pass
handler . addQuickElement ( "summary" , item [ '_STR:1_' ] , { "type" : "html" } )
if item [ '_STR:2_' ] is not None :pass
handler . addQuickElement ( "link" , '' ,  { "rel" : "enclosure" ,  "href" : item [ 'enclosure' ] . url ,  "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
for cat in item [ '_STR:5_' ] :pass
handler . addQuickElement ( "category" , "" , { "term" : cat } )
if item [ '_STR:1_' ] is not None :pass
handler . addQuickElement ( "rights" , item [ '_STR:1_' ] )
DefaultFeed = Rss201rev2Feed
from __future__ import absolute_import
import decimal
import datetime
from importlib import import_module
import unicodedata
from django . conf import settings
from django . utils import dateformat , numberformat , datetime_safe
from django . utils . encoding import force_str
from django . utils . functional import lazy
from django . utils . safestring import mark_safe
from django . utils import six
from django . utils . translation import get_language , to_locale , check_for_language
_format_cache = { }
_format_modules_cache = { }
ISO_INPUT_FORMATS = {  '_STR:1_' : ( '_STR:0_' , ) ,  'TIME_INPUT_FORMATS' : ( '%H:%M:%S' , '%H:%M:%S.%f' , '%H:%M' ) ,  'DATETIME_INPUT_FORMATS' : (  '%Y-%m-%d %H:%M:%S' ,  '%Y-%m-%d %H:%M:%S.%f' ,  '%Y-%m-%d %H:%M' ,  '_STR:0_'  ) ,  }
def reset_format_cache ( ) :pass
global _format_cache , _format_modules_cache
_format_cache = { }
_format_modules_cache = { }
def iter_format_modules ( lang , format_module_path = None ) :pass
if not check_for_language ( lang ) :pass
return
if format_module_path is None :pass
format_module_path = settings . FORMAT_MODULE_PATH
format_locations = [ ]
if format_module_path :pass
if isinstance ( format_module_path , six . string_types ) :pass
format_module_path = [ format_module_path ]
for path in format_module_path :pass
format_locations . append ( path + '_STR:0_' )
format_locations . append ( '_STR:0_' )
locale = to_locale ( lang )
locales = [ locale ]
if '_STR:0_' in locale :pass
locales . append ( locale . split ( '_STR:0_' ) [ 0 ] )
for location in format_locations :pass
for loc in locales :pass
try :pass _newline_ except: pass
yield import_module ( '_STR:0_' % ( location % loc ) )
try: pass _newline_ except ImportError :pass
pass
def get_format_modules ( lang = None , reverse = False ) :pass
if lang is None :pass
lang = get_language ( )
modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
if reverse :pass
return list ( reversed ( modules ) )
return modules
def get_format ( format_type , lang = None , use_l10n = None ) :pass
format_type = force_str ( format_type )
if use_l10n or ( use_l10n is None and settings . USE_L10N ) :pass
if lang is None :pass
lang = get_language ( )
cache_key = ( format_type , lang )
try :pass _newline_ except: pass
cached = _format_cache [ cache_key ]
if cached is not None :pass
return cached
if True: pass _newline_ else :pass
return getattr ( settings , format_type )
try: pass _newline_ except KeyError :pass
for module in get_format_modules ( lang ) :pass
try :pass _newline_ except: pass
val = getattr ( module , format_type )
for iso_input in ISO_INPUT_FORMATS . get ( format_type , ( ) ) :pass
if iso_input not in val :pass
if isinstance ( val , tuple ) :pass
val = list ( val )
val . append ( iso_input )
_format_cache [ cache_key ] = val
return val
try: pass _newline_ except AttributeError :pass
pass
_format_cache [ cache_key ] = None
return getattr ( settings , format_type )
get_format_lazy = lazy ( get_format , six . text_type , list , tuple )
def date_format ( value , format = None , use_l10n = None ) :pass
return dateformat . format ( value , get_format ( format or 'DATE_FORMAT' , use_l10n = use_l10n ) )
def time_format ( value , format = None , use_l10n = None ) :pass
return dateformat . time_format ( value , get_format ( format or 'TIME_FORMAT' , use_l10n = use_l10n ) )
def number_format ( value , decimal_pos = None , use_l10n = None , force_grouping = False ) :pass
if use_l10n or ( use_l10n is None and settings . USE_L10N ) :pass
lang = get_language ( )
if True: pass _newline_ else :pass
lang = None
return numberformat . format (  value ,  get_format ( 'DECIMAL_SEPARATOR' , lang , use_l10n = use_l10n ) ,  decimal_pos ,  get_format ( 'NUMBER_GROUPING' , lang , use_l10n = use_l10n ) ,  get_format ( 'THOUSAND_SEPARATOR' , lang , use_l10n = use_l10n ) ,  force_grouping = force_grouping  )
def localize ( value , use_l10n = None ) :pass
if isinstance ( value , bool ) :pass
return mark_safe ( six . text_type ( value ) )
if True: pass _newline_ elif isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :pass
return number_format ( value , use_l10n = use_l10n )
if True: pass _newline_ elif isinstance ( value , datetime . datetime ) :pass
return date_format ( value , '_STR:0_' , use_l10n = use_l10n )
if True: pass _newline_ elif isinstance ( value , datetime . date ) :pass
return date_format ( value , use_l10n = use_l10n )
if True: pass _newline_ elif isinstance ( value , datetime . time ) :pass
return time_format ( value , '_STR:0_' , use_l10n = use_l10n )
if True: pass _newline_ else :pass
return value
def localize_input ( value , default = None ) :pass
if isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :pass
return number_format ( value )
if True: pass _newline_ elif isinstance ( value , datetime . datetime ) :pass
value = datetime_safe . new_datetime ( value )
format = force_str ( default or get_format ( 'DATETIME_INPUT_FORMATS' ) [ 0 ] )
return value . strftime ( format )
if True: pass _newline_ elif isinstance ( value , datetime . date ) :pass
value = datetime_safe . new_date ( value )
format = force_str ( default or get_format ( 'DATE_INPUT_FORMATS' ) [ 0 ] )
return value . strftime ( format )
if True: pass _newline_ elif isinstance ( value , datetime . time ) :pass
format = force_str ( default or get_format ( 'TIME_INPUT_FORMATS' ) [ 0 ] )
return value . strftime ( format )
return value
def sanitize_separators ( value ) :pass
if settings . USE_L10N and isinstance ( value , six . string_types ) :pass
parts = [ ]
decimal_separator = get_format ( '_STR:0_' )
if decimal_separator in value :pass
value , decimals = value . split ( decimal_separator , 1 )
parts . append ( decimals )
if settings . USE_THOUSAND_SEPARATOR :pass
thousand_sep = get_format ( '_STR:0_' )
for replacement in set ( [  thousand_sep , unicodedata . normalize ( '_STR:0_' , thousand_sep ) ] ) :pass
value = value . replace ( replacement , '' )
parts . append ( value )
value = '_STR:0_' . join ( reversed ( parts ) )
return value
import copy
import operator
from functools import wraps
import sys
import warnings
from django . utils import six
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils . six . moves import copyreg
def curry ( _curried_func , * args , ** kwargs ) :pass
def _curried ( * moreargs , ** morekwargs ) :pass
return _curried_func ( * ( args + moreargs ) , ** dict ( kwargs , ** morekwargs ) )
return _curried
def memoize ( func , cache , num_args ) :pass
warnings . warn ( "memoize wrapper is deprecated and will be removed in "  "Django 1.9. Use django.utils.lru_cache instead." ,  RemovedInDjango19Warning , stacklevel = 2 )
@ wraps ( func ) _newline_ def dummy(): pass
def wrapper ( * args ) :pass
mem_args = args [ : num_args ]
if mem_args in cache :pass
return cache [ mem_args ]
result = func ( * args )
cache [ mem_args ] = result
return result
return wrapper
class cached_property ( object ) :pass
def __init__ ( self , func , name = None ) :pass
self . func = func
self . name = name or func . __name__
def __get__ ( self , instance , type = None ) :pass
if instance is None :pass
return self
res = instance . __dict__ [ self . name ] = self . func ( instance )
return res
class Promise ( object ) :pass
pass
def lazy ( func , * resultclasses ) :pass
@ total_ordering _newline_ def dummy(): pass
class __proxy__ ( Promise ) :pass
__dispatch = None
def __init__ ( self , args , kw ) :pass
self . __args = args
self . __kw = kw
if self . __dispatch is None :pass
self . __prepare_class__ ( )
def __reduce__ ( self ) :pass
return (  _lazy_proxy_unpickle ,  ( func , self . __args , self . __kw ) + resultclasses  )
@ classmethod _newline_ def dummy(): pass
def __prepare_class__ ( cls ) :pass
cls . __dispatch = { }
for resultclass in resultclasses :pass
cls . __dispatch [ resultclass ] = { }
for type_ in reversed ( resultclass . mro ( ) ) :pass
for ( k , v ) in type_ . __dict__ . items ( ) :pass
meth = cls . __promise__ ( resultclass , k , v )
if hasattr ( cls , k ) :pass
continue
setattr ( cls , k , meth )
cls . _delegate_bytes = bytes in resultclasses
cls . _delegate_text = six . text_type in resultclasses
assert not ( cls . _delegate_bytes and cls . _delegate_text ) , '_STR:0_'
if cls . _delegate_text :pass
if six . PY3 :pass
cls . __str__ = cls . __text_cast
if True: pass _newline_ else :pass
cls . __unicode__ = cls . __text_cast
if True: pass _newline_ elif cls . _delegate_bytes :pass
if six . PY3 :pass
cls . __bytes__ = cls . __bytes_cast
if True: pass _newline_ else :pass
cls . __str__ = cls . __bytes_cast
@ classmethod _newline_ def dummy(): pass
def __promise__ ( cls , klass , funcname , method ) :pass
def __wrapper__ ( self , * args , ** kw ) :pass
res = func ( * self . __args , ** self . __kw )
for t in type ( res ) . mro ( ) :pass
if t in self . __dispatch :pass
return self . __dispatch [ t ] [ funcname ] ( res , * args , ** kw )
raise TypeError ( '_STR:0_' )
if klass not in cls . __dispatch :pass
cls . __dispatch [ klass ] = { }
cls . __dispatch [ klass ] [ funcname ] = method
return __wrapper__
def __text_cast ( self ) :pass
return func ( * self . __args , ** self . __kw )
def __bytes_cast ( self ) :pass
return bytes ( func ( * self . __args , ** self . __kw ) )
def __cast ( self ) :pass
if self . _delegate_bytes :pass
return self . __bytes_cast ( )
if True: pass _newline_ elif self . _delegate_text :pass
return self . __text_cast ( )
if True: pass _newline_ else :pass
return func ( * self . __args , ** self . __kw )
def __ne__ ( self , other ) :pass
if isinstance ( other , Promise ) :pass
other = other . __cast ( )
return self . __cast ( ) != other
def __eq__ ( self , other ) :pass
if isinstance ( other , Promise ) :pass
other = other . __cast ( )
return self . __cast ( ) == other
def __lt__ ( self , other ) :pass
if isinstance ( other , Promise ) :pass
other = other . __cast ( )
return self . __cast ( ) < other
def __hash__ ( self ) :pass
return hash ( self . __cast ( ) )
def __mod__ ( self , rhs ) :pass
if self . _delegate_bytes and six . PY2 :pass
return bytes ( self ) % rhs
if True: pass _newline_ elif self . _delegate_text :pass
return six . text_type ( self ) % rhs
return self . __cast ( ) % rhs
def __deepcopy__ ( self , memo ) :pass
memo [ id ( self ) ] = self
return self
@ wraps ( func ) _newline_ def dummy(): pass
def __wrapper__ ( * args , ** kw ) :pass
return __proxy__ ( args , kw )
return __wrapper__
def _lazy_proxy_unpickle ( func , args , kwargs , * resultclasses ) :pass
return lazy ( func , * resultclasses ) ( * args , ** kwargs )
def allow_lazy ( func , * resultclasses ) :pass
@ wraps ( func ) _newline_ def dummy(): pass
def wrapper ( * args , ** kwargs ) :pass
for arg in list ( args ) + list ( six . itervalues ( kwargs ) ) :pass
if isinstance ( arg , Promise ) :pass
break
if True: pass _newline_ else :pass
return func ( * args , ** kwargs )
return lazy ( func , * resultclasses ) ( * args , ** kwargs )
return wrapper
empty = object ( )
def new_method_proxy ( func ) :pass
def inner ( self , * args ) :pass
if self . _wrapped is empty :pass
self . _setup ( )
return func ( self . _wrapped , * args )
return inner
class LazyObject ( object ) :pass
_wrapped = None
def __init__ ( self ) :pass
self . _wrapped = empty
__getattr__ = new_method_proxy ( getattr )
def __setattr__ ( self , name , value ) :pass
if name == '_STR:0_' :pass
self . __dict__ [ '_STR:0_' ] = value
if True: pass _newline_ else :pass
if self . _wrapped is empty :pass
self . _setup ( )
setattr ( self . _wrapped , name , value )
def __delattr__ ( self , name ) :pass
if name == '_STR:0_' :pass
raise TypeError ( '_STR:0_' )
if self . _wrapped is empty :pass
self . _setup ( )
delattr ( self . _wrapped , name )
def _setup ( self ) :pass
raise NotImplementedError ( '_STR:0_' )
def __getstate__ ( self ) :pass
if self . _wrapped is empty :pass
self . _setup ( )
return self . _wrapped . __dict__
@ classmethod _newline_ def dummy(): pass
def __newobj__ ( cls , * args ) :pass
return cls . __new__ ( cls , * args )
def __reduce_ex__ ( self , proto ) :pass
if proto >= 2 :pass
return ( self . __newobj__ , ( self . __class__ , ) , self . __getstate__ ( ) )
if True: pass _newline_ else :pass
return ( copyreg . _reconstructor , ( self . __class__ , object , None ) , self . __getstate__ ( ) )
def __deepcopy__ ( self , memo ) :pass
if self . _wrapped is empty :pass
result = type ( self ) ( )
memo [ id ( self ) ] = result
return result
return copy . deepcopy ( self . _wrapped , memo )
if six . PY3 :pass
__bytes__ = new_method_proxy ( bytes )
__str__ = new_method_proxy ( str )
__bool__ = new_method_proxy ( bool )
if True: pass _newline_ else :pass
__str__ = new_method_proxy ( str )
__unicode__ = new_method_proxy ( unicode )
__nonzero__ = new_method_proxy ( bool )
__dir__ = new_method_proxy ( dir )
__class__ = property ( new_method_proxy ( operator . attrgetter ( '_STR:0_' ) ) )
__eq__ = new_method_proxy ( operator . eq )
__ne__ = new_method_proxy ( operator . ne )
__hash__ = new_method_proxy ( hash )
__getitem__ = new_method_proxy ( operator . getitem )
__setitem__ = new_method_proxy ( operator . setitem )
__delitem__ = new_method_proxy ( operator . delitem )
__len__ = new_method_proxy ( len )
__contains__ = new_method_proxy ( operator . contains )
_super = super
class SimpleLazyObject ( LazyObject ) :pass
def __init__ ( self , func ) :pass
self . __dict__ [ '_STR:0_' ] = func
_super ( SimpleLazyObject , self ) . __init__ ( )
def _setup ( self ) :pass
self . _wrapped = self . _setupfunc ( )
def __repr__ ( self ) :pass
if self . _wrapped is empty :pass
repr_attr = self . _setupfunc
if True: pass _newline_ else :pass
repr_attr = self . _wrapped
return '_STR:0_' % ( type ( self ) . __name__ , repr_attr )
def __deepcopy__ ( self , memo ) :pass
if self . _wrapped is empty :pass
result = SimpleLazyObject ( self . _setupfunc )
memo [ id ( self ) ] = result
return result
return copy . deepcopy ( self . _wrapped , memo )
class lazy_property ( property ) :pass
def __new__ ( cls , fget = None , fset = None , fdel = None , doc = None ) :pass
if fget is not None :pass
@ wraps ( fget ) _newline_ def dummy(): pass
def fget ( instance , instance_type = None , name = fget . __name__ ) :pass
return getattr ( instance , name ) ( )
if fset is not None :pass
@ wraps ( fset ) _newline_ def dummy(): pass
def fset ( instance , value , name = fset . __name__ ) :pass
return getattr ( instance , name ) ( value )
if fdel is not None :pass
@ wraps ( fdel ) _newline_ def dummy(): pass
def fdel ( instance , name = fdel . __name__ ) :pass
return getattr ( instance , name ) ( )
return property ( fget , fset , fdel , doc )
def partition ( predicate , values ) :pass
results = ( [ ] , [ ] )
for item in values :pass
results [ predicate ( item ) ] . append ( item )
return results
if sys . version_info >= ( 2 , 7 , 2 ) :pass
from functools import total_ordering
if True: pass _newline_ else :pass
def total_ordering ( cls ) :pass
convert = {  '__lt__' : [ ( '_STR:0_' , lambda self , other : not ( self < other or self == other ) ) ,  ( '__le__' , lambda self , other : self < other or self == other ) ,  ( '__ge__' , lambda self , other : not self < other ) ] ,  '__le__' : [ ( '__ge__' , lambda self , other : not self <= other or self == other ) ,  ( '__lt__' , lambda self , other : self <= other and not self == other ) ,  ( '_STR:0_' , lambda self , other : not self <= other ) ] ,  '_STR:0_' : [ ( '__lt__' , lambda self , other : not ( self > other or self == other ) ) ,  ( '__ge__' , lambda self , other : self > other or self == other ) ,  ( '__le__' , lambda self , other : not self > other ) ] ,  '__ge__' : [ ( '__le__' , lambda self , other : ( not self >= other ) or self == other ) ,  ( '_STR:0_' , lambda self , other : self >= other and not self == other ) ,  ( '__lt__' , lambda self , other : not self >= other ) ]  }
roots = set ( dir ( cls ) ) & set ( convert )
if not roots :pass
raise ValueError ( '_STR:0_' )
root = max ( roots )
for opname , opfunc in convert [ root ] :pass
if opname not in roots :pass
opfunc . __name__ = opname
opfunc . __doc__ = getattr ( int , opname ) . __doc__
setattr ( cls , opname , opfunc )
return cls
from __future__ import unicode_literals
import re
import sys
from django . utils . encoding import force_text , force_str
from django . utils . functional import allow_lazy
from django . utils . safestring import SafeData , mark_safe
from django . utils import six
from django . utils . six . moves . urllib . parse import quote , unquote , urlsplit , urlunsplit
from django . utils . text import normalize_newlines
from . html_parser import HTMLParser , HTMLParseError
TRAILING_PUNCTUATION = [ '_STR:0_' , '_STR:1_' , '_STR:2_' , '_STR:3_' , '_STR:4_' , '_STR:5_' , '_STR:6_' ]
WRAPPING_PUNCTUATION = [ ( '_STR:0_' , '_STR:1_' ) , ( '_STR:2_' , '_STR:3_' ) , ( '[' , ']' ) , ( '&lt;' , '&gt;' ) , ( '"' , '"' ) , ( '\'' , '\'' ) ]
DOTS = [ '_STR:6_' , '_STR:7_' , '_STR:8_' , '_STR:9_' , '_STR:10_' , '_STR:11_' ]
unencoded_ampersands_re = re . compile ( r'_STR:0_' )
word_split_re = re . compile ( r'_STR:0_' )
simple_url_re = re . compile ( r'_STR:0_' , re . IGNORECASE )
simple_url_2_re = re . compile ( r'_STR:0_' , re . IGNORECASE )
simple_email_re = re . compile ( r'^\S+@\S+\.\S+$' )
link_target_attribute_re = re . compile ( r'_STR:0_' )
html_gunk_re = re . compile ( r'(?:<br clear="all">|<i><\/i>|<b><\/b>|<em><\/em>|<strong><\/strong>|<\/?smallcaps>|<\/?uppercase>)' , re . IGNORECASE )
hard_coded_bullets_re = re . compile ( r'_STR:1_' % '|' . join ( re . escape ( x ) for x in DOTS ) , re . DOTALL )
trailing_empty_content_re = re . compile ( r'_STR:1_' )
def escape ( text ) :pass
return mark_safe ( force_text ( text ) . replace ( '_STR:0_' , '_STR:1_' ) . replace ( '<' , '&lt;' ) . replace ( '>' , '&gt;' ) . replace ( '"' , '&quot;' ) . replace ( "'" , '&#39;' ) )
escape = allow_lazy ( escape , six . text_type )
_js_escapes = {  ord ( '\\' ) : '_STR:0_' ,  ord ( '\'' ) : '\\u0027' ,  ord ( '"' ) : '\\u0022' ,  ord ( '>' ) : '\\u003E' ,  ord ( '<' ) : '\\u003C' ,  ord ( '&' ) : '\\u0026' ,  ord ( '=' ) : '\\u003D' ,  ord ( '-' ) : '\\u002D' ,  ord ( ';' ) : '\\u003B' ,  ord ( '\u2028' ) : '\\u2028' ,  ord ( '\u2029' ) : '\\u2029'  }
_js_escapes . update ( ( ord ( '%c' % z ) , '\\u%04X' % z ) for z in range ( 32 ) )
def escapejs ( value ) :pass
return mark_safe ( force_text ( value ) . translate ( _js_escapes ) )
escapejs = allow_lazy ( escapejs , six . text_type )
def conditional_escape ( text ) :pass
if hasattr ( text , '_STR:0_' ) :pass
return text . __html__ ( )
if True: pass _newline_ else :pass
return escape ( text )
def format_html ( format_string , * args , ** kwargs ) :pass
args_safe = map ( conditional_escape , args )
kwargs_safe = dict ( ( k , conditional_escape ( v ) ) for ( k , v ) in six . iteritems ( kwargs ) )
return mark_safe ( format_string . format ( * args_safe , ** kwargs_safe ) )
def format_html_join ( sep , format_string , args_generator ) :pass
return mark_safe ( conditional_escape ( sep ) . join (  format_html ( format_string , * tuple ( args ) )  for args in args_generator ) )
def linebreaks ( value , autoescape = False ) :pass
value = normalize_newlines ( value )
paras = re . split ( '_STR:0_' , value )
if autoescape :pass
paras = [ '<p>%s</p>' % escape ( p ) . replace ( '_STR:0_' , '_STR:1_' ) for p in paras ]
if True: pass _newline_ else :pass
paras = [ '<p>%s</p>' % p . replace ( '_STR:0_' , '_STR:1_' ) for p in paras ]
return '_STR:1_' . join ( paras )
linebreaks = allow_lazy ( linebreaks , six . text_type )
class MLStripper ( HTMLParser ) :pass
def __init__ ( self ) :pass
if sys . version_info [ : 2 ] == ( 3 , 2 ) :pass
HTMLParser . __init__ ( self , strict = False )
if True: pass _newline_ else :pass
HTMLParser . __init__ ( self )
self . reset ( )
self . fed = [ ]
def handle_data ( self , d ) :pass
self . fed . append ( d )
def handle_entityref ( self , name ) :pass
self . fed . append ( '_STR:0_' % name )
def handle_charref ( self , name ) :pass
self . fed . append ( '_STR:0_' % name )
def get_data ( self ) :pass
return '' . join ( self . fed )
def _strip_once ( value ) :pass
s = MLStripper ( )
try :pass _newline_ except: pass
s . feed ( value )
try: pass _newline_ except HTMLParseError :pass
return value
try :pass _newline_ except: pass
s . close ( )
try: pass _newline_ except ( HTMLParseError , UnboundLocalError ) :pass
return s . get_data ( ) + s . rawdata
if True: pass _newline_ else :pass
return s . get_data ( )
