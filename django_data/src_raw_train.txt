from threading import local into default name space .
import module warnings .
from django.conf [ django . conf ] import settings into default name space .
from django.core [ django . core ] import signals into default name space .
from django.core.cache.backends.base [ django . core . cache . backends . base ] import InvalidCacheBackendError , CacheKeyWarning and BaseCache into default name space .
from django.core.exceptions [ django . core . exceptions ] import ImproperlyConfigured into default name space .
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
from django.utils.module_loading [ django . utils . module_loading ] import import_string into default name space .
__all__ is an list containing 6 elements : _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ ,
_STR:0_ and _STR:1_ DEFAULT_CACHE_ALIAS is a string _STR:2_ .
if DEFAULT_CACHE_ALIAS is not contained in settings.CACHES [ settings . CACHES ] ,
raise an exception ImproperlyConfigured with string _STR:0_ as argument , with ' % s ' replaced with DEFAULT_CACHE_ALIAS converted into a string .
define the function get_cache with backend and dictionary pair of elements kwargs as arguments .
call the function warnings.warn [ warnings . warn ] with string _STR:0_ , RemovedInDjango19Warning ,
and stacklevel set to 2 as arguments . call the _create_cache with backend and dictionary kwargs as arguments , substitute the result for cache .
call the function signals.request_finished.connect [ signals . request_finished . connect ] with argument cache.close [ cache . close ] .
return cache .
define the function _create_cache with backend and dictionary pair of elements kwargs as arguments .
try ,
try ,
substitute value under the backend key of settings.CACHES [ settings . CACHES ] dictionary for conf .
if KeyError exception is caught ,
try ,
call the function import_string with argument backend .
if ImportError , renamed to e , exception is caught ,
raise and exception InvalidCacheBackendError with string _STR:0_ as argument , replace ' % s ' with backend and e , respectively .
remove _STR:0_ key from kwargs dictionary and put it into location , or use an empty string if key doesnt exists .
substitute kwargs for params .
if not ,
call the function conf.copy [ conf . copy ] , substitute it for params .
call the function params.update [ params . update ] with argument kwargs .
remove _STR:0_ key from params dictionary and put it into backend .
remove _STR:0_ key from kwargs dictionary and put it into location , or use an empty string if key doesnt exists .
call the import_string with argument backend , substitute it for backend_cls .
if ImportError , renamed to e , is caught ,
aise and exception InvalidCacheBackendError with string _STR:0_ as argument , replace ' % s ' with backend and e , respectively .
evaluate the function backend_cls with location and params as arguments , return the result .
derive the class CacheHandler from the object base class .
define the __init__ method with argument self .
call the function local , substitute the result for self._caches [ self . _caches ] .
define the __getitem__ method with self and alias arguments .
try ,
return value under the alias key of self._caches.caches [ self . _caches . caches ] dictionary .
except if AttributeError is caught ,
self._caches.caches [ self . _caches . caches ] is an empty dictionary .
except if KeyError exception is caught ,
do nothing .
if alias is not contained in setting.CACHES [ setting . CACHES ] ,
raise and exception InvalidCacheBackendError with string _STR:0_ as argument , replace ' % s ' with alias .
call the function _create_cache with argument alias .
substitute cache for value under the alias key of self._caches.caches [ self . _caches . caches ] dictionary .
reuturn cache .
define the method all with argument self .
get attribute _STR:0_ from the self._caches [ self . _caches ] if exists , otherwise get an empty dictionary , call the values method on the return value , return it .
call the CacheHandler function , substitute the result for caches .
derive the class DefaultCacheProxy from the base class object .
define the method __getattr__ with self and name as arguments .
get attribute name from value under the DEFAULT_CACHE_ALIAS key of caches dictionary , return it .
define the method __setattr__ with self , name and value as arguments .
set the attribute name from value under the DEFAULT_CACHE_ALIAS key of caches dictionary to value , return it .
define the method __delattr__ with self and name as arguments .
delete the attribute name from the cache dictionary under the DEFAULT_CACHE_ALIAS key .
define the method __contains__ with self and key as arguments .
if key if contained in value under the DEFAULT_CACHE_ALIAS key of caches dictionary , return boolean True , otherwise return False .
define the method __eq__ with self and other as arguments .
if value under the DEFAULT_CACHE_ALIAS key of caches dictionary equals to other , return boolean True , otherwise return False .
define the method __ne__ with self and other as arguments .
if value under the DEFAULT_CACHE_ALIAS key of caches dictionary is not equal to other , return boolean True , otherwise return False .
call the DefaultCacheProxy function , substitute it for cache .
define the function close_caches with dictionary pair of elements kwargs as argument .
for every cache in return value of the function caches.all [ caches . all ] .
call the function cache.close [ cache . close ] .
call the function signals.request_finished.connect [ signals . request_finished . connect ] with argument close_caches .
from __future__ import unicode_literals into default name space .
import module time .
import module warnings .
from django.core.exceptions [ django . core . exceptions ] import ImproperlyConfigured and DjangoRuntimeWarning into default name space .
from django.utils.module_loading [ django . utils . module_loading ] import import_string into default name space .
derive class InvalidCacheBackendError from the ImproperlyConfigured base class .
do nothing .
derive class CacheKeyWarning from the DjangoRuntimeWarning base class .
do nothing .
DEFAULT_TIMEOUT is a instance of the class object .
MEMCACHE_MAX_KEY_LENGTH is integer 250 .
define the function default_key_func with 3 arguments , key , key_prefix and version .
convert key_prefix , version and key into strings , concatenate them respectively , with character _STR:0_ as delimiter , return the result .
define the function get_key_func with argument key_func .
if key_func is not of None type ,
if key_function is callable object ,
return key_func .
if not ,
evaluate the function import_string with key_func as argument , return the result .
return default_key_func .
derive the class BaseCache from the object base class .
define the initialization function __init__ with self class instance and params as arguments .
call the params.get [ params . get ] method with string _STR:0_ and integer 300 as arguments , use the string _STR:1_ and previous result as the arguments for the call to the params.get [ params . get ] method , substitute the result for timeout .
if timeout is not None ,
try ,
convert timeout into an integer .
if ValueError or TypeError exceptions occurred ,
timeout is integer 300 .
substitute timeout for self.default_timeout [ self . default_timeout ] .
call the params.get [ params . get ] with string _STR:0_ and empty dictionary as arguments , substitute the result for options .
call the options.get [ options . get ] method with string _STR:0_ and integer 300 as arguments , use the string _STR:1_ and previous result as the arguments for the call to the params.get [ params . get ] method , substitute the result for max_entries .
try ,
convert max_entries into a string , substitute it for self._max_entries [ self . _max_entries ] .
if ValueError or TypeError exceptions occurred ,
self._max_entries [ self . _max_entries ] is integer 300 .
call the options.get [ options . get ] method with string _STR:0_ and integer 3 as arguments , use the string _STR:1_ and previous result as the arguments for the call to the params.get [ params . get ] method , substitute the result for cull_frequency .
try ,
convert cull_frequency into an integer and substitute it for self._cull_frequency [ self . _cull_frequency ] .
if ValueError or TypeError exceptions occurred ,
self._cull_frequency [ self . _cull_frequency ] is integer 3 .
call the params.get [ params . get ] method with string _STR:0_ and an empty string as arguments , substitute the result for self._key_prefix [ self . _key_prefix ] .
call the params.get [ params . get ] method wit string _STR:0_ and integer 1 as arguments , substitute the result for self.version [ self . version ] .
call the method params.get [ params . get ] with 2 arguments , string _STR:0_ and None , use the result as the argument for the call to the function get_key_func , substitute the result for the self.key_func [ self . key_func ] .
define the method get_backend_timeout with self class instance and timeout set to DEFAULT_TIMEOUT as arguments ,
if timeout equals to DEFAULT_TIMEOUT ,
substitute self.default_timeout [ self . default_timeout ] for timeout .
else if timeout equals to integer 0 ,
timeout is a integer -1 .
if timeouts is None return None , otherwise return the sum of function time.time [ time . time ] return value and timeout .
define the function make_key with self class instance , key and version set to None as arguments .
if version is None ,
substitute self.version [ self . version ] for version .
call the method self.key_function [ self . key_function ] with key , self.key_prefix [ self . key_prefix ] and version as arguments , substitute the result for new_key .
return new_key .
define the method add with 5 arguments , self , key , value , timeout defaulting to DEFAULT_TIMEOUT and version defaulting to None .
docsring
raise an exception of class NotImplementedError with string _STR:0_ as argument .
define the method get with 4 arguments , self , key , default set to None and version set to None .
raise an exception of class NotImplementedError , with string _STR:0_ as argument .
define the method set with 5 arguments , self , key , value , timeout set to DEFAULT_TIMEOUT and version set to None .
raise an exception of class NotImplementedError , with string _STR:0_ as argument .
define delete method with self class instance , key and version set to None , as arguments .
raise an exception of class NotImplementedError , with string _STR:0_ as argument .
define the get_many method with self class instance , keys and version set to None as arguments .
d is an empty dictionary .
for every k in keys ,
call the self.get [ self . get ] method with k and version set to version as arguments , substitute the result for val .
if val is not None ,
substitute val for value under the k key of dictionary d .
return d .
define method has_key with self class instance , key and version set to None as arguments .
call the self.get [ self . get ] method with key and version set to version as arguments , return it if it is not None .
define the method incr with 4 arguments , self class instance , key , delta defaulting to integer 1 and version defaulting to None .
call the method self.get [ self . get ] with key and version set to version as arguments , substitute the result for value .
if value is None ,
raise an exception of class ValueError , with string _STR:0_ as argument , where ' % s ' is substituted for key .
add value and delta together , substitute the result for new_value .
call the self.set [ self . set ] method with key , new_value and version set to version as arguments .
return new_value .
define the method decr with arguments self , key , delta defaulting to integer 1 and version defaulting to None .
call the self.incr [ self . incr ] method with key , negative delta and version set to version as arguments .
define the private method __contains__ with self class instance and key as arguments .
evaluate the self.has_key [ self . has_key ] method with key as argument , return the result .
define the method set_many with arguments , self , data , timeout defaulting to DEFAULT_TIMEOUT and version set to None .
for every key and value in data.items [ data . items ] method return value ,
call the method self.set [ self . set ] with arguments key , value , timeout set to timeout , version set to version .
define the method delete_many with arguments self , keys and version defaulting to None .
for every key in keys ,
call the delete method with key and version set to version as arguments .
define the method clear with self class instance as the argument ,
raise an exception NotImplementedError with string _STR:0_ as argument .
define the method validate_key with self class instance and key as arguments .
if length of key is greater than MEMCACHE_MAX_KEY_LENGTH ,
substitute ' % s ' in string _STR:0_ with key ,
and MEMCACHE_MAX_KEY_LENGTH , call the function warnings.warn [ warnings . warn ] with previous string and CacheKeyWarning as arguments . for every char in key ,
if ascii value of char is smaller than integer 33 or is equal to integer 127 ,
substitute _STR:0_ in string _STR:1_ with key ,
call the function warnings.warn [ warnings . warn ] with previous string and CacheKeyWarning as arguments . define the method incr_version with 4 arguments , self , key , delta defaulting to integer 1 and version defaulting to None .
if version is None ,
substitute self.version [ self . version ] for version .
call the self.get [ self . get ] method with arguments key and version set to version , substitute the result for value .
if value is None ,
raise an exception of the class ValueError with string _STR:0_ as argument , ' % s ' is substituted for key .
call the method self.set [ self . set ] with key , value , version incremented by delta , as arguments .
call the self.delete [ self . delete ] method with key and version set to version as arguments .
sum version and delta together , return the result .
define the method decr_version with 4 arguments , self , key , delta defaulting to integer 1 and version defaulting to None .
call the method self.incr_version [ self . incr_version ] with key , negative delta and version as arguments .
define the close method with 2 arguments , self and dictionary of argument pairs kwargs .
docstirng
do nothing .
import module base64 .
from datetime import datetime into default name space .
try ,
from django.utils.six.moves [ django . utils . six . moves ] import cPickle as pickle , into default namespace .
if ImportError exception occurred ,
import pickle .
from django.conf [ django . conf ] import settings into default name space .
from django.core.cache.backends.base [ django . core . cache . backends . base ] import BaseCache and DEFAULT_TIMEOUT into default name space .
from django.db [ django . db ] import connections , transaction , router and DatabaseError into default name space .
from django.db.backends.utils [ django . db . backends . utils ] import typecast_timestamp into default name space .
from django.utils [ django . utils ] import timezone and six into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_bytes into default name space .
derive class Options from the base class object .
define the initialization method __init__ with self class instance and table as arguments .
substitute table for self.db_table [ self . db_table ] .
self.app_label [ self . app_label ] is a string _STR:0_ .
self.model_name [ self . model_name ] is a string _STR:0_ .
self.verbose_name [ self . verbose_name ] is a string _STR:0_ .
self.verbose_name_plural [ self . verbose_name_plural ] is a string _STR:0_ .
self.object_name [ self . object_name ] is a string _STR:0_ .
self.abstract [ self . abstract ] is boolean False .
self.managed [ self . managed ] is boolean True .
self.proxy [ self . proxy ] is boolean False .
derive class BaseDatabaseCache from BaseCache base class .
define the initialization method __init__ with self , table and params as arguments .
call the BaseCache.__init__ [ BaseCache . __init__ ] method with self class instance and params as the arguments .
substitute table for self._table [ self . _table ] .
derive CacheEntry class from the object base class .
_meta is class Options class instance initialized with table argument .
substitute CacheEntry for self.cache_model_class [ self . cache_model_class ] .
derive DatabaseCache from the BaseDatabaseCache base class .
define the method get with 4 arguments , self class instance , key , default set to None and version set to None .
call the method self.make_key [ self . make_key ] Whit key and version set to version as arguments , substitute the result for key .
call the method self.validate_key [ self . validate_key ] with argument key .
call the method router.db_for_read [ router . db_for_read ] with self.cache_model_class [ self . cache_model_class ] as argument , substitute the result for db .
call the ops.quote_name [ ops . quote_name ] method with argument self._table [ self . _table ] on the value under the db key of connections dictionary , substitute the result for table .
call the cursor method on the value under the db key of connections dictionary , preform following with return value named cursor ,
call the method cursor.execute [ cursor . execute ] with string _STR:0_ as argument ,
substitute the ' % s ' with table and list containing key , respectively . call the cursor.fetchone [ cursor . fetchone ] method , substitute the result for row .
if row is None ,
return default .
call the timezone.now [ timezone . now ] function , substitute the result for now .
substitute third element of row list for expires .
if features.needs_datetime_string_cast [ features . needs_datetime_string_cast ] field of the object represented stored under the db key of connections dictionary is true ,
and expires is not an instance of datetime . convert expires to a string , use it as argument for the call to the function typecast_timestamp , substitute the result for expires .
if expires is lesser than now ,
call the method router.db_for_write [ router . db_for_write ] with argument self.cache_model_class [ self . cache_model_class ] , substitute the result for db .
call the cursor method on the value under the db key of connections dictionary , preform following with return value named cursor ,
call the method cursor.execute [ cursor . execute ] with string _STR:0_ as argument ,
substitute the ' % s ' with table and list containing key , respectively . return default .
call the method ops.process_clob [ ops . process_clob ] with second element of row as argument , on the object under the db key of connections dictionary , substitute the result for value .
call the function force_bytes with argument value , use the result as an argument for the call to the method base64.b64decode [ base64 . b64decode ] ,
use the result as the argument for the function call to the pickle.loads [ pickle . loads ] , return the result . define the method set with 5 arguments , self class instance , key , value , timeout set to DEFAULT_TIMEOUT and version set to None .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute the result for key .
call the method self.validate_key [ self . validate_key ] with key as argument .
call the method self._base_set [ self . _base_set ] with string _STR:0_ , key , value and timeout as arguments .
define the method add with 5 arguments , self class instance , key , value , timeout set to DEFAULT_TIMEOUT and version set to None .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute the result for key .
call the method self.validate_key [ self . validate_key ] with key as argument .
call the method self._base_set [ self . _base_set ] with string _STR:0_ , key , value and timeout as arguments , return the result .
define the protected method _base_set with 4 arguments , self class instance , key , value and timeout set to DEFAULT_TIMEOUT .
call the method self.get_backend_timeout [ self . get_backend_timeout ] with argument timeout , substitute the result for timeout .
call the method router.db_for_write [ router . db_for_write ] with argument self.cache_model_class [ self . cache_model_class ] , substitute the result for db .
call the ops.quote_name [ ops . quote_name ] method with argument self._table [ self . _table ] on the object under the db key of connections dictionary , substitute the result for table .
call the cursor method on the value under the db key of connections dictionary , preform following with return value named cursor ,
call the method cursor.execute [ cursor . execute ] with string _STR:0_ as argument , substitute the ' % s ' with table .
fetch one record from the database cursor points at , substitute the first element of return value for num .
call the timezone.now [ timezone . now ] function , substitute the result for now .
call the function now.replace [ now . replace ] with microseconds set to integer 0 , substitute the result for now .
if timeout is None ,
substitute the datetime.max [ datetime . max ] for exp .
otherwise is settings.USE_TI [ settings . USE_TI ] is true ,
call the function datetime.utcfromtimestamp [ datetime . utcfromtimestamp ] with argument timeout , substitute it for exp .
if not ,
call the function datetime.fromtimestamp [ datetime . fromtimestamp ] with argument timeout , substitute it for exp .
call the exp.replace [ exp . replace ] with microsecond set to integer 0 , substitute the result for exp .
if num is greater than self._max_entries [ self . _max_entries ] ,
call the method self._cull [ self . _cull ] with db , cursor and now as arguments .
call the method pickle.dumps [ pickle . dumps ] with value and pickle.HIGHEST_PROTOCOL [ pickle . HIGHEST_PROTOCOL ] as arguments , substitute it for pickled .
call the method base64.b64encode [ base64 . b64encode ] with argument pickled , substitute the result for b64encoded .
if six.PY3 [ six . PY3 ] is true ,
call the method b64encoded.decode [ b64encoded . decode ] with string _STR:0_ as argument , substitute the result for b64encoded .
try ,
with return value of the function transaction.atomic [ transaction . atomic ] with using set to db as arguments , perform the following ,
call the method cursor.execute [ cursor . execute ] with string _STR:0_ as argument ,
substitute the ' % s ' with table and list containing key , respectively . fetch one entry from the database that cursor points at , substitute it for the result .
if result is true ,
substitute the second element of result for current_expires .
if features.needs_datetime_string_cast [ features . needs_datetime_string_cast ] field of object under the db key of connections dictionary is true and current_expires is not an instance of datetime object .
convert current_expires to a string , use it as the argument for the call to the function typecast_timestamp , substitute the result for current_expires .
on the object under the db key of connections dictionary call the method ops.value_to_db_datetime [ ops . value_to_db_datetime ] with argument exp , substitute the result for the exp .
if mode equals to string _STR:0_ and current_expires is lesser than now , or mode equals to string _STR:1_ , and result is true ,
call the method cursor.execute [ cursor . execute ] with string _STR:0_ as argument ,
substitute the ' % s ' with table and 3 elements of a list : b64encoded , exp and key , respectively . if not ,
call the method cursor.execute [ cursor . execute ] with string _STR:0_ ,
substitute the ' % s ' with table and 3 elements of a list : b64encoded , exp and key , respectively . if DatabaseError exception is caught ,
return boolean False .
if not ,
return boolean True .
define the method delete with self class instance , key and version set to None as arguments .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute the result for key .
call the method self.validate_key [ self . validate_key ] with argument key .
call the method router.db_for_write [ router . db_for_write ] with argument self.cache_model_class [ self . cache_model_class ] , substitute the result for db .
call the ops.quote_name [ ops . quote_name ] method with argument self._table [ self . _table ] on the object under the db key of connections dictionary , substitute the result for table .
call the cursor method on the value under the db key of connections dictionary , preform following with return value named cursor ,
call the method cursor.execute [ cursor . execute ] with string _STR:0_ as argument ,
substitute the ' % s ' with table and list containing key , respectively . define the method has_key with self class instance , key and version defaulting to None as arguments .
call the self.make_key [ self . make_key ] with key and version set to version as arguments , substitute the result for key .
call the self.validate_key [ self . validate_key ] method with argument key .
call the method router.db_for_write [ router . db_for_write ] with argument self.cache_model_class [ self . cache_model_class ] , substitute the result for db .
call the ops.quote_name [ ops . quote_name ] method with argument self._table [ self . _table ] on the object under the db key of connections dictionary , substitute the result for table .
if settings.USE_TZ [ settings . USE_TZ ] is true ,
call the function datetime.utcnow [ datetime . utcnow ] , substitute the result for now .
if not ,
call the function datetime.now [ datetime . now ] , substitute the result to now .
call the method now.replace [ now . replace ] with the argument microsecond set to integer 0 , substitute the result for now .
call the cursor method on the value under the db key of connections dictionary , preform following with return value named cursor ,
call the method cursor.execute [ cursor . execute ] with string _STR:0_ as argument ,
substitute the ' % s ' with table and list containing return value of the method call ops.value_to_db_datetime [ ops . value_to_db_datetime ] with argument now on the object under the db key of connections dictionary , respectively . if exists return next entry from the database that cursor points at .
define the protected method _cull with self class instance , db , cursor and now as arguments .
if self._cull_frequency [ self . _cull_frequency ] equals to integer 0 .
call the self.clear [ self . clear ] method .
if not ,
call the method now.replace [ now . replace ] with argument tzinfo set to None , substitute it for now .
call the ops.quote_name [ ops . quote_name ] method with argument self._table [ self . _table ] on the object under the db key of connections dictionary , substitute the result for table .
call the method cursor.execute [ cursor . execute ] with string _STR:0_ as argument ,
substitute the ' % s ' with table and list containing return value of the method call ops.value_to_db_datetime [ ops . value_to_db_datetime ] with argument now on the object under the db key of connections dictionary , respectively . call the method cursor.execute [ cursor . execute ] with string _STR:0_ as argument , substitute the ' % s ' with table .
fetch next entry for the database that cursor points into , substitute first element of it for num .
if num is greater than self._max_entries [ self . _max_entries ] ,
divide num by self._cull_frequency [ self . _cull_frequency ] , floor the result and substitute it for cull_num .
evaluate the method connections [ db ] .ops.cache_key_culling_sql , evaluate the result by table modulus , call the method cursor.execute [ cursor . execute ] ,
with previous result and list containing cull_num , respectively as arguments . call the method cursor.execute [ cursor . execute ] with string _STR:0_ as argument ,
substitute the ' % s ' with table and list containing first element of cursor.fetchone [ cursor . fetchone ] method , respectively . define the method clear with argument self .
call the method router.db_for_write [ router . db_for_write ] with argument self.cache_model_class [ self . cache_model_class ] , substitute the result for db .
call the ops.quote_name [ ops . quote_name ] method with argument self._table [ self . _table ] on the object under the db key of connections dictionary , substitute the result for table .
call the cursor method on the value under the db key of connections dictionary , preform following with return value named cursor ,
call the method cursor.execute [ cursor . execute ] with string _STR:0_ as argument , substitute the ' % s ' with table .
derive the class CacheClass from the DatabaseCache base class .
do nothing .
from django.core.cache.backends.base [ django . core . cache . backends . base ] import BaseCache and DEFAULT_TIMEOUT into default name space .
derive the class DummyCache from the base class BaseCache .
define initialization method __init__ with 4 arguments : self , host , list of arguments args and dictionary of arguments kwargs .
call the BaseCache initialization method __init__ with 3 arguments self , list of arguments args and dictionary of arguments kwargs .
define the method add with 5 arguments : self , key , value , timeout set to DEFAULT_TIMEOUT and version set to None .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute it for key .
call the method self.validate_key [ self . validate_key ] with argument key .
return boolean True .
define the method get with 4 arguments : self , key , default set to None and version set to None .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute it for key .
call the method self.validate_key [ self . validate_key ] with argument key .
return default .
define the method set with 5 arguments : self , key , value , timeout set to DEFAULT_TIMEOUT and version set to None .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute it for key .
call the method self.validate_key [ self . validate_key ] with argument key .
define the method delete with 3 arguments : self , key , and version set to None .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute it for key .
call the method self.validate_key [ self . validate_key ] with argument key .
define the method get_many with 3 arguments : self , keys , and version set to None .
return an empty dictionary .
define the method has_key with 3 arguments : self , key , and version set to None .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute it for key .
call the method self.validate_key [ self . validate_key ] with argument key .
return boolean False .
define the method set_many with 4 arguments : self , data , timeout set to DEFAULT_TIMEOUT and version set to None .
do nothing
define the method delete_many with 3 arguments : self , keys , and version set to None .
do nothing .
define the method clear with argument self .
do nothing .
derive the class CacheClass from the DummyCache base class .
do nothing .
import module errno .
import module glob .
import module hashlib .
import module io .
import module os .
import module random .
import module tempfile .
import module time .
import module zlib .
from django.core.cache.backends.base [ django . core . cache . backends . base ] import BaseCache and DEFAULT_TIMEOUT into default name space .
from django.core.files.move [ django . core . files . move ] import file_move_safe into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_bytes into default name space .
try ,
from django.utils.six.moves [ django . utils . six . moves ] import cPickle as pickle into default name space .
if ImportError exception is caught ,
import pickle .
derive the class FileBasedCache from BaseCache base class .
cache_suffix is a string _STR:0_ .
define the initialization method __init__ with arguments : self class instance , dir and params .
call method __init__ with argument params from the base class of the FileBaseCache .
get absolute directory path of dir , substitute it for self._dir [ self . _dir ] .
call the self._createdir [ self . _createdir ] method .
define the method add with 5 arguments , self class instance , key , value , timeout set to DEFAULT_TIMEOUT and version set to None .
evaluate method self.has_key [ self . has_key ] with key and version as arguments , if the result is true ,
return boolean False .
call the method self.set [ self . set ] with key , value , timeout and version as arguments .
return boolean True .
define the method get with 5 arguments , self class instance , key , default set to None and version set to None .
call the function self._key_to_file [ self . _key_to_file ] with key and version as arguments , substitute it for fname .
if fname file path exists ,
try ,
with return value of the function io.open [ io . open ] with fname and string _STR:0_ as arguments , named as f ,
evaluate self._is_expired [ self . _is_expired ] method with f as argument , if the result is false ,
call f.read [ f . read ] function , use the result as the argument for zlib.decompress [ zlib . decompress ] function call , call the pickle.loads [ pickle . loads ] function with the previous result as argument , return the result .
if IOError , renamed to e , exception is caught ,
if e.errno [ e . errno ] equals to errno.ENOENT [ errno . ENOENT ] ,
do nothing .
return default .
define the method set with 5 arguments , self class instance , key , value , timeout set to DEFAULT_TIMEOUT and version set to None .
call the self._createdir [ self . _createdir ] method .
call the function self._key_to_file [ self . _key_to_file ] with key and version as arguments , substitute it for fname .
call the method self._cull [ self . _cull ] .
call the method tempfile.mkstemp [ tempfile . mkstemp ] with dir set to self._dir [ self . _dir ] , substitute result for fd and tmp_path , respectively .
renamed is boolean False .
try ,
with return value of the function io.open [ io . open ] with fname and string _STR:0_ as arguments , named as f ,
call the method self.get_backend_timeout [ self . get_backend_timeout ] with argument timeout , substitute it for expiry .
call the function pickle.dumps [ pickle . dumps ] with expiry and integer -1 as arguments , use the result as the argument for the call to f.write [ f . write ] function .
call the function pickle.dumps [ pickle . dumps ] with argument value , use the result and integer -1 as arguments for the call to the function zlib.compress [ zlib . compress ] , use the result as an argument for the call to the f.write [ f . write ] method .
call the function file_move_safe with tmp_path , fname , allow_overwrite set to boolean True as arguments .
renamed is boolean True .
finally perform ,
if renamed is boolean False ,
remove file tmp_path .
define the method delete with self class instance , key and version defaulting to None as arguments .
call the function self._key_to_file [ self . _key_to_file ] with key and version as arguments , use the result as an argument for the call to the self._delete [ self . _delete ] method .
define the method _delete with self and fname as arguments .
if fname doesnt start with self._dir [ self . _dir ] and fname file path doesnt exists ,
return nothing .
try ,
call the function os.remove [ os . remove ] with argument fname .
if exception OSError , renamed to e , is caught ,
if e.errno [ e . errno ] does not equals to errno.ENOENT [ errno . ENOENT ] ,
raise an exception .
define the method has_key with self class instance , key and version defaulting to None as arguments .
call the function self._key_to_file [ self . _key_to_file ] with key and version as arguments , substitute it for fname .
if fname file path exists ,
with call to the io.open [ io . open ] function with fname and string _STR:0_ as arguments , renamed to f ,
call the method self._is_expired [ self . _is_expired ] with argument f , invert the boolean result and return it .
return boolean False .
define the method _cull with argument self .
call the self._list_cache_files [ self . _list_cache_files ] method , substitute the result for filelist .
num_entries is length of filelist .
if num_entries is lesser than self._max_entries [ self . _max_entries ] ,
return nothing .
if self._cull_frequency [ self . _cull_frequency ] equals to integer 0 .
evaluate self.clear [ self . clear ] method and return the result .
divide num_entries by self._cull_frequency [ self . _cull_frequency ] , convert the result to an integer , call the random.sample [ random . sample ] function with filelist and previous result as arguments , substitute the result for filelist .
for every fname in filelist ,
call self._delete [ self . _delete ] method with argument fname .
define the method _createdir with argument self .
if self._dir [ self . _dir ] path doesnt exists ,
try ,
call os.makedirs [ os . makedirs ] function with self._dir [ self . _dir ] and hexadecimal 0o700 as arguments .
if OSError , renamed to e , exception is caught ,
if e.errno [ e . errno ] is not equal to errno.EEXIST [ errno . EEXIST ] ,
raise an EnvironmentError exception with string _STR:0_ as argument ,
substitute ' % s ' with self._dir [ self . _dir ] converted to a string . define the method key_to_file with self class instance , key and version defaulting to None as arguments .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute the result for key .
call the method self.validate_key [ self . validate_key ] with argument key .
join into a string : md5 hash sum of force_bytes ( key ) and self.cache_suffix [ self . cache_suffix ] , compose root file path out of self._dir [ self . _dir ] and previous result , return it .
define the method clear with argument self .
if self._dir [ self . _dir ] file path does not exists ,
return nothing .
if fname is contained in self._list_cache_files [ self . _list_cache_files ] method return value ,
call the self._delete [ self . _delete ] method with argument fname .
define the method _is_expired with self and f as arguments .
call the function pickle.load [ pickle . load ] with argument f , substitute the result for exp .
if exp is not None and exp is lesser than return value of the function time.time [ time . time ] ,
call close method on a file stream .
call the self._delete [ self . _delete ] method with argument f.name [ f . name ] .
return boolean True .
return boolean False .
define the method _list_cache_files with argument self .
if self._dir [ self . _dir ] file path does not exists ,
return an empty list .
for every fname in return value of the glob.glob1 [ glob . glob1 ] function called with 2 arguments : self._dir [ self . _dir ] and ,
self.cache_suffix [ self . cache_suffix ] converted to a string , appended to the character _STR:0_ , call os.path.join [ os . path . join ] with self._dir [ self . _dir ] and fname as arguments , filelist is a list containing all the previous results . return filelist .
derive the class CacheClass from the base class FileBasedCache .
do nothing .
import module time .
try ,
from django.utils.six.moves [ django . utils . six . moves ] import cPickle as pickle into default name space .
if ImportError exception is caught ,
import pickle .
from django.core.cache.backends.base [ django . core . cache . backends . base ] import BaseCache and DEFAULT_TIMEOUT into default name space .
from django.utils.synch [ django . utils . synch ] import RWLock into default name space .
__caches is an empty dictionary .
__expire_info is an empty dictionary .
__locks is an empty dictionary .
derive the class LocMemCache from the base class BaseCache .
define the initialization method __init__ with 3 arguments : self , name and params .
call the __init__ method with self and params arguments from the base class BaseCache .
call the _caches.setdefault [ _caches . setdefault ] method with name and empty dictionary as arguments , substitute the result for self_cache .
call the _expire_info.setdefault [ _expire_info . setdefault ] method with name and empty dictionary as arguments , substitute the result for self_expire_info .
call the _lock.setdefault [ _lock . setdefault ] method with name and RWLock ( ) as arguments , substitute the result for self_lock .
define the method add with 5 arguments , self class instance , key , value , timeout set to DEFAULT_TIMEOUT and version set to None .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute the result for key .
call the method self.validate_key [ self . validate_key ] with argument key .
call the pickle.dumps [ pickle . dumps ] function with value and pickle.HIGHEST_PROTOCOL [ pickle . HIGHEST_PROTOCOL ] as arguments .
call the self._lock.writer [ self . _lock . writer ] method , with the result perform the following ,
evaluate self._has_expired [ self . _has_expired ] with argument key , if the result is True ,
call the method self._set [ self . _set ] with key , pickled and timeout as arguments .
return boolean True .
return boolean False .
define the method get with 4 arguments , self class instance , key , default set to None and version set to None .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute the result for key .
call the method self.validate_key [ self . validate_key ] with argument key .
substitute None for pickled .
call the self._lock.reader [ self . _lock . reader ] method , with the result perform the following ,
evaluate the method self._has_expired [ self . _has_expired ] with argument key , if it as False ,
substitute value under the key key of self._cache [ self . _cache ] dictionary for pickled .
if pickled is not None .
try ,
evaluate pickle.loads [ pickle . loads ] with argument pickled , return the result .
if pickle.PickleError [ pickle . PickleError ] exception is caught ,
return default .
call the self._lock.writer [ self . _lock . writer ] method , with the result perform the following ,
try ,
delete the value under key key of self._cache [ self . _cache ] dictionary .
delete the value under key key of self._expire_info [ self . _expire_info ] .
if KeyError exception is caught ,
do nothing .
return default .
define the method _set with 4 arguments , self class instance , key , value and timeout set to DEFAULT_TIMEOUT .
if length of self._cache [ self . _cache ] is greater or equal to self._max_entries [ self . _max_entries ] ,
call the self._cull [ self . _cull ] method .
substitute value for the value under the key key of self._cache [ self . _cache ] dictionary .
call the self.get_backend_timeout [ self . get_backend_timeout ] with argument timeout , substitute it for the value under the key key of self._expire_info [ self . _expire_info ] dictionary .
define the method get with 5 arguments , self class instance , key , value , timeout set to DEFAULT_TIMEOUT and version set to None .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute the result for key .
call the method self.validate_key [ self . validate_key ] with argument key .
call the function pickle.dumps [ pickle . dumps ] with value and pickle.HIGHEST_PROTOCOL [ pickle . HIGHEST_PROTOCOL ] as the arguments , substitute the result for pickled .
call the self._lock.writer [ self . _lock . writer ] method , with the result perform the following ,
call the method self._set [ self . _set ] with key , pickled and timeout as arguments .
define the method incr with self class instance , key , delta set to integer 1 and version set to None , as arguments .
call the self.get [ self . get ] method with key and version set to version as arguments , substitute the result for value .
if value is None ,
raise an ValueError exception with string _STR:0_ as argument , substitute ' % s ' with key converted into a string .
new_value is a sum of value and delta .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute the result for key .
call the function pickle.dumps [ pickle . dumps ] with value and pickle.HIGHEST_PROTOCOL [ pickle . HIGHEST_PROTOCOL ] as the arguments , substitute the result for pickled .
call the self._lock.writer [ self . _lock . writer ] method , with the result perform the following ,
substitute pickled for value under the key key of self._cache [ self . _cache ] dictionary .
return new_value .
define the method has_key with self class instance , key and version defaulting to None as arguments .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute the result for key .
call the method self.validate_key [ self . validate_key ] with argument key .
call the self._lock.reader [ self . _lock . reader ] method , with the result perform the following ,
if call to the _has_expired method with argument key evaluates to boolean False ,
return boolean True .
call the self._lock.writer [ self . _lock . writer ] method , with the result perform the following ,
try ,
delete the value under the key key of self._cache [ self . _cache ] dictionary .
delete the value under the key key of self._expire_info [ self . _expire_info ] dictionary .
if KeyError exception is caught ,
do nothing .
return boolean False .
define the method _has_expired with self and key as arguments .
call the method self._expire_info.get [ self . _expire_info . get ] with key and integer -1 as arguments , substitute the result for exp .
if exp is None or exp is greater than the return value of the call to the function time.time [ time . time ] ,
return boolean False .
return boolean True .
define the method _cull with argument self .
if self._cull_frequency [ self . _cull_frequency ] equals to integer 0 .
call self.clear [ self . clear ] method .
if not ,
for every i and k in enumerated values of self._cache [ self . _cache ] , if i is divisible by self._cull_frequency [ self . _cull_frequency ] , append k to doomed list .
for every k in doomed ,
call the method self._delete [ self . _delete ] with argument k .
define the method _delete with arguments self and key .
try ,
delete the value under the key key of self._cache [ self . _cache ] dictionary .
if KeyError exception is caught ,
do nothing .
try ,
delete the value under the key key of the self._expire_info [ self . _expire_info ] dictionary .
if KeyError exception is caught ,
do nothing .
define the method delete with self class instance , key and version defaulting to None as arguments .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute the result for key .
call the method self.validate_key [ self . validate_key ] with argument key .
call the self._lock.writer [ self . _lock . writer ] method , with the result perform the following ,
call the method self._delete [ self . _delete ] with argument key .
define the method clear with argument self .
call the method self._cache.clear [ self . _cache . clear ] .
call the method self._expire_info.clear [ self . _expire_info . clear ] .
derive the class CacheClass from the base class LocMemCache .
do nothing .
import module time .
import module pickle .
from django.core.cache.backends.base [ django . core . cache . backends . base ] import BaseCache and DEFAULT_TIMEOUT into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.deprecation [ django . utils . deprecation ] import RenameMethodsBase and RemovedInDjango19Warning into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_str into default name space .
from django.utils.functional [ django . utils . functional ] import cached_property into default name space .
derive the class BaseMemcachedCacheMethods from RenameMethodsBase the base class .
renamed methods is a tuple containing 3 elements : _STR:0_ , _STR:1_ and RemovedInDjango19Warning .
derive the class BaseMemcachedCache from base class BaseMemcachedCacheMethods and BaseCache .
define the method __init__ with , self , server , params , library , value_not_found_exception as arguments .
call the initialization method with argument params for the base class of the BaseMemcachedCache class .
if server is an instance of six.string_types [ six . string_types ] ,
split server with _STR:0_ as delimiter , substitute the result for self._servers [ self . _servers ] .
if not ,
substitute server for self._servers [ self . _servers ] .
substitute value_not_found_exception for self.LibraryValueNotFoundException [ self . LibraryValueNotFoundException ] .
substitute library for self._lib [ self . _lib ] .
call the params.get [ params . get ] function with string _STR:0_ and None as arguments , substitute the result for self._options [ self . _options ] .
property decorator ,
define the method _cache with argument self .
if self object has an attribute _STR:0_ ,
call the self._lib.Client [ self . _lib . Client ] with argument self._servers [ self . _servers ] , substitute the result for self._client [ self . _client ] .
return self._client [ self . _client ] .
define the method get_backend_timeout with self and timeout set to DEFAULT_TIMEOUT as arguments .
if timeout equals to DEFAULT_TIMEOUT ,
substitute self.default_timeout [ self . default_timeout ] for timeout .
if timeout is None ,
return integer 0 .
else if timeout converted into an integer equals to integer 0 ,
timeout is a integer -1 .
if timeout is greater than integer 2592000 ,
convert return value of the function time.time [ time . time ] to an integer , increment timeout by it .
convert timeout into an integer , return it .
define the method make_key with self class instance , key and version defaulting to None as arguments .
call the method make_key with arguments key and version from the base class of the class BaseMemcachedCache , use it as an argument for the call to the function force_str , return the result .
define the method add with 5 arguments , self class instance , key , value , timeout set to DEFAULT_TIMEOUT and version set to None .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute the result for key .
call the method self._cache.add [ self . _cache . add ] with key , value , self.get_backend_timeout [ self . get_backend_timeout ] ( timeout ) as arguments .
define the method get with 5 arguments , self class instance , key , default set to None and version set to None .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute the result for key .
call the self._cache.get [ self . _cache . get ] method with argument key , substitute the result for val .
if val is None ,
return default .
return val .
define the method set with 5 arguments , self class instance , key , value , timeout set to DEFAULT_TIMEOUT and version set to None .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute the result for key .
call the method self._cache.set [ self . _cache . set ] with key , value , self.get_backend_timeout [ self . get_backend_timeout ] ( timeout ) as arguments .
define the method delete with self , key and version set to None as arguments .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute the result for key .
call the method self._cache.delete [ self . _cache . delete ] with argument key .
define the method get_many with self class instance , keys and version defaulting to None as arguments .
define the method get_many with 3 arguments , self class instance , keys and version set to None .
call the method self._cache.get_multi [ self . _cache . get_multi ] with argument new_keys , substitute the result for ret .
if ret is true .
_ is an empty dictionary .
zip together new_keys and keys , convert it to dictionary , assign it to m .
for every k and v in return value of the ret.items [ ret . items ] function ,
substitute v for value under the k-th element of m key of _ dictionary .
substitute _ for ret .
return ret .
define the method close with self and dictionary pairs of elements kwargs .
call the method self._cache.disconnect_all [ self . _cache . disconnect_all ] .
define the method incr with self , key , delta defaulting to integer 1 and version defaulting to None as arguments .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute the result for key .
if delta is smaller than integer 0 ,
evaluate the method self._cache.decr [ self . _cache . decr ] with key and negative delta as arguments , return the result .
try ,
call the method self._cache.incr [ self . _cache . incr ] with key and delta as arguments , substitute the result for val .
if self.LibraryValueNotFoundException [ self . LibraryValueNotFoundException ] exception is caught ,
val is None .
if val is None ,
raise an ValueError exception with string _STR:0_ as argument , substitute ' % s ' for key .
return val .
define the method decr with self , key , delta defaulting to integer 1 and version defaulting to None as arguments .
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute the result for key .
if delta is smaller than integer 0 .
evaluate the method self._cache.incr [ self . _cache . incr ] with key and negative delta as arguments , return the result .
try ,
call the method self._cache.decr [ self . _cache . decr ] with key and delta as arguments , substitute the result for val .
if self.LibraryValueNotFoundException [ self . LibraryValueNotFoundException ] exception is caught ,
val is None .
if val is None ,
raise an ValueError exception with string _STR:0_ as argument , substitute ' % s ' for key .
return val .
define the method set_many with self , data , timeout set to DEFAULT_TIMEOUT and version set to None as arguments .
safe_data is an empty dictionary .
for every key and value in data.items [ data . items ] function return value ,
call the method self.make_key [ self . make_key ] with key and version set to version as arguments , substitute the result for key .
substitute value for value under the key key of safe_data dictionary .
call the method self._cache.set_multi [ self . _cache . set_multi ] with safe_data , self.get_backend_timeout [ self . get_backend_timeout ] ( timeout ) as arguments .
define the function delete_many with self , keys and version set to None as arguments .
l is lambda function with argument x , that calls the method self.make_key [ self . make_key ] with x and version set to version as arguments .
call the method self_cache.delete_multi [ self_cache . delete_multi ] with argument list containing keys mapped through function l .
define the method clear with argument self .
call the method self._cache_flush_all [ self . _cache_flush_all ] .
derive the class MemcachedCache from the BaseMemcachedCache base class .
define the method __init__ with argument self , server and params .
import memcache .
call method __init__ from the base class of the class MemcachedCache with arguments : server , params ,
library set to memcache and value_not_found_exception set to ValueError . property decorator ,
define the method _cache with self class instance as an argument .
if attribute _STR:0_ of the self object is None ,
call the method self._lib.Client [ self . _lib . Client ] with self._servers [ self . _servers ] and pickleProtocol set to pickle.HIGHEST_PROTOCOL [ pickle . HIGHEST_PROTOCOL ] as arguments , substitute the result for self._client [ self . _client ] .
return self._client [ self . _client ] .
derive the class PyLibMCCache from BaseMemcachedCache base class .
define the method __init__ with self , server and params as arguments .
import pylibmc .
call method __init__ from the base class of the class PyLibMCCache with arguments : server , params ,
library set to pylibmc and value_not_found_exception set to pylibmc.NotFound [ pylibmc . NotFound ] . decorator cached_property ,
define the method _cache with argument self .
call the method self._lib.Client [ self . _lib . Client ] with argument self._servers [ self . _servers ] .
if self._options [ self . _options ] exists ,
substitute self._options [ self . _options ] for client.behaviors [ client . behaviors ] .
return client .
from __future__ import unicode_literals into default name space .
import module hashlib .
from django.utils.encoding [ django . utils . encoding ] import force_bytes into default name space .
from django.utils.http [ django . utils . http ] import urlquote into default name space .
TEMPLATE_FRAGMENT_KEY_TEMPLATE is a string _STR:0_ .
define the function make_template_fragment_key with fragment_name and vary_on defaulting to None as arguments .
if vary_on is None ,
vary_on is an empty tuple .
call the function urlquote with argument var for every var in vary_on , join the results into a string separated by _STR:0_ , substitute it for key .
call the hashlib.md5 [ hashlib . md5 ] fuction with force_bytes ( key ) as argument .
substitute ' % s ' in TEMPLATE_FRAGMENT_KEY_TEMPLATE string with fragment_name and args.hexdigest [ args . hexdigest ] ( ) , respectively , return the result .
from __future__ import unicode_literals into default name space .
from .messages import CheckMessage , Debug , Info , Warning , Error , Critical , DEBUG , INFO , WARNING , ERROR and CRITICAL into default name space .
from .registry import register , run_checks , tag_exists and Tags into default name space .
import module django.core.checks.compatibility.django_1_6_0 [ django . core . checks . compatibility . django_1_6_0 ] .
import module django.core.checks.compatibility.django_1_7_0 [ django . core . checks . compatibility . django_1_7_0 ] .
import module django.core.checks.model_checks [ django . core . checks . model_checks ] .
__all__ is a list containing next strings , _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ , _STR:5_ ,
from __future__ import unicode_literals into default name space .
from django.apps [ django . apps ] import apps into default name space .
from .. import Warning , register and Tags into default name space .
decorator register with argument Tags.compatibility [ Tags . compatibility ] .
define the function check_1_6_compatibility with argument kwargs dictionary .
errors is an empty list
call the function _check_test_runner with dictionary kwargs as argument , use the result as an argument for the call to the function errors.extend [ errors . extend ] .
call the function _check_boolean_field_default_value with dictionary kwargs as argument , use the result as an argument for the call to the function errors.extend [ errors . extend ] .
return errors .
define the function _check_test_runner with app_config set to None and kwargs dictionary as arguments .
from django.conf [ django . conf ] import settings into default name space .
weight is an integer 0 .
if call to the settings.is_overridden [ settings . is_overridden ] with string _STR:0_ evaluates to boolean False .
try ,
settings.SITE_ID [ settings . SITE_ID ] .
increment weight by integer 2 .
if AttributeError exception is caught ,
do nothing .
try ,
settings.BASE_DIR [ settings . BASE_DIR ] .
if AttributeError exception is caught ,
increment weight by integer 2 .
call the function settings.is_overridden [ settings . is_overridden ] with argument string _STR:0_ , if it evaluates to boolean True ,
increment weight by integer 2 .
call the function settings.is_overridden [ settings . is_overridden ] with argument string _STR:0_ , if it evaluates to boolean True ,
increment weight by integer 2 .
call the function settings.is_overridden [ settings . is_overridden ] with argument string _STR:0_ , if it evaluates to boolean True ,
increment weight by integer 2 .
if string _STR:0_ is not contained in settings.MIDDLEWARE_CLASSES [ settings . MIDDLEWARE_CLASSES ] set ,
increment weight by integer 2 .
if weight is greater or equal to integer 6 ,
call the Warning function with 3 arguments : hint tuple containing one string , Django 1.6 [ 1 . 6 ] introduced a new default test runner .
It looks like this project was generated using Django 1.5 [ 1 . 5 ] or earlier . You should ensure your tests are all running & behaving as expected . See https : //docs.djangoproject.com/en/dev/releases/1.6/ [ //docs . djangoproject . com/en/dev/releases/1 . 6/ ] # new-test-runner for more information . `` , obj set to None and id set to a string _STR:0_ , put the result into a list and return it . if not ,
return an empty list .
define the function _check_boolean_field_default_value with app_config set to None and kwargs dictionary as arguments .
from django.db [ django . db ] import models into default name space .
append field to problem_fields list for every model in apps.get_models [ apps . get_models ] with argument kwargs dictionary , only if app_configs is None ,
or model._meta.app_config [ model . _meta . app_config ] is contained in app_configs , for every field in model._meta.local_fields [ model . _meta . local_fields ] , # ANNOTATION only if field is an instance of models.BooleanField [ models . BooleanField ] and field.has_default [ field . has_default ] ( ) evaluates to False . call the Warning function with 4 arguments : string _STR:0_ ,
from __future__ import unicode_literals into default name space .
from .. import Warning , register and Tags into default name space .
decorator register with argument Tags.compatibility [ Tags . compatibility ] .
define the function check_1_7_compatibility with argument kwargs dictionary .
errors is an empty list .
call the function _check_middleware_classes with dictionary kwargs as argument , use the result as an argument for the call to the function errors.extend [ errors . extend ] .
return errors .
define the function _check_middleware_classes with app_config set to None and kwargs dictionary as arguments .
from django.conf [ django . conf ] import settings into default name space .
call the function settings.is_overridden [ settings . is_overridden ] with argument string _STR:0_ , if the result is boolean False ,
call the Warning function with 4 arguments : string _STR:0_ , hint tuple containing one string ,
_STR:0_ , obj set to None , and id set to a string _STR:1_ , put the result into a list and return it . if not ,
return an empty list .
from __future__ import unicode_literals into default name space .
from django.utils.encoding [ django . utils . encoding ] import python_2_unicode_compatible and force_st into default name space .
DEBUG is integer 10 .
INFO is integer 20 .
WARNING is integer 30 .
ERROR is integer 40 .
CRITICAL is integer 50 .
decorator python_2_unicode_compatible .
derive class CheckMessage from object base class .
define initialization method __init__ with self class instance , level , msg , hint defaulting to None , obj defaulting to None and if defaulting to None as arguments .
if level is not an integer raise an error with message string _STR:0_ .
substitute level for self.level [ self . level ] .
substitute msg for self.msg [ self . msg ] .
substitute hint for self.hint [ self . hint ] .
substitute obj for self.obj [ self . obj ] .
substitute id for self.id [ self . id ] .
define private method __eq__ with self class instance and other as arguments .
if for all attr in list of attributes _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ and _STR:4_ , self and other have the same attribute attr ,
return boolean True , otherwise return boolean False . define private method __ne__ with self class instance and other as arguments .
if self equals to other return boolean False , otherwise return True .
define private method __str__ with argument self .
from django.db [ django . db ] import models into default name space .
if self.obj [ self . obj ] is None ,
obj is a string _STR:0_ .
otherwise if self.object [ self . object ] is an instance of the models.base.ModelBase [ models . base . ModelBase ] class ,
substitute self.obj [ self . obj ] for model .
substitute model._meta.app_label [ model . _meta . app_label ] for app .
convert app and model._meta.object_name [ model . _meta . object_name ] to strings , join them with separating _STR:0_ character , substitute it for obj .
if not ,
call the function force_str with argument self.obj [ self . obj ] , substitute the result for obj .
if self.id [ self . id ] exists , convert self.id [ self . id ] to a string , surround it with round brackets , substitute id for it , otherwise id is an empty string .
if self.hint [ self . hint ] exists , replace ' % s ' in a string _STR:0_ with value of self.hint [ self . hint ] , substitute it for hint , otherwise hint is an empty string .
replace all ' % s ' from string _STR:0_ with values of obj , id , self.msg [ self . msg ] and hint , respectively , return the result .
define private method __repr__ with argument self .
in the string _STR:0_ , replace ' % s ' with the name of the type of this class instance ,
replace all the _STR:0_ with self.level [ self . level ] , self.msg [ self . msg ] , self.hint [ self . hint ] . self.obj [ self . obj ] and self.id [ self . id ] , respectively , return the result . define the method is_serious with argument self .
return boolean True if self.level [ self . level ] is greater than or equals to ERROR , otherwise return boolean False .
define the method is_silence with argument self .
from django.conf [ django . conf ] import settings into default name space .
if self.id [ self . id ] is contained in settings.SILENCED_SYSTEM_CHECKS [ settings . SILENCED_SYSTEM_CHECKS ] return boolean True , False otherwise .
derive the class Debug from base class CheckMessage .
define initialization method __init__ with self class instance , unpacked list args , unpacked dictionary kwargs as arguments .
call the __init__ method with 3 arguments : DEBUG , unpacked list args and unpacked dictionary kwargs from the base class of Debug .
derive the class Info from base class CheckMessage .
define initialization method __init__ with self class instance , unpacked list args , unpacked dictionary kwargs as arguments .
call the __init__ method with 3 arguments : INFO , unpacked list args and unpacked dictionary kwargs from the base class of Info .
derive the class Warning from base class CheckMessage .
define initialization method __init__ with self class instance , unpacked list args , unpacked dictionary kwargs as arguments .
call the __init__ method with 3 arguments : WARNING , unpacked list args and unpacked dictionary kwargs from the base class of Warning .
derive the class Error from base class CheckMessage .
define initialization method __init__ with self class instance , unpacked list args , unpacked dictionary kwargs as arguments .
call the __init__ method with 3 arguments : ERROR , unpacked list args and unpacked dictionary kwargs from the base class of Error .
derive the class Critical from base class CheckMessage .
define initialization method __init__ with self class instance , unpacked list args , unpacked dictionary kwargs as arguments .
call the __init__ method with 3 arguments : CRITICAL , unpacked list args and unpacked dictionary kwargs from the base class of Critical .
from __future__ import unicode_literals into default name space .
from itertools import chain into default name space .
import module types .
from django.apps [ django . apps ] import apps into default name space .
from . import Error , Tags and register into default name space .
decorator register with Tags.models [ Tags . models ] as an argument .
define the function check_all_models with app_configs defaulting to None and unpacked dictionary kwargs as arguments .
call the model.check [ model . check ] method with unpacked dictionary kwargs for every model in return value of function apps.get_models [ apps . get_models ] ,
only if app_configs is None ot model._meta.app_config [ model . _meta . app_config ] is contained in app_configs , error is a list containing all the previous elements . chain all errors elements into a list , return it .
decorator register with Tags.models [ Tags . models ] and Tags.signals [ Tags . signals ] as arguments .
define the function check_model_signals with app_config defaulting to None and unpacked dictionary kwargs as arguments ,
from django.db [ django . db ] import models into default name space .
errors is an empty list .
for name in attributes of models_signals object ,
get models.signals [ models . signals ] name attribute , store it in obj .
if obj is instance of models.signals.ModelSignal [ models . signals . ModelSignal ] class ,
for every reference and receivers in return value of the call of obj.unresolved_references.items [ obj . unresolved_references . items ] method ,
for every receiver , _ and _ in receivers ,
if receiver is an instance of types.FunctionType [ types . FunctionType ] type ,
description is a string _STR:0_ replaced by value of receiver.__name__ [ receiver . __name__ ] .
if not ,
description is a string _STR:0_ with ' % s ' replaced by value of receiver.__class__.__name__ [ receiver . __class__ . __name__ ] .
call the Error function with 4 arguments , string `` % s was connected to the ' % s ' signal with a lazy reference to the ' % s ' sender ,
which has not been installed . '' with all the ' % s ' replaced by values of description , name and reference joined into a string delimited by _STR:0_ , respectively , obj set to receiver.__module__ [ receiver . __module__ ] , hint set to None and id set to string _STR:1_ , append the result to errors . return errors .
from __future__ import unicode_literals into default name space .
from itertools import chain into default name space .
from django.utils.itercompat [ django . utils . itercompat ] import is_iterable into default name space .
derive the class Tags with base class object .
admin is a string _STR:0_
compatibility is a string _STR:0_ .
models is a string _STR:0_
signal is a string _STR:0_
derive the class CheckRegistry with object as base class .
define initialization method __init__ with argument self .
self.registered_checks [ self . registered_checks ] is an empty list .
define the method register with self ans unpacked list tags as arguments .
define the method inner with argument check .
replace tags for check.tags [ check . tags ] .
if check is not contained in self.registered_checks [ self . registered_checks ] .
call the method self.registered_checks.append [ self . registered_checks . append ] with argument check .
return check .
return inner .
define the method run_checks with self class instance , app_configs defaulting to None , tags defaulting to None as argument .
errors is an empty list .
if tags is not None .
append check to checks list , for every check in self.register_checks [ self . register_checks ] , if check has an attribute _STR:0_ and check.tags [ check . tags ] and tags set intersection is a non empty set .
if not .
substitute self.registered_checks [ self . registered_checks ] for checks .
for every check in checks ,
call the check function with argument app_config set to app_config , substitute the result for new_errors .
if new_errors is not an iterable object raise an error with error message _STR:0_ , with ' % s ' replaced by value of check .
call the method errors.extend [ errors . extend ] with argument new_errors .
return errors .
define the method tag_exists with self class instance and tag as arguments .
return boolean True if tag is contained in self.tags_available [ self . tags_available ] method return value , return False otherwise .
define the method tags_available with argument self .
append check.tags [ check . tags ] into a list for every check in self.registered_checks [ self . registered_checks ] if check has _STR:0_ attribute , put the elements into a set and return it .
call the function CheckRegistry , substitute the result for registry .
substitute registry.register [ registry . register ] for register .
substitute registry.run_checks [ registry . run_checks ] for run_checks .
substitute registry.tag_exists [ registry . tag_exists ] for tag_exists .
from __future__ import unicode_literals into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.middleware.csrf [ django . middleware . csrf ] import get_token into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.encoding [ django . utils . encoding ] import smart_text into default name space .
from django.utils.functional [ django . utils . functional ] import lazy into default name space .
define the function csrf with an argument request .
define the function _get_val .
call the function get_token with an argument request , substitute the result for token .
if token is None ,
return string _STR:0_ .
if not ,
call the smart_text function with an argument token , return the result .
call the function lazy with arguments _get_val and six.text_type [ six . text_type ] , substitute the result for _get_val .
return an dictionary containing 1 entry : return value of the function _get_val for _STR:0_ .
define the function debug with an argument request .
context_extras is an empty dictionary .
if settings.DEBUG [ settings . DEBUG ] is true and value of the request.META [ request . META ] dictionary under the _STR:0_ key is contained in settings.INTERNAL_IPS [ settings . INTERNAL_IPS ] ,
value under the _STR:0_ key of the context_extras dictionary is boolean True .
from django.db [ django . db ] import connection into default name space .
substitute connection.queries [ connection . queries ] for value under the _STR:0_ key of the context_extras dictionary .
return context_extras .
define the function i18n with an argument request .
from django.utils [ django . utils ] import translation into default name space .
context_extras is an empty dictionary .
substitute settings.LANGUAGES [ settings . LANGUAGES ] for the value under the _STR:0_ key of the context_extras dictionary .
call the translation.get_language [ translation . get_language ] function , substitute the result for the value under the _STR:0_ key of the context_extras dictionary .
call the translation.get_language_bidi [ translation . get_language_bidi ] function , substitute the result for the value under the _STR:0_ key of the context_extras dictionary .
return context_extras .
define the function tz with an argument request .
from django.utils [ django . utils ] import timezone into default name space .
return an dictionary containing 1 entry : return value of the function timezone.get_current_timezone_name [ timezone . get_current_timezone_name ] for _STR:0_ .
define the function static with an argument request .
return an dictionary containing 1 entry : settings.STATIC_URL [ settings . STATIC_URL ] for _STR:0_ .
define the function media with an argument request .
return an dictionary containing 1 entry : settings.MEDIA_URL [ settings . MEDIA_URL ] for _STR:0_ .
define the function request with an argument request .
return an dictionary containing 1 entry : request for _STR:0_ .
from functools import reduce into default name space .
import module operator .
from django.utils [ django . utils ] import six into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_text into default name space .
derive the class DjangoRuntimeWarning from the RuntimeWarning base class .
do nothing .
derive the class AppRegistryNotReady from the Exception base class .
do nothing .
derive the class ObjectDoesNotExist from the Exception base class .
silent_variable_failure is an boolean True .
derive the class MultipleObjectsReturned from the Exception base class .
do nothing .
derive the class SuspiciousOperation from the Exception base class .
derive the class SuspiciousMultipartForm from the SuspiciousOperation base class .
do nothing .
derive the class SuspiciousFileOperation from the SuspiciousOperation base class .
do nothing .
derive the class DisallowedHost from the SuspiciousOperation base class .
do nothing .
derive the class DisallowedRedirect from the SuspiciousOperation base class .
do nothing .
derive the class PermissionDenied from the Exception base class .
do nothing .
derive the class ViewDoesNotExist from the Exception base class .
do nothing .
derive the class MiddlewareNotUsed from the Exception base class .
do nothing .
derive the class ImproperlyConfigured from the Exception base class .
do nothing .
derive the class FieldError from the Exception base class .
do nothing .
NON_FIELD_ERRORS is an string _STR:0_ .
derive the class ValidationError from the Exception base class .
define the method __init__ with 4 arguments : self , message , code set to None and params set to None .
call the __init__ method from the base class of the class ValidationError with arguments message , code and params .
if message is an instance of ValidationError class ,
if message has an _STR:0_ attribute ,
substitute message.error_dict [ message . error_dict ] for message .
alternatively , if six.PY3 [ six . PY3 ] is true check if message does not have an attribute _STR:0_ , if six.PY3 [ six . PY3 ] is false , check if message doesnt have an attribute _STR:1_ , perform the following ,
substitute message.error_list [ message . error_list ] for message .
if not ,
substitute message.message [ message . message ] , message.code [ message . code ] , message.params [ message . params ] for message , code and params , respectively .
if message is an instance of dict type ,
self.error_dict [ self . error_dict ] is an empty dictionary .
for every field , messages in return value of the message.items [ message . items ] method ,
if messages is not an instance of the ValidationError class ,
messages is an instance of the ValidationError class created with an argument messages .
substitute messages.error_list [ messages . error_list ] for the value under the field key of the self.error_dict [ self . error_dict ] dictionary .
otherwise if message is an instance of the list type .
self.error_list [ self . error_list ] is an empty list .
for every message is message ,
if message is not an instance of the ValidationError class ,
message is an instance of the ValidationError class created with an argument message .
extend the self.error_list [ self . error_list ] list with message.error_list [ message . error_list ] .
if not ,
substitute message for self.message [ self . message ] .
substitute code for self.code [ self . code ] .
substitute params for self.params [ self . params ] .
substitute list containing element self for self.error_list [ self . error_list ] .
property getter decorator ,
define the method message_dict with an argument self .
get attribute _STR:0_ from the self object .
convert object self to a dictionary , return it .
property getter decorator ,
define the messages with an argument self .
if self has an _STR:0_ attribute ,
call the operator.add [ operator . add ] on the values of the self object converted into a dictionary , until it is reduced to a single value , return it .
convert self to a list and return it .
define the method update_error_dict with arguments self and error_dict .
if self has an _STR:0_ attribute ,
for every field , error_list in self.error_dict.items [ self . error_dict . items ] method return value ,
call the method extend with an argument error_list on the return value of the method error_dict.setdefault [ error_dict . setdefault ] called with 2 arguments : field and an empty list .
if not ,
call the method extend with an argument error_list on the return value of the method error_dict.setdefault [ error_dict . setdefault ] called with 2 arguments : NON_FIELD_ERRORS and an empty list .
return error_dict .
define the method __iter__ with an argument self .
if self has an _STR:0_ attribute ,
for every field , errors in self.error_dict.items [ self . error_dict . items ] method return value ,
yield field and ValidationError object converted to an list , created with an argument errors .
if not ,
for every error in self.error_list [ self . error_list ] ,
substitute error.message [ error . message ] for message .
if error.params [ error . params ] is true ,
divide message by error.params [ error . params ] , substitute the residue of the division for message .
call the force_text with an argument message , yield the result .
define the method __str__ with an argument self .
if self has an attribute _STR:0_ ,
return the printable representation of the self object converted to a dictionary .
return the printable representation of the self object converted to a list .
define the method __repr__ with an argument self .
return the string _STR:0_ , replace ' % s ' with self .
from django.core.files.base [ django . core . files . base ] import File into default name space .
__all__ is an list containing a string _STR:0_ .
from __future__ import unicode_literals into default name space .
import module os .
from io import BytesIO , StringIO and UnsupportedOperation into default name space .
from django.utils.encoding [ django . utils . encoding ] import smart_text into default name space .
from django.core.files.utils [ django . core . files . utils ] import FileProxyMixin into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_bytes and python_2_unicode_compatible into default name space .
decorator python_2_unicode_compatible ,
derive the class File from the FileProxyMixin base class .
bring integer 2 to the power of 10 , multiply it by 64 , substitute the result for DEFAULT_CHUNK_SIZE .
define the method __init__ with self class instance , file , and name defaulting to None as arguments .
substitute file for self.file [ self . file ] .
if name is None ,
get _STR:0_ attribute from the file object , if it doesnt exists use None , substitute it for name .
substitute name for self.name [ self . name ] .
if file object has an attribute _STR:0_ ,
substitute file.mode [ file . mode ] for self.mode [ self . mode ] .
define the method __str__ with argument self .
evaluate the function smart_text with argument self.name [ self . name ] , if exists , or an empty string , if not , return the result .
define the method __repr__ with argument self .
substitute ' % s ' in string _STR:0_ with self.__class__.__name__ [ self . __class__ . __name__ ] and self , if exists , or string _STR:1_ if it doesnt , return it .
define the method __bool__ with argument self .
convert self.name [ self . name ] into an boolean , return it .
define the method __nonzero__ with argument self .
call the __bool__ method with argument self , on the return value of the type function with argument self , return the result .
define the method __len__ with argument self .
return self.size [ self . size ] .
define the method _get_size_from_underlying_file with argument self .
if self.file [ self . file ] has an attribute _STR:0_ ,
return self.file.size [ self . file . size ] .
if self.file [ self . file ] has an attribute _STR:0_ ,
try ,
call the os.path.getsize [ os . path . getsize ] function with argument self.file.name [ self . file . name ] , return the result .
if OSError or TypeError errors occurred .
do nothing .
if self.file [ self . file ] has an attribute _STR:0_ and an attribute _STR:1_ ,
get the position of the self.file [ self . file ] file pointer , substitute it for pos .
position the file self.file [ self . file ] pointer at the end .
get the position of the file self.file [ self . file ] pointer , substitute it for size .
position file self.file [ self . file ] pointer at the pos position .
return size .
raise an AttributeError exception with string _STR:0_ as argument .
define the method _get_size with argument self .
if self has an attribute _STR:0_ .
return self._size [ self . _size ] .
call the method self._get_size_from_underlying_file [ self . _get_size_from_underlying_file ] , substitute the result for self._size [ self . _size ] .
return self._size [ self . _size ] .
define the method _set_size with arguments self and size .
substitute size for self._size [ self . _size ] .
size is a property object with _get_size as getter method and _set_size as setter method .
define the method _get_closed with argument self .
if self.file [ self . file ] is false or self.file.closed [ self . file . closed ] is true , return boolean true , otherwise return boolean false .
closed is a property object with _get_closed as a getter method .
define the method chunks with arguments self and chunk_size defaulting to None .
if chunk_size is false ,
substitute the self.DEFAULT_CHUNK_SIZE [ self . DEFAULT_CHUNK_SIZE ] for chunk_size .
try ,
position the file pointer at the beginning of self file .
if AttributeError or UnsupportedOperation exception occurred .
do nothing .
endless loop ,
call the self.read [ self . read ] method with argument chunk_size , substitute the result for data .
if data is false ,
break from the smallest enclosing loop .
yield one element of data iterable .
define the method __multiple_chunks__ with arguments self and chunk_size defaulting to None .
if chunk_size is false ,
substitute self.DEFAULT_CHUNK_SIZE [ self . DEFAULT_CHUNK_SIZE ] for chunk_size .
if self.size [ self . size ] is greater than chunk_size , return boolean True , otherwise return boolean False .
define the method __iter__ with argument self .
buffer_ is None .
for every chunk in return value of the method self.chunks [ self . chunks ] ,
evaluate the function BytesIO with argument chunk , substitute it for chunk_buffer .
for every line in chunk_buffer ,
if buffer_ is true ,
increment line by buffer_ .
buffer_ is None .
if last element of line is newline or carriage return character ,
yield one element of line iterable .
if not ,
substitute line for buffer_ .
if buffer_ is not None ,
yield one element from the buffer_ iterable .
define the method __enter__ with argument self .
return self .
define the method __exit__ with self , exc_type , exc_value and tb as arguments .
close the file self .
define the method open with arguments self and mode defaulting to None .
if file self is not closed ,
position the file pointer at the beginning of self file .
otherwise if self.name [ self . name ] exists and self.name [ self . name ] file path exists ,
open the file self.name [ self . name ] in mode or self.mode [ self . mode ] mode , whichever exists , assign the file handler to self.file [ self . file ] .
if not ,
raise an ValueError exception with string _STR:0_ as an argument .
define the method close with argument self .
call the method self.file.close [ self . file . close ] .
decorator python_2_unicode_compatible ,
derive the class ContentFile from File base class .
define the method __init__ with arguments self , content and name defaulting to None .
if six.PY3 [ six . PY3 ] is boolean True ,
substitute StringIO for stream_class if content is an instance of six.text_type [ six . text_type ] , otherwise substitute BytesIO for stream_class .
if not ,
substitute BytesIO for stream_class .
call the function force_bytes with argument content , substitute it for content .
call the __init__ method with stream_class ( content ) and name set to name arguments , from the base class of the ContentFile class .
substitute length of content for self.size [ self . size ] .
define the method __str__ with argument self .
return a string _STR:0_ .
define the method __bool__ with argument self .
return boolean True .
define the method __nonzero__ with argument self .
evaluate the method type ( self ) .__bool__ with argument self , return the result .
define the method open with arguments self and mode set to None .
call the self.seek [ self . seek ] method with argument integer 0 .
define the method close with argument self .
do nothing .
import module zlib .
from django.core.files [ django . core . files ] import File into default name space .
derive class ImageFile from the base class File .
define method _get_width with self class instance as the argument .
return the first element of the return value of the call to the self._det_image_dimensions [ self . _det_image_dimensions ] method .
get property attribute _get_width , and substitute it for width .
define method _get_height with self class instance as the argument .
return the second element of the return value of the call to the self._det_image_dimensions [ self . _det_image_dimensions ] method .
get property attribute _get_height , and substitute it for width .
define the method _get_image_dimensions with self class instance as the argument .
if self does not have an attribute named _STR:0_ .
substitute self.closed [ self . closed ] for close .
call the method self.open [ self . open ] ( )
evaluate the method get_image_dimensions with self class instance and close set to close as the arguments , substitute the result for self._dimensions_cache [ self . _dimensions_cache ] .
return self._dimensions_cache [ self . _dimensions_cache ] .
define the function get_image_dimension with file_or_path and close set to boolean False as the arguments .
from PIL module import ImageFile as PillowImageFile .
p is image parser object , set by calling the PillowImageFile.Parser [ PillowImageFile . Parser ] method .
if file_or_path has an attribute _STR:0_ ,
substitute file_or_path for file .
get the position in bytes from the start of the file , store it in file_pos .
set the file position pointer at the beginning .
if not ,
open file named file_or_path for reading , store the file object handle in file .
close is boolean True .
try ,
chunk_size is an integer 1024 .
endless while loop ,
read chunk_size bytes from file and store it in data .
if data is empty .
break from the endless loop .
try ,
feed data to the parser p .
if zlib.error [ zlib . error ] as e exception is raised ,
if e.args [ e . args ] list first element starts with string _STR:0_ ,
do nothig .
if not ,
raise an exception .
if p.image [ p . image ] is not empty ,
return size of the image that was fed to the parser p .
double the chunk size .
return None .
execute regardless of the exception being raised ,
if close is True ,
close file file .
if not ,
set the file position pointer at file_pos .
import module os .
__all__ is a tuple containing strings : _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ and _STR:4_ .
define the _fd function with argument f .
return result of the f.fileno [ f . fileno ] method if f has an _STR:0_ attribute , otherwise return f .
if os.name [ os . name ] equals to _STR:0_ ,
import msvcrt .
from ctypes import sizeof , c_ulong , c_void_p , c_int64 , Structure , Union , POINTER , windll and byref into default name space .
from ctypes.wintypes [ ctypes . wintypes ] import BOOL , DWORD and HANDLE into default name space .
LOCK_SH is a integer 0 .
LOCK_NB is a hexadecimal 1 .
LOCK_EX is a hexadecimal 2 .
if size of c_ulong does not equals to size of c_void_p ,
substitute c_int64 for ULONG_PTR .
if not ,
substitute c_ulong for ULONG_PTR .
substitute c_void_p for PVOID .
derive the class _OFFSET from the Structure base class .
_fields_ is a list containing 2 tuples : first tuple contains : string _STR:0_ and DWORD , second contains : string _STR:1_ and DWORD .
derive the class _OFFSET_UNION from the Union base class .
_anonymous_ is a list containing one string : _STR:0_ .
_fields_ is a list containing 2 tuples : first tuple contains : string _STR:0_ and _OFFSET , second contains : string _STR:1_ and PVOID .
derive the class OVERLAPPED from the Structure base class .
_anonymous_ is a list containing one string : _STR:0_ .
_fields_ is a list containing 4 tuples : first tuple contains : string _STR:0_ and ULONG_PTR ,
second contains : string _STR:0__offset_union_STR:1_hEvent ' and HANDLE . call the function POINTER with argument OVERLAPPED , substitute the result for LPOVERLAPPED .
substitute windll.kernel32.LockFileEx [ windll . kernel32 . LockFileEx ] for LockFileEx .
substitute BOOL for LockFileEx.restype [ LockFileEx . restype ] .
LockFileEx.argtypes [ LockFileEx . argtypes ] is a list containing 6 elements : HANDLE , DWORD , DWORD , DWORD , DWORD and LPOVERLAPPED .
substitute windll.kernel32.UnlockFileEx [ windll . kernel32 . UnlockFileEx ] for UnlockFileEx .
substitute BOOL for UnlockFileEx.restype [ UnlockFileEx . restype ] .
UnlockFileEx.argtypes [ UnlockFileEx . argtypes ] is a list containing 5 elements : HANDLE , DWORD , DWORD , DWORD and LPOVERLAPPED .
define the function lock with arguments f and flags .
call the function msvcrt.get_osfhandle [ msvcrt . get_osfhandle ] with return value of the _fd ( f ) function as argument , substitute the result for hfile .
call the OVERLAPPED function , substitute the result for overlapped .
call the LockFileEx function with 6 arguments : hfile , flags , integer 0 , integer 0 , hexadecimal value FFFF0000 , return value of the byref function called with argument overlapped , substitute the result for ret .
convert ret to a boolean , return it .
define the function unlock with argument f .
call the function msvcrt.get_osfhandle [ msvcrt . get_osfhandle ] with return value of the _fd ( f ) function as argument , substitute the result for hfile .
call the OVERLAPPED function , substitute the result for overlapped .
call the LockFileEx function with 5 arguments : hfile , integer 0 , integer 0 , hexadecimal value FFFF0000 , return value of the byref function called with argument overlapped , substitute the result for ret .
convert ret to a boolean , return it .
if not ,
try ,
import fcntl .
substitute fcntl.LOCK_SH [ fcntl . LOCK_SH ] for LOCK_SH .
substitute fcntl.LOCK_NB [ fcntl . LOCK_NB ] for LOCK_NB .
substitute fcntl.LOCK_EX [ fcntl . LOCK_EX ] for LOCK_EX .
if ImportError or AttributeError exception occurred ,
LOCK_EX , LOCK_SH and LOCK_NB are all equal to integer 0 .
define the function lock with arguments f and flags .
return boolean False .
define the function unlock with argument f .
return boolean True .
if not ,
define the function lock with arguments f and flags .
call the function fcntl.flock [ fcntl . flock ] with return value of the _fd ( f ) function and flags as arguments , substitute the result for ret .
if ret equals to integer 0 , return boolean True , otherwise return boolean False .
define the function unlock with argument f .
all the function fcntl.flock [ fcntl . flock ] with return value of the _fd ( f ) function and fcntl.LOCK_UN [ fcntl . LOCK_UN ] as arguments , substitute the result for ret .
if ret equals to integer 0 , return boolean True , otherwise return boolean False .
import module os .
from django.core.files [ django . core . files ] import locks into default name space .
try ,
from shutil import copystat into default name space .
if ImportError exception occurred ,
import stat .
define the function copystat with arguments src and dst .
call the os.stat [ os . stat ] function with argument src , substitute the result for st .
call the function stat.S_IMODE [ stat . S_IMODE ] with argument st.st_mode [ st . st_mode ] , substitute the result for mode .
if os has an attribute _STR:0_ ,
call the os.utime [ os . utime ] function with arguments dst and tuple containing 2 elements : st.st_atime [ st . st_atime ] and st.st_mtime [ st . st_mtime ] .
if os has an attribute _STR:0_ ,
call the function os.chmod [ os . chmod ] with arguments dst and mode .
__all__ is a list containing a string _STR:0_ .
define the function _samefile with arguments src and dst .
if os.path [ os . path ] has an attribute _STR:0_ ,
try ,
call the os.path.samefile [ os . path . samefile ] with arguments src and dst , return the result .
if exception OSError occurred ,
return boolean False .
if file path of src and dst files are the same , return boolean True , otherwise return boolean False .
define the function file_move_safe with 4 arguments : old_file_name , new_file_name , chunk_size set to multiple of integers 1024 and 64 ,
if call to the function _samefile with old_file_name and new_file_name evaluates to boolean True ,
return nothing .
try ,
if allow_overwrite is boolean False and call to the os.access [ os . access ] function with arguments new_file_name and os.F_OK [ os . F_OK ] evaluates to boolean True ,
raise an IOError exception with string _STR:0_ as argument , where ' % s ' is replaced by new_file_name .
call the os.rename [ os . rename ] function with arguments old_file_name and new_file_name .
return nothing .
if OSError exception is caught ,
do nothing .
open file old_file_name in read bytes mode , with file descriptor as f ,
evaluate the binary expression with 4 operands : os.O_WRONLY [ os . O_WRONLY ] , binary or os.O_CREATE [ os . O_CREATE ] , binary or _STR:0_ attribute of object os ,
binary or os.O_EXCL [ os . O_EXCL ] if allow_overwrite is boolean False , use the previous as the mode to open new_file_name file , assign the file descriptor to fd . try ,
call the function locks.lock [ locks . lock ] with arguments fd and locks.LOCK_EX [ locks . LOCK_EX ] .
current_chunk is None .
as long as current_chunk is not an empty string ,
read chunk_size bytes from the old_file file , substitute the result for current_chunk .
write current_chunk to file fd .
finally perform ,
call the function locks.unlock [ locks . unlock ] with fd as argument .
close the file fd .
call the function copystat with old_file_name and new_file_name as arguments .
tr ,
remove the old_file_name file .
if OSError , renamed to e , is caught ,
if attribute _STR:0_ of object e is not equal to integer 32 and if _STR:1_ attribute is not equal to integer 13 ,
raise an exception .
import module os .
import module errno .
import module itertools .
from datetime import datetime into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.core.exceptions [ django . core . exceptions ] import SuspiciousFileOperation into default name space .
from django.core.files [ django . core . files ] import locks and File into default name space .
from django.core.files.move [ django . core . files . move ] import file_move_safe into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_text and filepath_to_uri into default name space .
from django.utils.functional [ django . utils . functional ] import LazyObject into default name space .
from django.utils.module_loading [ django . utils . module_loading ] import import_string into default name space .
from django.utils.six.moves.urllib.parse [ django . utils . six . moves . urllib . parse ] import urljoin into default name space .
from django.utils.text [ django . utils . text ] import get_valid_filename into default name space .
from django.utils._os [ django . utils . _os ] import safe_join and abspathu into default name space .
from django.utils.deconstruct [ django . utils . deconstruct ] import deconstructible into default name space .
__all__ is a tuple containing strings : _STR:0_ , _STR:1_ , _STR:2_ and _STR:3_ .
derive the class Storage from the object base class .
define the method open with arguments self , name and mode defaulting to string _STR:0_ .
call the self._open [ self . _open ] method with name and mode arguments , return the result .
define the method save with arguments self , name and content .
if name is None ,
substitute content.name [ content . name ] for name .
if content has an _STR:0_ attribute ,
content is a File object instance created with content argument .
call the method self.get_available_name [ self . get_available_name ] with argument name , substitute it for name .
call the method self._save [ self . _save ] with arguments name and content , substitute it for name .
replace all the strings _STR:0_/ ' in the string name , use it as an argument for the call to the force_text function , return the result .
define the method det_valid_name with arguments self and name .
call the get_valid_filename with argument name , return the result .
define the method get_available_name with arguments self and name .
call the os.path.split [ os . path . split ] with argument name , assign the result to the dir_name and file_name respectively .
call the os.path.splitext [ os . path . splitext ] with argument file_name , assign the result to the file_root and file_ext respectively .
call the itertools.count [ itertools . count ] function with argument integer 1 , substitute the result for count .
as long as self.exists [ self . exists ] function with argument name evaluates to boolean True ,
substitute ' % s ' in string _STR:0_ with : file_root , next ( count ) and file_ext , join the dir_name and previous string into a valid file path , substitute it for name .
return name .
define the method path with arguments self and name .
raise an NotImplementedError exception with argument string _STR:0_ .
define the method delete with arguments self and name .
raise an NotImplementedError exception with argument string _STR:0_ .
define the method exists with arguments self and name .
raise an NotImplementedError exception with argument string _STR:0_ .
define the method listdir with arguments self and path .
raise an NotImplementedError exception with argument string _STR:0_ .
define the method size with arguments self and name .
raise an NotImplementedError exception with argument string _STR:0_ .
define the method url with arguments self and name .
raise an NotImplementedError exception with argument string _STR:0_ .
define the method accessed_time with arguments self and name .
raise an NotImplementedError exception with argument string _STR:0_ .
define the method created_time with arguments self and name .
raise an NotImplementedError exception with argument string _STR:0_ .
define the method modified_time with arguments self and name .
raise an NotImplementedError exception with argument string _STR:0_ .
decorator deconstructible ,
derive the class FileSystemStorage from the Storage base class .
define the method __init__ with 5 arguments : self , location set to None , base_url set to None , file_permissions_mode set to None ,
and directory_permissions_mode set to None . if location is None ,
substitute the settings.MEDIA_ROOT [ settings . MEDIA_ROOT ] for location .
substitute the location for self.base_location [ self . base_location ] .
substitute the return value of the function abspathu with self.base_location [ self . base_location ] as argument for self.location [ self . location ] .
if base_url is None ,
substitute settings.MEDIA_URL [ settings . MEDIA_URL ] for base_url .
otherwise if base_url does not ends with _STR:0_ character ,
append character _STR:0_ to the base_url .
substitute base_url for self.base_url [ self . base_url ] .
self.file_permissions_mode [ self . file_permissions_mode ] is a tuple containing : file_permissions_mode if file_permissions_mode is not None ,
or settings.FILE_UPLOAD_PERMISSIONS [ settings . FILE_UPLOAD_PERMISSIONS ] if it is . self.directory_permissions_mode [ self . directory_permissions_mode ] is a tuple containing : directory_permissions_mode if directory_permissions_mode is not None ,
or settings.FILE_UPLOAD_DIRECTORY_PERMISSIONS [ settings . FILE_UPLOAD_DIRECTORY_PERMISSIONS ] if it is . define the method _open with arguments self , name and mode defaulting to string _STR:0_ .
call the function self.path [ self . path ] with argument name , use it and mode as arguments for the call to the function open , use it as an argument for creatinon of a File object instance , return it .
define the method _save with arguments self , name and content .
substitute result of the self.path [ self . path ] function with argument name for full_path .
call the function os.path.dirname [ os . path . dirname ] with argument full_path , substitute the result for directory .
if call to the function os.path.exists [ os . path . exists ] with argument directory evaluates to boolean False ,
try ,
if self.directory_permissions_mode [ self . directory_permissions_mode ] is not None ,
call the os.umask [ os . umask ] function with argument integer 0 , substitute the result for old_umask .
try ,
call the os.makedirs [ os . makedirs ] function with directory and self.directory_permissions_mode [ self . directory_permissions_mode ] as arguments .
finally perform ,
call the os.umask [ os . umask ] function with argument old_umask .
if not ,
call the function os.makedirs [ os . makedirs ] with argument directory .
if exception OSError , renamed to e , occurred ,
if e.errno [ e . errno ] is not equal to errno.EEXIST [ errno . EEXIST ] ,
raise an exception .
if directory is not an directory ,
raise an IOError exception with argument string _STR:0_ , where ' % s ' is replaced by directory .
endless loop ,
try ,
if content has an attribute _STR:0_ ,
call the function file_move_safe with content.temporary_file_path [ content . temporary_file_path ] function result and full_path .
if not ,
evaluate binary expression with 4 operands : os.O_WRONLY [ os . O_WRONLY ] , binary or os.O_CREAT [ os . O_CREAT ] , binary or os.O_EXCL [ os . O_EXCL ] ,
binary or _STR:0_ attribute of the os object , or integer 0 if it doesnt exists . call the os.open [ os . open ] function with full_path , flags and octal number 0o666 as arguments , substitute the result for fd .
_file is None .
try ,
call the function locks.lock [ locks . lock ] with fd and locks.LOCK_EX [ locks . LOCK_EX ] as arguments .
for every chunk in content.chunks [ content . chunks ] function return value ,
if _file is None ,
mode is a string _STR:0_ is chunk is instance of the type bytes , otherwise mode is a string _STR:1_ .
call the function os.fdopen [ os . fdopen ] with arguments fd and mode , substitute it for _file .
write the chunk to the file _file .
finally perform ,
call the function locks.unlock [ locks . unlock ] with argument fd .
if _file is not None ,
close the _file file .
if not ,
close fd file .
if OSError , renamed to e , is caught ,
if e.errno [ e . errno ] equals to errno.EEXIST [ errno . EEXIST ] ,
call the method self.get_available_name [ self . get_available_name ] with argument name , substitute the result for name .
call the method self.path [ self . path ] with argument name , substitute the result for full_path .
if not ,
raise an exception .
if not ,
break from the smallest enclosing loop .
if self.file_permissions_mode [ self . file_permissions_mode ] is not None ,
call the function os.chmod [ os . chmod ] with arguments full_path and self.file_permissions_mode [ self . file_permissions_mode ] .
return name .
define the method delete with arguments self and name .
if name is boolean False raise an assert error with message string _STR:0_ .
call the self.path [ self . path ] with argument name , substitute it for name .
if os.path.exists [ os . path . exists ] function with argument name , evaluates to boolean True ,
try ,
call the os.remove [ os . remove ] function with argument name .
if OSError , renamed to e , is caught ,
if e.errno [ e . errno ] equals to errno.EEXIST [ errno . EEXIST ] ,
raise an exception .
define the method exists with arguments self and name .
call the self.path [ self . path ] function with argument name , use the result as the argument for the call to the os.path.exists [ os . path . exists ] function , return the result .
define the method listdir with arguments self and path .
call the self.path [ self . path ] function with argument path , substitute it for path .
directories , files are empty lists .
for every entry in os.listdir [ os . listdir ] function return value called with the argument path ,
join path and entry into a file path , if it exists ,
append entry to the directories list .
if not ,
append entry to files list .
return directories and files .
define the method path with arguments self and name .
try ,
call the safe_join function with arguments self.location [ self . location ] and name , substitute it for path .
if ValueError exception is caught ,
raise an SuspiciousFileOperation exception with string _STR:0_ as argument , replace ' % s ' with name .
call the os.path.normpath [ os . path . normpath ] with argument path , return the result .
define the method size with arguments self and name .
call the self.path [ self . path ] with argument name , use the result as an argument for the call to the os.path.getsize [ os . path . getsize ] function , return the result .
define the method url with arguments self and name .
if self.base_url [ self . base_url ] is None ,
raise an ValueError with string _STR:0_ as argument .
call the urljoin function with arguments : self.base_url [ self . base_url ] and result of the call to the function filepath_to_uri with argument name , return the result .
define the method accessed_time with arguments self and name .
call the function self.path [ self . path ] with argument name , use the result as an argument for the call to the function os.path.getatime [ os . path . getatime ] ,
use the result as an argument for the call to the function datetime.fromtimestamp [ datetime . fromtimestamp ] , return the result . define the method created_time with arguments self and name .
call the function self.path [ self . path ] with argument name , use the result as an argument for the call to the function os.path.getctime [ os . path . getctime ] ,
use the result as an argument for the call to the function datetime.fromtimestamp [ datetime . fromtimestamp ] , return the result . define the method modified_time with arguments self and name .
call the function self.path [ self . path ] with argument name , use the result as an argument for the call to the function os.path.getmtime [ os . path . getmtime ] ,
use the result as an argument for the call to the function datetime.fromtimestamp [ datetime . fromtimestamp ] , return the result . define the function get_storage_class with argument import_path=None defaulting to None .
call the import_string with argument : import_path if exists or settings.DEFAULT_FILE_STORAGE [ settings . DEFAULT_FILE_STORAGE ] , if not , return the result .
derive the class DefaultStorage from the LazyObject base class .
define the _setup method with argument self .
call the function that is the return value of get_storage_class method , substitute the result for self._wrapped [ self . _wrapped ] .
call the DefaultStorage method , substitute the result for default_storage .
import module os .
import module tempfile .
from django.core.files.utils [ django . core . files . utils ] import FileProxyMixin into default name space .
__all__ is a tuple , containing strings _STR:0_ and _STR:1_ .
if module os field name equals to string _STR:0_ ,
derive class TemporaryFile from the base class FileProxyMixin .
define method __init__ with self class instance , mode string _STR:0_ , bufsize set to integer -1 , suffix and prefix set to empty strig ,
dir set to None as the arguments . call the method tmpfile.mkstemp [ tmpfile . mkstemp ] with suffix set to suffix , prefix set to prefix and dir set to dir , store the result in the fd and name , respective .
substitute name for self.name [ self . name ] .
call the os.fdopen [ os . fdopen ] function with fd , mode and bufsize as the arguments , assign the file handle object to self.file [ self . file ] .
substitute False for self.close_called [ self . close_called ] .
substitute os.unlink [ os . unlink ] for unlink .
define the method close with self class instance as the argument .
if self.close_called [ self . close_called ] is False ,
substitute True for self.close_called [ self . close_called ] .
try ,
close the file object .
if OSError or IOError exceptions were raised ,
do nothing .
try ,
call the method unlink on self with self.name [ self . name ] as the argument .
if OSError exception was raised ,
do nothing .
property decorator , to be called by property built-in function .
define the method closed with self as the argument .
return self.file.closed [ self . file . closed ] .
define __del__ method with self as the argument .
call the method close on self .
define __enter__ method with self as the argument .
call the file.__enter__ [ file . __enter__ ] method on self .
return self .
define method __exit__ with self , exc , value and tb as the arguments .
call the file.__exit__ [ file . __exit__ ] method on self with exc , value and tb as the arguments .
substitute TemporaryFile for NamedTemporaryFile .
if not ,
substitute tempfile.NamedTemporaryFile [ tempfile . NamedTemporaryFile ] for NamedTemporaryFile .
substitute tempfile.gettempdir [ tempfile . gettempdir ] for gettempdir .
import module errno .
import module os .
from io import BytesIO into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.core.files.base [ django . core . files . base ] import File into default name space .
from django.core.files [ django . core . files ] import temp as tempfile into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_str into default name space .
__all__ is a tuple containing strings : _STR:0_ , _STR:1_ , _STR:2_ and _STR:3_ .
derive the UploadedFile class from the File base class .
bring integer 2 to the power of 10 , multiply it by integer 64 , substitute the result for DEFAULT_CHUNK_SIZE .
define the method __init__ with 7 arguments : self , file set to None , name set to None , content_type set to None , size set to None , charset set to None and content_type_extra set to None .
call the __init__ method with arguments file and name , from the base class of the UploadedFile class .
substitute size for self.size [ self . size ] .
substitute content_type for self.content_type [ self . content_type ] .
substitute charset for self.charset [ self . charset ] .
substitute content_type_extra for self.content_type_extra [ self . content_type_extra ] .
define the method __repr__ with argument self .
substitute ' % s ' from string _STR:0_ with self.__class__.__name__ [ self . __class__ . __name__ ] , self.name [ self . name ] and self.content_type [ self . content_type ] , respectively , use it as an argument for the call to the function force_str , return the result .
define the method _get_name with argument self .
return self._name [ self . _name ] .
define the method _set_name with arguments self and name .
if name is not None ,
call the function os.path.basename [ os . path . basename ] with argument name , substitute the result for name .
if length of name is greater than integer 255 ,
call the os.path.splitex [ os . path . splitex ] with argument name , assign the result to name and ext , respectively .
substitute the first 255 elements of ext for ext .
subtract length of the ext from the integer 255 , take first elements of the name list up to the previous result index ,
append ext to the end of it , substitute the resulting list for name . substitute name for self._name [ self . _name ] .
name is a property object with _get_name as a getter method and _set_name as a setter method .
derive the TemporaryUploadedFile class from the UploadedFile base class .
define the __init__ method with 6 arguments : self , name , content_type , size , charset and content_type_extra set to None .
if settings.FILE_UPLOAD_TEMP_DIR [ settings . FILE_UPLOAD_TEMP_DIR ] is true ,
call the method tempfile.NamedTemporaryFile [ tempfile . NamedTemporaryFile ] with arguments : suffix set to string _STR:0_ and dir set to settings.FILE_UPLOAD_TEMP_DIR [ settings . FILE_UPLOAD_TEMP_DIR ] .
if not ,
call the method tempfile.NamedTemporaryFile [ tempfile . NamedTemporaryFile ] with argument suffix set to string _STR:0_ .
call the method __init__ from the base class of the TemporaryUploadedFile class with arguments : file , name , content_type , size , charset and content_type_extra .
define the method temporary_file_path with argument self .
return self.file.name [ self . file . name ] .
define the method close with argument self .
try ,
call the self.file.close [ self . file . close ] method , return the result .
if OSError , renamed to e , exception is caught ,
if e.errno [ e . errno ] is not equal to errno.ENOENT [ errno . ENOENT ] ,
raise an exception .
derive the InMemoryUploadedFile class from the UploadedFile base class .
define the method __init__ with 8 arguments : self , file , field_name , name , content_type , size , charset and content_type_extra set to None .
call the method __init__ from the base class of the InMemoryUploadedFile base class , with 6 arguments : file , name , content_type ,
size , charset , content_type_extra . substitute field_name for self.field_name [ self . field_name ] .
define the method open with arguments self and mode set to None .
set the file pointer at the beginning of the self.file [ self . file ] file .
define the method chunks with arguments self ad chunk_size set to None .
set the file pointer at the beginning of the self.file [ self . file ] file .
read the whole self file and yield it as a generator return value .
define the method multiple_chunks with arguments self and hunk_size set to None .
return boolean False .
derive the SimpleUploadedFile class from the InMemoryUploadedFile base class .
define the method __init__ with 4 arguments : self , name , content and content_type defaulting to a string _STR:0_ .
if content is empty , substitute it for an empty string .
call the __init__ method from the base class of the SimpleUploadedFile class with 7 arguments : BytesIO ( content ) , None , name ,
content_type , length of content , None and None . decorator classmethod .
define the method from_dict with argument cls and file_dict .
call the method cls with 3 arguments : value under the _STR:0_ key of file_dict , value under the _STR:1_ key of file_dict ,
from __future__ import unicode_literals into default name space .
from io import BytesIO into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.core.files.uploadedfile [ django . core . files . uploadedfile ] import TemporaryUploadedFile and InMemoryUploadedFile into default name space .
from django.utils.encoding [ django . utils . encoding ] import python_2_unicode_compatible into default name space .
from django.utils.module_loading [ django . utils . module_loading ] import import_string into default name space .
__all__ is a string containing strings : _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ ,
_STR:0_ , _STR:1_ , _STR:2_ and _STR:3_ . derive the class UploadFileException from the Exception base class .
do nothing .
decorator python_2_unicode_compatible ,
derive the class StopUpload from the UploadFileException base class .
define the method __init__ with arguments self and connection_reset defaulting to boolean False .
substitute connection_reset for self.connection_reset [ self . connection_reset ] .
define the method __str__ with argument self .
if self.connection_reset [ self . connection_reset ] is true ,
return string _STR:0_ .
if not ,
return string _STR:0_ .
derive the class SkipFile from the UploadFileException base class .
do nothing .
derive the class StopFutureHandlers from the UploadFileException base class .
do nothing .
derive the class FileUploadHandler from the object base class .
bring integer 2 to the power of 10 , multiply it by integer 64 , substitute the result for chunk_size .
define the method __init__ with arguments self and request defaulting to None .
self.file_name [ self . file_name ] is None .
self.content_type [ self . content_type ] is None .
self.content_length [ self . content_length ] is None .
self.charset [ self . charset ] is None .
self.content_type_extra [ self . content_type_extra ] is None .
self.request [ self . request ] is None .
define the method handle_raw_input with arguments : self , input_data , META , content_length , boundary and encoding set to None .
do nothing .
define the method new_file with arguments : self , field_name , file_name , content_type , content_length , charset set to None ,
substitute field_name for self.field_name [ self . field_name ] .
substitute file_name for self.file_name [ self . file_name ] .
substitute content_type for self.content_type [ self . content_type ] .
substitute content_length for self.content_length [ self . content_length ] .
substitute charset for self.charset [ self . charset ] .
substitute content_type_extra for self.content_type_extra [ self . content_type_extra ] .
define the method receive_data_chunk with arguments : self , raw_data and start .
raise an NotImplementedError with argument string _STR:0_ .
define the method file_complete with arguments : self and file_size .
raise an NotImplementedError with argument string _STR:0_ .
define the method upload_complete with argument self .
do nothing .
derive the class TemporaryFileUploadHandler from the FileUploadHandler base class .
define the method __init__ with arguments self , argument list args and dictionary of arguments kwargs .
call the __init__ method from the base class of the TemporaryFileUploadHandler class with arguments : unpacked list args ,
and unpacked dictionary kwargs . define the method new_file with arguments : self , file_name , unpacked list args and unpacked dictionary kwargs .
call the method new_file from the base class of the TemporaryFileUploadHandler class with arguments : file_name , unpacked list args and unpacked dictionary kwargs .
self.file [ self . file ] is a instance of a class TemporaryUploadedFile initialized with arguments : self.file_name [ self . file_name ] , self.content_type [ self . content_type ] , integer 0 ,
self.charset [ self . charset ] and self.content_type_extra [ self . content_type_extra ] . define the method receive_data_chunk with arguments : self , raw_data and start .
call the method self.file.write [ self . file . write ] with argument raw_data .
define the method file_complete with arguments self and file_size .
position the file pointer at the start of the self.file [ self . file ] file .
substitute file_size for self.file.size [ self . file . size ] .
return self.file [ self . file ] .
derive the class MemoryFileUploadHandler from the FileUploadHandler base class .
define the method handle_raw_input with arguments : self , input_data , META , content_length , boundary and encoding set to None .
if content_length is greater than settings.FILE_UPLOAD_MAX_MEMORY_SIZE [ settings . FILE_UPLOAD_MAX_MEMORY_SIZE ] ,
self.activated [ self . activated ] is boolean False .
if not ,
self.activated [ self . activated ] is boolean True .
define the method new_file with arguments : self , unpacked list args and unpacked dictionary kwargs .
call the new_file method form the base class from the MemoryFileUploadHandler class with arguments : unpacked list args and unpacked list kwargs .
if self.activated [ self . activated ] is boolean True ,
call the function BytesIO , substitute the result for self.file [ self . file ] .
raise an exception StopFutureHandlers .
define the function receive_data_chunk with arguments self , raw_data and start .
if self.activated [ self . activated ] is boolean True ,
write raw_data to self.file [ self . file ] file .
if not ,
return raw_data .
define the function file_complete with arguments self and file_size .
if self.activated [ self . activated ] is boolean False ,
return nothing .
set file pointer at the beginning of the self.file [ self . file ] file .
initialize the object of a InMemoryUploadedFile class with arguments : file set to self.file [ self . file ] , field_name set to self.field_name [ self . field_name ] ,
name set to self.file_name [ self . file_name ] , content_type set to self.content_type [ self . content_type ] , size set to file_size , charset set to self.charset [ self . charset ] , and content_type_extra set to self.content_type_extra [ self . content_type_extra ] , return it . define the function load_handler with arguments : path , unpacked list args and unpacked dictionary kwargs .
call the import_string with arguments path , call the return function with arguments : unpacked list args and unpacked dictionary kwargs , return the result .
derive class FileProxyMixin from the base class object , making it a new-style class .
define lambda function that returns self.file.encoding [ self . file . encoding ] field , use it as an argument for property function , put the result in encoding .
define lambda function that returns self.file.fileno [ self . file . fileno ] field , use it as an argument for property function , put the result in fileno .
define lambda function that returns self.file.flush [ self . file . flush ] field , use it as an argument for property function , put the result in flush .
define lambda function that returns self.file.isatty [ self . file . isatty ] field , use it as an argument for property function , put the result in isatty .
define lambda function that returns self.file.newlines [ self . file . newlines ] field , use it as an argument for property function , put the result in newlines .
define lambda function that returns self.file.read [ self . file . read ] field , use it as an argument for property function , put the result in read .
define lambda function that returns self.file.readinto [ self . file . readinto ] field , use it as an argument for property function , put the result in readinto .
define lambda function that returns self.file.readline [ self . file . readline ] field , use it as an argument for property function , put the result in readline .
define lambda function that returns self.file.readlines [ self . file . readlines ] field , use it as an argument for property function , put the result in readlines .
define lambda function that returns self.file.seek [ self . file . seek ] field , use it as an argument for property function , put the result in seek .
define lambda function that returns self.file.softspace [ self . file . softspace ] field , use it as an argument for property function , put the result in softspace .
define lambda function that returns self.file.tell [ self . file . tell ] field , use it as an argument for property function , put the result in tell .
define lambda function that returns self.file.truncate [ self . file . truncate ] field , use it as an argument for property function , put the result in truncate .
define lambda function that returns self.file.write [ self . file . write ] field , use it as an argument for property function , put the result in write .
define lambda function that returns self.file.writelines [ self . file . writelines ] field , use it as an argument for property function , put the result in writelines .
define lambda function that returns self.file.xreadlines [ self . file . xreadlines ] field , use it as an argument for property function , put the result in xreadlines .
define iterator method __iter__ with self as the argument .
return iterator object based on the self.file [ self . file ] collection object .
from __future__ import unicode_literals into default name space .
import module logging .
import module sys .
import module types .
from django import http into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.core [ django . core ] import urlresolvers into default name space .
from django.core [ django . core ] import signals into default name space .
from django.core.exceptions [ django . core . exceptions ] import MiddlewareNotUsed , PermissionDenied and SuspiciousOperation into default name space .
from django.db [ django . db ] import connections and transaction into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_text into default name space .
from django.utils.module_loading [ django . utils . module_loading ] import import_string into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.views [ django . views ] import debug into default name space .
call the function logging.getLogger [ logging . getLogger ] with string _STR:0_ as the argument , assign the return object handle to logger .
derive class BaseHandler , derive from the base class object , making this a new style class .
response_fixes is a list with http.fix_location_header [ http . fix_location_header ] and http.conditional_content_removal [ http . conditional_content_removal ] as elements .
define initialization method __init__ , with self class instance as the argument .
set class fields _request_middleware , _view_middleware , _template_response_middleware , _response_middleware and _exception_middleware to None .
define method load_middleware with class instance self as the argument .
self._view_middleware [ self . _view_middleware ] is an empty list .
self._template_response_middleware [ self . _template_response_middleware ] is an empty list .
_response_middleware is an empty list .
exception_middleware is an empty list .
request_middleware is an empty list .
for every middleware_path in settings.MIDDLEWARE_CLASSES [ settings . MIDDLEWARE_CLASSES ] :
evaluate the function import_string with middleware_path as argument , substitute the result for my_class .
try ,
call the mw_class function , store the result in the mw_instance .
if MiddlewareNotUsed exception is raised ,
skip this iteration of he smallest enclosing loop .
if mw_instance has an attribute named _STR:0_ .
append mw_instance.process_request [ mw_instance . process_request ] at the end of request_middleware .
if mw_instance has an attribute named _STR:0_ .
append mw_instance.process_view [ mw_instance . process_view ] at the end of self._view_middleware [ self . _view_middleware ] .
if mw_instance has an attribute named _STR:0_ .
insert mw_instance.process_template_response [ mw_instance . process_template_response ] at the beginning of self._template_response_middleware [ self . _template_response_middleware ] .
if mw_instance has an attribute named _STR:0_ .
insert mw_instance.process_response [ mw_instance . process_response ] at the beginning of self._response_middleware [ self . _response_middleware ] .
if mw_instance has an attribute named _STR:0_ .
insert mw_instance.process_exception [ mw_instance . process_exception ] at the beginning of self._exception_middleware [ self . _exception_middleware ] .
substitute self._request_middleware [ self . _request_middleware ] for request_middleware .
define the method make_view_atomic , with self class instance and view as the arguments .
get attribute _STR:0_ from the view object , if the attribute doesnt exist return the empty set , substitute the result for non_atomic_requests .
call the method connections.all [ connections . all ] ( ) , perform the following for every db in the result ,
if value under the key 'ATOMIC_REQUESTS of db.settings_dic [ db . settings_dic ] dictionary is True and db.alias [ db . alias ] is not present in the non_atomic_requests ,
call the function transaction.atomic [ transaction . atomic ] , with using set to db.alias [ db . alias ] as the argument , return value is a function which is called ,
with the argument view , store the result in the view . return view
define method get_exception_response , with self class instance , request , resolver and status_code as the arguments .
try ,
call the function resolver.resolve_error_handler [ resolver . resolve_error_handler ] with status_code as an argument , assign the result to the callback and param_dict , respectively .
call the callback function with request and dictionary argument param_dict as the arguments , substitute it for response .
if an exception occurred ,
call the method signals.got_request_exception.send [ signals . got_request_exception . send ] with the sender set to the type of this class , and request set to request as the arguments .
call the method self.handle_uncaught_exception [ self . handle_uncaught_exception ] with request , resolver and return value of the function sys.exec_info [ sys . exec_info ] as the arguments .
return response
define the method get_response , with self class instance and request as the arguments .
substitute settings.ROOT_URLCONF [ settings . ROOT_URLCONF ] for urlconf .
call the method urlresolvers.set_urlconf [ urlresolvers . set_urlconf ] with urlconf as the argument .
call the method urlresolvers.RegexURLResolver [ urlresolvers . RegexURLResolver ] with raw literal string _STR:0_ and urlconf as the arguments , substitute the result for resolver .
try ,
set response to None .
for every middleware_method in self._request_middleware [ self . _request_middleware ] ,
call the middleware_method with the request as an argument , substitute the result for response .
if response is True ,
breaks from the smallest enclosing loop execution .
if response is None ,
if request has an attribute named _STR:0_ ,
substitute request.urlconf [ request . urlconf ] for urlconf .
call the function urlresolvers.set_urlconf [ urlresolvers . set_urlconf ] with urlconf as the argument .
call the method urlresolvers.RegexURLResolver [ urlresolvers . RegexURLResolver ] with raw literal string _STR:0_ and urlconf as the arguments , substitute the result for resolver .
call to the resolver.resolve [ resolver . resolve ] method with request.path_info [ request . path_info ] as an argument .
assign the values to the callback , callback_args , callback_kwargs , respectively , from the resolver_match tuple .
substitute resolver_match for request.resolver_match [ request . resolver_match ] .
for every middleware_method in self._view_middleware [ self . _view_middleware ] ,
call the middleware_method with request , callback , callback_args and callback_kwargs as the arguments , substitute the result for response .
if response is True ,
break from the smallest enclosing loop execution .
if response is None ,
call the method self.make_view_atomic [ self . make_view_atomic ] with callback as the argument , substitute the result for the wrapped_callback .
try ,
call the function wrapped_callback with request , list or arguments callback_args and dictionary arguments callback_kwargs ,
as the arguments , substitute the result for response . if Exception , renamed to e , exception is caught ,
for every middleware_method in self._exception_middleware [ self . _exception_middleware ] ,
call the middleware_method with request and e as the arguments , substitute the result for response .
if response is True ,
break from the smallest enclosing loop execution .
if response is None ,
raise the exception .
if response is None ,
if callback is of instance types.FunctionType [ types . FunctionType ] ,
get the name of the callback , substitute it for view_name .
if not ,
get the name of the type of the callback , append the string _STR:0_ to it , substitute it for view_name .
substitute the ' % s ' in the string _STR:0_ ,
with the name of the module callback is in and the view_name , respectively , use it as the argument for the ValueError exception raise . if response has an attribute named _STR:0_ and response.render [ response . render ] is a callable function ,
for every middleware_method in self._template_response_middleware [ self . _template_response_middleware ] ,
call the function middleware_method with the request and response as the arguments , assign the result to response .
if response is None ,
replace ' % s ' in the string _STR:0_ ,
with name of the class type of the middleware_method instance , use it as the argument for call to the ValueError exception raise . call the response.render [ response . render ] ( ) method and assign the return to the response .
if exception http.Http404 [ http . Http404 ] as e is caught ,
substitute ' % s ' in _STR:0_ with request.path [ request . path ] , extra is an dictionary with two pairs of elements _STR:1_ with value 404 ,
and 'request with value request , respectively use the previous as the arguments for the call to the logger.warning [ logger . warning ] function . if settings.DEBUG [ settings . DEBUG ] is True ,
call the function debug.technical_404_response [ debug . technical_404_response ] with request and e as arguments , assign the result to response .
if not ,
call the method self.get_exception_response [ self . get_exception_response ] with request , resolver and integer 404 as the arguments , assign the result to response .
if exception PermissionDenied is caught ,
substitute ' % s ' in _STR:0_ with request.path [ request . path ] , extra is an dictionary with two pairs of elements ,
_STR:0_ with value 403 , and 'request with value request , respectively use the previous as the arguments for the call to the logger.warning [ logger . warning ] function . call the method self.get_exception_response [ self . get_exception_response ] with request , resolver and integer 403 as the arguments , assign the result to response .
if exception SuspiciousOperation as e is caught ,
substitute ' % s ' in _STR:0_ with the name of the type of the class object e , use it as the argument for the call to the ,
function logging.getLogger [ logging . getLogger ] , assign the result to the security_logger . evaluate the function force_text with e as an argument , extra is an dictionary with two pair of elements ,
_STR:0_ with integer value of 400 and _STR:1_ with value request , respectively use the previous to call the function security_logger.error [ security_logger . error ] . if settings.DEBUG [ settings . DEBUG ] is True ,
evaluate the function debug.technical_500_response [ debug . technical_500_response ] with request , evaluated value of function sys.exc_info [ sys . exc_info ] as a list ,
status code set to integer 400 , return the result . call the method self.get_exception_response [ self . get_exception_response ] with the request , resolver and integer 400 as the arguments , substitute the result for response .
if SystemExit exception is caught ,
raise an exception .
otherwise if any other exception is caught ,
call the method signals.got_request_exception.send [ signals . got_request_exception . send ] with sender set to type of the self class instance and request set to request .
call to the self.handle_uncaught_exception [ self . handle_uncaught_exception ] method with request , resolver and value of the evaluated function sys.exec_info [ sys . exec_info ] ,
as the arguments , substitute the result for response . try ,
for every middleware_method in self._response_middleware [ self . _response_middleware ] ,
call the function middleware_method with request and response as the arguments , substitute the result for response .
if response is None ,
substitute ' % s ' is _STR:0_ ,
with the name of the type of the self class instance of the middleware_method , raise the ValueError with the previous as the argument . call the method self.apply_response_fixes [ self . apply_response_fixes ] with the request and response as the arguments , substitute the result for response .
if any exception is caught ,
call the signals.got_request_exception.send [ signals . got_request_exception . send ] method with sender set to type of the self class instance and request set to request .
call to the self.handle_uncaught_exception [ self . handle_uncaught_exception ] method with request , resolver and value of the evaluated function sys.exec_info [ sys . exec_info ] ,
as the arguments , substitute the result for response . append the request to the end of the protected class member response._closable_objects [ response . _closable_objects ] .
return response .
define the method handle_uncaught_exception with self class instance , request , resolver and exec_info as arguments .
if settings.DEBUG_PROPAGATE_EXCEPTIONS [ settings . DEBUG_PROPAGATE_EXCEPTIONS ] is True ,
raise an exception .
substitute ' % s ' in _STR:0_ with request.path [ request . path ] , exc_info set to exc_info ,
extra is an dictionary with two pairs of elements _STR:0_ with value 500 , and 'request with value request , respectively use the previous as the arguments for the call to the logger.error [ logger . error ] function . if settings.DEBUG [ settings . DEBUG ] is True ,
evaluate debug.technical_500_response [ debug . technical_500_response ] with request and list of arguments exec_info , return the result .
if resolver.urlconf_module [ resolver . urlconf_module ] is None :
call the function reraise from the module six , with list of arguments exec_info .
call the resolver.resolve_error_handler [ resolver . resolve_error_handler ] with integer 500 as the argument , assign the resulting tuple elements to the callback ,
and param_dict , respectively . evaluate the function callback with request and dictionary of parameters param_dict as the arguments , return the result .
define the method apply_response_fixes with self class instance , request and response as the arguments .
for every func in self.response_fixes [ self . response_fixes ] ,
call the function func with request and response as arguments , assign the result to response .
return response .
from __future__ import unicode_literals into default name space .
import module cgi .
import module codecs .
import module logging .
import module sys .
from io import BytesIO into default name space .
from threading import Lock into default name space .
import module warnings .
from django import http into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.core [ django . core ] import signals into default name space .
from django.core.handlers [ django . core . handlers ] import base into default name space .
from django.core.urlresolvers [ django . core . urlresolvers ] import set_script_prefix into default name space .
from django.utils [ django . utils ] import datastructures into default name space .
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_str and force_text into default name space .
from django.utils.functional [ django . utils . functional ] import cached_property into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.http.response [ django . http . response ] import REASON_PHRASES as STATUS_CODE_TEXT # NOQA into default name space .
call logging.getLogger [ logging . getLogger ] method with string _STR:0_ as argument , store the result in logger .
ISO_8859_1 is a string _STR:0_ , UTF_8 is a string _STR:1_ .
derive class LimitedStream from the object base class , making it a new-style class .
def initialization method __init__ with self class instance , stream , limit and buf_size set to integer value of the product 64*1024*1024 .
substitute stream for self.stream [ self . stream ] .
substitute limit for self.remaining [ self . remaining ] .
substitute empty bytes string for self.buffer [ self . buffer ] .
substitute buf_size for self.buf_size [ self . buf_size ] .
define the method _read_limited with self class instance and size set to None as arguments .
if size is None or size is greater than self.remaining [ self . remaining ] ,
substitute self.remaining [ self . remaining ] for size .
if size equals to integer zero .
return empty bytes string .
read size number of bytes from self.stream [ self . stream ] stream , store the result in the result .
decrement self.remaining [ self . remaining ] by length of result .
return result .
define the method read with self class instance and size set to None as arguments .
if size is None ,
add self.buffer [ self . buffer ] and self._read_limited [ self . _read_limited ] method return value together , store it in result .
substitute empty bytes string for self.buffer [ self . buffer ] .
otherwise if size is less than length of self.buffer [ self . buffer ] ,
substitute first size elements of self.buffer [ self . buffer ] for result .
truncate first size number of elements of self.buffer [ self . buffer ] .
if not ,
call the method self.read_limited [ self . read_limited ] with length of self.buffer [ self . buffer ] subtracted from size as argument , add result to self.buffer [ self . buffer ] , store it in result .
substitute empty bytes string for self.buffer [ self . buffer ] .
return result .
define method readline with self class instance and size set to None .
while newline character is not contained in self.buffer [ self . buffer ] and , size is None or length of self.buffer [ self . buffer ] is less than size ,
if size is not zero ,
call the self._read_limiter [ self . _read_limiter ] with length of self.buffer [ self . buffer ] subtracted from size as argument , store the result into chunk .
if not ,
call the method self._read_limited [ self . _read_limited ] , store the return value into chunk .
if chunk is empty ,
break the execution of the smallest enclosing loop .
increment self.buffer [ self . buffer ] by chunk .
call the function BytesIO with self.buffer [ self . buffer ] as argument , store the result is sio .
if size is not empty ,
call the sio.readline [ sio . readline ] method with size as an argument , substitute the result for line .
if not ,
call the sio.readline [ sio . readline ] method , substitute the result for line .
call the sio.read [ sio . read ] method , substitute the result for self.buffer [ self . buffer ] .
return line .
derive the class WSGIRequest from base class http.HttpRequest [ http . HttpRequest ] .
define the initialization method __init__ with self class instance and environ as arguments .
call the get_script_name function with environ as argument , substitute the result for script_name .
call the get_path_info function with environ as argument , substitute the result for path_info .
if path_info is empty ,
path_info is a character _STR:0_ .
substitute environ for self.environ [ self . environ ] .
substitute path_info for self.path_info [ self . path_info ] .
strip trailing _STR:0_ from the script_name string , remove first occurrence of _STR:0_ in path_info string , append second result to the first , separated with _STR:0_ , assign the result to self.path [ self . path ] .
substitute environ for self.META [ self . META ] .
assign path_info to the value under the _STR:0_ key of the self.META [ self . META ] dictionary .
assign script_name to the value under the _STR:0_ key of the self.META [ self . META ] dictionary .
convert value under the _STR:0_ key of the environ dictionary to uppercase , substitute it for self.method [ self . method ] .
get the value under the _STR:0_ key of environ dictionary , if the key doesnt exist get the empty string ,
use it to call the cgi.parse_header [ cgi . parse_header ] method , assign the result to the _ and content_params respectively . if string _STR:0_ is contained in content_params ,
try ,
get the value under the _STR:0_ key of content_params dictionary , use it to call the codec.lookup [ codec . lookup ] method .
if exception LookupError is caught ,
do nothing .
if not ,
get the value under the _STR:0_ key of content_params dictionary , substitute it for self.encoding [ self . encoding ] .
self._post_parse_error [ self . _post_parse_error ] is boolean False .
try ,
convert value under the _STR:0_ key of the environ dictionary to an integer , substitute it for content_length .
if exception ValueError or TypeError is caught ,
content_length is integer 0 .
self._stream [ self . _stream ] is a class instance of a LimitedStream class , initialized with self.environ [ self . environ ] dictionary value under the _STR:0_ key ,
and content_length . self._read_started [ self . _read_started ] is boolean False .
self.resolver_match [ self . resolver_match ] is None .
define the method _get_scheme with self class instance as argument .
return value under the _STR:0_ key of self.environ [ self . environ ] dictionary .
define the method _get_request with self class instance as argument .
call the warnings.warn [ warnings . warn ] method with string _STR:0_ ,
RemovedInDjango19Warning and integer 2 as arguments . if self does not have an _STR:0_ attribute ,
call the datastructures.MergeDict [ datastructures . MergeDict ] with self.POST [ self . POST ] and self.GET [ self . GET ] as arguments , assign the result to self._request [ self . _request ] .
return self._request [ self . _request ] .
decorator cached_property .
define method GET with self class instance as an argument .
call the get_bytes_from_wsgi function with self.environ [ self . environ ] , string _STR:0_ and empty string as arguments , substitute the return value for raw_query_string .
evaluate the http.QueryDict [ http . QueryDict ] method with raw_query_string and encoding set to self._encoding [ self . _encoding ] as arguments , return the result .
def _get_post method with self class instance as the argument .
if self does not has an _STR:0_ attribute .
call the self._load_post_and_files [ self . _load_post_and_files ] method .
return self._post [ self . _post ] .
define the _set_post method with self class instance and post as the arguments .
substitute post for self._post [ self . _post ] .
decorator cached_property .
define COOKIES method with self as the argument .
call get_str_from_wsgi function with self.environ [ self . environ ] , string _STR:0_ and empty string as arguments , substitute it for raw_cookie .
evaluate the function http.parse_cookie [ http . parse_cookie ] with raw_cookie as an argument , return the result .
define _get_files method with self class instance as the argument .
if self does not have _STR:0_ attribute ,
call the method self._load_post_and_files [ self . _load_post_and_files ] .
return self._files [ self . _files ] .
_get_post is a getter function and _set_post is a setter function for POST attribute of this class .
_get_files is getter function for FILES attribute of this class .
_get_request is getter function for REQUEST attribute of this class .
derive the WSGIHandler class from the base class base.BaseHandler [ base . BaseHandler ] .
evaluate function Lock ( ) assign the result to initLock .
substitute WSGIRequest for request_class .
define private method __call__ with self class instance , environ and start_response as the arguments .
if self._request_middleware [ self . _request_middleware ] is None ,
with self.initLock [ self . initLock ] ,
try ,
if self._request_middleware [ self . _request_middleware ] is None ,
call the self.load_middleware [ self . load_middleware ] method .
if exception is caught ,
self._request_middleware [ self . _request_middleware ] is None .
re raise an exception .
call the get_script_name function with environ as argument , use the result as an argument for call to the set_script_prefix function .
call the signals.request_started.send [ signals . request_started . send ] method with sender set to self.__class__ [ self . __class__ ] as argument .
try ,
call the self.request_class [ self . request_class ] method with environ as an argument , substitute the result for request .
if UnicodeDecodeError exception is caught ,
call the logger.warning [ logger . warning ] method with string _STR:0_ , exec_info set to sys.exec_info [ sys . exec_info ] ( ) and dictionary extra
with one entry _STR:0_ is integer 400 , as arguments . call the http.HttpResponseBadRequest [ http . HttpResponseBadRequest ] function , assign the result to the response .
if not ,
call the self.get_response [ self . get_response ] with request as the argument , substitute the result for response .
substitute self.__class__ [ self . __class__ ] for response._handler_class [ response . _handler_class ] .
replace ' % s ' in the string _STR:0_ with response.status_code [ response . status_code ] and response.reason_phrase [ response . reason_phrase ] , respectively , substitute it for status .
convert to k and v to strings for every k and v in return value of the response.item [ response . item ] method , response_headers is a list containing all the above iteration elements .
for every c in return value of the method response.cookies.values [ response . cookies . values ] ,
convert _STR:0_ to a string and convert the return value of method c.output [ c . output ] ( header=_STR:1_ ) call to a string ,
format the previous in a tuple , append the tuple to the response_headers . call the start_response function with force_str ( status ) method return value and response_headers as arguments .
return response .
define the get_path_info function with environ as the argument .
call the function get_bytes_from_wsgi with environ , string _STR:0_ and character _STR:1_ as arguments , substitute the result for path_info .
return path_info.decode [ path_info . decode ] method return value called with UTF_8 as the argument .
define get_script_name function with environ as an argument .
if settings.FORCE_SCRIPT_NAME [ settings . FORCE_SCRIPT_NAME ] is not None ,
evaluate the force_text function with settings.FORCE_SCRIPT_NAME [ settings . FORCE_SCRIPT_NAME ] as argument , return the result .
call the get_bytes_from_wsgi function with environ , string _STR:0_ and empty strings as arguments , substitute the result for script_url .
if script_url is false ,
call the get_bytes_from_wsgi function with environ , string _STR:0_ and empty strings as arguments , substitute the result for script_url .
if script_url is true ,
call the get_bytes_from_wsgi function with environ , string _STR:0_ and empty strings as arguments , substitute the result for path_info .
take all but the length of path_info last elements of script_url , substitute it for script_name .
if not ,
call the get_bytes_from_wsgi function with environ , string _STR:0_ and empty strings as arguments , substitute the result for script_name .
return scrip_name.decode [ scrip_name . decode ] method result called with UTF_8 as argument .
define the function get_bytes_from_wsgi with environ , key and default as arguments .
convert key and default to strings , get the value under the key string key of the environ dictionary , if it does not exists use the ,
default string value , substitute it for value . return value if six.PY2 [ six . PY2 ] is true , if not return value.encode [ value . encode ] ( ISO_8859_1 ) .
define the get_str_from_wsgi function with environ , key and default as arguments .
convert key and default to strings , get the value under the key string key of the environ dictionary , if it does not exists use the ,
default string value , substitute it for value . return value if six.PY2 [ six . PY2 ] is true , if not return value.encode [ value . encode ] ( ISO_8859_1 ) .decode ( UTF_8 ) .
from __future__ import unicode_literals into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.utils.module_loading [ django . utils . module_loading ] import import_string into default name space .
from django.core.mail.utils [ django . core . mail . utils ] import CachedDnsName and DNS_NAME into default name space .
from django.core.mail.message [ django . core . mail . message ] import EmailMessage , EmailMultiAlternatives , SafeMIMEText , SafeMIMEMultipart ,
DEFAULT_ATTACHMENT_MIME_TYPE , make_msgid , BadHeaderError and forbid_multi_line_headers into default name space . __all__ is a list of strings , _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ ,
_STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ , _STR:5_ , _STR:6_ , _STR:7_ , _STR:8_ and _STR:9_ . define function get_connection with backend set to None , fail_silently set to boolean False and dictionary kwds as arguments .
call the function import_string with backend if exists or settings.EMAIL_BACKEND [ settings . EMAIL_BACKEND ] if not , store the result into klass .
call the klass method with fail_silently set to fail_silently and dictionary arguments kwds as arguments , return the result .
define send_mail funtion with subject , message , from_email , recipient_list , fail_silently set to boolean False ,
if connection exists dont modify it , if not call get_connection function with username set to auth_user , password set to auth_password , fail_silently set to fail_silently as arguments , assign it to connection .
call the EmailMultiAlternatives function with , subject , message , from_email , recipient_list and connection set to connection , as arguments , assign the result to mail .
if html_message is True ,
call the mail.attach_alternative [ mail . attach_alternative ] method with html_message and string _STR:0_ as arguments .
return the evaluated result of the mail.send [ mail . send ] method .
define the function send_mass_mail with , datatuple , fail_silently set to False , auth_user set to None , auth_password set to None ,
if connection exists dont change it , if not call the get_connection function with username set to auth_user ,
password set to auth_password , fail_silently set to fail_silently as arguments , assign the result to connection . call the EmailMessage function wit subject , message , sender , recipient and connection set to connection ,
for every subject , message , sender and recipient in datatuple , store the results in the messages list . return evaluated result of the method connection.send_messages [ connection . send_messages ] with messages as argument .
define the function mail_admins with subject , message , fails_silently set to boolean False , connection set to None ,
if settings.ADMINS [ settings . ADMINS ] is false ,
return nothing .
call the function EmailMultiAlternatives with settings.EMAIL_SUBJECT_PREFIX [ settings . EMAIL_SUBJECT_PREFIX ] and subject converted to strings and concatenated ,
message , settings.SERVER_EMAIL [ settings . SERVER_EMAIL ] , list of second elements of a for every a in settings.Managers [ settings . Managers ] and connection set to connection , as arguments , assign the result to mail . if html_message is true ,
call method mail.attach_alternative [ mail . attach_alternative ] as html_message and string _STR:0_ as arguments .
call the mail.send [ mail . send ] method with fail_silently=fail_silently as argument .
define the function mail_managers with subject , message , fails_silently set to boolean False , connection set to None ,
if settings.MANAGERS [ settings . MANAGERS ] does not exist ,
return nothing .
call the function EmailMultiAlternatives with settings.EMAIL_SUBJECT_PREFIX [ settings . EMAIL_SUBJECT_PREFIX ] and subject converted to strings and concatenated ,
message , settings.SERVER_EMAIL [ settings . SERVER_EMAIL ] , list of second elements of a for every a in settings.Managers [ settings . Managers ] and connection set to connection , as arguments , assign the result to mail . if html_message is true ,
call the mail.attach_alternative [ mail . attach_alternative ] method with html_message and string _STR:0_ as arguments .
call the mail.send [ mail . send ] method with fail_silently set to fail_silently as argument .
derive the class BaseEmailBackend from the object base class .
define the method __init__ with arguments : self , fail_silently set to boolean False and unpacked dictionary kwargs .
substitute fail_silently for self.fail_silently [ self . fail_silently ] .
define the method open with argument self .
do nothing .
define the method close with argument self .
do nothing
define the method __enter__ with argument self .
call the method self.open [ self . open ] .
return self .
define the method __exit__ with arguments : self , exc_type , exc_value and traceback .
call the method self.close [ self . close ] .
define the method send_messages with arguments self and email_messages .
raise an NotImplementedError exception with argument string _STR:0_ .
import module sys .
import module threading .
from django.core.mail.backends.base [ django . core . mail . backends . base ] import BaseEmailBackend into default name space .
from django.utils [ django . utils ] import six into default name space .
derive the class EmailBackend from the BaseEmailBackend base class .
define the __init__ method with arguments : self , unpacked list args and unpacked dictionary kwargs .
pop the value under the _STR:0_ key of the kwargs dictionary , if it exists replace it for self.stream [ self . stream ] , if not replace sys.stdout [ sys . stdout ] for self.stream [ self . stream ] .
call the method threading.RLock [ threading . RLock ] , substitute the result for self._lock [ self . _lock ] .
call the __init__ method from the base class of the EmailBackend class , with arguments : unpacked list args and unpacked dictionary kwargs .
define the method write_message with arguments self and message .
call the method message.message [ message . message ] , substitute the result for msg .
call the method msg.as_bytes [ msg . as_bytes ] , substitute the result for msg_data .
if six.PY3 [ six . PY3 ] is boolean True ,
if method msg.get_charset [ msg . get_charset ] evaluates to true , call the get_output_charset method on the return value of the msg.get_charset [ msg . get_charset ] method , substitute the result for charset , otherwise if it is false , substitute the string _STR:0_ for charset .
call the method msg_data.decode [ msg_data . decode ] with argument charset , substitute the result for msg_data .
call the method self.stream.write [ self . stream . write ] with argument string _STR:0_ , with ' % s ' replaced with msg_data .
write 79 _STR:0_ characters into self.stream [ self . stream ] file stream .
write a newline into a self.stream [ self . stream ] file stream .
define the method send_messages with arguments self and email_messages .
if email_messages is false ,
return .
msg_count is an integer 0 .
call the method self._lock [ self . _lock ] , with the result ,
try ,
call the method self.open [ self . open ] , substitute the result for stream_created .
for every message in email_messages ,
call the method self.write_message [ self . write_message ] with argument message .
call the method self.stream.flush [ self . stream . flush ] .
increment msg_count by one .
if stream_created is true ,
call the method self.close [ self . close ] .
if Exception exception is caught ,
if self.fail_silently [ self . fail_silently ] is boolean False ,
raise an exception .
return msg_count .
from django.core.mail.backends.base [ django . core . mail . backends . base ] import BaseEmailBackend into default name space .
derive the class EmailBackend from the BaseEmailBackend base class .
define the method send_messages with arguments self and email_messages .
create list out of email_messages , return the length of the list .
import module datetime .
import module os .
from django.conf [ django . conf ] import settings into default name space .
from django.core.exceptions [ django . core . exceptions ] import ImproperlyConfigured into default name space .
from django.core.mail.backends.console [ django . core . mail . backends . console ] import EmailBackend as ConsoleEmailBackend into default name space .
from django.utils [ django . utils ] import six into default name space .
derive the class EmailBackend from the ConsoleEmailBackend base class .
define the __init__ method with arguments : self , unpacked list args and unpacked dictionary kwargs .
self._fname [ self . _fname ] is None .
if _STR:0_ is contained in kwargs ,
pop the value under the _STR:0_ key of kwargs dictionary , substitute it for self.file_path [ self . file_path ] .
if not ,
get _STR:0_ from the settings , if it exists , substitute it for self.file_path [ self . file_path ] , if not substitute None for self.file_path [ self . file_path ] .
if self.file_path [ self . file_path ] is not an instance of six.string_types [ six . string_types ] ,
raise an ImproperlyConfigured exception with argument string _STR:0_ , replace _STR:1_ with self.file_path [ self . file_path ] .
call the os.path.abspath [ os . path . abspath ] with argument self.file_path [ self . file_path ] , substitute the result for self.file_path [ self . file_path ] .
if self.file_path [ self . file_path ] file path exists and it is not a directory ,
raise an ImproperlyConfigured exception with argument string _STR:0_ , replace ' % s ' with self.file_path [ self . file_path ] .
otherwise if self.file_path [ self . file_path ] file path doesnt exists ,
try ,
call the os.makedirs [ os . makedirs ] with argument self.file_path [ self . file_path ] .
if OSError , renamed to err , is caught ,
raise an ImproperlyConfigured exception with argument string _STR:0_ ,
replace ' % s ' with self.file_path [ self . file_path ] and err , respectively . if self.file_path [ self . file_path ] file is not writable ,
raise an ImproperlyConfigured exception with argument string _STR:0_ , replace ' % s ' with self.file_path [ self . file_path ] .
set value under the _STR:0_ key of kwargs dictionary to None .
call the __init__ method of the base class of the EmailBackend class with arguments : unpacked list args and unpacked dictionary kwargs .
define the method write_message with arguments self and message .
call the as_bytes method on the return value of the message.message [ message . message ] method append to it _STR:0_ character , use it as the argument for the call to the self.stream.write [ self . stream . write ] method .
write 79 _STR:0_ characters into self.stream [ self . stream ] file stream .
write a newline character into self.stream [ self . stream ] file stream .
define the method _get_filename with argument self .
if self._fname [ self . _fname ] is None :
call the strftime function with argument string _STR:0_ on the return value of the function datetime.datetime.now [ datetime . datetime . now ] , substitute the result for timestamp .
fname is a string _STR:0_ , with ' % s ' replaced by timestamp and absolute value of the return value of the function id with argument self , respectively .
join self.file_path [ self . file_path ] and fname into a valid file path , substitute it for self._fname [ self . _fname ] .
return self._fname [ self . _fname ] .
define the method open with argument self .
if self.stream [ self . stream ] is None :
open the file in mode _STR:0_ and with file name obtained by calling the self._get_filename [ self . _get_filename ] method .
return boolean True .
return boolean True .
define the method close with argument self .
try ,
if self.stream [ self . stream ] is not None ,
call the self.stream.close [ self . stream . close ] function .
finally perform ,
self.stream [ self . stream ] is None .
from django.core [ django . core ] import mail into default name space .
from django.core.mail.backends.base [ django . core . mail . backends . base ] import BaseEmailBackend into default name space .
derive the class EmailBackend from the BaseEmailBackend base class .
define the method __init__ with arguments : self , unpacked list args and unpacked dictionary kwargs .
call the method __init__ from the base class of EmailBackend class , with arguments : unpacked list args and unpacked dictionary kwargs .
if mail doesnt have an _STR:0_ attribute ,
mail.outbox [ mail . outbox ] is an empty list .
define the method send_messages with arguments self and messages .
msg_count is integer 0 .
for every message in messages ,
call the method message.message [ message . message ] .
increment mes_count by one .
call the method mail.outbox.extend [ mail . outbox . extend ] with messages .
return msg_count .
import module smtplib .
import module ssl .
import module threading .
from django.conf [ django . conf ] import settings into default name space .
from django.core.mail.backends.base [ django . core . mail . backends . base ] import BaseEmailBackend into default name space .
from django.core.mail.utils [ django . core . mail . utils ] import DNS_NAME into default name space .
from django.core.mail.message [ django . core . mail . message ] import sanitize_address into default name space .
derive the class EmailBackend from the BaseEmailBackend base class .
define the method __init__ with arguments : self , host set to None , port set to None , username set to None , password set to None ,
use_tls set to None , fail_silently set to False , use_ssl set to None , timeout set to None and unpacked dictionary kwargs . call the __init__ method from the base class of the EmailBackend class with argument fail_silently set to fail_silently .
if host exists substitute it for self.host [ self . host ] , if not substitute settings.EMAIL_HOST [ settings . EMAIL_HOST ] for self.host [ self . host ] .
if port exists substitute it for self.host [ self . host ] , if not substitute settings.EMAIL_PORT [ settings . EMAIL_PORT ] for self.port [ self . port ] .
if username is None substitute settings.EMAIL_HOST_USER [ settings . EMAIL_HOST_USER ] for self.username [ self . username ] , if not substitute username for self.username [ self . username ] .
if password is None substitute settings.EMAIL_HOST_PASSWORD [ settings . EMAIL_HOST_PASSWORD ] for self.username [ self . username ] , if not substitute password for self.password [ self . password ] .
if use_tls is None substitute settings.EMAIL_USE_TLS [ settings . EMAIL_USE_TLS ] for self.username [ self . username ] , if not substitute use_tls for self.use_tls [ self . use_tls ] .
if use_ssl is None substitute settings.EMAIL_USE_SSL [ settings . EMAIL_USE_SSL ] for self.username [ self . username ] , if not substitute use_ssl for self.use_ssl [ self . use_ssl ] .
substitute timeout for self.timeout [ self . timeout ] .
if self.use_ssl [ self . use_ssl ] and self.use_tls [ self . use_tls ] are boolean True ,
raise an ValueError exception with argument string _STR:0_ .
self.connection [ self . connection ] is None .
call the method threading.RLock [ threading . RLock ] , substitute the result for self._lock [ self . _lock ] .
define the method open with argument self .
if self.connection [ self . connection ] is true ,
return boolean False ,
substitute smtplib.SMTP_SSL [ smtplib . SMTP_SSL ] for connection_class if self.use_ssl [ self . use_ssl ] is true , if not substitute smtplib.SMTP [ smtplib . SMTP ] for connection_class .
connection_params is a dictionary with 1 initial entry : return value of the function DNS_NAME.get_fqdn [ DNS_NAME . get_fqdn ] for _STR:0_ .
if self.timeout [ self . timeout ] is not None ,
set value under the _STR:0_ key of the connection_params to self.timeout [ self . timeout ] .
try ,
self.connection [ self . connection ] is a instance of a class contained in connection_class , instantiated with arguments : self.host [ self . host ] , self.port [ self . port ] ,
and unpacked dictionary connection_params . if self.use_ssl [ self . use_ssl ] and self.use_tls [ self . use_tls ] are false ,
call the method self.connection.ehlo [ self . connection . ehlo ] .
call the method self.connection.starttls [ self . connection . starttls ] .
call the method self.connection.ehlo [ self . connection . ehlo ] .
if self.username [ self . username ] and self.password [ self . password ] are true ,
call the method self.connection.login [ self . connection . login ] with arguments self.username [ self . username ] and self.password [ self . password ] .
return boolean True .
if smtplib.SMTPException [ smtplib . SMTPException ] exception is caught ,
if self.fail_silently [ self . fail_silently ] is boolean False ,
raise an exception .
define the method close with argument self .
if self.connection [ self . connection ] is None ,
return nothing .
try ,
try ,
call the method self.connection.quit [ self . connection . quit ] .
if ssl.SSLError [ ssl . SSLError ] or smtplib.SMTPServerDisconnected [ smtplib . SMTPServerDisconnected ] exception occurred ,
call the method self.connection.close [ self . connection . close ] .
if smtplib.SMTPException [ smtplib . SMTPException ] exception is caught ,
if self.fail_silently [ self . fail_silently ] is boolean True ,
return nothing .
raise an exception .
finally perform ,
self.connection [ self . connection ] is None .
define the method send_messages with arguments self and email_message .
if email_messages is false ,
return nothing .
call the method self._lock [ self . _lock ] , with the return value ,
call the method self.open [ self . open ] , substitute the result for the new_conn_created .
if self.connection [ self . connection ] is false ,
return nothing .
num_sent is an integer 0 .
for every message in email_messages :
call the method self._send [ self . _send ] with argument message , substitute the result for sent .
if sent is true ,
increment num_sent by one .
if new_conn_created is true ,
call the self.close [ self . close ] method .
return num_sent .
define the method _send with arguments self and email_message .
call the email_message.recipients [ email_message . recipients ] method , if it evaluates to false ,
return boolean False .
call the function sanitize_address with arguments email_message.from_email [ email_message . from_email ] and email_message.encoding [ email_message . encoding ] , substitute the result for from_email .
call the function sanitize_address with arguments addr and email_message.encoding [ email_message . encoding ] , for every addr in return value of the function email_message.recipients [ email_message . recipients ] , store the results in a recipients list .
call the function email_message.message [ email_message . message ] , substitute the result for message .
try ,
call the method self.connection.sendmail [ self . connection . sendmail ] with arguments : from_email , recipients and return value of the function message.as_bytes [ message . as_bytes ] .
if smtplib.SMTPException [ smtplib . SMTPException ] exception is caught ,
if self.fail_silently [ self . fail_silently ] is false ,
raise an exception .
return boolean False .
return boolean True .
from __future__ import unicode_literals into default name space .
import module mimetypes .
import module os .
import module random .
import module sys .
import module time .
from email import charset as Charset , encoders as Encoders , message_from_string and generator .
from email.message [ email . message ] import Message into default name space .
from email.mime.text [ email . mime . text ] import MIMEText into default name space .
from email.mime.multipart [ email . mime . multipart ] import MIMEMultipart into default name space .
from email.mime.base [ email . mime . base ] import MIMEBase into default name space .
from email.mime.message [ email . mime . message ] import MIMEMessage into default name space .
from email.header [ email . header ] import Header into default name space .
from email.utils [ email . utils ] import formatdate , getaddresses , formataddr and parseaddr into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.core.mail.utils [ django . core . mail . utils ] import DNS_NAME into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_text into default name space .
from django.utils [ django . utils ] import six into default name space .
call the function Charset.Charset [ Charset . Charset ] with argument string _STR:0_ , substitute the result for utf8_charset .
utf8_charset.body_encoding [ utf8_charset . body_encoding ] is None .
DEFAULT_ATTACHMENT_MIME_TYPE is a string _STR:0_ .
derive the class BadHeaderError from the ValueError base class .
do nothing .
define the function make_msgid with argument idstring set to None .
call the function time.time [ time . time ] , substitute the result for timeval .
call the function time.gmtime [ time . gmtime ] with argument timeval , use string _STR:0_ and the previous result as an argument for the call to the time.strftime [ time . strftime ] function , substitute the result for utcdate .
try ,
call the function os.getpid [ os . getpid ] , substitute it for pid .
if AttributeError exception is caught ,
pid is integer 1 .
call the function random.randrange [ random . randrange ] with argument integer 100000 , substitute the result for randint .
if idstring is None ,
idstring is an empty string .
if not ,
append idstring to the _STR:0_ character , substitute it for idstring .
substitute DNS_NAME for idhost .
msgid is a string _STR:0_ , replace ' % s ' with utcdate , pid , randint , idstring and idhost , respectively .
return msgid .
ADDRESS_HEADERS is a set containing strings : _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ , _STR:5_ , _STR:6_ , _STR:7_ ,
_STR:0_ , _STR:1_ and _STR:2_ . define the function forbid_multi_line_headers with arguments : name , val and encoding .
if encoding does not exists substitute it for settings.DEFAULT_CHARSET [ settings . DEFAULT_CHARSET ] .
call the function force_text with argument val , substitute it for val .
if characters _STR:0_ or _STR:1_ are contained in val ,
raise an BadHeaderError exception with argument string _STR:0_ ,
where _STR:0_ are replaced by val and name , respectively . try ,
call the method val.encode [ val . encode ] with argument string _STR:0_ .
if UnicodeEncodeError exception is caught ,
convert name to lower case , if it is contained in ADDRESS_HEADERS , s
call the function sanitize_address with arguments addr and encoding , for every addr in return value of the getadresses function with tuple containing val as argument , join all the results into a string separated by _STR:0_ , substitute the result for val .
if not ,
call the encode function on the Header class instance , created with arguments val and encoding , substitute the result for val .
if not ,
if name converted to lower case equals to string _STR:0_ ,
call the encode function on the Header class instance , created with argument val , substitute the result for val .
return name converted to a string and val .
define the function sanitize_address with arguments addr and encoding .
if addr is a instance of six.string_types [ six . string_types ] ,
call the parseaddr function with return value of the force_text with argument addr , as argument , substitute the result for addr .
nm and addr are addr .
try ,
call the encode function on the Header class instance , created with arguments nm and encoding , substitute the result for nm .
if UnicodeEncodeError exception is caught ,
call the encode function on the Header class instance , created with arguments nm and string _STR:0_ , substitute the result for nm .
try ,
call the addr.encode [ addr . encode ] method with string _STR:0_ as an argument .
if UnicodeEncodeError exception is caught ,
if character _STR:0_ is contained in addr ,
call the addr.split [ addr . split ] method with character _STR:0_ and integer 1 as arguments , substitute the result for localpart and domain , respectively .
instantiate Header class with localpart and encoding , convert it to a string , substitute the result for localpart .
call the decode function with argument string _STR:0_ on the return value of the method domain.encode [ domain . encode ] with argument string _STR:1_ substitute the result for domain .
join localpart and domain in a string separated by _STR:0_ character , substitute it for addr .
if not ,
call the encode function on the Header class instance , created with arguments addr and encoding , substitute the result for addr .
call the formataddr function with argument tuple containing 2 elements nm and addr .
derive the class MIMEMixin .
define the method as_string with arguments self and unixfrom set to boolean False .
fp is a instance of a class six.StringIO [ six . StringIO ] .
g is an instance of a class generator.Generator [ generator . Generator ] called with fp and mangle_from_ set to False .
call the method g.flatten [ g . flatten ] with arguments self and unixfrom set to unixfrom .
call the method fp.getvalue [ fp . getvalue ] , return the result .
if six.PY2 [ six . PY2 ] is boolean True ,
substitute as_string for as_bytes .
if not ,
define the method as_bytes with arguments self and unixfrom set to boolean False .
fp is a instance of a class six.BytesIO [ six . BytesIO ] .
g is an instance of a class generator.BytesGenerator [ generator . BytesGenerator ] called with fp and mangle_from_ set to False .
call the method g.flatten [ g . flatten ] with arguments self and unixfrom set to unixfrom .
call the method fp.getvalue [ fp . getvalue ] , return the result .
derive the class SafeMIMEMessage from the MIMEMixin and MIMEMessage base class .
define the method __setitem__ with arguments self , name and val .
call the function forbid_multi_line_headers with 3 arguments : name , val and string _STR:0_ , substitute the result for name and val , respectively .
call the method MIMEMessage.__setitem__ [ MIMEMessage . __setitem__ ] with arguments self , name and val .
derive the class SafeMIMEText from the MIMEMixin and MIMEText base class .
define the __init__ method with arguments : self , text , subtype and charset .
substitute charset for self.encoding [ self . encoding ] .
if charset equals to string _STR:0_ ,
call the method MIMEText.__init__ [ MIMEText . __init__ ] with 4 arguments : self , text , subtype and None .
delete the value under the _STR:0_ key of self dictionary .
if integers 3 and 2 in a tuple are smaller than the sys.version_info [ sys . version_info ] and sys.version_info [ sys . version_info ] is smaller than integers 3,4 and 4 in a tuple , respectively ,
call the method text.encode [ text . encode ] with argument utf8_charset.output_charset [ utf8_charset . output_charset ] , substitute the result for payload .
call the method payload.decode [ payload . decode ] with 2 arguments : string _STR:0_ and string _STR:1_ , substitute the result for self._payload [ self . _payload ] .
call the method self.set_charset [ self . set_charset ] with utf8_charset as an argument .
if not ,
call the method payload.decode [ payload . decode ] with 2 arguments : text and utf8_charset , substitute the result for self._payload [ self . _payload ] .
call the method self.replace_header [ self . replace_header ] with argument string _STR:0_ , _STR:1_ , where ' % s ' symbols are replaced by :
subtype and charset , respectively . if not ,
call the method MIMEText.__init__ [ MIMEText . __init__ ] with 4 arguments : self , text , subtype and charset .
define the method __setitem__ with arguments self , name and val .
call the function forbid_multi_line_headers with 3 arguments : name , val and self.encoding [ self . encoding ] , substitute the result for name and val , respectively .
call the method MIMEText.__setitem__ [ MIMEText . __setitem__ ] with arguments self , name and val .
derive the class SafeMIMEMultipart from the MIMEMixin and MIMEMultipart base class .
define the method __init__ with 6 arguments : self , _subtype set to string _STR:0_ , boundary set to None , _subparts set to None ,
encoding set to None and unpacked dictionary _params . substitute encoding for self.encoding [ self . encoding ] .
call the method MIMEMultipart.__init__ [ MIMEMultipart . __init__ ] with 5 arguments : self , _subtype , boundary , _subparts and unpacked dictionary _params .
define the method __setitem__ with arguments self , name and val .
call the function forbid_multi_line_headers with 3 arguments : name , val and self.encoding [ self . encoding ] , substitute the result for name and val , respectively .
call the method MIMEMultipart.__setitem__ [ MIMEMultipart . __setitem__ ] with arguments self , name and val .
derive the class EmailMessage from the object base class .
content_subtype is a string _STR:0_ .
mixed_subtype is a string _STR:0_ .
encoding is None .
define the method __init__ with 10 arguments : self , subject set to an empty string , body set to an empty string ,
if to is true ,
if to is not an six.string_types [ six . string_types ] instance raise an error with message string _STR:0_ .
put to into a list , assign it to self.to [ self . to ] .
if not ,
self.to [ self . to ] is an empty list .
if cc is true ,
if cc is not an six.string_types [ six . string_types ] instance raise an error with message string _STR:0_ .
put cc into a list , assign it to self.cc [ self . cc ] .
if not ,
self.cc [ self . cc ] is an empty list .
if bcc is true ,
if bcc is not an six.string_types [ six . string_types ] instance raise an error with message string _STR:0_ .
put bcc into a list , assign it to self.bcc [ self . bcc ] .
if not ,
self.bcc [ self . bcc ] is an empty list .
if from_email exists substitute from_email for self.from_email [ self . from_email ] , if not substitute settings.DEFAULT_FROM_EMAIL [ settings . DEFAULT_FROM_EMAIL ] for self.from_email [ self . from_email ] .
substitute subject for self.subject [ self . subject ] .
substitute body for self.body [ self . body ] .
if attachments exists substitute it for self.attachments [ self . attachments ] , if not attachments is an empty list .
if headers exists substitute it for self.extra_headers [ self . extra_headers ] , if not extra_headers is an empty dictionary .
substitute connection for self.connection [ self . connection ] .
define the method get_connection with arguments self and fail_silently set to boolean False .
from django.core.mail [ django . core . mail ] import get_connection into default name space .
if self.connection [ self . connection ] is false ,
call the function get_connection with argument fail_silently set to fail_silently , substitute it for self.connection [ self . connection ] .
return self.connection [ self . connection ] .
define the method message with argument self .
if self.encoding [ self . encoding ] exists substitute it for encoding , if not substitute settings.DEFAULT_CHARSET [ settings . DEFAULT_CHARSET ] for encoding .
msg is a instance of a SafeMIMEText class created with arguments : self.body [ self . body ] , self.content_subtype [ self . content_subtype ] and encoding .
call the self._create_message [ self . _create_message ] method with argument msg , substitute it for msg .
substitute self.subject [ self . subject ] for value under the _STR:0_ key of msg dictionary .
call the method self.extra_headers.get [ self . extra_headers . get ] with string _STR:0_ and self.from_email [ self . from_email ] as arguments , substitute the result for value under the _STR:0_ key of msg dictionary .
call the method self.extra_headers.get [ self . extra_headers . get ] with arguments : string _STR:0_ and joined string from self.to [ self . to ] elements separated by _STR:1_ ,
substitute the result for value under the _STR:0_ key of msg dictionary . if self.cc [ self . cc ] is true ,
join elements of self.cc [ self . cc ] into a string separated by _STR:0_ , substitute the result for value under the _STR:1_ key of msg dictionary .
call the key.lower [ key . lower ] method for every key in self.extra_headers [ self . extra_headers ] , join the results into a header_names .
if _STR:0_ is not in header_names ,
call the formatdate function , substitute it for value under the _STR:0_ key of msg dictionary .
if message-id ' is not in header_names ,
call the make_msgid function , substitute it for value under the _STR:0_ key of msg dictionary .
for every name and value in return value of the method self.extra_headers.items [ self . extra_headers . items ] ,
convert name to lower case if it equals to string _STR:0_ or 'to ,
skip this loop execution ,
substitute value for value under name key of msg dictionary .
return msg .
define the method recipients with argument self .
add together self.to [ self . to ] , self.cc [ self . cc ] and self.bcc [ self . bcc ] , return the result .
define the method send with arguments self and fail_silently set to boolean False .
call the method self.recipients [ self . recipients ] , if it evaluates to false ,
return an integer 0 .
call the method self.get_connection [ self . get_connection ] with argument fail_silently , on the result call the method send_messages with one argument : list containing self , return the result .
define the method attach with 4 arguments : self , filename set to None , content set to None and mimetype set to None .
if filename is an instance of MIMEBase ,
if content is not None raise an error .
if mimetype is not None raise an error .
append filename to the self.attachments [ self . attachments ] list .
if not ,
if content is not None raise an error .
append a tuple containing 3 elements : filename , content , mimetype to self.attachments [ self . attachments ] list .
define the method attach_file with arguments self , path and mimetype set to None .
call the os.path.basename [ os . path . basename ] with path as argument , substitute the result for filename .
open file named path in _STR:0_ mode , with file descriptor as f ,
read the whole file f , substitute the result for content .
call the method self.attach [ self . attach ] with arguments filename , content and mimetype .
define the method _create_message with arguments self and msg .
call the method self._create_attachments [ self . _create_attachments ] with argument msg , return the result .
define the method _create_attachments with arguments self and msg .
if self.attachments [ self . attachments ] is true ,
if self.encoding [ self . encoding ] exists substitute it for encoding , if not substitute settings.DEFAULT_CHARSET [ settings . DEFAULT_CHARSET ] for encoding .
substitute msg for body_msg .
msg is an instance of a class SafeMIMEMultipart , created with arguments : _subtype set to self.mixed_subtype [ self . mixed_subtype ] and encoding set to encoding .
if self.body [ self . body ] is true ,
call the method msg.attach [ msg . attach ] with an argument body_msg .
for every attachment in self.attachments [ self . attachments ] ,
if attachment is an instance of MIMEBase ,
call the method msg.attach [ msg . attach ] with an argument attachment .
if not ,
call the method self._create_attachment [ self . _create_attachment ] with an unpacked list attachment as an argument , use the result as an argument for the call to the msg.attach [ msg . attach ] method .
return msg .
define the method _create_mime_attachment with arguments self , content and mimetype .
call the method mimetype.split [ mimetype . split ] with arguments : character _STR:0_ and integer 1 , substitute the result for basetype and subtype , respectively .
if basetype equals a string _STR:0_ ,
if self.encoding [ self . encoding ] exists substitute it for encoding , if not substitute settings.DEFAULT_CHARSET [ settings . DEFAULT_CHARSET ] for encoding .
attachment is an instance of a class SafeMIMEText , created with arguments : content , subtype and encoding .
otherwise if basetype equals a string _STR:0_ and subtype equals a string _STR:1_ ,
if content is an instance of a EmailMessage class ,
call the method content.message [ content . message ] , substitute the result for content .
otherwise if content is not an instance of Message class ,
call the message_from_string function with an argument content , substitute the result for content .
attachment is an instance of a class SafeMIMEMessage , created with the arguments content and subtype .
if not ,
attachment is an instance of a class MIMEBase , created with the arguments basetype and subtype .
call the method attachment.set_payload [ attachment . set_payload ] with an argument content .
call the method Encoders.encode_base64 [ Encoders . encode_base64 ] with an argument attachment .
return attachment .
define the method _create_attachment with 4 arguments : self , filename , content and mimetype set to None .
if mimetype is None ,
call the mimetypes.guess_type [ mimetypes . guess_type ] with an argument filename , assign the result to the mimetype and _ , respectively .
if mimetype is None ,
substitute DEFAULT_ATTACHMENT_MIME_TYPE for mimetype .
call the method self._create_mime_attachment [ self . _create_mime_attachment ] with the arguments content and mimetype , substitute the result for attachment .
if filename is true ,
try ,
call the method filename.encode [ filename . encode ] with an argument string _STR:0_
if UnicodeEncodeError exception is caught ,
if six.PY2 [ six . PY2 ] is true ,
call the method filename.encode [ filename . encode ] with an argument string _STR:0_ , substitute the result for filename .
filename is a tuple containing 3 initial elements : string _STR:0_ , and empty string and filename .
call the method attachment.add_header [ attachment . add_header ] with 3 arguments : string _STR:0_ , string _STR:1_ and filename set to filename .
return attachment .
derive the class EmailMultiAlternatives from the EmailMessage base class .
alternative_subtype is a string _STR:0_ .
define the method __init__ with 11 arguments : self , subject set to an empty string , body set to an empty string ,
call the method __init__ from the base class of the EmailMultiAlternatives class , with 9 arguments : subject , body , from_email , to ,
bcc , connection , attachments , headers and cc . if alternatives exists substitute it for self.alternatives [ self . alternatives ] , if not self.alternatives [ self . alternatives ] is an empty list .
define the method attach_alternative with arguments self , content and mimetype .
if content is None , raise an error .
if mimetype is None , raise an error .
append a tuple containing 2 elements : content and mimetype , to the self.alternatives [ self . alternatives ] list .
define the method _create_message with arguments self and msg .
call the method self._create_alternatives [ self . _create_alternatives ] with an argument msg , use it as an argument for the call to the self._create_attachments [ self . _create_attachments ] method , return the result .
define the method _create_alternatives with arguments self and msg .
if self.encoding [ self . encoding ] exists substitute it for encoding , if not substitute settings.DEFAULT_CHARSET [ settings . DEFAULT_CHARSET ] for encoding .
if self.alternatives [ self . alternatives ] is true ,
substitute msg for body_msg .
msg is an instance of a class SafeMIMEMultipart , created with the arguments : _subtype set to self.alternative_subtype [ self . alternative_subtype ] and encoding set to encoding .
if self.body [ self . body ] is true ,
call the msg.attach [ msg . attach ] with an argument body_msg .
for every alternative in self.alternatives [ self . alternatives ] ,
call the method self._create_mime_attachment [ self . _create_mime_attachment ] with unpacked list alternative as an argument , use the result as an argument for the call to the msg.attach [ msg . attach ] method .
return msg .
import module socket .
derive class CachedDnsName from the object base class .
define the method __str__ with argument self .
evaluate the self.get_fqdn [ self . get_fqdn ] method , return the result .
define the method get_fqdn with argument self .
if self doesnt have an attribute _STR:0_ ,
call the function socket.getfqdn [ socket . getfqdn ] , substitute the result for self._fqdn [ self . _fqdn ] .
return self._fqdn [ self . _fqdn ] .
DNS_NAME is a instance of CachedDnsName class .
from __future__ import unicode_literals into default name space .
import module collections .
from importlib import import_module into default name space .
import module os .
import module sys .
import module django .
from django.apps [ django . apps ] import apps into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.core.exceptions [ django . core . exceptions ] import ImproperlyConfigured into default name space .
from django.core.management.base [ django . core . management . base ] import BaseCommand , CommandError , CommandParser and handle_default_options into default name space .
from django.core.management.color [ django . core . management . color ] import color_style into default name space .
from django.utils [ django . utils ] import lru_cache into default name space .
from django.utils [ django . utils ] import six into default name space .
define the function find_commands with an argument management_dir .
join management_dir and string _STR:0_ into a file path name , substitute it for command_dir .
try ,
for every f in return value of the os.listdir [ os . listdir ] function called with an argument command_dir , append f without 3 last elements to a list , only if f doesnt start with character _STR:0_ and doesnt ends with string _STR:1_ , return the resulting list .
if OSError exception is caught ,
return an empty list .
define the function load_command_class with arguments : app_name and name .
replace ' % s ' in string _STR:0_ with app_name and name , respectively , use it as an result for the call to the
import_module function , substitute the result for module . return an instance of the module.Command [ module . Command ] class .
decorator lru_cache.lru_cache [ lru_cache . lru_cache ] with an argument maxsize set to None .
define the function get_commands .
commands is an dictionary containing elements : string _STR:0_ for every name in the function find_commands return value , called with first element of __path__ as an argument .
if settings.configured [ settings . configured ] is false ,
return commands .
for every app_config in reversed list created out of the return value of the function apps.get_app_configs [ apps . get_app_configs ] ,
join app_config.path [ app_config . path ] and string _STR:0_ into a file path , substitute it for path .
call the method commands.update [ commands . update ] , with an argument dictionary containing entries : app_config_name for name , for every name in return value of the function find_commands , called with an argument path .
return commands .
define the function call_command with 3 arguments : name , unpacked list args and unpacked dictionary options .
try ,
call the function get_commands , substitute the value under the name key of the return value , for app_name .
if KeyError exception is caught ,
raise an CommandError exception with an argument string _STR:0_ , with _STR:1_ replaced by name .
if app_name is an instance of BaseCommand ,
substitute app_namefor command .
if not ,
call the function load_command_class with arguments : app_name and name , substitute the result for command .
all the method command.create_parser [ command . create_parser ] with arguments : empty and name , substitute the result for parser .
if command.use_argparse [ command . use_argparse ] is true ,
call the method parser.parse_args [ parser . parse_args ] with an argument args set to args , substitute the result for defaults .
create dictionary out of the unpacked dictionary options , using defaults._get_kwargs [ defaults . _get_kwargs ] as a mapping function , substitute the result for defaults .
if not ,
call the method parser.parse_args [ parser . parse_args ] with an arguments args set to an empty list , assign the result for defaults and _ , respectively .
create dictionary out of the unpacked dictionary options , using defaults.__dict__ [ defaults . __dict__ ] as a mapping function , substitute the result for defaults .
call the command.execute [ command . execute ] method with arguments : unpacked list args and unpacked dictionary defaults , return the result .
derive the class ManagementUtility from object base class .
define the method __init__ with arguments : self class instance and argv set to None .
if argv is true , substitue it for self.argv [ self . argv ] , if not substitute sys.argv [ sys . argv ] for self.argv [ self . argv ] .
call the function os.path.basename [ os . path . basename ] with first element of self.argv [ self . argv ] as an argument , substitute the result for self.prog_name [ self . prog_name ] .
self.settings_exception [ self . settings_exception ] is None .
define the method main_help_text with arguments : self class instance and commands_only set to boolean False .
if commands_only is true ,
call the function get_commands , call the method keys on the result , substitute sorted result for usage .
if not ,
usage is a list containing 4 entries : an empty string , string _STR:0_ ,
where ' % s ' is replaced with self.prog_name [ self . prog_name ] , an empty string and string _STR:0_ . call the method collections.defaultdict [ collections . defaultdict ] with a argument : lambda function without arguments that returns an empty list ,
substitute the result for commands_dict . for every name and app in return value of the function six.iteritems [ six . iteritems ] calle with return argument of function get_commands as an arugment ,
if app equals a string _STR:0_ ,
app is a string _STR:0_
if not ,
call the method app.rpartition [ app . rpartition ] with an argument _STR:0_ , substitute last element of the result for app .
append name to the value of under the app key of the commands_dict .
call the color_style function , substitute the result for style .
for every app in sorted return value of the commands_dict.keys [ commands_dict . keys ] function ,
append an empty string to usage .
call the style.NOTICE [ style . NOTICE ] method with an argument string _STR:0_ , where ' % s ' is replaced with app , append the result to usage .
for every name in sorted value under the app key of the commands_dict dictionary ,
append string _STR:0_ , where ' % s ' is replaced by name to the usage .
if self.settings_exception [ self . settings_exception ] is not None ,
call the method style.NOTICE [ style . NOTICE ] with an argument string _STR:0_ , where ' % s ' is replaced by self.settings_exception [ self . settings_exception ] , append the result to usage .
join usage elements in a string separated by newline characters , return it .
define the method fetch_command , with arguments self and subcommand .
call the function get_commands , substitute it for commands .
try ,
substitute value under the subcommand key of the commands dictionary for app_name .
if KeyError exception is caught ,
call settings.INSTALLED_APPS [ settings . INSTALLED_APPS ] .
call the method sys.stderr.write [ sys . stderr . write ] with an argument string _STR:0_ ,
where _STR:0_ is replaced with subcommand and ' % s ' is replaced with self.prog_name [ self . prog_name ] . call the function sys.exit [ sys . exit ] with an argument integer 1 .
if app_name is an instance of BaseCommands .
substitute app_name for klass .
if not ,
call the function load_command_class with arguments app_name and subcommand , substitute the result for klass .
return klass .
define the method autocomplete with an argument self .
if string _STR:0_ is not contained in os.environ [ os . environ ] ,
return nothing .
slit by whitespace the value under the _STR:0_ key of the os.environ [ os . environ ] dictionary , substitute the result without the first element for cwords .
convert to an integer value under the _STR:0_ key of the os.environ [ os . environ ] dictionary , substitute it for cword .
try ,
substitute cwords element at the cword decremented by 1 index for curr .
if IndexError exception is caugh ,
curr is an empty string .
call the function get_commands , convert the result to a list , append string _STR:0_ to it , substitute it for subcommands .
options is a list containing a tuple with 2 entries : string _STR:0_ and None .
if cword equlals a integer 1 ,
filter all the subcommands element through the lambda function with an argument x , that evaluates the method x.startswith [ x . startswith ] ,
with an argument curr , sort the result and join it in a list separated with blank spaces , print it to the standard output . otherwise if first element of cwords is contanied in subcommands and is not equal to string _STR:0_ ,
call the method self.fetch_command [ self . fetch_command ] with first element of cwords as an argument , substitute it for subcommand_cls .
if first element of cwords equals a string _STR:0_ ,
from django.core.servers.fastcgi [ django . core . servers . fastcgi ] import FASTCGI_OPTIONS into default namespace ,
append tuple containing two entries : k and integer 1 to options , for every k in FASTCGI_OPTIONS .
otherwise if first element of cwords is contanied in tuple with 8 entries : _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ ,
try ,
call the method apps.get_app_configs [ apps . get_app_configs ] , substitute the result for app_configs .
append tuple containing two entries : app_config.label [ app_config . label ] and integer 0 to options , for every app_config in app_configs .
if ImportError exception is caught ,
do nothing .
call the method subcommand_cls.create_parser [ subcommand_cls . create_parser ] with 2 argument an empty string an first element of cwords , substitute it for parser .
if subcommand_cls.use_argparse [ subcommand_cls . use_argparse ] is true ,
append to options a tuple containing 2 entries : firs element of sorted list of the s_opt.option_strings [ s_opt . option_strings ] ,
and evaluated boolean expression s_opt.nargs [ s_opt . nargs ] doesnt equal to integer 0 , for every s_opt in parser._actions [ parser . _actions ] , only if s_opt.option_strings [ s_opt . option_strings ] is true , if not ,
append to options a tuple containing 2 entries : result of the method s_opt.get_opt_string [ s_opt . get_opt_string ] and s_opt.nargs [ s_opt . nargs ] ,
for every s_opt in parser.option_list [ parser . option_list ] . for every x in slice of cwords from the second element to the element at the cword decremented by 1 index ,
split x by character _STR:0_ and append first element of the result to the prev_opts list . for every opt in options , if first element of opt is not contained in prev_opts , append opt to the list , substitute it for options .
append tuple containing 2 elements : k and v to a list , for every k and v in options , only if k starts with curr ,
sort the result and substitute it for options . for every option in options ,
substitute first element of options for opt_label .
if second element of options is true ,
append _STR:0_ to opt_label .
print opt_label to the standard output .
call the function sys.exit [ sys . exit ] with an integer 1 as an argument .
define the method execute with an argument self ,
try ,
substitute first element of self.argv [ self . argv ] for subcommand .
if IndexError exception is caught ,
subcommand is a string _STR:0_ .
parser is an instance of CommandParser class , created with 3 arguments , None , usage as a string _STR:0_ and add_help set to boolean False .
call the method parser.add_argument [ parser . add_argument ] with an argument string _STR:0_ .
call the method parser.add_argument [ parser . add_argument ] with an argument string _STR:0_ .
call the method parser.add_argument [ parser . add_argument ] with arguments : string _STR:0_ and nargs set to _STR:1_ .
try ,
call the method parser.parse_known_args [ parser . parse_known_args ] wiht an argument self.argv [ self . argv ] , without the first two elements , assign the result for options ,
and args , respectively . call the method handle_default_options with an argument options .
if CommandError exception is caught ,
do nothing .
no_settings_commands is a list containing entries : _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ , _STR:5_ , _STR:6_ ,
_STR:0_ and _STR:1_ . try ,
call the settings.INSTALLED_APPS [ settings . INSTALLED_APPS ] .
if ImproperlyConfigured renamed to exc , exception is caught ,
substitute exc for self.settings_exception [ self . settings_exception ] ,
if subcommand is contained in no_settings_commands ,
call the method settings.configure [ settings . configure ] .
if settings.configured [ settings . configured ] is true ,
call the method django.setup [ django . setup ] .
call the method self.autocomplete [ self . autocomplete ] .
if subcommand equals to a string _STR:0_ .
if string _STR:0_ is contained in args ,
call the method self.main_help_text [ self . main_help_text ] with an argument commands_only set to boolean True , append new line to it , write it to sys.stdout [ sys . stdout ] .
otherwise , length of options.args [ options . args ] is lesser than integer 1 ,
call the method self.main_help_text [ self . main_help_text ] append new line to it , write it to sys.stdout [ sys . stdout ] .
if not ,
call the method self.fetch_command [ self . fetch_command ] with first element of options.args [ options . args ] as argument , on the result call the method print_help ,
with 2 arguments : self.prog_name [ self . prog_name ] and first element of options.args [ options . args ] . otherwise if subcommand equals a string _STR:0_ or self.argv [ self . argv ] , without the first element equals a list containing a string _STR:1_
call the method django.get_version [ django . get_version ] append new line to it , write it to sys.stdout [ sys . stdout ] .
if self.argv [ self . argv ] , without the first element is contained in a tuple with 2 entries : a list containing a string _STR:0_ ,
and a list containing a string _STR:0_ , call the method self.main_help_text [ self . main_help_text ] , append new line to it , write it to sys.stdout [ sys . stdout ] .
if not ,
call the method self.fetch_command [ self . fetch_command ] with an argument command , call the method run_from_argv on the result with an argument self.argv [ self . argv ] .
define the function execute_from_command_line with an argument argv set to None .
utility is a instance of ManagementUtility class , created with an argument argv .
call the method utility.execute [ utility . execute ] .
from __future__ import unicode_literals into default name space .
import module os .
import module sys .
import module warnings .
from argparse import ArgumentParser into default name space .
from optparse import OptionParser into default name space .
import module django .
from django.core [ django . core ] import checks into default name space .
from django.core.exceptions [ django . core . exceptions ] import ImproperlyConfigured into default name space .
from django.core.management.color [ django . core . management . color ] import color_style and no_style into default name space .
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning and RemovedInDjango20Warning into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_st into default name space .
derive the class CommandError from the base class Exception .
do nothing .
derive the CommandParser class from the ArgumentParser base class .
define the method __init__ with arguments : self , cmd and unpacked dictionary kwargs .
substitute cmd for self.cmd [ self . cmd ] .
call the method __init__ from the base class of the CommandParser class , with unpacked dictionary kwargs as argument .
define the method parse_args with 3 arguments : self , args set to None and namespace set to None .
if self.cmd [ self . cmd ] has an attribute _STR:0_ and next statement is not true : args is true or any arg doesnt start with _STR:1_ for arg in args ,
call the method self.error [ self . error ] with an argument self.cmd.missing_args_message [ self . cmd . missing_args_message ] .
call the parse_args method with arguments args and namespace , from the base class of the CommandParser class .
define the method error with arguments self and message .
if self.cmd._called_from_command_line [ self . cmd . _called_from_command_line ] is true ,
call the method error with an argument message , from the base class of the class CommandParser .
if not ,
raise an CommandError exception with an argument string _STR:0_ , with ' % s ' replaced by message .
define the function handle_default_options with an argument options .
if options.settings [ options . settings ] is true ,
substitute options.settings [ options . settings ] for value under the _STR:0_ key of the os.environ [ os . environ ] dictionary .
if options.pythonpath [ options . pythonpath ] is true ,
insert options.pythonpath [ options . pythonpath ] at the beginning of sys.path [ sys . path ] .
derive the OutputWrapper class from the object base class .
define the method __init__ with 4 arguments : self , out , style , func set to None and endings set to newline character .
substitute out for self._out [ self . _out ] .
substitute None for self.style_func [ self . style_func ] .
if out has an _STR:0_ argument and return value of the function out.isatty [ out . isatty ] is true ,
substitute style_func for self.style_func [ self . style_func ] .
substitute ending for self.ending [ self . ending ] .
define the method __getattr__ with arguments self and name .
get name attribute of the self._out [ self . _out ] object , return it .
define the method write with 4 arguments : self , msg , style_func with None and ending set None .
if ending is None substitute self.ending [ self . ending ] for ending .
if ending is true and msg doesnt end with ending ,
append ending to msg .
if f is not None append it to a list for every f in tuple containing 3 elements : style_func , self.style_func [ self . style_func ] ,
and lambda function returning x for x , substitute the firs element of resulting list for style_func . call the function style_func with an argument msg , use the result as an argument for the call to the function force_str ,
use the result as an argument for the call to the function self._out.write [ self . _out . write ] . derive the BaseCommand class from the object base class .
options_list is an empty tuple .
help is an empty string .
args is an empty string .
_called_from_command_line is boolean False .
can_import_settings is boolean True .
output_transaction is boolean False .
leave_locale_alone is boolean False .
define the method __init__ with an argument self .
call the function color_style , substitute the result for self.style [ self . style ] .
if self has an _STR:0_ attribute , has_old_option is boolean True , otherwise it is boolean False .
if self has an _STR:0_ attribute , has_new_option is boolean True , otherwise it is boolean False .
if has_old_option is true ,
call the function warnings.warn [ warnings . warn ] with 2 arguments : string _STR:0_
_STR:0_ and RemovedInDjango19Warning . if has_old_option and has_new_option are both true ,
raise an ImproperlyConfigured exception wiht an argument string _STR:0_
_STR:0_ , replace ' % s ' for self.__class__.__name__ [ self . __class__ . __name__ ] . call the method self.requires_system_checks [ self . requires_system_checks ] with an argument : self.requires_system_checks [ self . requires_system_checks ] if has_new_option is true ,
or if it is false , but has_old_option is true use self.requires_model_validation [ self . requires_model_validation ] , if they are both false use boolean True as an argument . property decorator ,
define the method use_argparse with an argument self ,
convert self.option_list [ self . option_list ] into a boolean , return the inverted value .
define the method get_version with an arguments self .
call the function django.get_version [ django . get_version ] , return the result .
define the method usage with arguments self and subcommand .
substitute ' % s ' in the string _STR:0_ with subcommand and self.args [ self . args ] , respectively , substitute it for usage .
if self.help [ self . help ] is true ,
join usage and self.help [ self . help ] into a string , separated by 2 new line characters , return it .
if not ,
return usage .
define the method create_parser with 3 arguments : self , prog_name and subcommand .
if self.use_argparse [ self . use_argparse ] is false ,
call the function warnings.warn [ warnings . warn ] with 2 arguments : string _STR:0_
_STR:0_ and RemovedInDjango20Warning . parser is an instance of the object OptionParser , created with arguments : prog set to prog_name ,
usage set to return value of the method self.usage [ self . usage ] called with an argument subcommand , version set to return value of the method self.get_version [ self . get_version ] . call the method parser.add_option [ parser . add_option ] with 8 arguments : string _STR:0_ , string _STR:1_ , action set to string _STR:2_ ,
dest set to string _STR:0_ , default set to string _STR:1_ , type set to string _STR:2_ , choices is a list containing elements : _STR:3_ , _STR:1_ , _STR:4_ , _STR:5_ , and help as a string _STR:6_ . call the method parser.add_option [ parser . add_option ] with 2 arguments : string _STR:7_ and help as a string _STR:8_ .
call the method parser.add_option [ parser . add_option ] with 2 arguments : string _STR:0_ and help set to string _STR:1_ .
call the method parser.add_option [ parser . add_option ] with 3 arguments : string _STR:0_ , action set to a string _STR:1_ ,
and help=_STR:0_ . call the method parser.add_option [ parser . add_option ] with 5 arguments : string _STR:1_ , action set to a string _STR:2_ ,
dest set to string _STR:0_ default set to boolean False and help set to a string _STR:1_ . for every opt in self.option_list [ self . option_list ] ,
call the method parser.add_option [ parser . add_option ] with an argument opt .
if not ,
parser is an instance of CommandParser class , created with 3 arguments : self , prog as a string created by joining :
os.path.basename [ os . path . basename ] ( prog_name ) and subcommand , separated by whitespace and description set to self.help [ self . help ] , if exists , or None , otherwise . call the method parser.add_option [ parser . add_option ] with 3 arguments : string _STR:0_ , action set to string _STR:1_ ,
and version set to result of the method self.get_version [ self . get_version ] . call the method parser.add_option [ parser . add_option ] with 8 arguments : string _STR:0_ , string _STR:1_ , action set to string _STR:2_ ,
dest set to string _STR:0_ , default set to string _STR:1_ , type set to int , choices is a list , containing integers : 0 , 1 , 2 and 3 , call the method parser.add_option [ parser . add_option ] with 2 arguments : string _STR:2_ and help as a string _STR:3_
call the method parser.add_option [ parser . add_option ] with 2 arguments : string _STR:0_ and help set to a string _STR:1_
call the method parser.add_option [ parser . add_option ] with 3 arguments : string _STR:0_ , action set to a string _STR:1_ ,
and help set to string _STR:0_ . call the method parser.add_option [ parser . add_option ] with 5 arguments : string _STR:1_ , action is string _STR:2_ , dest is string _STR:3_ ,
default is boolean False , and help is a string _STR:0_ . if self.args [ self . args ] is true ,
call the method parser.add_argument [ parser . add_argument ] with 2 arguments : string _STR:0_ and nargs set to _STR:1_ .
call the method self.add_arguments [ self . add_arguments ] with an argument parser .
return parser
define the method add_arguments with an argument self and parser .
do nothing
define the method print_help with 3 arguments : self , prog_name and subcommand .
call the method self.create_parser [ self . create_parser ] with arguments prog_name and subcommand .
call the method parser.print_help [ parser . print_help ] .
define the method run_from_argv with arguments self and argv .
self._called_from_command_line [ self . _called_from_command_line ] is boolean True .
call the method self.create_parser [ self . create_parser ] with first and second element of argv , substitute the result for parser .
if self.use_argparse [ self . use_argparse ] is true ,
call the method parser.parse_args [ parser . parse_args ] with argv , without the first 2 elements , substitute the result for options .
call the function vars with an argument options , substitute the result for cmd_options .
if _STR:0_ is contained in options ,
substitute options.args [ options . args ] for args .
delete value under the _STR:0_ key of the cmd_options dictionary .
if not ,
args is an empty tuple .
if not ,
call the method parser.parse_args [ parser . parse_args ] with argv , without the first 2 elements , substitute the result for options and args .
call the function vars with an argument options , substitute the result for cmd_options .
call the function handle_default_options with an argument options .
try ,
call the method self.execute [ self . execute ] , with 2 arguments : unpacked list args and unpacked dictionary cmd_options .
if Exception , renamed to e , exception is caught ,
if options.traceback [ options . traceback ] is true or e is not CommandError instance ,
raise an exception .
if it exists , get _STR:0_ attribute of self , substitute it for stderr , if not , stderr is an instance of OutputWrapper class ,
created with arguments sys.stderr [ sys . stderr ] and self.style.ERROR [ self . style . ERROR ] . replace ' % s ' in string _STR:0_ with e.__class__.__name__ [ e . __class__ . __name__ ] and e , respectively , write it to the stderr stream .
call the function sys.exit [ sys . exit ] with an argument integer 1 .
define the method execute with 3 arguments : self , unpacked list args and unpacked dictionary options .
self.stdout [ self . stdout ] is an instance of OutputWrapper class created with an argument : value under the _STR:0_ key of the options dictionary ,
if the key doesnt exists use sys.stdout [ sys . stdout ] as an argument . if value under the _STR:0_ key of the options dictionary .
call the function no_style , substitute the result for self.style [ self . style ] .
self.stderr [ self . stderr ] is an OutputWrapper object instance , created with value under the _STR:0_ key of the options dictionary as an argument ,
if the key doesnt exists use sys.stderr [ sys . stderr ] as an argument . if not ,
self.stderr [ self . stderr ] is an instance of an OutputWrapper object , created with 2 arguments : value under the _STR:0_ key of the options dictionary , if it doesnt exists use the sys.stderr [ sys . stderr ] instead , and self.style.ERROR [ self . style . ERROR ] .
if self.can_import_settings [ self . can_import_settings ] is true ,
from django.conf [ django . conf ] import settings into default namespace ,
saved_locale is None .
if self.leave_locale_alone [ self . leave_locale_alone ] is false ,
if self.can_import_settings [ self . can_import_settings ] is false ,
raise an CommandError exception with an argument string , _STR:0_
_STR:0_ , replace ' % s ' with self.leave_locale_alone [ self . leave_locale_alone ] and self.can_import_settings [ self . can_import_settings ] . from django.utils [ django . utils ] import translation into default namespace .
call the method translation.get_language [ translation . get_language ] , substitute th result for saved_locale .
call the method translation.activate [ translation . activate ] with an argument string _STR:0_ .
try ,
if self.requires_system_checks [ self . requires_system_checks ] is true and values under the _STR:0_ and _STR:1_ keys of the options dictionary are false ,
call the method self.check [ self . check ] ,
call the method self.handle [ self . handle ] with 2 arguments unpacked list args and unpacked dictionary options , substitute the result for output .
if output is true ,
if self.output_transaction [ self . output_transaction ] is true ,
from django.db [ django . db ] import connections and DEFAULT_DB_ALIAS into default namespace .
get the value under the _STR:0_ key of the options dictionary , if it doesnt exists use the DEFAULT_DB_ALIAS to address an element
from the connections list , substitute it for connection . call the method connection.ops.start_transaction_sql [ connection . ops . start_transaction_sql ] , if it evaluates to true ,
call the method connection.ops.start_transaction_sql [ connection . ops . start_transaction_sql ] , use the result as an argument for the call to the method self.style.SQL_KEYWORD [ self . style . SQL_KEYWORD ] ,
write the result to the self.stdout [ self . stdout ] stream . write output to self.stdout [ self . stdout ] stream .
if self.output_transaction [ self . output_transaction ] is true ,
call the method connection.ops.end_transaction_sql [ connection . ops . end_transaction_sql ] , use the result as the argument for the call to the method self.style.SQL_KEYWORD [ self . style . SQL_KEYWORD ] ,
append the result to the _STR:0_ string , write it to self.stdout [ self . stdout ] . finally perform ,
if saved_locale is not None ,
call the method translation.activate [ translation . activate ] with an argument saved_locale .
define the method with 3 arguments : self , app_config set to None and display_num_errors set to boolean False .
if app_config is None ,
app_configs is not None .
if not ,
app_configs is a list containing app_config .
call the method self.check [ self . check ] with 2 arguments app_configs set to app_configs , display_num_errors set to display_num_errors , return the result .
define the method check with 4 arguments : self , app_configs set to None , tags set to None , display_num_errors set to boolean False .
call the method checks.run_checks [ checks . run_checks ] with 2 arguments : app_configs set to app_configs , tags set t tags , substitute the result for all_issues .
msg is an empty string .
visible_issue_count is an integer 0 .
if all_issues is true ,
append e to debugs list for every e in all_issues , if e.level [ e . level ] is lesser than checks.INFO [ checks . INFO ] and result of the method e.is_silenced [ e . is_silenced ] in false .
append e to infos list for every e in all_issues , if checks.INFO [ checks . INFO ] is lesser or equal to e.level [ e . level ] ,
and e.level [ e . level ] is lesser than checks.WARNING [ checks . WARNING ] and result of the method e.is_silenced [ e . is_silenced ] in false . append e to warnings list for every e in all_issues , if checks.WARNING [ checks . WARNING ] is lesser than or equal to e.level [ e . level ] ,
and e.level [ e . level ] is lesser than checks.WARNING [ checks . WARNING ] and result of the method e.is_silenced [ e . is_silenced ] in false . append e to errors list for every e in all_issues , if checks.ERROR [ checks . ERROR ] is lesser than or equal to e.level [ e . level ] ,
and e.level [ e . level ] is lesser than checks.CRITICAL [ checks . CRITICAL ] . append e to criticals list for every e in all_issues , if checks.CRITICAL [ checks . CRITICAL ] is lesser than or equal to e.level [ e . level ] .
sorted_issues is a list of tuples with 5 entries : criticals and _STR:0_ , errors and _STR:1_ , warnings and _STR:2_ ,
infos , _STR:0_ for every issues and group_name in sorted_issues ,
if issues is true ,
increment visible_issue_count for length of issues .
if e.is_serious [ e . is_serious ] method evaluates to true , call the function color_style , on the result call the method ERROR with result of the force_str called with an argument e , if not call the function color_style on the result call the method ERROR with result of the force_str called with an argument e , for every e in issues , formatted is a tuple containing the previous result .
sort elements formatted , join them in the list separated with newline character , substitute the result for formatted .
substitute ' % s ' in the string _STR:0_ , with group_name and formatted , substitute the result for msg .
if msg is true ,
replace ' % s ' in string _STR:0_ with msg , substitute it for msg .
if display_num_errors is true ,
if msg is true ,
append newline character to msg .
append string _STR:0_ to msg , replace first ' % s ' for : string _STR:1_ ,
if visible_issue_count equals to integer 0 , or for string _STR:0_ if visible_issue_count equals integer 1 , or for string _STR:1_ , with ' % s ' replaced by visible_issue_count , subtract visible_issue_count from length of all_issues , and substitute it for second ' % s ' in the stirting string . if any element in the return value of the e.is_serious [ e . is_serious ] method is true , and if return value of the method e.is_silenced [ e . is_silenced ] is false ,
for every e in all_issues , raise an CommandError with argument msg ,
otherwise if msg and visible_issue_count are true ,
write msg to self.stderr [ self . stderr ] stream .
otherwise if msg is true ,
write msg to self.stderr [ self . stderr ] stream .
define the method handle with 3 arguments : self , unpacked args and unpacked dictionary options .
raise an NotImplementedError exception with an argument string _STR:0_ .
derive the AppCommand class from the BaseCommand base class .
missing_args_message is an string _STR:0_ .
define the method add_arguments with self and parser as arguments .
call the method parser.add_argument [ parser . add_argument ] with 4 arguments : string _STR:0_ , metavar set to _STR:1_ , nargs set to _STR:2_ ,
and help set to string _STR:0_ . define the method handle with 3 arguments : self , unpacked list app_labels and unpacked dictionary options .
from django.apps [ django . apps ] import apps into default name space .
try ,
call the method apps.get_app_config [ apps . get_app_config ] with an argument app_lable , for every app_label in app_labels , append the results to app_configs list .
if LookupError or ImportError , renamed to e , exceptions are caught ,
raise an CommandError with an argument string _STR:0_ , with ' % s ' replaced by e .
output is an empty list .
for eery app_config in app_configs ,
call the self.handle_app_config [ self . handle_app_config ] method with app_config and options as arguments , substitute the result for app_output .
if app_output is true ,
append app_output to output .
join elements of output into a string , separated by newline characters , return it .
define the method handle_app_config with 3 arguments : self , app_config and unpacked dictionary options .
try ,
substitute self.handle_app [ self . handle_app ] for handle_app .
if AttributeError exception is caught ,
raise an NotImplementedError with an argument string _STR:0_ .
if not ,
call the function warnings.warn [ warnings . warn ] with 3 argument : string _STR:0_ ,
RemovedInDjango19Warning and stacklevel set to integer 2. if app_config.models_module [ app_config . models_module ] is None ,
raise an CommandError with an argument string _STR:0_ , where ' % s ' is replaced by app_config.label [ app_config . label ] .
call the function handle_app with 2 arguments : app_config.models_module [ app_config . models_module ] and unpacked dictionary options .
derive the LabelCommand class from the BaseCommand base class .
label is a string _STR:0_
substitute string _STR:0_ , with ' % s ' replaced by label , for missing_args_message .
define the method add_arguments with arguments self and parser .
call the method parser.add_argument [ parser . add_argument ] with 3 arguments : string _STR:0_ , metavar set to self.label [ self . label ] and nargs set to _STR:1_ .
define the method handle with 3 arguments : self , unpacked list labels and unpacked dictionary options .
output is an empty list .
for every label in labels ,
call the method self.handle_label [ self . handle_label ] with 2 arguments : label and unpacked dictionary options , substitute the result for label_output .
if label_output is true ,
append label_output to output .
join output into a string , separated by newline characters , return it .
define the method handle_label with 3 arguments : self , label and unpacked dictionary options .
raise an NotImplementedError exception with an argument string _STR:0_ .
derive the NoArgsCommand class from the BaseCommand base class .
args is an empty string .
define the method __init__ with an argument self .
call the function warnings.warn [ warnings . warn ] with 2 arguments : string _STR:0_
_STR:0_ and RemovedInDjango20Warning . call the __init__ method from the base class of the NoArgsCommand class .
define the method handle with 3 arguments : self , unpacked list args and unpacked dictionary options .
if args is true ,
raise an CommandError exception with an argument string _STR:0_ .
call the self.handle_noargs [ self . handle_noargs ] method with with unpacked dictionary options as argument , return the result .
define the method handle_noargs with 2 arguments : self and unpacked dictionary options .
raise an NotImplementedError with an argument string _STR:0_ .
import module os .
import module sys .
from django.utils [ django . utils ] import termcolors into default name space .
define the function supports_color , without arguments .
substitute sys.platform [ sys . platform ] for plat .
evaluate the logic expression , plat does not equals to string _STR:0_ , and plat does not equals to string _STR:1_
or string _STR:0_ is in os.environ [ os . environ ] , substitute the evaluated boolean for supported_platform . if sys.stdout [ sys . stdout ] has an attribute named _STR:1_ and call to the sys.stdout.isatty [ sys . stdout . isatty ] returns boolean True , substitute True for is_a_tty .
if supported_platform is False or is_a_tty is False ,
return boolean False .
return boolean True .
define function color_style , without input arguments .
call the function supports_color , if evaluates to False ,
substitute return value of function no_style for style .
if not ,
get the value under the key _STR:0_ of os.environ [ os . environ ] dictionary , if key doesnt exists return empty string , assign the result to DJANGO_COLORS .
call the function termcolors.parse_color_setting [ termcolors . parse_color_setting ] with DJANGO_COLORS as an argument , assign the result to color_settings .
if color_setting is True ,
define class dummy .
do nothing .
style is an instance of the dummy class .
for every role in termcolors.PALETTES [ termcolors . PALETTES ] list at the index termcolors.NOCOLOR_PALETTE [ termcolors . NOCOLOR_PALETTE ] ,
assign the value of the dictionary color_settings under the key role to format , if key doesnt exist assign the empty dictionary .
sets the role attribute of the style object to the value of the call to the termcolors.make_style [ termcolors . make_style ] function with dictionary format as an argument .
substitute style.ERROR [ style . ERROR ] for style.ERROR_OUTPUT [ style . ERROR_OUTPUT ] .
if not ,
substitute return value of function no_style for style .
return style .
define function no_style , without input arguments .
define class dummy .
define private method __getattr__ with self class instance and attr as the arguments .
create lambda identity function which returns x for input parameter x , return the function .
return an instance of a dummy class .
from __future__ import unicode_literals into default name space .
from django.apps [ django . apps ] import apps into default name space .
from django.core [ django . core ] import checks into default name space .
from django.core.checks.registry [ django . core . checks . registry ] import registry into default name space .
from django.core.management.base [ django . core . management . base ] import BaseCommand and CommandError into default name space .
derive the class Command from the BaseCommand base class .
help is a string _STR:0_ .
requires_system_checks is boolean False .
define the method add_arguments with arguments self and parser .
call the method parser.add_argument [ parser . add_argument ] with 3 arguments : string _STR:0_ , metavar set to string _STR:1_ and nargs set to _STR:2_ .
call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:0_ , string _STR:1_ , action set to string _STR:2_ ,
dest set to string _STR:0_ and help set to string _STR:1_ . call the method parser.add_argument [ parser . add_argument ] with 4 arguments : string _STR:2_ , action set to string _STR:3_ ,
dest set to string _STR:0_ and help set to string _STR:1_ . define method handle with arguments self , unapcked list app_labels and unpacked dictionary options .
if value under the _STR:0_ key of options dictionay is true ,
call the method registry.tags_available [ registry . tags_available ] , sort the result and join it into a string , separate by newlines , write it to self.stdout [ self . stdout ] .
return nothing .
if app_labels is true ,
call the method apps.get_app_config [ apps . get_app_config ] with an argument app_label , for every app_label in app_labels , append the results to a list ,
substitute the resulting list for app_config . if not ,
app_configs is None .
get the value under the _STR:0_ key of the options dictionary , if it exists substitute it for tags , if not , tags is None .
if tags exists and if all elements in the return value of the method checks.tag_exists [ checks . tag_exists ] called with an argument tag ,
for every tag in tags , are false , for every tag in tags , if return value of the method checks.tag_exists [ checks . tag_exists ] called with an argument tag , evaluates to false ,
use tag as an argument to call the iterator method next , substitute the result for invalid_tag . raise an CommandError exception with an argument string _STR:0_ , where ' % s ' is replaced with invalid_tag .
call the method self.check [ self . check ] with arguments : app_configs set to app_configs , tags set to tags , display_num_errors set to boolean True .
from __future__ import unicode_literals into default name space .
import module codecs .
import module glob .
import module os .
from django.core.management.base [ django . core . management . base ] import BaseCommand and CommandError into default name space .
from django.core.management.utils [ django . core . management . utils ] import find_command and popen_wrapper into default name space .
from django.utils._os [ django . utils . _os ] import npath and upath into default name space .
define the function has_bom with fn as argument .
open the file fn in read mode , with file descriptor as f ,
read 4 bytes from file f and store it in sample .
evaluate the boolean expression , if first three characters of sample equals to string of bytes '\xef\xbb\xbf\ ' ,
of if sample starts with codecs.BOM_UTF16_LE [ codecs . BOM_UTF16_LE ] or sample starts with codecs.BOM_UTF16_BE [ codecs . BOM_UTF16_BE ] , return the evaluated boolean expression . define the function is_writable with path as argument ,
try ,
with open file path in append mode ,
call the os.utime [ os . utime ] unction , with path and None as arguments .
if IOError or OSError exceptions occurred ,
return boolean False .
return boolean True .
derive class Command from base class BaseCommand .
help is string _STR:0_ .
requires_system_checks is boolean False .
leave_locale_alone is boolean True .
program is string _STR:0_
program_options is list containing string _STR:0_ .
define method add_arguments with self class instance and parser as arguments .
call the method parser.add_argument [ parser . add_argument ] with string _STR:0_ , string _STR:1_ , dest set to string _STR:2_ , action set to string _STR:3_ ,
default as an empty list and help as an string _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with string _STR:1_ , string _STR:2_ , dest set to string _STR:3_ , action set to string _STR:4_ ,
default as an empty list and help as an string _STR:0_ . define the handle method with self class instance and dictionary **options as arguments .
get the value under the key _STR:0_ of the options dictionary , substitute it for locale .
get the value under the key _STR:0_ of the options dictionary , substitute it for exclude .
get the value under the key _STR:0_ of the options dictionary , convert it to an integer , substitute it for exclude .
if evaluation of the function find_command with self.program [ self . program ] as argument equals to None ,
raise CommandError exception , with sring _STR:0_ as argument , substitute ' % s ' with self.program [ self . program ] .
basedirs is a list containing tuple with strings , _STR:0_ and _STR:1_ .
if value under the _STR:0_ key of os.environ [ os . environ ] dictionary exists .
from django.conf [ django . conf ] import settings into default name space .
call function update with path as the argument , for every path in settings.LOCALE_PATHS [ settings . LOCALE_PATHS ] , extend basedirs list with previous items .
create a list out of basedir elements for which function os.path.isdir [ os . path . isdir ] returns true , apply the os.path.abspath [ os . path . abspath ] function on every element , and put the results in a list , basedir is set of previous list elements .
if basedirs is empty ,
raise CommandError exception with string _STR:0_ , as argument .
all_locales is an empty string .
for every basedir in basedirs ,
locale_dirs is a list of elements from the list of path names that maths the basedir path with _STR:0_ wild card characters for which call to the os.path.isdir [ os . path . isdir ] returned true , assign it to locale_dirs .
extend all_locales list with the elements of locale_dirs list on which os.path.basename [ os . path . basename ] function was applied .
take locale or all_locales , whichever is not empty , respectively , and substitute it for locales .
locales is relative complement of set exclude in set locales .
for every basedir in basedirs ,
if locales in not empty ,
join basedir , l and string _STR:0_ into a path separated by _STR:1_ for every l in locales , assign the list to dirs .
if not ,
dirs is a list containing basedir .
locations is an empty list .
for every ldir in dirs ,
for dirpath , dirnames and filenames , respectively , in directory tree tuple starting from the ldir ,
extend locations with tuple containing dirpath and f , for every f in filenames , only if it ends with string _STR:0_ .
if locations is not empty ,
call the self.compile_messages [ self . compile_messages ] with locations as argument ,
define compile_messages method with self class instance and locations as a arguments .
for every i and tuple containing dirpath and f , in enumerated list of locations ,
if self.verbosity [ self . verbosity ] is greater than integer 0 ,
call the self.stdout.write [ self . stdout . write ] method with string _STR:0_ as argument , replacing all the occurrences of ' % s ' with f and dirpath , respectively .
po_path is a string containing joined directory path from dirpath and f .
evaluate function has_bom with po_path as argument .
raise CommandError exception with string _STR:0_ , with ' % s ' replaced with po_path , as argument .
call os.path.splitext [ os . path . splitext ] function with po_path as argument , substitute the first element of the result for base_path .
if i equals to integer 0 and
call the self.stderr.write [ self . stderr . write ] , with string _STR:0_ as argument , with ' % s ' replaced by dirpath .
return nothing .
extend self.program [ self . program ] list with self.program_options [ self . program_options ] , string _STR:0_ ,
return value of the npath function with string _STR:0_ appended to the base_path as argument , and return value of the npath function with string _STR:1_ appended to the base_path as argument , substitute it for args . call the popen_wrapper with args as the argument , assign the result to the output , errors and status , respectively .
if status is True ,
if errors is True ,
msg is a string _STR:0_ , with ' % s ' replaced by self.program [ self . program ] and errors .
if not ,
msg is a string _STR:0_ , with ' % s ' replaced by self.program [ self . program ] .
raise CommandError exception with msg as argument .
from django.conf [ django . conf ] import settings into default name space .
from django.core.cache [ django . core . cache ] import caches into default name space .
from django.core.cache.backends.db [ django . core . cache . backends . db ] import BaseDatabaseCache into default name space .
from django.core.management.base [ django . core . management . base ] import BaseCommand and CommandError into default name space .
from django.db [ django . db ] import connections , router , transaction , models and DEFAULT_DB_ALIAS into default name space .
from django.db.utils [ django . db . utils ] import DatabaseError into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_text into default name space .
derive the class Command from the BaseCommand base class .
help is an string _STR:0_ .
requires_system_checks is boolean False .
define the method add_arguments with arguments self and parser .
call the method parser.add_argument [ parser . add_argument ] with 4 arguments : string _STR:0_ , metavar set to string _STR:1_ , nargs set to _STR:2_ character ,
and help set to a string _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:1_ , action set to string _STR:2_ , dest as a string _STR:3_ ,
default set to DEFAULT_DB_ALIAS and help set to a string : _STR:0_ define the method handle with arguments self , unpacked list tablenames and unpacked dictionary options .
get value under the _STR:0_ key of the options dictionary , substitute it for db .
get the value under the _STR:0_ key of the options dictionary , convet it to an integer and substitute for self.verbosity [ self . verbosity ] .
if length of tablenames is greater than zero ,
for every tablename in tablenames ,
call the method self.create_table [ self . create_table ] with arguments : db and tablename .
if not ,
for every cache_alias in settings.CACHES [ settings . CACHES ] ,
substitute value under the cache_alias key of the caches dictionary for cache .
if cache is an instance of BaseDatabaseCache ,
all the method self.create_table [ self . create_table ] with arguments : db and cache._table [ cache . _table ] .
define the method create_table with arguments self , database and tablename .
cache is an instance of BaseDatabaseCache class , created with arguments : tablename and an empty dictionary .
call the method router.allow_migrate [ router . allow_migrate ] with 2 arguments : database and cache.cache_model_class [ cache . cache_model_class ] , if it evaluates to false ,
return nothing .
substitute value under the database key of the connections dictionary for connection .
if tablename is contained in return value of the method connection.introspection.table_names [ connection . introspection . table_names ] ,
if self.verbosity [ self . verbosity ] is greater than integer 0 ,
replace ' % s ' in string _STR:0_ with tablename , write it to the self.stdout [ self . stdout ] stream .
return nothing .
fields is an tuple containing 3 entries : return value of the method models.CharField [ models . CharField ] called with 4 arguments :
name set to a string _STR:0_ , max_length set to integer 255 , unique set to boolean True and primary_key set to boolean True , return value of the method models.TextField [ models . TextField ] called with argument name set to a string _STR:1_ , and return value of the method models.DateTimeField [ models . DateTimeField ] called with 2 arguments : name set to string _STR:2_ and db_index set to True . table_output is an empty list .
index_output is an empty list .
substitute connection.ops.quote_name [ connection . ops . quote_name ] for qn .
for every f in fields ,
field_output is an list containing 2 elements : return value of the function qn called with an argument f.name [ f . name ] ,
and return value of the function f.db_type [ f . db_type ] called with an argument connection set to connection . if f.null [ f . null ] is false , append string append _STR:0_ to field_output , otherwise append _STR:1_ to field_output .
if f.primary_key [ f . primary_key ] is true ,
append string _STR:0_ to field_output .
otherwise if f.unique [ f . unique ] is true ,
append string _STR:0_ to field_output .
if f.db_index [ f . db_index ] is true ,
if f.unique [ f . unique ] is true , substitute _STR:0_ for unique , otherwise unique is an empty string .
replace ' % s ' in string _STR:0_ with : unique , return value of the function qn called with an argument :
a string _STR:0_ , where ' % s ' is replaced with tablename and f.name [ f . name ] , respectively , return value of the function qn called with an argument tablename and return value of the function qn called with an argument f.name [ f . name ] . join field_output elements into a string , separated by whitespaces , append it to table_output .
full_statement is a list containing : string _STR:0_ , where % s is replaced by result of the function qn called with an argument tablename .
for every i and line in enumerated iterable table_output ,
replace % s in string _STR:0_ with : line and character _STR:1_ if i is lesser than length of table_output decremented by one ,
or with an empty string if its not , append the resulting string to full_statement . append string _STR:0_ to full_statement .
evaluate method transaction.atomic [ transaction . atomic ] with arguments : using set to database and savepoint set to connection.features.can_rollback_ddl [ connection . features . can_rollback_ddl ] ,
with the result , evaluate method connection.cursor [ connection . cursor ] , with return value as curs ,
try ,
join full_statement into a string , separated by newlines , use it as an argument for the call to the method curs.execute [ curs . execute ] .
if DatabaseError , renamed to e , exception is caught ,
raise an CommandError with an argument string _STR:0_ , replace ' % s ' with :
tablename and return value of the function force_text called with an argument e , respectively . for every statement in index_output ,
execute statement on the database that curs points to .
if self.verbosity [ self . verbosity ] is greater than integer 1 ,
replace ' % s ' in string _STR:0_ with tablename , write it to self.stdout [ self . stdout ] .
from django.core.management.base [ django . core . management . base ] import BaseCommand and CommandError into default name space .
from django.db [ django . db ] import connections and DEFAULT_DB_ALIAS into default name space .
derive the class Command from the BaseCommand base class .
help is a tuple containing a string _STR:0_ .
requires_system_checks is boolean False .
define the method add_arguments with self and parser .
call the method parser.add_argument [ parser . add_argument ] with arguments : string _STR:0_ , action set to string _STR:1_ , dest set to string _STR:2_ ,
default set to DEFAULT_DB_ALIAS and help set to string _STR:0_ . define the method handle with arguments self and unpacked dictionary options .
get the value under the _STR:0_ key of the options dictionary , use it as a key to access the element under the connections dictionary , substitute it for connection .
try ,
call the method connection.client.runshell [ connection . client . runshell ] .
if OSError exception is caught ,
raise an CommandError exception with an argument string _STR:0_ ,
from django.core.management.base [ django . core . management . base ] import BaseCommand into default name space .
define the function module_to_dict with 2 arguments : module and omittable as a lambda function with an argument k ,
return dictionary created out of tuple elements k and printable representation of v ,
for every k and v in return value of the method module.__dict__.items [ module . __dict__ . items ] , only if result of the method omittable called with an argument k is false . derive the class Command from the BaseCommand base class .
requires_system_checks is boolean False .
define the method add_arguments with 2 arguments self and parser .
call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:0_ , action set to string _STR:1_ , dest set to string _STR:2_ ,
default set to boolean False and help set to a string _STR:0_ define the method handle with arguments self and unpacked dictionary options .
from django.conf [ django . conf ] import settings , global_settings into default name space .
call the method settings._setup [ settings . _setup ] .
call the function module_to_dict with an argument settings._wrapped [ settings . _wrapped ] , substitute it for user_settings .
call the function module_to_dict with an argument global_settings , substitute it for default_settings .
output is an empty string .
for every key in sorted list of user_settings ,
if key is not contained in default_settings ,
replace ' % s ' in string _STR:0_ with key and value under the key key of the user_setting dictionary , append it to the output .
otherwise if value under the key key of the user_settings dictionary is not equal to the value under the key key of the default_settings dictionary ,
replace ' % s ' in string _STR:0_ with key and value under the key key of the user_setting dictionary , append it to the output .
otherwise if value under the key _STR:0_ of the options dictionary is true ,
replace ' % s ' in string _STR:0_ with key and value under the key key of the user_setting dictionary , append it to the output .
join elements of the output into a string , separated by newlies , return the string .
import module warnings .
from collections import OrderedDict into default name space .
from django.apps [ django . apps ] import apps into default name space .
from django.core.management.base [ django . core . management . base ] import BaseCommand and CommandError into default name space .
from django.core [ django . core ] import serializers into default name space .
from django.db [ django . db ] import router and DEFAULT_DB_ALIAS into default name space .
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
derive the class Command from the BaseCommand base class .
help is a tuple containing a string _STR:0_
_STR:0_ . define the method add_arguments with arguments self and parser .
call the method parser.add_argument [ parser . add_argument ] with 4 arguments : string _STR:0_ , metavar set to string _STR:1_ ,
nargs set to _STR:0_ and help is a string _STR:1_ . call the method parser.add_argument [ parser . add_argument ] with 4 arguments : string _STR:2_ , default set to string _STR:3_ ,
dest set to _STR:0_ and help is a string _STR:1_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:2_ , default set to None , dest set to _STR:3_ ,
type set to int and help is a string _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:1_ , default set to string _STR:2_ , dest set to _STR:3_ ,
add set to DEFAULT_DB_ALIAS and help is _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 6 arguments : string _STR:1_ , string _STR:2_ , dest set to _STR:3_ , action set to _STR:4_ ,
default is a an empty list and help is a string _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 6 arguments : string _STR:1_ , string _STR:2_ , action is string _STR:3_ , dest is string _STR:4_ ,
default is boolean False and help is a string _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:1_ , action set to string _STR:2_ ,
dest is string _STR:0_ , default is boolean False and help is a string _STR:1_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:2_ , action set to _STR:3_ ,
dest is _STR:0_ , default is boolean False and help is a string _STR:1_ . call the method parser.add_argument [ parser . add_argument ] with 6 arguments : string _STR:2_ , string _STR:3_ , action set to _STR:4_ ,
dest is _STR:0_ , default is boolean False and help is a string _STR:1_ . call the method parser.add_argument [ parser . add_argument ] with 3 arguments : string _STR:2_ , dest set to string _STR:3_ ,
and help is a string _STR:0_ _STR:1_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:2_ , string _STR:3_ , default is None , dest set to string _STR:4_ ,
and help is a string _STR:0_ . define the method handle with arguments self , unpacked list app_labels and unpacked dictionary options .
get the value under the _STR:0_ key of the options dictionary , substitute the result for format .
get the value under the _STR:0_ key of the options dictionary , substitute the result for indent .
get the value under the _STR:0_ key of the options dictionary , substitute the result for database .
get the value under the _STR:0_ key of the options dictionary , substitute the result for exclude .
get the value under the _STR:0_ key of the options dictionary , substitute the result for output .
get the value under the _STR:0_ key of the options dictionary , substitute the result for traceback .
get the value under the _STR:0_ key of the options dictionary , substitute the result for use_natural_keys .
if use_natural_keys is true ,
call the function warnings.warn [ warnings . warn ] with an argument string _STR:0_ ,
and RemovedInDjango19Warning . get the value under the _STR:0_ key of the options dictionary , substitute the result for use_natural_foreign_keys .
get the value under the _STR:0_ key of the options dictionary , substitute the result for use_natural_primary_keys .
get the value under the _STR:0_ key of the options dictionary , substitute the result for use_base_manager .
get the value under the _STR:0_ key of the options dictionary , substitute the result for pks .
if pks is true ,
split string pks by _STR:0_ , substitute the result for primary_keys .
if not ,
primary_keys is an empty list .
excluded_apps is an empty set .
excluded_models is an empty set .
for every exclude in excludes ,
if _STR:0_ is contained in exclude ,
try ,
call the method apps.get_model [ apps . get_model ] with exclude as an argument , substitute it for model .
if LookupError exception is caught ,
raise an CommandError exception with an argument string _STR:0_ , where ' % s ' is replaced with exclude .
add model to excluded_models set .
if not ,
try ,
call the method apps.get_app_config [ apps . get_app_config ] with an argument exclude , substitute the result for app_config .
if LookupError exception is caught ,
raise CommandError with an argument string _STR:0_ , where ' % s ' is replaced with exclude .
add app_config to excluded_apps set .
if length of app_labels equals integer 0 ,
if primary_keys is true ,
raise an CommandError exception with an argument string _STR:0_ .
app_list is an instance of OrderedDict class , created with an argument a tuple containing elements : app_config and None ,
for every app_config in return value of the method apps.get_app_configs [ apps . get_app_configs ] , only if app_config.models_module [ app_config . models_module ] is not None , and app_config is not contained in excluded_apps . if not ,
if length of app_labels is greater than integer 1 and primary_keys is true ,
raise an CommandError exception with an argument string _STR:0_ .
app_list is an instance of a class OrderedDict .
for every label in app_labels ,
try ,
split label by _STR:0_ , assign the result to app_label and model_label , respectively .
try ,
call the method apps.get_app_config [ apps . get_app_config ] with an argument app_label , substitute the result for app_config .
if LookupError exception is caught ,
raise CommandError with an argument string _STR:0_ , where ' % s ' is replaced with exclude .
if app_config.models_module [ app_config . models_module ] is None or app_config is contained in excluded_apps ,
skip this loop iteration .
try ,
call the method app_config.get_model [ app_config . get_model ] with an argument model_label , substitute the result for model .
if LookupError exception is caught ,
raise CommandError with an argument string _STR:0_ , where ' % s ' is replaced with app_label and model_label , respectively .
call the method app_list.setdefault [ app_list . setdefault ] with 2 arguments app_config and an empty list , substitute the result for app_list_value .
if app_list_value is not None ,
if mode is not contained in app_list_value ,
append model to app_list_value .
if ValueError exception is caught ,
if primary_keys is true ,
raise an CommandError exception with an argument string _STR:0_ .
substitute label for app_label .
try ,
call the method apps.get_app_config [ apps . get_app_config ] with an argument app_label , substitute the result for app_config .
if LookupError exception is caught ,
raise CommandError with an argument string _STR:0_ , where ' % s ' is replaced with app_label .
if app_config.models_module [ app_config . models_module ] is None or app_config is contained in excluded_apps
skip this loop iteration .
value under the app_config key of the app_list is None .
if format is not contained in return value of the method serializers.get_public_serializer_formats [ serializers . get_public_serializer_formats ] ,
try ,
call the method serializers.get_serializer [ serializers . get_serializer ] with an argument format .
if serializers.SerializerDoesNotExist [ serializers . SerializerDoesNotExist ] exception is caught ,
do nothing .
raise CommandError with an argument string _STR:0_ , where ' % s ' is replaced with format .
define the function get_objects .
call the method app_list.items [ app_list . items ] , use the result as an argument for the call to the function sort_dependencies , for every model in result ,
if model is contained in excluded_models ,
skip this loop iteration .
if model._meta.proxy [ model . _meta . proxy ] is false and return value of the function router.allow_migrate [ router . allow_migrate ] called with arguments using and model is true ,
if use_base_manager is true ,
substitute model._base_manager [ model . _base_manager ] for objects .
if not ,
substitute model._default_manager [ model . _default_manager ] for objects .
call the method objects.using [ objects . using ] with an argument using , call the method order_by on the result with an argument model._meta.pk.name [ model . _meta . pk . name ] ,
substitute the result for queryset . if primary_keys is true ,
call the method queryset.filter [ queryset . filter ] with an argument pk__in set to primary_keys , substitute the result for queryset .
for every obj in result of the method queryset.iterator [ queryset . iterator ] ,
yield obj , as an return value of the generator .
try ,
self.stdout.ending [ self . stdout . ending ] is None .
open the output file in writing mode if output is true , assign the file descriptor to stream , otherwise stream is None .
try ,
call the method serializers.serialize [ serializers . serialize ] with 6 arguments : format , result of the function get_objects , indent set to indent ,
use_natural_foreign_keys set to use_natural_foreign_keys , use_natural_primary_keys set to use_natural_primary_keys , and stream set to stream , if the stream is true , otherwise stream set to self.stdout [ self . stdout ] . finally perform ,
if stream is true ,
close the file stream .
if Exception , renamed to e , exception is caught ,
if show_traceback is true ,
raise an exception .
raise CommandError with an argument string _STR:0_ , where ' % s ' is replaced with e .
define the function sort_dependencies with an argument app_list .
model_dependencies is an empty list .
models is an empty set .
for every app_config and model_list in app_list ,
if model_list is None ,
call the method app_config.get_models [ app_config . get_models ] , substitute the result fr model_list .
for every model in model_list ,
add model to models set .
if model has an _STR:0_ attribute ,
get _STR:0_ attribute of the model.natural_key [ model . natural_key ] , substitute it for deps , if the attribute doesnt exist , deps in an empty list .
if deps is true ,
for every dep in deps call the method apps.get_model [ apps . get_model ] with an argument dep , and append the result to the list , substitute it for deps .
if not ,
deps is an empty list .
for every field in model._meta.fields [ model . _meta . fields ] ,
if field.rel [ field . rel ] has an _STR:0_ attribute ,
substitute field.rel.to [ field . rel . to ] with rel_model .
if rel_model has an attribute _STR:0_ and rel_model is not equal to model ,
append rel_model to deps .
for every field in model._meta.many_to_many [ model . _meta . many_to_many ] ,
if field.rel.through._meta.auto_created [ field . rel . through . _meta . auto_created ] is true ,
substitute field.rel.to [ field . rel . to ] for rel_model .
if rel_model has an _STR:0_ attribute and rel_model is not equal to model ,
append rel_model to deps .
append a tuple containing 2 elements : model and deps to model_dependencies .
call the methof model_dependencies.reverse [ model_dependencies . reverse ] .
model_list is an empty list .
while model_dependencies is true ,
skipped is an empty list .
changed is boolean False .
while model_dependencies is true ,
remove first element from model_dependencies , assign it to model and deps , respectively .
found is boolean True .
for every d in deps , if d is not contained in models and d is contained in model_list add boolean True to a tuple ,
otherwise add boolean False , for every candidate in the result perform following , if candidate is false ,
found is boolean False .
if found is true ,
append model to model_list .
changed is boolean True .
if not ,
append a tuple containing 2 elemetns : model and deps , to skipped .
if changed is false ,
raise an CommandError with argument : string _STR:0_ , where ' % s ' is replaced with :
model._meta.app_label [ model . _meta . app_label ] and model._meta.object_name [ model . _meta . object_name ] joined into a string , with separator _STR:0_ , result joined into a string , separated by string _STR:1_ for every model and deps in sorted list of elements skipped sorted by key : return value of the lambda function with an argument obj , and result the __name__ field of the first element of obj . substitute skipped for model_dependencies .
return model_list .
import module sys .
from importlib import import_module into default name space .
from django.apps [ django . apps ] import apps into default name space .
from django.db [ django . db ] import connections , router , transaction and DEFAULT_DB_ALIAS into default name space .
from django.core.management [ django . core . management ] import call_command into default name space .
from django.core.management.base [ django . core . management . base ] import BaseCommand and CommandError into default name space .
from django.core.management.color [ django . core . management . color ] import no_style into default name space .
from django.core.management.sql [ django . core . management . sql ] import sql_flush and emit_post_migrate_signal into default name space .
from django.utils.six.moves [ django . utils . six . moves ] import input into default name space .
from django.utils [ django . utils ] import six into default name space .
derive the class Command from the BaseCommand base class .
help is a tuple containing a string : _STR:0_
_STR:0_ define the add_arguments with arguments self and parser .
call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:0_ , action set to string _STR:1_ ,
dest set to string _STR:0_ , default set to boolean True , help as a string _STR:1_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:2_ , action set to string _STR:3_ , dest as a string _STR:4_ ,
default set to DEFAULT_DB_ALIAS and help as a string _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:1_ , action set to string _STR:2_ ,
dest set to string _STR:0_ , default=True and help as a string _STR:1_ . define the method handle with arguments self and unpacked dictionary options .
substitute value under the _STR:0_ key of the options dictionary for database .
substitute value under the database key of the connections dictionary for connection .
substitute value under the _STR:0_ key of the options dictionary for verbosity .
substitute value under the _STR:0_ key of the options dictionary for interactive .
get the value _STR:0_ key of the options dictionary , if it exists substitute it for reset_sequences , otherwise reset_sequences is boolean True .
get the value _STR:0_ key of the options dictionary , if it exists substitute it for allow_cascade , otherwise allow_cascade is boolean False .
get the value _STR:0_ key of the options dictionary , if it exists substitute it for inhibit_post_migrate , otherwise inhibit_post_migrate is boolean False .
call the function no_style , substitute it for self.style [ self . style ] .
for every app_config in return value of the method apps.get_app_configs [ apps . get_app_configs ] ,
try ,
call the function import_module with 2 arguments : string .management and app_config.name [ app_config . name ] .
if ImportError exception is caught ,
do nothing .
call the method sql_flush with 5 arguments : self.style [ self . style ] , connection , only_django set to boolean True ,
reset_sequences set to reset_sequences , allow_cascade set to allow_cascade , substitute the result for sql_list . if interactive is true ,
request user input from the standard input , assign it o confirm , with the query string : _STR:0_
_STR:0_ _STR:1_Type _STR:2_ to continue , or _STR:3_ to cancel : `` , where ' % s ' is replaced with value under the _STR:4_ key of the connection.settings_dict [ connection . settings_dict ] dictionary . if not ,
confirm is a string _STR:0_ .
if confirm equals a string _STR:0_ ,
try ,
call the method transaction.atomic [ transaction . atomic ] with 2 arguments : using set to database , savepoint set to connection.features.can_rollback_ddl [ connection . features . can_rollback_ddl ] ,
with the result , call the method connection.cursor [ connection . cursor ] , with the result as cursor ,
for every sql in sql_list ,
call the method cursor.execute [ cursor . execute ] with an argument sql .
if Exception , renamed to e , exception is caught ,
new_msg is a tuple containing a string : _STR:0_
_STR:0_ _STR:1_ _STR:2_ , where ' % s ' is replaced by value under the _STR:3_ key of the connection.settings_dict [ connection . settings_dict ] dictionary and e. call the function six.reraise [ six . reraise ] with 3 arguments : CommandError , CommandError created with argument new_msg ,
and third element of the return value of the function sys.exc_info [ sys . exc_info ] . if inhibit_post_migrate is false ,
call the method self.emit_post_migrate [ self . emit_post_migrate ] with arguments verbosity , interactive and database .
if value under the _STR:0_ key of the options dictionary is true ,
call the function call_command with 3 arguments : string _STR:0_ , string _STR:1_ and unpacked dictionary options .
if not ,
write string _STR:0_ to self.stdout [ self . stdout ] stream .
class static method ,
define the method emit_post_migrate with arguments verbosity , interactive and database .
all_models is an empty list .
for every app_config in return value of the method apps.get_app_configs [ apps . get_app_configs ] ,
call the method router.get_migratable_models [ router . get_migratable_models ] with arguments app_config , database and include_auto_created set to boolean True ,
extend all_models list with the result . call the function emit_post_migrate_signal with 4 arguments : all_models converted into a set , verbosity , interactive and database .
from __future__ import unicode_literals into default name space .
from collections import OrderedDict into default name space .
import module keyword .
import module re .
from django.core.management.base [ django . core . management . base ] import BaseCommand and CommandError into default name space .
from django.db [ django . db ] import connections and DEFAULT_DB_ALIAS into default name space .
derive the class Command from the BaseCommand base class .
help is an string _STR:0_ .
requires_system_checks is boolean False .
db_module is a string _STR:0_ .
define the method add_arguments with arguments self and parser .
call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:0_ , action set to string _STR:1_ , dest as a string _STR:2_ ,
default set to DEFAULT_DB_ALIAS and help as a string _STR:0_ . define the method handle with 2 arguments : self and unpacked dictionary options .
try ,
for every line in return value of the method self.handle_inspection [ self . handle_inspection ] called with an argument options ,
append new line to line , write it to self.stdout [ self . stdout ] stream .
if NotImplementedError exception is caught ,
raise an CommandError exception with an argument _STR:0_ .
define the method handle_inspection with 2 argument : self and options .
get value under the _STR:0_ key of the options dictionary , use it as a key to get the value from the connections dictionary ,
substitute the result for connection . get the value under the _STR:0_ key of the options dictionary , substitute it for table_name_filter .
table2model is a lambda function with an argument table_name , return value is the return value of the re.sub [ re . sub ] method ,
called with 3 arguments : raw string _STR:0_ , empty string and result of the method table_name.title [ table_name . title ] . strip_prefix is a lambda function with an argument s , return value is s without the first element if s starts with string _STR:1_ ' ,
otherwise returns s. call the method connection.cursor [ connection . cursor ] , with the result as cursor ,
yield string _STR:0_ as the result .
yield string _STR:0_ as the result .
yield string _STR:0_ as the result .
yield string _STR:0_ as the result .
yield string _STR:0_ as the result .
yield string _STR:0_ as the result .
yield string _STR:0_ as the result .
yield string _STR:0_ as the result .
yield string _STR:0_ as the result .
yield string _STR:0_ as the result .
yield and empty string as the result .
yield string _STR:0_ % self.db_module [ self . db_module ] as the result , where `` % s '' is replaced with self.db_module [ self . db_module ] .
known_models is an empty list .
for every table_name in return value of the method connection.introspection.table_names [ connection . introspection . table_names ] called with an argument cursor ,
if table_name_filter is not None and table_name_filter is callable object ,
call the function table_name_filter with an argument table_name , if it evaluates to true ,
skip this loop iteration ,
yield and empty string as the result .
yield and empty string as the result .
yield string _STR:0_ % self.db_module [ self . db_module ] as the result , where `` % s '' is replaced with result of the call to the function ,
table2model with an argument table_name . call the function table2model with an argument table_name , append the result to known_models .
try ,
call the method connection.introspection.get_relations [ connection . introspection . get_relations ] with 2 arguments cursor , table_name and substitute the result for relations .
if NotImplementedError exception is caught ,
relations is an empty dictionary .
try ,
call the method connection.introspection.get_relations [ connection . introspection . get_relations ] with 2 arguments cursor , table_name and substitute the result for indexes .
if NotImplementedError exception is caught ,
indexes is an empty dictionary .
used_column_names is an empty list .
for every i and row in enumerated result of the method connection.introspection.get_table_description [ connection . introspection . get_table_description ] called with arguments : cursor and table_name ,
comment_notes is an empty list .
extra_params is an instance of the class OrderedDict .
substitute first element of row for column_name .
if i is contained in relations , is_relation is boolean True , otherwise is_relation is boolean False .
call the method self.normalize_col_name [ self . normalize_col_name ] with 3 arguments column_name , used_column_names , is_relation , assign the result to att_name , params and notes , respectively .
add params to extra_params dictionary .
extend comment_notes list with notes .
append att_name to used_column_names list .
if column_name is contained in indexes ,
if value under the _STR:0_ key of the dictionary contained under the column_name key of the dictionary indexes is true ,
value under the _STR:0_ key of the extra_params dictionary is boolean True ,
otherwise if , if value under the _STR:0_ key of the dictionary contained under the column_name key of the dictionary indexes is true ,
value under the _STR:0_ key of the extra_params dictionary is boolean True ,
if is_relation is true ,
if second element of the i-th row of relations equals table_name , rel_to is string _STR:0_ ,
otherwise call the method table2model with second element of the i-th row of relations and substitute it for rel_to . if rel_to is contained in known_models ,
append rel_to to string 'ForeignKey ( , substitute the result for field_type .
if not ,
append rel_to to string _STR:0_ '' to it , substitute the result for field_type .
if not ,
call the method self.get_field_type [ self . get_field_type ] with 3 arguments connection , table_name and row , assign the result to field_type , field_params ,
field_notes , respectively . add field_params to extra_params dictionary .
extend comment_notes list with field_notes .
append _STR:0_ to field_type .
if att_name equals string _STR:0_ and extra_params equals a dictionary with 1 entry : boolean True for _STR:1_ ,
if field_type equals a string _STR:0_ ,
skip this loop iteration .
otherwise if field_type equals a string _STR:0_ and connection.features.can_introspect_autofield [ connection . features . can_introspect_autofield ] is false ,
append string _STR:0_ to comment_notes .
if seventh element of row is true ,
if field_type equals a string _STR:0_ ,
field_type is a string _STR:0_
if not ,
value under the _STR:0_ key of the extra_params dictionary is boolean True .
if field_type is not equal to string _STR:0_ or string _STR:1_ ,
value under the _STR:0_ key of the extra_params dictionary is boolean True .
field_desc is a string _STR:0_ , where ' % s ' is replaced with : att_name , an empty string if _STR:1_ is contained in field_type ,
or with string _STR:0_ if it is not and field_type . if extra_params is true ,
if field_desc doesnt end with _STR:0_ ,
append string _STR:0_ to field_desc .
in string _STR:0_ replace ' % s ' with k and return value of the function strip_prefix with an argument printable representation of v ,
for every k and v in return value of the extra_params.items [ extra_params . items ] method , join all results into a string separated by a string _STR:0_ , substitute it for field_desc . append string _STR:1_ to field_desc .
if comment_notes is true ,
join elements of comment_notes into a string , separated by whitespaces , append it to the string _STR:0_ , append the result to field_desc .
yield string _STR:0_ , where ' % s ' is replaced with field_desc .
for meta_line in return value of the method self.get_meta [ self . get_meta ] called with an argument table_name .
yield meta_line as the result .
define the method normalize_col_name with 4 arguments : self , col_name , used_column_names and is_relation .
field_params is an empty dictionary .
field_notes is an empty list .
convert col_name to lowercase , substitute the result for new_name .
if new_name is not equal to col_name ,
append string _STR:0_ to field_notes .
if is_relation ,
if new_name ends with string _STR:0_ ,
substitute new_name , without the last 3 elements for new_name .
if not ,
substitute col_name for value under the _STR:0_ key of the field_params dictionary .
cal the method re.subn [ re . subn ] with 3 arguments : raw string _STR:0_ , string _STR:1_ and new_name .
if num_repl is greater than integer 0 ,
append string _STR:0_ to field_notes .
call the method new_name.find [ new_name . find ] , with an argument string _STR:0_ , if it evaluates to greater or equal than integer 0 ,
while the result of the method new_name.find [ new_name . find ] , called with an argument string _STR:0_ is greater or equals integer 0 ,
replace all the occurrences of _STR:0_ with _STR:1_ in new_name .
convert col_name to lowercase , on the result call the method find with an argument string _STR:0_ , if the result is greater of equal to integer 0 ,
append string _STR:0_ to field_notes .
if new_name starts with a string _STR:0_ ,
convert new_name to a string and append it to string _STR:0_ , substitute the result for new_name .
append string _STR:0_ to field_notes .
if new_name ends with a string _STR:0_ ,
convert new_name to a string and append string _STR:0_ to it , substitute the result for new_name .
append string _STR:0_ to field_notes .
call the method keyword.iskeyword [ keyword . iskeyword ] with an argument new_name , if it evaluates to true ,
append string _STR:0_ to new_name .
append string _STR:0_ to field_notes .
if first element of new_name is digit ,
convert new_name to a string and append it to string _STR:0_ , substitute the result for new_name .
append string _STR:0_ to field_notes .
if new_name is contained in used_column_names ,
num is an integer 0 .
in string _STR:0_ , replace ' % s ' with new_name and _STR:1_ with num , while the result is contained in used_column_names ,
increment num by one .
in string _STR:0_ , replace ' % s ' with new_name and _STR:1_ with num , substitute the result for new_name .
append string _STR:0_ to field_notes .
if col_name is not equal to new_name and field_notes is true ,
substitute col_name for value under the _STR:0_ key of the field_params dictionary .
return new_name , field_params and field_notes .
define the method get_field_type with 4 arguments : self , connection , table_name and row .
field_params is an instance of a class OrderedDict .
field_notes is an empty list .
try ,
call the method connection.introspection.get_field_type [ connection . introspection . get_field_type ] with 2 arguments : second element of row and row , substitute the result for field_type .
if KeyError exception is caught ,
field_type is a string _STR:0_ .
append a string _STR:0_ to field_notes .
if field_type is a tuple ,
substitute field_type for field_type and new_params , respectively .
call the method field_params.update [ field_params . update ] with an argument new_params.1 [ new_params . 1 ]
if field_type equals a string CharField ' and fourth element of row is true ,
convert fourth element of row to an integer , substitute it for value under the _STR:0_ key of the field_params .
if field_type equals a string _STR:0_ ,
if fifth and sixth elements of row are None ,
append string _STR:0_ to field_notes .
if fifth element of row is not None , substitute it for value under the _STR:0_ key of the field_params ,
otherwise , value under the _STR:0_ key of the field_params is integer 10. if sixth element of row is not None , substitute it for value under the _STR:1_ key of the field_params ,
otherwise , value under the _STR:0_ key of the field_params is integer 5. if not
substitute fifth element of row for value under the _STR:0_ key of the field_params .
substitute sixth element of row for value under the _STR:0_ key of the field_params .
return field_type , field_params and field_notes .
define the method get_meta with arguments self and table_name .
return the list , containing 4 elements : an empty string , string _STR:0_ , string _STR:1_ ,
from __future__ import unicode_literals into default name space .
import module glob .
import module gzip .
import module os .
import module warnings .
import module zipfile .
from django.apps [ django . apps ] import apps into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.core [ django . core ] import serializers into default name space .
from django.core.management.base [ django . core . management . base ] import BaseCommand and CommandError into default name space .
from django.core.management.color [ django . core . management . color ] import no_style into default name space .
from django.db [ django . db ] import connections , router , transaction , DEFAULT_DB_ALIAS , IntegrityError and DatabaseError into default name space .
from django.utils [ django . utils ] import lru_cache into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_text into default name space .
from django.utils.functional [ django . utils . functional ] import cached_property into default name space .
from django.utils._os [ django . utils . _os ] import upath into default name space .
from itertools import product into default name space .
try ,
import bz2 .
has_bz2 is boolean True .
if ImportError exception is caught ,
has_bz2 is boolean False .
derive the class Command from the BaseCommand base class .
help is an string _STR:0_ .
missing_args_message is a tuple containing a string _STR:0_
_STR:0_ define the method add_arguments with 2 arguments : self and parser .
call the method parser.add_argument [ parser . add_argument ] with 4 arguments : string _STR:0_ , metavar set to string _STR:1_ , nargs set to _STR:2_ ,
and help set to _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:1_ , action set to string _STR:2_ , dest as a string _STR:3_ ,
default set to DEFAULT_DB_ALIAS and help as a string _STR:0_ call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:1_ , action as a string _STR:2_ , dest as a string _STR:3_ ,
default set to None , help is a string _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 6 arguments : string _STR:1_ , string _STR:2_ , action as a string _STR:3_ ,
dest as a string _STR:0_ , default set to boolean False and help set to string _STR:1_ . define the method handle with 3 arguments : self , unpacked list fixture_labels and unpacked dictionary options .
get the value under the _STR:0_ key of the options dictionary , substitute it for self.ignore [ self . ignore ] .
get the value under the _STR:0_ key of the options dictionary , substitute it for self.database [ self . database ] .
get the value under the _STR:0_ key of the options dictionary , substitute it for self.app_label [ self . app_label ] .
get the value under the _STR:0_ key of the options dictionary , if the key exists substitute it for self.hide_empty [ self . hide_empty ] ,
if not , self.hide_empty [ self . hide_empty ] is boolean False . get the value under the _STR:0_ key of the options dictionary , substitute it for self.verbosity [ self . verbosity ] .
call the method transaction.atomic [ transaction . atomic ] with an argument using set to self.using [ self . using ] , with the result ,
call the method self.loaddata [ self . loaddata ] with an argument fixture_labels .
call the method transaction.get_autocommit [ transaction . get_autocommit ] with an argument self.using [ self . using ] , if it evaluates to true ,
get the value under the self.using [ self . using ] key of the connections dictionary , call the method close on it .
define the method loaddata with 2 arguments self and fixture_labels .
get the value under the self.using [ self . using ] key of the connections dictionary , substitute it for connection .
self.fixture_count [ self . fixture_count ] is integer 0 .
self.loaded_object_count [ self . loaded_object_count ] is integer 0 .
self.fixture_object_count [ self . fixture_object_count ] is integer 0 .
self.models [ self . models ] is an empty set .
call the method serializers.get_public_serializer_formats [ serializers . get_public_serializer_formats ] , substitute the result for self.serialization_formats [ self . serialization_formats ] .
self.compression_formats [ self . compression_formats ] is an dictionary with 3 initial entries : tuple containing 2 elements : open and string _STR:0_ for None ,
tuple with 2 arguments : gzip.GzipFile [ gzip . GzipFile ] and string _STR:0_ for _STR:1_ , tuple with 2 arguments : SingleZipReader and string _STR:2_ for _STR:3_ . if has_bz2 is true ,
substitute tuple with 2 elements : bz2.BZ2File [ bz2 . BZ2File ] and string _STR:0_ for value under the _STR:1_ key of the self.compression_formats [ self . compression_formats ] dictionary .
call the method connection.constraint_checks_disabled [ connection . constraint_checks_disabled ] , with the result perform ,
for every fixture_label in fixture_labels ,
call the method self.load_label [ self . load_label ] with an argument fixture_label .
for model in self.models [ self . models ] append model._meta.db_table [ model . _meta . db_table ] to a list , substitute the resulting list for table_names .
try ,
call the method connection.check_constraints [ connection . check_constraints ] with an arguments table_names set to table_names .
if Exception , renamed to e , exception is caught ,
e.args [ e . args ] is a tuple , containing 1 element : string _STR:0_ , where ' % s ' is replaced with e .
raise an exception .
if self.loaded_object_count [ self . loaded_object_count ] is greater than zero ,
call the method connection.ops.sequence_reset_sql [ connection . ops . sequence_reset_sql ] with 2 arguments : return value of the no_style and self.models [ self . models ] ,
substitute the result for sequence_sql . if sequence_sql is true ,
if self.verbosity [ self . verbosity ] is grater than , or equal to integer 2 ,
write a string _STR:0_ to self.stdout [ self . stdout ] stream .
call the method connection.cursor [ connection . cursor ] , with the result renamed to cursor , perform the following ,
for every line in sequence_sql ,
call the method cursor.execute [ cursor . execute ] with an argument line .
if self.verbosity [ self . verbosity ] is greater of equal to integer 1 ,
if self.fixture_count [ self . fixture_count ] equals integer 0 and self.hide_empty [ self . hide_empty ] is true ,
do nothing .
otherwise if self.fixture_object_count [ self . fixture_object_count ] equals self.loaded_object_count [ self . loaded_object_count ] ,
call the method self.stdout.write [ self . stdout . write ] with an argument string _STR:0_ ,
where _STR:0_ is replaced with self.loaded_object_count [ self . loaded_object_count ] and self.fixture_count [ self . fixture_count ] , respectively . if not ,
call the method self.stdout.write [ self . stdout . write ] with an argument string _STR:0_ ,
substitute _STR:0_ with self.loaded_object_count [ self . loaded_object_count ] , self.fixture_object_count [ self . fixture_object_count ] and self.fixture_count [ self . fixture_count ] . define the method load_label with self and fixture_label as arguments .
for every fixture_file , fixture_dir and fixture_name in return value of the method self.find_fixtures [ self . find_fixtures ] called with an argument fixture_label ,
call the function os.path.basename [ os . path . basename ] with an argument fixture_file , use the result as an argument for the call to the method ,
self.parse_name [ self . parse_name ] , assign the result to _ , ser_fmt and cmp_fmt , respectively . get the value under the cmp_fmt key of the self.compression_formats [ self . compression_formats ] dictionary , assign it to open_method and mode .
call the function open_method with arguments : fixture_file and mode , substitute the result for fixture .
try ,
increment self.fixture_count [ self . fixture_count ] by one .
objects_in_fixture is integer 0 .
loaded_objects_in_fixture is integer 0 .
if self.verbosity [ self . verbosity ] is greater or equal to integer 2 ,
call the method self.stdout.write [ self . stdout . write ] with an argument string _STR:0_ ,
substitute ' % s ' with ser_fmt , fixture_name and return value of the function humanize called with an argument fixture_dir . call the method serializers.deserialize [ serializers . deserialize ] with 4 arguments : ser_fmt , fixture , using set to self.using [ self . using ] ,
and ignorenonexistent set to self.ignore [ self . ignore ] , substitute the result for objects . for every obj in objects ,
increment objects_in_fixture by one .
call the method router.allow_migrate [ router . allow_migrate ] with 2 arguments : self.using [ self . using ] and obj.object.__class__ [ obj . object . __class__ ] , if it evaluates to true ,
increment loaded_objects_in_fixture by one .
add obj.object.__class__ [ obj . object . __class__ ] to self.models [ self . models ] set .
try ,
call the method obj.save [ obj . save ] with an argument using set to self.using [ self . using ] .
if DatabaseError or IntegrityError , renamed to e , exceptions are caught ,
e.args [ e . args ] is a tuple containing string `` Could not load % ( app_label ) s. % ( object_name ) s ( pk= % ( pk ) s ) : % ( error_msg ) s ,
where _STR:0_ is replaced for obj.object._meta.app_label [ obj . object . _meta . app_label ] , _STR:1_ is replaced with obj.object._meta.object_name [ obj . object . _meta . object_name ] , _STR:2_ is replaced with obj.object.pk [ obj . object . pk ] and _STR:3_ is replaced with result of the function force_text with an argument e. raise an exceptions
increment self.loaded_object_count [ self . loaded_object_count ] by loaded_objects_in_fixture .
increment self.fixture_object_count [ self . fixture_object_count ] by objects_in_fixture .
if Exception , renamed to e , exception is caught ,
if e is not an instance of CommandError class ,
e.args [ e . args ] is a tuple containing string _STR:0_ , where ' % s ' is replaced with fixture_file , e .
raise an exception .
finally perform ,
call the method fixture.close [ fixture . close ] .
if objects_in_fixture equals integer 0 ,
call the method warnings.warn [ warnings . warn ] with 2 arguments : string _STR:0_ ,
where ' % s ' is replaced with fixture_name , and RuntimeWarning . decorator method lru_cache.lru_cache [ lru_cache . lru_cache ] with an argument maxsize set to None .
define the method find_fixtures with arguments : self and fixture_label .
call the method self.parse_name [ self . parse_name ] with an argument fixture_label , substitute the result for fixture_name , ser_fmt , cmp_fmt , respective .
databases is a list containing 2 elements : self.using [ self . using ] and None .
call the method self.compression_formats.keys [ self . compression_formats . keys ] , convert it to list , substitute it for cmp_fmts if cmp_fmt is None ,
otherwise cmp_fmts is a list containing cmp_fmt . call the method serializers.get_public_serializer_formats [ serializers . get_public_serializer_formats ] , substitute the result for ser_fmts if ser_fmt is None ,
otherwise ser_fmts is a list containing ser_fmt . if self.verbosity [ self . verbosity ] is greater or equal to integer 2 ,
call the method self.stdout.write [ self . stdout . write ] with an argument string _STR:0_ , where ' % s ' is replaced with fixture_name .
if fixture_name is an absolute file path ,
call the method os.path.dirname [ os . path . dirname ] with an argument fixture_name , append it to a list , substitute resulting list for fixture_dirs .
call the method os.path.basename [ os . path . basename ] with an argument fixture_name , substitute the result for fixture_name .
if not ,
substitute self.fixture_dirs [ self . fixture_dirs ] for fixture_dirs .
if os.path.sep [ os . path . sep ] is contained in fixture_name ,
join dir_ and return value of the function os.path.dirname [ os . path . dirname ] called with an argument fixture_name into a valid file path ,
append it to a list , perform the previous for every dir_ in fixture_dirs , substitute the resulting list for fixture_dirs . call the method os.path.basename [ os . path . basename ] with an argument fixture_name , substitute the result for fixture_name .
for every ext in combo , if ext is true , join it to a string , separated by _STR:0_ , put the result in a tuple ,
perform the previous for every combo in result of the function product called with 3 arguments : databases , ser_fmts and cmp_fmts , substitute the result for suffixes . join fixture_name and suffix into a string , separated by _STR:0_ for every suffix in suffixes , put the results in set , substitute it for targets .
fixture_files is an empty list .
for every fixture_dir in fixture_dirs ,
if self.verbosity [ self . verbosity ] is greater or equals to integer 2 .
call the method self.stdout.write [ self . stdout . write ] with an argument string _STR:0_ ,
where ' % s ' is replaced with result of the function humanize , called with an argument fixture_dir . fixture_files_in_dir is an empty list .
join fixture_dir , fixture_name with appended character _STR:0_ into a valid file path ,
use it as an argument for the call to the glob.iglob [ glob . iglob ] , for every candidate in result , call the method os.path.basename [ os . path . basename ] with an argument candidate , is result is contained in targets ,
append tuple containing 3 elements : candidate , fixture_dir and fixture_name to list fixture_files_in_dir .
if self.verbosity [ self . verbosity ] is greater or equals integer 2 and fixture_files_in_dir is false ,
call the method self.stdout.write [ self . stdout . write ] with an argument string _STR:0_ , where ' % s ' is replaced with fixture_name ,
and result of the function humanize called with an argument fixture_dir . if length of fixture_files_in_dir is greater than 1 ,
raise an CommandError exception with an argument string _STR:0_ , where ' % s ' is replaced with :
fixture_name and result of the function humanize called with an argument fixture_dir . extend fixture_files list with fixture_files_in_dir .
if fixture_name is not equal to string _STR:0_ and fixture_files is false ,
call the method warnings.warn [ warnings . warn ] with an argument string _STR:0_ where ' % s ' is replaced with fixture_name .
return fixture_files .
decorator cached_property ,
define the method fixture_dirs with an argument self .
dirs is an empty dictionary .
for ever app_config in return value of the method apps.get_app_configs [ apps . get_app_configs ] ,
if self.app_label [ self . app_label ] is true and app_config.label [ app_config . label ] is not equal to self.app_label [ self . app_label ] ,
skip this loop iteration .
join app_config.path [ app_config . path ] and string _STR:0_ into a valid file path , substitute it for app_dir .
if app_dir is a directory ,
append app_dir to dirs list .
convert settings.FIXTURE_DIRS [ settings . FIXTURE_DIRS ] to a list , extend dirs by it .
append an empty string to dirs list .
call the function os.path.realpath [ os . path . realpath ] with an argument d , use the result as an argument for the call to the function os.path.abspath [ os . path . abspath ] ,
use the result as an argument for the call to the upath function , for every d in dirs , append the results into a list , substitute the resulting list for dirs . return dirs .
define the method parse_name with arguments self and fixture_name .
call the method fixture_name.rsplit [ fixture_name . rsplit ] with 2 arguments : character _STR:0_ and integer 2 , substitute the result for parts .
if length of parts is greater than integer 1 and last element of parts is contained in self.compression_formats [ self . compression_formats ] ,
substitute the last element of parts for cmp_fmt .
substitute the last element of parts for parts .
if not ,
cmp_fmt is None .
if length of parts is greater than integer 1 .
if last element of parts is contained in self.serialization_formats [ self . serialization_formats ] ,
substitute the last element of parts for ser_fmt .
substitute the last element of parts for parts .
if not ,
raise an CommandError with an argument string _STR:0_ ,
replace ' % s ' with : elements of last element of parts joined into a string and last element of parts . if not ,
ser_fmt is None .
join elements of parts into a string , separated with _STR:0_ , substitute it for name .
return name , ser_fmt and cmp_fmt .
derive class SingleZipReader for zipfile.ZipFile [ zipfile . ZipFile ] base class .
define the method __init__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
call the method zipfile.ZipFile.__init___ [ zipfile . ZipFile . __init___ ] with the arguments self , unpacked list args and unpacked dictionary kwargs .
call the method self.namelist [ self . namelist ] , if the length of the result is not integer 1 ,
raise an ValueError with an string _STR:0_ .
define the method read with an argument self .
call the method zipfile.ZipFile.read [ zipfile . ZipFile . read ] with 2 arguments : self and first element of the result of the self.namelist [ self . namelist ] method .
define the function humanize with an argument dirname .
if dirname is true , return dirname converted to a string and surounded by single quotes , if not return string _STR:0_ .
from __future__ import unicode_literals into default name space .
import module fnmatch .
import module glob .
import module io .
import module os .
import module re .
import module sys .
from itertools import dropwhile into default name space .
import module django .
from django.core.management.base [ django . core . management . base ] import CommandError and BaseCommand into default name space .
from django.core.management.utils [ django . core . management . utils ] import handle_extensions , find_command and popen_wrapper into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_st into default name space .
from django.utils.functional [ django . utils . functional ] import total_ordering into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.text [ django . utils . text ] import get_text_list into default name space .
from django.utils.jslex [ django . utils . jslex ] import prepare_js_for_gettext into default name space .
call the method re.compile [ re . compile ] with 2 arguments : raw string _STR:0_ ,
and result of the bitwise OR performed on the re.MULTILINE [ re . MULTILINE ] and re.DOTALL [ re . DOTALL ] operands , substitute the result for plural_forms_re/ STATUS_OK is integer 0 .
define the method check_programs with an argument unpacked list programs .
for every program in programs ,
call the function find_command with an argument program , if it evaluates to None ,
raise an CommandError exception with an argument _STR:0_ , where ' % s ' is replaced with program .
total_ordering decorator ,
derive the class TranslatableFile from the object class .
define the method __init__ with 4 arguments : self , dirpath , file_name and locale_dir .
substitute file_name for self.file_name [ self . file_name ] .
substitute dirpath for self.dirpath [ self . dirpath ] .
substitute locale_dir for self.locale_dir [ self . locale_dir ] .
define the method __repr__with an argument self .
join self.dirpath [ self . dirpath ] and self.file [ self . file ] in a string , substitute with it ' % s ' in string _STR:0_ , return the result .
define the method __eq__ with self and other arguments :
if self.path [ self . path ] equals other.path [ other . path ] , return boolean True , if not return boolean False .
define the mehod __lt__ with self and other .
if self.path [ self . path ] is lesser than other.path [ other . path ] , return boolean True , otherwise return boolean False .
property decorator .
define the method path with an argument self .
join self.dirpath [ self . dirpath ] and self.file [ self . file ] into a file path , return it .
define the method process with 3 arguments : self , command and domain .
from django.conf [ django . conf ] import settings into default namespace .
from django.utils.translation [ django . utils . translation ] import templatize into default namespace .
if command.verbosity [ command . verbosity ] is greater than integer 1 ,
substitute ' % s ' is string _STR:0_ with self.file [ self . file ] and self.dirpath [ self . dirpath ] , write it to command.stdout [ command . stdout ] .
call the method os.path.splitext [ os . path . splitext ] with an argument self.file [ self . file ] , assign the result to _ and file_ext .
if domain equals a string _STR:0_ and file_ext is contained in command.extensions [ command . extensions ] ,
is_templatized is boolean True .
join self.dirpath [ self . dirpath ] and self.file [ self . file ] into a file path , substitute it for orig_file .
call the function io.open [ io . open ] with orig_file and encoding set to settings.FILE_CHARSET [ settings . FILE_CHARSET ] , with the result renamed to fp ,
perform the following : call the method fp.read [ fp . read ] , substitute the result for src_data .
call the function prepare_js_for_gettext with an argument src_data , substitute it for src_data .
convert self.file [ self . file ] to a string and append _STR:0_ string to it , substitute the result for thefile .
join self.dirpath [ self . dirpath ] and thefile in a string , substitute the result for work_file .
call the function io.open [ io . open ] with 3 arguments : work_file , string _STR:0_ and encoding set to string _STR:1_ as arguments ,
with the result renamed to fp , perform the following : call the method fp.write [ fp . write ] with an arguments src_data .
append command.xgettext_options [ command . xgettext_options ] to the list containing 10 elements : string _STR:0_ , string _STR:1_ , domain , string _STR:2_ ,
string _STR:0_ , string _STR:1_ , string _STR:2_ , string _STR:3_ , string _STR:4_ and string _STR:5_ , substitute it for args . append work_file to args .
otherwise if domains equals a string django_STR:0_.py [ django_STR:0_ . py ] ' or file_ext is contained in command.extensions [ command . extensions ] ,
substitute self.file [ self . file ] for thefile .
join self.dirpath [ self . dirpath ] and self.file [ self . file ] into a file path , substitute it for orig_file .
if file_ext is contained in command.extensions [ command . extensions ] , is_templatized is boolean True , otherwise it is boolean False .
if is_templatized is true ,
call the function io.open [ io . open ] with 3 arguments : work_file , string _STR:0_ and encoding set to settings.FILE_CHARSET [ settings . FILE_CHARSET ] as arguments ,
with the result renamed to fp , perform the following : call the method fp.read [ fp . read ] , substitute the result for src_data .
convert self.file [ self . file ] to string and append string _STR:0_ to it , substitute the result for thefile .
call the function templatize with 2 arguments : src_data and sliced orig_file , without first 2 elements , substitute the result for content .
call the function io.open [ io . open ] with 3 arguments : self.dirpath [ self . dirpath ] and thefile joined into a file path , string _STR:0_ ,
and encoding set to string _STR:0_ as arguments , with the result renamed to fp , perform the following : call the method fp.write [ fp . write ] with an argument content .
join self.dirpath [ self . dirpath ] , thefile into a file path , substitute it for work_file .
append command.xgettext_options [ command . xgettext_options ] to list containing 15 elements : string _STR:0_ , string _STR:1_ , domain , string _STR:2_ ,
string _STR:0_ , string _STR:1_ , string _STR:2_ , string _STR:3_ , string _STR:4_ , string _STR:5_ , string _STR:6_ , string _STR:7_ , string _STR:8_ , string _STR:9_ and string _STR:10_ , substitute the result for args . append work_file to args .
if not ,
return nothing .
call the function popen_wrapper with argument args , assign the result to msgs , errors and status .
if errors is true ,
if status is not equal to STATUS_OK ,
if is_templatized is true ,
call the function os.unlink [ os . unlink ] with an argument work_file .
raise an CommandError exception with an argument string _STR:0_ ,
where ' % s ' are replaced by sel.file [ sel . file ] and errors , respectively . if command.verbosity [ command . verbosity ] is greater than integer 0 ,
call the method command.stdout.write [ command . stdout . write ] with an argument errors .
if msgs is true ,
if six.PY2 [ six . PY2 ] is true ,
call the method msgs.decode [ msgs . decode ] with an argument string _STR:0_ , substitute the result for msgs .
join into a file path : self.locale_dir [ self . locale_dir ] and string _STR:0_ appended to domain converted to string , substitute it for potfile .
if is_templatized is true ,
if os.name [ os . name ] equals string _STR:0_ ,
append work_file to string _STR:0_ , substitute it for old .
append orig_file to string _STR:0_ , substitute it for new .
if not ,
append work_file to string _STR:0_ , substitute it for old .
append orig_file to string _STR:0_ , substitute it for new .
replace every occurrence of old for new in msgs , substitute the result for msgs .
call the function write_pot_file with 2 arguments : potfile and msgs .
if is_templatized is true ,
call the function os.unlink [ os . unlink ] with an argument work_file .
define the function write_pot_file with 2 arguments potfile and msgs .
if potfile fie exists ,
call the function dropwhile with 2 arguments : function len and msgs spit into parts at newlines , join the result into a string ,
separated by newline , substitute it for msgs . if not ,
replace every occurrence of string _STR:0_ for string _STR:1_ in msgs , substitute the result for msgs .
call the function io.open [ io . open ] with 3 arguments : potfile , string _STR:0_ and encoding set to string _STR:1_ as arguments ,
with the result renamed to fp , perform the following : call the method fp.write [ fp . write ] with an argument msgs .
derive the class Command from the BaseCommands base class .
help is a string _STR:0_
_STR:0_ _STR:1_ _STR:2_ _STR:3_ . requires_system_checks is boolean False .
leave_locale_alone is boolean True
msgmerge_options is an list with elements : strings _STR:0_ and _STR:1_ .
msguniq_options is an list with elements : string _STR:0_ .
msgattrib_options is an list with elements : string _STR:0_ .
xgettext_options is an list with elements : strings _STR:0_ and _STR:1_ .
define the method add_arguments with 2 arguments : self and parser .
call the method parser.add_argument [ parser . add_argument ] with 6 arguments : string _STR:0_ , string _STR:1_ , default as an empty list ,
dest as a string _STR:0_ , action as a string _STR:1_ and help as a string , _STR:2_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:3_ , string _STR:4_ , default as a empty list ,
dest as a string _STR:0_ , action as a string _STR:1_ and help as a string _STR:2_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:3_ , string _STR:4_ , default as a string _STR:5_ ,
dest set to string _STR:0_ and help as a string _STR:1_ . call the method parser.add_argument [ parser . add_argument ] with 6 arguments : string _STR:2_ , string _STR:3_ , action as a string_STR:4_ ,
dest as a string _STR:0_ default as boolean False and help as a string _STR:1_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:2_ , string _STR:3_ , dest set to string _STR:4_ ,
help set to a string _STR:0_ _STR:1_ and action as a string _STR:2_ . call the method parser.add_argument [ parser . add_argument ] with 6 arguments : string _STR:3_ , string _STR:4_ , action as a string _STR:5_ ,
dest as a string _STR:0_ , default as boolean False and help as a string _STR:1_ _STR:2_ . call the method parser.add_argument [ parser . add_argument ] with 7 arguments : string _STR:3_ , string _STR:4_ , action as a string _STR:5_ ,
dest as a string _STR:0_ , default as an empty list , metavar as a string _STR:1_ , and help as a string _STR:2_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:3_ , action as a string _STR:4_ ,
dest as a string _STR:0_ , default set to boolean True , and help as a string _STR:1_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:2_ , action as a string _STR:3_ , dest as a string _STR:4_ ,
default as boolean False and help as a string _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:1_ , action set to string _STR:2_ ,
dest set to string _STR:0_ , default as boolean False and help as a string _STR:1_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:2_ , action as a string _STR:3_ ,
dest as a string _STR:0_ , default as boolean False and help as a string _STR:1_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:2_ , action as a string _STR:3_ ,
dest as a string _STR:0_ , default as boolean False and help as a string _STR:1_ define the method handle with 3 arguments : self , unpacked list args and unpacked dictionary options .
get the value under the _STR:0_ key of the options dictionary , substitute it for locale .
get the value under the _STR:0_ key of the options dictionary , substitute it for exclude .
get the value under the _STR:0_ key of the options dictionary , substitute it for self.domain [ self . domain ] .
get the value under the _STR:0_ key of the options dictionary , substitute it for self.verbosity [ self . verbosity ] .
get the value under the _STR:0_ key of the options dictionary , substitute it for process_all .
get the value under the _STR:0_ key of the options dictionary , substitute it for extensions .
get the value under the _STR:0_ key of the options dictionary , substitute it for self.symlinks [ self . symlinks ] .
get the value under the _STR:0_ key of the options dictionary , substitute it for ignore_patterns .
get the value under the _STR:0_ key of the options dictionary , if it is true ,
append list containing 4 elements : _STR:0_ , _STR:1_ , _STR:2_ and _STR:3_ , to ignore_patterns .
put elements of ignore_patterns into a set , substitute the length of it for self.ignore_patterns [ self . ignore_patterns ] .
get the value under the _STR:0_ key of the options dictionary , if it is true ,
append list containing string _STR:0_ to self.msgmerge_options [ self . msgmerge_options ]
append list containing string _STR:0_ to self.msguniq_options [ self . msguniq_options ] .
append list containing string _STR:0_ to self.msgattrib_options [ self . msgattrib_options ] .
append list containing string _STR:0_ to self.xgettext_options [ self . xgettext_options ] .
get the value under the _STR:0_ key of the options dictionary , if it is true ,
append list containing string _STR:0_ to self.msgmerge_options [ self . msgmerge_options ] .
append list containing string _STR:0_ to self.msguniq_options [ self . msguniq_options ] .
append list containing string _STR:0_ to self.msgattrib_options [ self . msgattrib_options ] .
append list containing string _STR:0_ to self.xgettext_options [ self . xgettext_options ] .
get the value under the _STR:0_ key of the options dictionary , substitute it for self.no_obsolete [ self . no_obsolete ] .
get the value under the _STR:0_ key of the options dictionary , substitute it for self.keep_pot [ self . keep_pot ] .
if self.domain [ self . domain ] is not equal to string _STR:0_ or string _STR:1_ ,
raise an CommandError exception with an argument string _STR:0_ .
if self.domain [ self . domain ] equals to string _STR:0_ ,
if extensions is false , substitute it for exts , otherwise exts is a list containing string _STR:0_ .
if not ,
if extensions is false , substitute it for exts , otherwise exts is a list containing 2 elements : string _STR:0_ and string _STR:1_ .
call the function handle_extensions exts , substitute self.extensions [ self . extensions ] .
evaluate the boolean expression : locale is None and exclude is false and process_all is false ,
if the result is true or self.domain [ self . domain ] is not None , raise an CommandError exception with an argument string _STR:0_ , where ' % s ' are replaced by :
return value of the function os.path.basename [ os . path . basename ] called with first element of sys.argv [ sys . argv ] as an argument , and second element of sys.argv [ sys . argv ] . from django.conf [ django . conf ] import settings into default namespace .
if settings.configured [ settings . configured ] ,
settings.USE_I18N [ settings . USE_I18N ] is boolean True .
if not ,
call the method settings.configure [ settings . configure ] with an argument USE_I18N set to boolean True .
if self.verbosity [ self . verbosity ] is integer 1 ,
call the method self.stdout.write [ self . stdout . write ] with an argument string _STR:0_ ,
substitute ' % s ' with return value of the function get_text_list called with 2 arguments : self.extensions [ self . extensions ] converted into a list and string _STR:0_ . self.invoked_for_django [ self . invoked_for_django ] is boolean False .
self.locale_paths [ self . locale_paths ] is an empty list .
self.default_locale_path [ self . default_locale_path ] is None .
join _STR:0_ and _STR:1_ into a file path , if it is a directory ,
join _STR:0_ and _STR:1_ into a file path , use it as an argument for the call the method os.path.abspath [ os . path . abspath ] ,
put the results into a list , substitute self.locale_paths [ self . locale_paths ] for it . substitute first element of self.locale_paths [ self . locale_paths ] for self.default_locale_path [ self . default_locale_path ] .
self.invoked_for_django [ self . invoked_for_django ] is boolean True .
if not ,
convert settings.LOCALE_PATHS [ settings . LOCALE_PATHS ] into a list and extend list self.locale_paths [ self . locale_paths ] with it .
if _STR:0_ is a directory ,
call the function os.path.abspath [ os . path . abspath ] with an argument _STR:0_ , append the result to self.locale_paths [ self . locale_paths ] .
if self.locale_paths [ self . locale_paths ] is true ,
substitute first element of self.locale_paths [ self . locale_paths ] for self.default_locale_path [ self . default_locale_path ] .
if self.default_locale_path [ self . default_locale_path ] directory doesnt exists ,
create a directory self.default_locale_path [ self . default_locale_path ] .
call the function glob.glob [ glob . glob ] with an argument : string _STR:0_ appended to self.default_locale_path [ self . default_locale_path ] converted into a string ,
filter out the results for which function os.path.isdir [ os . path . isdir ] returns false , substitute the result for locale_dirs . map the locale_dirs elements with mapping function os.path.basename [ os . path . basename ] , substitute the result for all_locales .
if process_all is true ,
substitute all_locales for locales .
if not ,
if locale is not false or None , substitute it for locales , otherwise substitute all_locales for locales .
locales is a difference between the locales and exclude sets .
if locales is true ,
call the function check_programs with 3 arguments : strings _STR:0_ , _STR:1_ and _STR:2_ .
call the function check_programs with an argument string _STR:0_ .
try ,
call the method self.build_potfiles [ self . build_potfiles ] , substitute the result for potfiles .
for every locale in locales ,
if self.verbosity [ self . verbosity ] is greater than integer 0 ,
replace ' % s ' in string _STR:0_ with locale , write it to self.stdout [ self . stdout ] .
for every potfile in potfiles ,
call the method self.write_po_file [ self . write_po_file ] with 2 arguments : potfile and locale .
finally perform ,
if self.keep_pot [ self . keep_pot ] is false ,
call the method self.remove_potfiles [ self . remove_potfiles ] .
define the method build_potfiles with an argument self .
call the method self.find_files [ self . find_files ] with an argument string _STR:0_ , substitute the result for file_list .
call the method self.remove_potfiles [ self . remove_potfiles ] .
for f in file_list ,
try ,
call the function f.process [ f . process ] with 2 arguments : self and self.domain [ self . domain ] .
if except UnicodeDecodeError exception is caught ,
substitute ' % s ' in string _STR:0_ with f.file [ f . file ] and f.dirpath [ f . dirpath ] , write it to self.stdout [ self . stdout ] .
potfiles is an empty list .
for every path in self.locale_paths [ self . locale_paths ] ,
join into a path : path and string _STR:0_ , where ' % s ' is replaced with self.domain [ self . domain ] converted into a string .
if potfile file path doesnt exist ,
skip this loop iteration .
append self.msguniq_options [ self . msguniq_options ] to a list containing a string _STR:0_ , append list containing potfile to the result , substitute it for args .
call the function popen_wrapper with an argument args , assign the result to msgs , errors and status , respectively .
if six.PY2 [ six . PY2 ] is true ,
call the method msgs.decode [ msgs . decode ] with an argument string _STR:0_ , substitute it for msgs .
if errors is true ,
if status is not equal to STATUS_OK ,
raise an CommandError exception with an argument string _STR:0_ , where ' % s ' is replaced with errors .
otherwise if self.verbosity [ self . verbosity ] is greater than integer 0 ,
write errors to self.stdout [ self . stdout ] .
call the function io.open [ io . open ] with 3 arguments : potfile , string _STR:0_ and encoding set to string _STR:1_ as arguments ,
with the result renamed to fp , perform the following : write msgs to fp .
append potfile to potfiles .
return potfiles .
define the method remove_potfiles with an argument self .
for every path in self.locale_paths [ self . locale_paths ] ,
join into a file path : path and string _STR:0_ , where ' % s ' is replaced with self.domain [ self . domain ] converted into a string , substitute the result for pot_path .
if pot_path file path exists ,
call the method os.unlink [ os . unlink ] with an argument pot_path .
define the method find_potfiles with an arguments self and root .
define the function is_ignored with arguments path and ignore_patterns .
call the function os.path.basename [ os . path . basename ] with an arguments path , substitute the result for filename .
ignore is a lambda function with pattern as an argument , return value is the return value of the function fnmatch.fnmatchcase [ fnmatch . fnmatchcase ] ,
called with arguments : filename and pattern . call the function ignore with an argument pattern , for every pattern in ignore_patterns ,
if any resulting element is true , return boolean True , otherwise return boolean False . convert os.sep [ os . sep ] into a string and append _STR:0_ to it , substitute the result for dir_suffix .
for p in self.ignore_patterns [ self . ignore_patterns ] if p ends with dir_suffix take sliced list p from the start ,
to the negative length of the dir_suffix as the end index and append it to a list , if p doesnt end with dir_suffix , append p to a list , substitute resulting list for norm_patterns . all_files is an empty list .
call the function os.walk [ os . walk ] with 3 arguments : root , topdown set to boolean True , followlinks set to self.symlinks [ self . symlinks ] ,
for every dirpath , dirnames and filenames in the result , for every dirname in list dirnames ,
join dirpath and dirname into a file path , use is as an argument for the call to the function os.path.join [ os . path . join ] ,
use the result as an argument for the call to the os.path.join [ os . path . join ] function , use the result and the norm_patterns as arguments for the call to the is_ignored function , if it evaluates to true , remove dirname from the dirnames .
if self.verbosity [ self . verbosity ] is greater than integer 1 ,
replace ' % s ' in string _STR:0_ with dirname , write it to self.stdout [ self . stdout ] stream .
otherwise if dirname equals string _STR:0_ ,
remove dirname from the dirnames .
call the method os.path.abspath [ os . path . abspath ] with an argument dirpath , join the result and dirname into a file path , inset it at the beggining of self.locale_paths [ self . locale_paths ] .
for every filename in filenames ,
join dirpath and filename into path , use it as an argument for the call to the function os.path.normpath [ os . path . normpath ] , substitute it for file_path .
call the function is_ignored , with arguments : file_path and self.ignore_patterns [ self . ignore_patterns ] , if it evaluates to true ,
if self.verbosity [ self . verbosity ] is greater than integer 1 ,
replace ' % s ' in string _STR:0_ with filename and dirpath , write it to self.stdout [ self . stdout ] .
if not ,
locale_dir is None .
for every path in self.locale_paths [ self . locale_paths ] ,
call the function os.path.abspath [ os . path . abspath ] with an argument dirpath , if it starts with return value of the method os.path.dirname [ os . path . dirname ] ,
called with an argument path , substitute path for locale_dir .
break the loop execution .
if locale_dir is false ,
substitute self.default_locale_path [ self . default_locale_path ] for locale_dir .
if locale_dir is false ,
raise an CommandError with an argument string _STR:0_ ,
where ' % s ' is replaced with file_path . create an object TranslatableFile with arguments : dirpath , filename and locale_dir , append it to all_files .
sort all_files and return it .
define the method write_po_file with arguments self , potfile and locale .
call the method os.path.dirname [ os . path . dirname ] with an argument potfile , join the result , locale and string _STR:0_ into a file path ,
substitute it for basedir . if basedir is not a directory ,
make basedir directory ,
convert self.domain [ self . domain ] into a string and append string _STR:0_ to it , join basedir and result in file path , substitute it for pofile .
if pofile path exists ,
append self.msgmerge_options [ self . msgmerge_options ] to a list containing string _STR:0_ , append to it a list containing pofile and potfile , substitute the result for args .
call the function popen_wrapper with an argument args , assign the result to msgs , errors and status .
if six.PY2 [ six . PY2 ] is true ,
call the method msgs.decode [ msgs . decode ] with an argument string _STR:0_ , substitute the result for msgs .
if errors is true ,
if statue is not equal to STATUS_OK .
raise an CommandError with an argument string _STR:0_ , where ' % s ' is replaced with errors .
otherwise if self.verbosity [ self . verbosity ] is greater than integer 0 ,
write errors to self.stdout [ self . stdout ] .
if not ,
call the function io.open [ io . open ] with 3 arguments : potfile , string _STR:0_ and encoding set to string _STR:1_ as arguments ,
with the result renamed to fp , perform the following : read file fp and substitute the result for msgs .
if self.invoked_for_django [ self . invoked_for_django ] is false ,
call the method self.copy_plural_forms [ self . copy_plural_forms ] with arguments : msgs and locale , substitute it for msgs .
substitute ' % s ' in string _STR:0_ with self.domain [ self . domain ] ,
replace all the occurrences of previous string in msgs for an empty string , substitute the result for msgs . call the function io.open [ io . open ] with 3 arguments : pofile , string _STR:0_ and encoding set to string _STR:1_ as arguments ,
with the result renamed to fp , perform the following : write msgs to fp .
if self.no_obsolete [ self . no_obsolete ] is true ,
append self.msgattrib_options [ self . msgattrib_options ] to a list containing string _STR:0_ , append to it a list containing string _STR:1_ , pofile and pofile ,
substitute the result for args . call the function popen_wrapper with an argument args , assign the result to msgs , errors and status , respectively .
if errors is true ,
if status is not equal to STATUS_OK ,
raise an CommandError with an argument string _STR:0_ , where ' % s ' is replaced with errors .
otherwise if self.verbosity [ self . verbosity ] is greater than integer 0 ,
write errors to self.stdout [ self . stdout ] .
define the method copy_plural_forms with arguments self , msgs and locale .
call the function os.path.dirname [ os . path . dirname ] with an argument django.__file__ [ django . __file__ ] , join the result into a path ,
use it as an argument for the call to the function os.path.normpath [ os . path . normpath ] , substitute the result for django_dir . if self.domain [ self . domain ] equals a string _STR:0_ ,
domains is a tuple with 2 elements : strings _STR:0_ and _STR:1_ .
if not ,
domains is a tuple with element string _STR:0_ .
for every domain in domains ,
join into a file path : django_dir , _STR:0_ , _STR:1_ , locale , _STR:2_ and string _STR:3_ appended to domain , substitute the result for django_po .
if django_po file path exists ,
call the function io.open [ io . open ] with 3 arguments : django_po , string _STR:0_ and encoding set to string _STR:1_ as arguments ,
with the result renamed to fp , perform the following : read data from file fp , use the result as an argument for the call to the function plural_forms_re.search [ plural_forms_re . search ] , substitute it for m .
if m is true ,
call the method m.group [ m . group ] with an argument string _STR:0_ , use the result as an argument for the call to the force_str ,
substitute the result for plural_form_line . if self.verbosity [ self . verbosity ] is greater than integer 1 ,
replace ' % s ' in string _STR:0_ with plural_form_line , write it to self.stdout [ self . stdout ] .
lines is an empty list .
found is boolean False .
split msgs by newline characters , for every line in result ,
if found is false and , line is false or return value of the function plural_forms_re.search [ plural_forms_re . search ] called with an argument line is false ,
append newline to plural_form_line , substitute the result for line .
found is boolean True .
append line to lines .
join elements of lines into a string , separated by newline characters , substitute it for msgs .
break the loop execution .
return msgs .
import module sys .
import module os .
import module operator .
from django.apps [ django . apps ] import apps into default name space .
from django.core.management.base [ django . core . management . base ] import BaseCommand and CommandError into default name space .
from django.db.migrations [ django . db . migrations ] import Migration into default name space .
from django.db.migrations.loader [ django . db . migrations . loader ] import MigrationLoader into default name space .
from django.db.migrations.autodetector [ django . db . migrations . autodetector ] import MigrationAutodetector into default name space .
from django.db.migrations.questioner [ django . db . migrations . questioner ] import MigrationQuestioner and InteractiveMigrationQuestioner into default name space .
from django.db.migrations.state [ django . db . migrations . state ] import ProjectState into default name space .
from django.db.migrations.writer [ django . db . migrations . writer ] import MigrationWriter into default name space .
from django.utils.six.moves [ django . utils . six . moves ] import reduce into default name space .
derive the class Command from the BaseCommand class .
help is a string _STR:0_ .
define the method add_arguments with 2 arguments self and parser .
call the method parser.add_argument [ parser . add_argument ] with 4 arguments : string _STR:0_ , metavar set to string _STR:1_ , nargs set to character_STR:2_ ,
and help as a string _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:1_ , action as a string _STR:2_ , dest as string _STR:3_ ,
default set to boolean False , help as a string _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:1_ , action as a string _STR:2_ , dest as a string _STR:3_ ,
default set to boolean False and help set to a string _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:1_ , action as a string _STR:2_ , dest as a string _STR:3_ ,
default set to boolean False and help as a string _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:1_ , action as a string _STR:2_ ,
dest as a string _STR:0_ , default set to boolean True , and help as a string _STR:1_ . define the method handle with 3 arguments : self , unpacked list app_labels and unpacked dictionary options .
get the value under the _STR:0_ key of the options dictionary , substitute it for self.verbosity [ self . verbosity ] .
get the value under the _STR:0_ key of the options dictionary , substitute it for self.interactive [ self . interactive ] .
get the value under the _STR:0_ key of the options dictionary , if the key exists substitute it for self.dry_run [ self . dry_run ] ,
if not , self.dry_run [ self . dry_run ] is boolean False . get the value under the _STR:0_ key of the options dictionary , if the key exists substitute it for self.merge [ self . merge ] ,
if not , self.merge [ self . merge ] is boolean False . get the value under the _STR:0_ key of the options dictionary , if the key exists substitute it for self.empty [ self . empty ] ,
if not , self.empty [ self . empty ] is boolean False . crate a set containing of app_labels elements , substitute it for app_labels .
bad_app_labels is an empty set .
for every app_label in app_labels ,
try ,
call the method apps.get_app_config [ apps . get_app_config ] with an argument app_label .
if LookupError exception is caught ,
call the method bad_app_labels with an argument app_label ,
if bad_app_labels is true ,
for every app_label in bad_app_labels ,
write string _STR:0_ with ' % s ' where ' % s ' is replaced with app_label ,
write it for self.stderr [ self . stderr ] . exit the program with the integer 2 as exit code .
loader is an instance of MigrationLoader class , created with 2 arguments : None and ignore_no_migrations set to boolean True .
call the method loader.detect_conflicts [ loader . detect_conflicts ] , substitute the result for conflicts .
if conflicts is true and self.merge [ self . merge ] is false ,
for every app and names in result of the method conflicts.items [ conflicts . items ] , join names into a string , separated by _STR:0_ ,
join it with app into a string , separated with string _STR:0_ , substitute it for name_str . substitute _STR:1_python manage.py [ manage . py ] makemigrations -- merge ' '' ,
with name_str , use it as an argument to throw an CommandError exception . if self.merge [ self . merge ] is true and conflicts is false ,
write string _STR:0_ to self.stdout [ self . stdout ] stream .
return nothing .
if self.merge [ self . merge ] and conflicts are both true ,
call the method self.handle_merge [ self . handle_merge ] with 2 arguments : loader and conflicts , return the result .
autodetector is an instance of the MigrationAutodetector class , created with 3 arguments : result of the method loader.project_state [ loader . project_state ] ,
result of the method ProjectState.from_apps [ ProjectState . from_apps ] with an argument apps and result of the method InteractiveMigrationQuestioner , called with 2 arguments specified_apps set to app_labels and dry_run set to self.dry_run [ self . dry_run ] . if self.empty [ self . empty ] is true ,
if app_labels is false ,
raise an CommandError with an argument string _STR:0_ .
crate a dictionary with app mapping and from the class Migration , created with arguments : string _STR:0_ and app ,
for every app in app_labels . call the method autodetector.arrange_for_graph [ autodetector . arrange_for_graph ] with 2 arguments : changes , loader.graph [ loader . graph ] , substitute the result for changes .
call the method self.write_migration_files [ self . write_migration_files ] with an argument changes .
return nothing .
call the method autodetector.changes [ autodetector . changes ] with 3 arguments : graph set to loader.graph [ loader . graph ] , trim_to_apps set to app_labels ,
if it exists or None if not and convert_apps set to app_labels , if it exists or None if not , substitute the result for changes . if changes is false and self.verbosity [ self . verbosity ] is greater than , or equal to iteger 1 ,
if length of app_labels is equal to integer 1 ,
substitute ' % s ' in string _STR:0_ with the result of the method app_labels.pop [ app_labels . pop ] , write it to self.stdout [ self . stdout ] .
otherwise if length of app_labels is greater than integer 1 ,
substitute ' % s ' in string _STR:0_ with the app_labels joined into a string , separated by string _STR:1_ ,
write it to self.stdout [ self . stdout ] . if not ,
write string _STR:0_ to self.stdout [ self . stdout ] stream .
return nothing .
call the method self.write_migration_files [ self . write_migration_files ] with an argument changes .
define the method write_migration_files with arguments self and changes .
directory_created is an empty dictionary .
for every app_label and app_migrations in result of the method changes.items [ changes . items ] ,
if self.verbosity [ self . verbosity ] is greater or equal to integer 1 ,
substitute ' % s ' in a string _STR:0_ with app_label , append newline to it ,
use it as an argument for the call to the method self.style.MIGRATE_HEADING [ self . style . MIGRATE_HEADING ] , write the result to self.stdout [ self . stdout ] . for every migration in app_migrations ,
writer is an instance of MigrationWriter class , created with an argument migration .
if self.verbosity [ self . verbosity ] is greater or equal to integer 1 ,
substitute ' % s ' in a string _STR:0_ with return value of the self.style.MIGRATE_LABEL [ self . style . MIGRATE_LABEL ] method called with argument writer.filename [ writer . filename ] ,
write the result to self.stdout [ self . stdout ] . for every operation in migration.operations [ migration . operations ] ,
substitute ' % s ' in a string _STR:0_ with return value of the operation.describe [ operation . describe ] method , write the result to self.stdout [ self . stdout ] .
if self.dry_run [ self . dry_run ] is false ,
call the function os.path.dirname [ os . path . dirname ] with an argument writer.path [ writer . path ] , substitute the result for migrations_directory .
get the value under the app_label key of the directory_created dictionary , if exists and it is false ,
if migrations_directory is not a directory ,
make a directory migrations_directory .
join migrations_directory and string _STR:0_ into a file path , substitute it for init_path .
if init_path is not a file ,
crate a file named init_path .
value under the all_label key of the directory_created dictionary is boolean True .
call the method writer.as_string [ writer . as_string ] , substitute the result for migration_string .
open writer.path [ writer . path ] file in write mode , with the file descriptor as fh , perform ,
write migration_string to file fh .
otherwise if self.verbosity [ self . verbosity ] equals integer 3 ,
substitute ' % s ' in a string _STR:0_ with writer.filename [ writer . filename ] , append newline to it ,
use it as an argument for the call to the method self.style.MIGRATE_HEADING [ self . style . MIGRATE_HEADING ] , write the result to self.stdout [ self . stdout ] . call the method writer.as_string [ writer . as_string ] , append newline to the result , write it to self.stdout [ self . stdout ] .
define the method handle_merge with arguments self , loader and conflicts .
if self.interactive [ self . interactive ] is true ,
questioner is an instance of a InteractiveMigrationQuestioner class .
if not ,
questioner is an instance of a InteractiveMigrationQuestioner class , created with an argument : defaults set to dictionary with entry :
boolean True for _STR:0_ . for every app_label and migration_names in result of the method conflicts.items [ conflicts . items ] ,
merge_migrations is an empty list .
for every migration_name in migration_names ,
call the method loader.get_migration [ loader . get_migration ] with arguments app_label and migration_name , substitute the result for migration .
call the method loader.graph.forwards_plan [ loader . graph . forwards_plan ] with argument a tuple , with 2 elements : app_label and migration_name ,
substitute the result for migration.ancestry [ migration . ancestry ] . append migration to merge_migrations .
common_ancestor is None .
for m in merge_migrations append m.ancestry [ m . ancestry ] to a list , zip the resulting list into tuples of pairs , for every level in result ,
apply operator.eq [ operator . eq ] function to elements of level iterable , until level is reduced to a single value , if the result is true ,
substitute first element of level for common_ancestor .
if not ,
break the loop execution ,
if common_ancestor is None ,
raise an ValueError with an argument string _STR:0_ , where ' % s ' is replaced with migration_names .
for every migration in merge_migrations ,
call the method migration.ancestry.index [ migration . ancestry . index ] with an argument common_ancestor , increment the result by one ,
slice migration.ancestry [ migration . ancestry ] list from the last result as an starting index to the end , substitute the slice for migration.branch [ migration . branch ] . migration.merged_operations [ migration . merged_operations ] is an empty list .
for every node_app and node_name in migration.branch [ migration . branch ] ,
call the method loader.get_migration [ loader . get_migration ] with arguments node_app and node_name , extend the migration.merged_operations [ migration . merged_operations ] with the operations field of the result .
if self.verbosity [ self . verbosity ] is greater than integer 1 ,
substitute ' % s ' in a string _STR:0_ with app_label ,
use it as an argument for the call to the method self.style.MIGRATE_HEADING [ self . style . MIGRATE_HEADING ] , write the result to self.stdout [ self . stdout ] . for every migration in merge_migrations ,
substitute ' % s ' in a string _STR:0_ with migration.name [ migration . name ] ,
use it as an argument for the call to the method self.style.MIGRATE_HEADING [ self . style . MIGRATE_HEADING ] , write the result to self.stdout [ self . stdout ] . for every operation in migration.merged_operations [ migration . merged_operations ] ,
substitute ' % s ' in a string _STR:0_ with return value of the operation.describe [ operation . describe ] method , write the result to self.stdout [ self . stdout ] .
call the method questioner.ask_merge [ questioner . ask_merge ] with an argument app_label , if it evaluates to true ,
numbers is a list containing return value of the MigrationAutodetector.parse_number [ MigrationAutodetector . parse_number ] method called with an argument migration.name [ migration . name ] ,
for every migration in merge_migrations . try ,
biggest_number is maximum numbers element .
if ValueError exception is caught ,
biggest_number is integer 1 .
subclass is a instance of a class named Migration , derived from the base class Migration , with 1 field :
dependencies set to a list of tuples with 2 elements : app_label and migration.name [ migration . name ] for every migration in merge_migrations . call the method subsclass with 2 arguments : string _STR:0_ , replace _STR:1_ with biggest_number incremented by one ,
that occupies minimum 4 places within a string , and app_label , substitute the result for new_migration . writer is instance of MigrationWriter class , created with new_migration argument .
open writer.path [ writer . path ] file in write mode , with the file descriptor as fh , perform the following ,
call the method writer.as_string [ writer . as_string ] , write the result to fh file .
if self.verbosity [ self . verbosity ] is greater than integer 0 ,
substitute ' % s ' in a string _STR:0_ with writer path , write it to self.stdout [ self . stdout ] .
from __future__ import unicode_literals into default name space .
from collections import OrderedDict into default name space .
from importlib import import_module into default name space .
import module itertools .
import module traceback .
from django.apps [ django . apps ] import apps into default name space .
from django.core.management [ django . core . management ] import call_command into default name space .
from django.core.management.base [ django . core . management . base ] import BaseCommand and CommandError into default name space .
from django.core.management.color [ django . core . management . color ] import no_style into default name space .
from django.core.management.sql [ django . core . management . sql ] import custom_sql_for_model , emit_post_migrate_signal and emit_pre_migrate_signal into default name space .
from django.db [ django . db ] import connections , router , transaction and DEFAULT_DB_ALIAS into default name space .
from django.db.migrations.executor [ django . db . migrations . executor ] import MigrationExecutor into default name space .
from django.db.migrations.loader [ django . db . migrations . loader ] import MigrationLoader and AmbiguityError into default name space .
from django.db.migrations.state [ django . db . migrations . state ] import ProjectState into default name space .
from django.db.migrations.autodetector [ django . db . migrations . autodetector ] import MigrationAutodetector into default name space .
from django.utils.module_loading [ django . utils . module_loading ] import module_has_submodule into default name space .
derive the class Command from the base class BaseCommand .
help is a string _STR:0_ .
define the method add_arguments with self class instance and parse as the arguments .
call the method parser.add_argument [ parser . add_argument ] with string _STR:0_ , nargs set to charcter _STR:1_ , help containing string ,
_STR:0_ as arguments . call the method parser.add_argument [ parser . add_argument ] with string _STR:1_ , nargs set to charcter _STR:2_ , help containing string ,
_STR:0_ as arguments . call the method parser.add_argument [ parser . add_argument ] with string _STR:1_ , action containing string _STR:2_ , dest set to string _STR:3_ ,
default set to True , help containing string _STR:0_ as arguments . call the method parser.add_argument [ parser . add_argument ] with string _STR:1_ , action containing string _STR:2_ ,
dest set to string _STR:0_ , default set to True , help containing string _STR:1_ as arguments . call the method parser.add_argument [ parser . add_argument ] with string _STR:2_ , action containing string _STR:3_ , dest set to string _STR:4_ ,
default set to DEFAULT_DB_ALIAS , help containing string _STR:0_ as arguments . call the method parser.add_argument [ parser . add_argument ] with string _STR:1_ , action containing string _STR:2_ , dest set to string _STR:3_ ,
default set to False , help containing string _STR:0_ as arguments . call the method parser.add_argument [ parser . add_argument ] with string _STR:1_ , string _STR:2_ , action contains string _STR:3_ , dest set to string _STR:4_ ,
default set to False , help containing string _STR:0_ as arguments . define the method handle with self instance of a class , list args , dictionary options as arguments .
get the value from the options dictionary under the key _STR:0_ , substitute it for self.verbosity [ self . verbosity ] .
get the value from the options dictionary under the key _STR:0_ , substitute it for self.interactive [ self . interactive ] .
get the value from the options dictionary under the key _STR:0_ , substitute it for self.show_traceback [ self . show_traceback ] .
get the value from the options dictionary under the key _STR:0_ , substitute it for self.load_initial_data [ self . load_initial_data ] .
get the value from the options dictionary under the key _STR:0_ , or False if the key dont exists , substitute it for self.test_database [ self . test_database ] .
for every app_config in return value of the call to the function apps.get_app_configs [ apps . get_app_configs ] ,
if call to the function module_has_submodule with app_config.module [ app_config . module ] and _STR:0_ evaluates to True .
import module _STR:0_ from the package app_config.name [ app_config . name ] .
get the value under the key _STR:0_ of the options dictionary , substitute it for db .
substitute connections element at the index of the value db for connections .
get the value under the _STR:0_ key of options dictionary , if key doesnt exist return False , if the return value is True ,
call the method self.show_migration_list [ self . show_migration_list ] with connection as first argument , as second argument use value under the _STR:0_ key of options dictionary ,
if exists , if not use None as the second argument , return the result . call the function MigrationExecutor with connection and self.migration_progress_callback [ self . migration_progress_callback ] as arguments , substitute the result fro executor .
call the executor.loader.detect_conflicts [ executor . loader . detect_conflicts ] , substitute the result fr conflicts .
if conflicts is true ,
for every app and names in key , value tuple pairs of conflicts dictionary join names into a string separated by commas ,
in _STR:0_ substitute ' % s ' with names string and app , respective , join all the previous pairs into a string separated by _STR:1_ , substitute it for name_str . raise CommandError exception , with _STR:2_ ,
with ' % s ' substituted for name_str , as argument . run_syncdb is boolean False .
target_app_labels_only is boolean True .
if values under the _STR:0_ and _STR:1_ keys of the options dictionary are True ,
assign values under the _STR:0_ and _STR:1_ keys of the options dictionary to the app_label and migration_name , respectively .
if app_label is not contained in executor.loader.migrated_apps [ executor . loader . migrated_apps ] ,
raise CommandError exception with _STR:0_ ,
with ' % s ' substituted for app_label , as arguments . if migration_name equals to string _STR:0_ ,
targets is a list containing tuple with two elements , app_label and None .
if not ,
try ,
call the executor.loader.get_migration_by_prefix [ executor . loader . get_migration_by_prefix ] with app_label and migration_name , substitute the result for migration .
if AmbiguityError exception is caught ,
raise CommandError exception with _STR:0_ ,
with ' % s ' substituted for migration_name and app_label , respectively , as arguments . if KeyError exception is caught ,
raise CommandError exception with _STR:0_ ,
with ' % s ' substituted for migration_name and app_label , respectively , as arguments . targets is a list containing tuple with two elements , app_label and migration.name [ migration . name ] .
target_app_labels_only is boolean False .
otherwise if value under the _STR:0_ key of options dictionary is true ,
substitute the value under the _STR:0_ key of options dictionary for app_label .
if app_label is not contained in executor.loader.migrated_apps [ executor . loader . migrated_apps ] ,
raise CommandError exception with _STR:0_ ,
with ' % s ' substituted for app_label , as arguments . for every key in return vale of the method executor.loader.graph.leaf_nodes [ executor . loader . graph . leaf_nodes ] , check if the first element of key equals to app_label ,
if it does append it to targets list . if not ,
call the method executor.loader.graph.leaf_nodes [ executor . loader . graph . leaf_nodes ] and substitute its result for targets .
run_syncdb is boolean True .
call the executor.migration_plan [ executor . migration_plan ] method with targets as the argument , substitute the result for plan .
if self.verbosity [ self . verbosity ] is greater or equal to integer 1 .
call the self.style.MIGRATE_HEADING [ self . style . MIGRATE_HEADING ] method , with string _STR:0_ as an argument ,
use the result as an argument for the call to the self.stdout.write [ self . stdout . write ] method . if run_syncdb and executor.loader.unmigrated_apps [ executor . loader . unmigrated_apps ] exist ,
join the executor.loader.unmigrated_apps [ executor . loader . unmigrated_apps ] into a string separated by string _STR:0_ append it to the end of a string _STR:1_ ,
use it as an argument for the call to the self.style.MIGRATE_LABEL [ self . style . MIGRATE_LABEL ] method , use the result of the previous method as an argument for the call to the self.stdout.write [ self . stdout . write ] method . if target_app_labels_only is true ,
for every a and n in targets , put a into a set , join all the set elements into a string separated by string _STR:0_ ,
if set is empty return string _STR:0_ instead , append the previous to the string _STR:1_ , use the previous string as the argument for the call to the method self.style.MIGRATE_LABEL [ self . style . MIGRATE_LABEL ] , use the result as an argument for the call to the method self.stdout.write [ self . stdout . write ] . if not ,
if element of targets in first row and second column is None ,
convert the first element of the first row of targets to string , append it to the string _STR:0_ ,
use the it as an argument for the call to the self.style.MIGRATE_LABEL [ self . style . MIGRATE_LABEL ] method , use the result to cal the self.stdout.write [ self . stdout . write ] method . if not ,
replace ' % s ' in string _STR:0_ with second and first element of the first targets row , respectively ,
append it to the string _STR:0_ , use it as the argument for the call to the self.style.MIGRATE_LABEL [ self . style . MIGRATE_LABEL ] method , call the self.stdout.write [ self . stdout . write ] method with previous return value as an argument . if run_syncdb and executor.loader.unmigrated_apps [ executor . loader . unmigrated_apps ] is true ,
if self.verbosity [ self . verbosity ] is greater or equal to integer 1 .
call the self.style.MIGRATE_HEADING [ self . style . MIGRATE_HEADING ] with string _STR:0_ as an argument ,
use the result as an argument for the call to the self.stdout.write [ self . stdout . write ] . call the self.sync_apps [ self . sync_apps ] method with connection and executor.loader.unmigrated_apps [ executor . loader . unmigrated_apps ] as arguments , substitute it for created_models .
if not ,
create_models is an empty list .
if the value under the _STR:0_ key of the options dictionary exists ,
call the function call_command with string _STR:0_ , verbosity set to greater element , self.verbosity [ self . verbosity ] decremented by 1 or integer 0 ,
interactive set to boolean False , database set to db , reset_sequences set to boolean False , inhibit_post_migrate set to boolean True . if self.verbosity [ self . verbosity ] is greater or equal to integer 1 ,
call the self.style.MIGRATE_HEADING [ self . style . MIGRATE_HEADING ] method with string _STR:0_ as an argument , use the result as an argument for the call to the self.stdout.write [ self . stdout . write ] method .
if plan is not true ,
if self.verbosity [ self . verbosity ] is greater or equal to integer 1 ,
call the method self.stdout.write [ self . stdout . write ] with string _STR:0_ as an argument .
call the MigrationAutodetector function with arguments , return value of the call to the method executor.loader.project_state [ executor . loader . project_state ] ,
and return value of the call to the method ProjectState.from_apps [ ProjectState . from_apps ] with apps as an argument , assign it to the autodetector . call the method autodetector.changes [ autodetector . changes ] with the graph set to executor.loader.graph [ executor . loader . graph ] as an argument , substitute it for the changes .
if changes is true ,
call the method self.style.NOTICE [ self . style . NOTICE ] with string _STR:0_ as an argument , use the result as an argument for the call to the self.stdout.write [ self . stdout . write ] method .
call the method self.style.NOTICE [ self . style . NOTICE ] with string _STR:0_ as an argument , use the result as an argument for the call to the self.stdout.write [ self . stdout . write ] method .
if not ,
call the executor.migrate [ executor . migrate ] method with , targets , plan and fake set to the value under the _STR:0_ key of options dictionary ,
if the _STR:0_ key doesnt exists set fake to boolean False , as arguments . call the method emit_post_migrate_signal with created_models , self.verbosity [ self . verbosity ] , self.interactive [ self . interactive ] and connection.alias [ connection . alias ] as arguments .
define the method migration_progress_callback with self class instance , action , migration and fake set to boolean False as arguments .
if self.verbosity [ self . verbosity ] is greater or equal to integer 1 ,
if action equals to string _STR:0_ ,
call the self.stdout.write [ self . stdout . write ] method , with string _STR:0_ with ' % s ' replaced with migration and ending set to _STR:1_ , as arguments .
flush the output buffer of the self.stdout [ self . stdout ] object .
otherwise if action equals to string _STR:0_ ,
if fake is true ,
wrte to the standard output result of the call to the method self.style.MIGRATE_SUCCESS [ self . style . MIGRATE_SUCCESS ] with string _STR:0_ as a argument .
if not ,
wrte to the standard output result of the call to the method self.style.MIGRATE_SUCCESS [ self . style . MIGRATE_SUCCESS ] with string _STR:0_ as a argument .
otherwise if action equals to string _STR:0_ .
call the self.stdout.write [ self . stdout . write ] method , with string _STR:0_ with ' % s ' replaced with migration and ending set to _STR:1_ , as arguments .
flush the output buffer of the self.stdout [ self . stdout ] object .
otherwise if action equals to string _STR:0_ .
if fake is true ,
wrte to the standard output result of the call to the method self.style.MIGRATE_SUCCESS [ self . style . MIGRATE_SUCCESS ] with string _STR:0_ as a argument .
if not ,
wrte to the standard output result of the call to the method self.style.MIGRATE_SUCCESS [ self . style . MIGRATE_SUCCESS ] with string _STR:0_ as a argument .
define the method sync_apps with self class instance , connection and app_labels as arguments .
call the connection.cursor [ connection . cursor ] method , substitute the result for cursor .
try ,
call the connection.introspection.table_names [ connection . introspection . table_names ] with cursor as argument , store the result in tables .
call the connection.introspection.table_names [ connection . introspection . table_names ] with tables as argument , store the result in seen_models .
created_models is a set .
pending_references is a empty dictionary .
for every app_config in return value of the method apps.get_app_configs [ apps . get_app_configs ] if app_config.models_module [ app_config . models_module ] is not None ,
and app_config.label [ app_config . label ] is contained in app_labels , create a tuple containing app_config.label [ app_config . label ] and return value of the method router.get_migratable_models [ router . get_migratable_models ] called with app_config , connection.alias [ connection . alias ] and include_auto_created set to True , append the tuple to the list all_models . define the method model_installed with model as an argument .
substitute model._meta [ model . _meta ] for opts .
substitute connection.introspection.table_name_converter [ connection . introspection . table_name_converter ] for converter .
evaluate next boolean expression , value of converter function with opts.db_table [ opts . db_table ] as argument is contained in tables ,
or opts.auto_created [ opts . auto_created ] is True and return value of converter function with opts.auto_created._meta.db_table [ opts . auto_created . _meta . db_table ] is contained in tables , invert the evaluated expression and return it . manifest is OrderDict class instance , created with tuple of two elements , app_name and list of elements of model_list for which model_installed function returned true , for every app_name and model_list in all_modules .
unpack the manifest.values [ manifest . values ] function return value and feed it to the itertools.chain [ itertools . chain ] function , create_models is a set containing chanied list .
call the emit_pre_migrate_signal with create_models , self.verbosity [ self . verbosity ] , self.interactive [ self . interactive ] . connection.alias [ connection . alias ] as arguments .
if self.verbosity [ self . verbosity ] is greater or equal than integer 1 ,
write the string _STR:0_ to the standard output .
with the call to the transaction.atomic [ transaction . atomic ] method with using set to connection.alias [ connection . alias ] , savepoint set to connection.features.can_rollback_ddl [ connection . features . can_rollback_ddl ] as arguments ,
for every app_name and model_list in return value of manifest.items [ manifest . items ] function ,
for every model in model_list ,
if self.verbosity [ self . verbosity ] is greater or equal to 3 ,
call the self.stdout.write [ self . stdout . write ] method with string _STR:0_ as argument , with all occurrences of ' % s ' replaced with ,
app_name and model._meta.object_name [ model . _meta . object_name ] , respectively . evaluate connection.creation.sql_create_model [ connection . creation . sql_create_model ] method with model , no_style ( ) and seen_models as arguments ,
assign the result to the sql and references , respectively . add model to seen_models set .
add model to created_models set .
for every refto and refs in return value of references.items [ references . items ] method .
call the method extend with refs as argument , on the result call the pending_references.setdefault [ pending_references . setdefault ] method with refto and empty list as arguments .
if refto is contained in seen_models ,
call the connection.creation.sql_for_pending_references [ connection . creation . sql_for_pending_references ] method with refto , no_style ( ) and pending_references as arguments ,
use the result as the argument for the call to the sql.extend [ sql . extend ] method . call the connection.creation.sql_for_pending_references [ connection . creation . sql_for_pending_references ] method with refto , no_style ( ) and pending_references as arguments ,
use the result as the argument for the call to the sql.extend [ sql . extend ] method . if self.verbosity [ self . verbosity ] is greater or equal than integer 1 and sql is true ,
call the self.stdout.write [ self . stdout . write ] method with string _STR:0_ as argument , with all occurrences of ' % s ' replaced with model._meta.db_table [ model . _meta . db_table ] .
for statements is sql ,
call the cursor.execute [ cursor . execute ] method with statement as argument .
evaluate the method connection.introspection.table_name_converter [ connection . introspection . table_name_converter ] with model._meta.db_table [ model . _meta . db_table ] as argument , append it to tables .
finally , perform ,
call the cursor.close [ cursor . close ] method .
call the connection.cursor [ connection . cursor ] method , substitute it for cursor .
try ,
if self.verbosity [ self . verbosity ] is greater or equal than integer 1 ,
write the string _STR:0_ to the standard output .
for every app_name and mode_list in return value of manifest.items [ manifest . items ] method ,
for model in model_list ,
if model is contained in created_models ,
call the method custom_sql_for_model with model , no_style ( ) and connection as arguments , substitute the result for custom_sql .
if custom_sql is empty ,
if self.verbosity [ self . verbosity ] is greater or equal to integer 2 ,
call the self.stdout.write [ self . stdout . write ] method with string _STR:0_ as argument ,
with all occurrences of ' % s ' replaced with app_name and model._meta.object_name [ model . _meta . object_name ] , respectively . try ,
with call to the function transaction.atomic [ transaction . atomic ] with using set to connection.alias [ connection . alias ] as argument ,
for every sql in custom_sql ,
call the cursor.execute [ cursor . execute ] method with sql as argument .
if exception of class Exception , as e , is caught ,
call the self.stderr.write [ self . stderr . write ] method with string _STR:0_ as argument ,
with all occurrences of ' % s ' replaced with app_name and model._meta.object_name [ model . _meta . object_name ] and e , respectively . if self.show_traceback [ self . show_traceback ] is true ,
call the traceback.print_exc [ traceback . print_exc ] method .
if not ,
if self.verbosity [ self . verbosity ] is greater or equal to integer 3 ,
call the self.stderr.write [ self . stderr . write ] method with string _STR:0_ as argument ,
with all occurrences of ' % s ' replaced with app_name and model._meta.object_name [ model . _meta . object_name ] , respectively . if self.verbosity [ self . verbosity ] is greater or equal to integer 1 ,
write string _STR:0_ to the standard output .
for every app_name and model_list in return value of manifest.items [ manifest . items ] method ,
for every model in model_list ,
if model is contained in created_models ,
call the connection.creation.sql_indexes_for_model [ connection . creation . sql_indexes_for_model ] with model and no_style ( ) as arguments , substitute the result for index_squl .
if index_sql is not empty ,
if self.verbosity [ self . verbosity ] is greater or equal to integer 2 ,
call the self.stderr.write [ self . stderr . write ] method with string _STR:0_ as argument ,
with all occurrences of ' % s ' replaced with app_name and model._meta.object_name [ model . _meta . object_name ] , respectively . try ,
with call to the function transaction.atomic [ transaction . atomic ] with using set to connection.alias [ connection . alias ] and savepoint set to connection.features.can_rollback_ddl [ connection . features . can_rollback_ddl ] , as arguments .
for every sql in index_sql ,
call the method cursor.execute [ cursor . execute ] with sql as argument .
if exception of the class Exception , as e , is caught ,
call the self.stderr.write [ self . stderr . write ] method with string _STR:0_ as argument ,
with all occurrences of ' % s ' replaced with app_name and model._meta.object_name [ model . _meta . object_name ] and e , respectively . finally perform ,
call the cursor.close [ cursor . close ] method .
if self.load_initial_data [ self . load_initial_data ] is not empty ,
for every app_label in app_labels ,
call the method call_command with string _STR:0_ , string _STR:1_ , verbosity set to self.verbosity [ self . verbosity ] ,
database set to connection.alias [ connection . alias ] , skip_validation set to boolean True , app_label set to app_label and hide_empty set to boolean True . return created_models
define show_migration_list with self class instance , connection and app_names set to None , as arguments .
loader is instance of MigrationLoader initialized with connection as an argument .
substitute loader.graph [ loader . graph ] for graph .
if app_names is not empty ,
invalid_apps is an empty list .
for every app_name is app_names ,
if app_name is not contained in loader.migrated_apps [ loader . migrated_apps ] ,
append app_name to the invalid_apps .
if invalid_apps in not empty ,
raise a CommandError exception , with string _STR:0_ as argument , substitute ' % s ' in previous string with ,
string joined from invalided_apps list and separated with string _STR:0_ . if not ,
sort loader.migrated_apps [ loader . migrated_apps ] , substitute it for app_names .
for every app_name in app_names .
call self.stdout.write [ self . stdout . write ] method with app_name and self.style.MIGRATE_LABEL [ self . style . MIGRATE_LABEL ] as arguments .
shown is an empty set .
for every node in return value of the graph.leaf_nodes [ graph . leaf_nodes ] method called with the app_name argument ,
for every plan_node in return value of the graph.forwards_plan [ graph . forwards_plan ] method called with node as argument .
if plan_node is not contained in shown and first element of plan_node equals to app_name ,
substitute second element of plan_node for title .
if replaces filed of graph.nodes [ graph . nodes ] element at the plan_node index is true ,
substitute ' % s ' in the string _STR:0_ with length of replaces filed of graph.nodes [ graph . nodes ] element at the plan_node index , append the string to the title .
if plan_node is contained in loader.applied_migrations [ loader . applied_migrations ] ,
substitute ' % s ' with title in the string _STR:0_ , write it to the standard output .
if not ,
substitute ' % s ' with title in the string _STR:0_ , write it to the standard output .
add plan_node to the shown set .
if shown is an empty set ,
call the self.stdout.write [ self . stdout . write ] method with string _STR:0_ and self.style.MIGRATE_FAILURE [ self . style . MIGRATE_FAILURE ] as arguments .
import module argparse .
import module warnings .
from django.core.management.base [ django . core . management . base ] import BaseCommand into default name space .
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
derive the class Command from the BaseCommand class .
help is a string _STR:0_ .
define the method add_arguments with 2 arguments self and parser .
call the method parser.add_argument [ parser . add_argument ] with 3 arguments : string _STR:0_ , nargs set to argparse.REMAINDER [ argparse . REMAINDER ] and help as a string _STR:1_
define the method handle with 3 arguments : self , unpacked list args and unpacked dictionary options .
call the method warnings.warn [ warnings . warn ] with 2 arguments : string _STR:0_ ,
and RemovedInDjango19Warning . from django.conf [ django . conf ] import settings into default namespace .
from django.utils [ django . utils ] import translation into default namespace .
try ,
call the method translation.activate [ translation . activate ] with an argument settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] .
if AttributeError exception is caught ,
do nothing .
from django.core.servers.fastcgi [ django . core . servers . fastcgi ] import runfastcgi into default namespace .
call the function runfastcgi with an argument args .
define the method usage with 2 argument : self and subcommand .
from django.core.servers.fastcgi [ django . core . servers . fastcgi ] import FASTCGI_HELP into default namespace .
return FASTCGI_HELP .
from __future__ import unicode_literals into default name space .
from datetime import datetime into default name space .
import module errno .
import module os .
import module re .
import module sys .
import module socket .
from django.core.management.base [ django . core . management . base ] import BaseCommand and CommandError into default name space .
from django.core.servers.basehttp [ django . core . servers . basehttp ] import run and get_internal_wsgi_application into default name space .
from django.db [ django . db ] import connections and DEFAULT_DB_ALIAS into default name space .
from django.db.migrations.executor [ django . db . migrations . executor ] import MigrationExecutor into default name space .
from django.utils [ django . utils ] import autoreload into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.core.exceptions [ django . core . exceptions ] import ImproperlyConfigured into default name space .
call the method re.compile [ re . compile ] with 2 arguments : raw string _STR:0_ '' ^ ( ? : ( ? P < addr > ( ? P < ipv4 > \d { 1,3 } ( ? : \.\d [ \ . \d ] { 1,3 } ) { 3 } ) |_STR:0_ ''
_STR:0_ '' ( ? P < ipv6 > \ [ [ a-fA-F0-9 : ] +\ ] ) | ( ? P < fqdn > [ a-zA-Z0-9- ] + ( ? : \ . [ a-zA-Z0-9- ] + ) * ) ) : ) ? ( ? P < port > \d+ ) $ _STR:0_ '' , re.X [ re . X ] DEFAULT_PORT is a string _STR:2_ .
derive the class Command from the BaseCommand class .
help is a string _STR:0_ .
requires_system_checks is boolean False .
define the method add_arguments with 2 arguments self and parser .
call the method parser.add_argument [ parser . add_argument ] with 3 arguments : string _STR:0_ , nargs=_STR:1_ and help as a string _STR:2_ .
call the method parser.add_argument [ parser . add_argument ] with 6 arguments : string _STR:0_ , string _STR:1_ , action set to string _STR:2_ ,
dest set to string _STR:0_ , default set to boolean False and help set to string _STR:1_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:2_ , action set to string _STR:3_ ,
dest set to string _STR:0_ , default set to boolean True and help set to _STR:1_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:2_ , action set to string _STR:3_ ,
dest set to string _STR:0_ , default set to boolean True and help is a string _STR:1_ . def get_handler with 3 arguments : self , unpacked list args and unpacked dictionary options .
call the function get_internal_wsgi_application , return the result .
define the method handle with 3 arguments : self , unpacked list args and unpacked dictionary options .
from django.conf [ django . conf ] import settings into default namespace .
if not settings.DEBUG [ settings . DEBUG ] is true and settings.ALLOWED_HOSTS [ settings . ALLOWED_HOSTS ] is false ,
raise an CommandError exception with an argument string _STR:0_ .
substitute value under the _STR:0_ key of the options dictionary for self.use_ipv6 [ self . use_ipv6 ] .
if self.use_ipv6 [ self . use_ipv6 ] is true and socket.has_ipv6 [ socket . has_ipv6 ] is false ,
raise an CommandError exception with an argument string _STR:0_ .
self._raw_ipv6 [ self . _raw_ipv6 ] is boolean False .
get the value under the _STR:0_ key of the options dictionary , if it is false ,
self.addr [ self . addr ] is an empty string .
substitute DEFAULT_PORT for self.port [ self . port ] .
if not ,
call the method re.match [ re . match ] with 2 arguments : naiveip_re and value under the _STR:0_ key of the options dictionary , substitute the result for m .
if m is None ,
raise an CommandError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with value under the _STR:0_ key of the options dictionary . call the method m.groups [ m . groups ] , assign the result to self.addr [ self . addr ] , _ipv4 , _ipv6 , _fqdn and self.port [ self . port ] , respectively .
call the method self.port.isdigit [ self . port . isdigit ] , if it evaluates to false ,
raise an CommandError exception with an argument string _STR:0_ , where _STR:1_ is repaced with self.port [ self . port ] .
if self.addr [ self . addr ] is true ,
if _ipv6 is true ,
substitute self.addr [ self . addr ] without the first and last element for self.addr [ self . addr ] .
self.use_ipv6 [ self . use_ipv6 ] is boolean True .
self._raw_ipv6 [ self . _raw_ipv6 ] is boolean True .
otherwise if self.use_ipv6 [ self . use_ipv6 ] is true and _fqdn is false ,
raise an CommandError exception with an argument string _STR:0_ where ' % s ' is replaced with self.addr [ self . addr ] .
if self.addr [ self . addr ] is false ,
if self.use_ipv6 [ self . use_ipv6 ] substitute string _STR:0_ for self.addr [ self . addr ] , if not substitute _STR:1_ for self.addr [ self . addr ] .
convert self.use_ipv6 [ self . use_ipv6 ] to boolean , substitute it for self._raw_ipv6 [ self . _raw_ipv6 ] .
call the self.run [ self . run ] method with unpacked dictionary options as an argument .
define the method run with 3 arguments : self and unpacked dictionary options .
substitute value under the _STR:0_ key of the options dictionary for use_reloader .
if use_reloader is true ,
call the method autoreload.main [ autoreload . main ] with 3 arguments : self.inner_run [ self . inner_run ] , None and options .
if not ,
call the method self.inner_run [ self . inner_run ] with 2 arguments : None and unpacked dictionary options .
define the method inner_run with 3 arguments : self , unpacked list args and unpacked dictionary options .
from django.conf [ django . conf ] import settings into default namespace .
django.utils [ django . utils ] import translation into default namespace .
substitute value under the _STR:0_ key of the options dictionary for threading .
get the value under the _STR:0_ key of the options dictionary , if it exists substitute it for shutdown_message ,
if not , shutdown_message is an empty string . if sys.platform [ sys . platform ] equals string win32_STR:0_CTRL-BREAK_STR:1_CONTROL-C ' for quit_command .
write string _STR:0_ to self.stdout [ self . stdout ] stream .
call the method self.validate [ self . validate ] with an argument display_num_errors set to boolean True .
try ,
call the method self.check_migrations [ self . check_migrations ] .
if ImproperlyConfigured exception is caught ,
do nothing .
call the function datetime.now [ datetime . now ] , on the result call the method strftime with an argument string _STR:0_ , substitute the result for now .
if six.PY2 [ six . PY2 ] is true ,
call the method now.decode [ now . decode ] with an argument string _STR:0_ , substitute the result for now .
call the method self.stdout.write [ self . stdout . write ] with an argument : string _STR:0_
_STR:0_ , where _STR:1_ is replaced with now , _STR:2_ is replaced with return value of the method self.get_version [ self . get_version ] , _STR:3_ is replaced with settings.SETTINGS_MODULE [ settings . SETTINGS_MODULE ] , _STR:4_ is replaced with self.addr [ self . addr ] if self._raw_ipv6 [ self . _raw_ipv6 ] is true , or with self.addr [ self . addr ] if it is false , _STR:5_ is replaced with self.port [ self . port ] and _STR:6_ is replaced with quit_command . call the method translation.activate [ translation . activate ] with an argument settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] .
try ,
call the method self.get_handler [ self . get_handler ] with 2 arguments unpacked list args and unpacked dictionary options , substitute the result for handler .
call the function run with 5 arguments : self.addr [ self . addr ] , self.port [ self . port ] converted to an integer , handler , ipv6 set to self.use_ipv6 [ self . use_ipv6 ] , and threading set to threading .
if socket.error [ socket . error ] , renamed to e , exception is caught ,
ERRORS is a dictionary with 3 initial entries : string _STR:0_ for errno.EACCES [ errno . EACCES ] ,
_STR:0_ for errno.EADDRINUSE [ errno . EADDRINUSE ] and _STR:1_ for errno.EADDRNOTAVAIL [ errno . EADDRNOTAVAIL ] . try ,
get the value under the e.errno [ e . errno ] key of the ERRORS dictionary , substitute it for error_text .
if KeyError exception is caught .
convert e to a string , substitute it for error_text .
replace ' % s ' in a string _STR:0_ with error_text , write it to self.stderr [ self . stderr ] .
exit the program with the code integer 1 .
if KeyboardInterrupt exception is caught ,
if shutdown_message is true ,
write shutdown_message to self.stdout [ self . stdout ] file stream .
exit program with code integer 0 .
define the method check_migrations with an argument self .
executor is an instance of the class MigrationExecutor created with an argument : value under the DEFAULT_DB_ALIAS key of the connections dictionary .
call the method executor.migration_plan [ executor . migration_plan ] wiht return value of te method executor.loader.graph.leaf_nodes [ executor . loader . graph . leaf_nodes ] as argument , substitute it for plan .
if plan is true ,
call the method self.style.NOTICE [ self . style . NOTICE ] with an argument :
string : _STR:0_ , write it to self.stdout [ self . stdout ] . call the method self.style.NOTICE [ self . style . NOTICE ] with an argument string _STR:1_ ,
write it to self.stdout [ self . stdout ] . substitute Command for BaseRunserverCommand .
import module os .
from django.core.management.base [ django . core . management . base ] import BaseCommand into default name space .
derive the class Command from the BaseCommand class .
help is a string _STR:0_ .
requires_system_checks is boolean False .
shells is a list containing 2 elements : string _STR:0_ and string _STR:1_ .
define the method add_arguments with 2 arguments self and parser .
call the method parser.add_argument [ parser . add_argument ] with 4 arguments : string _STR:0_ , action set to string _STR:1_ , dest as a string _STR:2_ ,
and help is a string _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 4 arguments : string _STR:1_ , action as a string _STR:2_ ,
dest as a string _STR:0_ and help as a string _STR:1_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:2_ , string _STR:3_ , choices set to string self.shells [ self . shells ] ,
dest as a string _STR:0_ and help as a string _STR:1_ . define the method _ipython_pre_011 with an argument self .
from IPython.Shell [ IPython . Shell ] import IPShell into default namespace .
shell is an instance of IPShell class , created with an argument argv as an empty list .
call the method shell.mainloop [ shell . mainloop ] .
define the method _ipython_pre_100 with an argument self .
from IPython.frontend.terminal.ipapp [ IPython . frontend . terminal . ipapp ] import TerminalIPythonApp into default namespace .
call the method instance of TerminalIPythonApp class , substitute the result for app .
call the method app.initialize [ app . initialize ] with an argument argv as an empty list .
call the method app.start [ app . start ] .
define the method _ipython with an argument self .
from IPython import start_ipython into default namespace .
call the method start_ipython with an argument argv as an empty list .
define the method ipython with an argument self .
for every ip in tuple containing 3 elements : self._ipython [ self . _ipython ] , self._ipython_pre_100 [ self . _ipython_pre_100 ] and self._ipython_pre_011 [ self . _ipython_pre_011 ] ,
try ,
call the function ip .
if ImportError exception is caught ,
do nothing .
if not ,
return nothing .
raise an ImportError exception with an argument string _STR:0_ .
define the method bpython with an argument self .
import bpython .
call the method bpython.embed [ bpython . embed ] .
define the method run_shell with an arguments self and shell set to None .
if shell is true substitute list with element shell for available_shells , if not substitute self.shells [ self . shells ] for available_shells .
for every shell in available_shells ,
try ,
get shell attribute of the self object , call it and return the result .
if ImportError exception is caught ,
do nothing .
raise an ImportError exception .
define the method handle with 3 arguments : self and unpacked dictionary options .
try ,
if value under _STR:0_ key of the options dictionary is true ,
raise an ImportError exception .
call the method self.run_shell [ self . run_shell ] with an argument shell set to value under the _STR:0_ key of the options dictionary .
if ImportError exception is caught ,
import code .
imported_objects is an empty dictionary .
try ,
import readline .
if ImportError exception is caught ,
do nothing .
if not ,
import rlcompleter .
call the method rlcompleter.Completer [ rlcompleter . Completer ] with an argument imported_objects , use the complete field of the result as an argument for the call to the method readline.set_completer [ readline . set_completer ] .
call the method readline.parse_and_bind [ readline . parse_and_bind ] with an argument string _STR:0_ .
get the value under the _STR:0_ key of the options dictionary , if it evaluates to false ,
for every pythonrc in tuple containing 2 elements : return value of the function os.environ.get [ os . environ . get ] called with a string _STR:0_ ,
and string _STR:0_ as tuples second element . if pythonrc is true ,
skip this loop iteration .
call the function os.path.expanduser [ os . path . expanduser ] with an argument pythonrc , substitute the result for pythonrc .
if pythonrc is not a file ,
skip this loop iteration .
try ,
open pythonrc , with the file handle renamed to handle perform the following ,
compile the handle.read [ handle . read ] in mode _STR:0_ source is read from file pythonrc , execute the compiled script with imported_objects variables .
if NameError exception is caught ,
do nothing .
call the method code.interact [ code . interact ] with an argument local set to imported_objects .
from __future__ import unicode_literals into default name space .
from django.core.management.base [ django . core . management . base ] import AppCommand into default name space .
from django.core.management.sql [ django . core . management . sql ] import sql_create into default name space .
from django.db [ django . db ] import connections and DEFAULT_DB_ALIAS into default name space .
derive the class Command from the AppCommand base class .
help is a string _STR:0_ .
output_transaction is boolean True .
define the method add_arguments with 2 arguments self and parser .
call the method add_arguments from the base class of the class Command , with an argument parser .
call the method parser.add_argument [ parser . add_argument ] with 3 arguments : string _STR:0_ , default set to DEFAULT_DB_ALIAS ,
and help set to a string _STR:0_ . define the method handle_app_config with 3 arguments : self , app_config and unpacked dictionary options .
if app_config.models_module [ app_config . models_module ] is None ,
return nothing .
get the value under the _STR:0_ key of the options dictionary , use it as the key to get the value from the connections dictionary , substitute the result for connection .
call the function sql_create with 3 arguments : app_config , self.style [ self . style ] and connection , substitute the result for statements .
join statements into a string , separated by newlines , return it .
from __future__ import unicode_literals into default name space .
from django.core.management.base [ django . core . management . base ] import AppCommand into default name space .
from django.core.management.sql [ django . core . management . sql ] import sql_all into default name space .
from django.db [ django . db ] import connections and DEFAULT_DB_ALIAS into default name space .
derive the class Command from the AppCommand base class .
help is a string _STR:0_ .
output_transaction is boolean True .
define the method add_arguments with 2 arguments self and parser .
call the method add_arguments from the base class of the class Command , with an argument parser .
call the method parser.add_argument [ parser . add_argument ] with 3 arguments : string _STR:0_ , default set to DEFAULT_DB_ALIAS ,
and help set to a string _STR:0_ . define the method handle_app_config with 3 arguments : self , app_config and unpacked dictionary options .
if app_config.models_module [ app_config . models_module ] is None ,
return nothing .
get the value under the _STR:0_ key of the options dictionary , use it as the key to get the value from the connections dictionary , substitute the result for connection .
call the function sql_all with 3 arguments : app_config , self.style [ self . style ] and connection , substitute the result for statements .
join statements into a string , separated by newlines , return it .
from __future__ import unicode_literals into default name space .
from django.core.management.base [ django . core . management . base ] import AppCommand into default name space .
from django.core.management.sql [ django . core . management . sql ] import sql_delete into default name space .
from django.db [ django . db ] import connections and DEFAULT_DB_ALIAS into default name space .
derive the class Command from the AppCommand base class .
help is a string _STR:0_ .
output_transaction is boolean True .
define the method add_arguments with 2 arguments self and parser .
call the method add_arguments from the base class of the class Command , with an argument parser .
call the method parser.add_argument [ parser . add_argument ] with 3 arguments : string _STR:0_ , default set to DEFAULT_DB_ALIAS ,
and help set to a string _STR:0_ . define the method handle_app_config with 3 arguments : self , app_config and unpacked dictionary options .
if app_config.models_module [ app_config . models_module ] is None ,
return nothing .
get the value under the _STR:0_ key of the options dictionary , use it as the key to get the value from the connections dictionary , substitute the result for connection .
call the function sql_destroy_indexes with 3 arguments : app_config , self.style [ self . style ] and connection , substitute the result for statements .
join statements into a string , separated by newlines , return it .
from __future__ import unicode_literals into default name space .
from django.core.management.base [ django . core . management . base ] import AppCommand into default name space .
from django.core.management.sql [ django . core . management . sql ] import sql_custom into default name space .
from django.db [ django . db ] import connections and DEFAULT_DB_ALIAS into default name space .
derive class Command from the base class AppCommand .
help is a string , _STR:0_ .
substitute True for output_transaction .
define method add_arguments with class instance self and parser as the input arguments .
call the function add_arguments with parser as an argument , from the base class of the Command class .
call the parser.add_argument [ parser . add_argument ] method with the string _STR:0_ , default set to DEFAULT_DB_ALIAS and help containig string ,
_STR:0_ as the arguments . define method handle_app_config with self class instance , app_config and dictionary options as arguments .
if app_config.models_module [ app_config . models_module ] is None ,
return nothing .
extract the value under the key _STR:0_ from the options dictionary , use the value for indexing connections list , substitute the result for connection .
call the function sql_custom with app_config , self.style [ self . style ] and connection as the arguments , substitute the result for statements .
join the list of statements into a string separated by new lines , return it .
from __future__ import unicode_literals into default name space .
from django.core.management.base [ django . core . management . base ] import AppCommand into default name space .
from django.core.management.sql [ django . core . management . sql ] import sql_destroy_indexes into default name space .
from django.db [ django . db ] import connections and DEFAULT_DB_ALIAS into default name space .
derive the class Command from the AppCommand base class .
help is an string _STR:0_ .
output_transaction is boolean True .
define the method add_arguments with 2 arguments : self and parser .
call the add_arguments method from the base class of the class Command with parser as an argument .
call the method parser.add_argument [ parser . add_argument ] with 3 arguments : string _STR:0_ , default set to DEFAULT_DB_ALIAS ,
and help set to string _STR:0_ . define the handle_app_config with 3 arguments self , app_config and unpacked dictionary options .
if app_config.models_module [ app_config . models_module ] is None .
return nothing .
get the value under the _STR:0_ key of the options dictionary , use it as the key to get the value from the connections dictionary , substitute the result for connection .
call the function sql_destroy_indexes with 3 arguments : app_config , self.style [ self . style ] and connection , substitute the result for statements .
join statements into a string , separated by newlines , return it .
from __future__ import unicode_literals into default name space .
from django.core.management.base [ django . core . management . base ] import BaseCommand into default name space .
from django.core.management.sql [ django . core . management . sql ] import sql_flush into default name space .
from django.db [ django . db ] import connections and DEFAULT_DB_ALIAS into default name space .
derive the class Command from the base class BaseCommand .
help is a string , containing _STR:0_ .
output_transaction is boolean True .
define method add_arguments with self class instance and parser as the arguments .
call the parent class of Command class add_arguments method and parser as the arguments .
call the add_argument method on parser object , use string _STR:0_ , default set to DEFAULT_DB_ALIAS and help set to string ,
_STR:0_ as the arguments . define the method handle with self class instance and dictionary options as the arguments .
call the sql_flush function with self.style [ self . style ] , connections under the key with the value of options dictionary under the _STR:0_ key ,
from __future__ import unicode_literals into default name space .
from django.core.management.base [ django . core . management . base ] import AppCommand into default name space .
from django.core.management.sql [ django . core . management . sql ] import sql_indexes into default name space .
from django.db [ django . db ] import connections and DEFAULT_DB_ALIAS into default name space .
derive the class Command from the base class AppCommand .
help is a string _STR:0_ .
output_transaction is boolean True .
define the method add_arguments with self class instance and parser as the arguments .
call the add_arguments method with parser as argument form the base class of the class Command .
call parse.add_argument [ parse . add_argument ] method , with string _STR:0_ , default set to DEFAULT_DB_ALIAS ,
and help as a string _STR:0_ , as arguments . define the method handle_app_config with self class instance , app_config and dictionary options as arguments .
if app_config.models_module [ app_config . models_module ] is None ,
return nothing .
get the value under the _STR:0_ key of options dictionary , use it as a index to get connections list element , store it in connection .
call the function sql_indexes with app_config , self.style [ self . style ] and connection as arguments , store the result in statements .
join statements in a string separated by newline , return the result .
from __future__ import unicode_literals into default name space .
from django.core.management.base [ django . core . management . base ] import BaseCommand and CommandError into default name space .
from django.db [ django . db ] import connections and DEFAULT_DB_ALIAS into default name space .
from django.db.migrations.executor [ django . db . migrations . executor ] import MigrationExecutor into default name space .
from django.db.migrations.loader [ django . db . migrations . loader ] import AmbiguityError into default name space .
derive class Command from the base class BaseCommand .
help is a string _STR:0_
def method add_arguments with self class instance and parser as the arguments .
call the add_argument method on the parser object , with string _STR:0_ , and help set to string _STR:1_ as arguments .
call the add_argument method on the parser object , with string _STR:0_ , and help set to string _STR:1_ as arguments .
call the add_argument method on the parser object , with string _STR:0_ , default set to DEFAULT_DB_ALIAS and help set to string _STR:1_ as arguments .
call the add_argument method on the parser object with string _STR:0_ , asction set to _STR:1_ , dest set to _STR:2_ ,
default set to False and help set to string_STR:0_ as arguments . define the method handle with self class instance , list of arguments args and options dictionary as the arguments .
get the value under the key _STR:0_ of the options dictionary , use it as a index to get an element from connections , substitute it for connection .
call the MigrationExecutor with the connection as the argument , substitute it for executor .
get the values under the keys _STR:0_ and _STR:1_ of the options dictionary , substitute the results for app_label and migration_name , respectively .
if app_label is not contained in executor.loader.migrated_apps [ executor . loader . migrated_apps ] ,
raise a exception of CommandError class , with string _STR:0_ with ' % s ' replaced with app_label as the argument .
try ,
call the executor.loader.get_migration_by_prefix [ executor . loader . get_migration_by_prefix ] with app_label and migration_name with arguments , substitute the result fr migration .
if AmbiguityError exception is raised ,
raise a exception of ComandError class with string _STR:0_ ,
with all ' % s ' strings replaced with migration_name and app_label , respectively , as an argument . if KeyError exception is raised ,
raise a exception of CommandError class , with string _STR:0_ ,
replace all the ' % s ' occurrences with migration_name and app_label , respectively . target is a list containing tuple with two elements app_label and migration.name [ migration . name ] .
get executor.loader.graph.nodes [ executor . loader . graph . nodes ] list item at the index of the first element of targets list , get the value under the _STR:0_ key of options dictionary , put previous two elements is a tuple , tuple is contained in a plan list .
call method executor.collect_sql [ executor . collect_sql ] with plan as the argument , substitute the result for sql_statements .
for every statements in sql_statements :
call method self.stdout.write [ self . stdout . write ] with statement as an argument .
from __future__ import unicode_literals into default name space .
from django.core.management.base [ django . core . management . base ] import AppCommand into default name space .
from django.core.management.sql [ django . core . management . sql ] import check_for_migrations into default name space .
from django.db [ django . db ] import connections and DEFAULT_DB_ALIAS into default name space .
derive the class Command from the AppCommand base class .
help is a string _STR:0_ .
output_transaction is boolean True .
define the method add_arguments , with 2 arguments self and parser .
call the method add_arguments from the base class of the Command class , with an argument parser .
call the method parser.add_argument [ parser . add_argument ] with 3 arguments : string _STR:0_ , default set to DEFAULT_DB_ALIAS ,
and help set to string _STR:0_ . define the method handle_app_config with 3 arguments : self , app_config and unpacked dictionary options .
if app_config.models_module [ app_config . models_module ] is None ,
return nothing .
get the value under the _STR:0_ key of the options dictionary ,
use the result as a key to get the value from the connections dictionary , substitute the result for connection . call the function check_for_migrations with 2 arguments : app_config and connection .
call the method app_config.get_models [ app_config . get_models ] with include_auto_created set to boolean True , substitute the result for models .
call the method connection.ops.sequence_reset_sql [ connection . ops . sequence_reset_sql ] with 2 arguments self.style [ self . style ] and models , substitute the result for statements .
join statements into a string , separated by newline characters , return it .
from django.core.management.base [ django . core . management . base ] import BaseCommand and CommandError into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.db [ django . db ] import connections , DEFAULT_DB_ALIAS and migrations into default name space .
from django.db.migrations.loader [ django . db . migrations . loader ] import AmbiguityError into default name space .
from django.db.migrations.executor [ django . db . migrations . executor ] import MigrationExecutor into default name space .
from django.db.migrations.writer [ django . db . migrations . writer ] import MigrationWriter into default name space .
from django.db.migrations.optimizer [ django . db . migrations . optimizer ] import MigrationOptimizer into default name space .
derive the class Command from the BaseCommand class .
help is a string _STR:0_ .
define the method add_arguments with 2 arguments self and parser .
call the method parser.add_argument [ parser . add_argument ] with 2 arguments : string _STR:0_ ,
and help is a string _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 2 arguments : string _STR:1_ ,
and help is a string _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:1_ , action as a string _STR:2_ ,
dest as a string _STR:0_ , default set to boolean False and help as a string _STR:1_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:2_ , action set to string _STR:3_ ,
dest as a string _STR:0_ , default as boolean True help as a string _STR:1_ . define the method handle with 3 arguments : self and unpacked dictionary options .
get the value under the _STR:0_ key of the options dictionary , substitute it for self.verbosity [ self . verbosity ] .
get the value under the _STR:0_ key of the options dictionary , substitute it for self.interactive [ self . interactive ] .
get the values under the _STR:0_ and _STR:1_ keys of the options dictionary ,
substitute them for app_label and migration_name , respectively . executor is an instance of MigrationExecutor , created with value under the DEFAULT_DB_ALIAS key of the connections dictionary .
if app_label is not contained in executor.loader.migrated_apps [ executor . loader . migrated_apps ] ,
raise an CommandError with an argument string _STR:0_ ,
where ' % s ' is replaced with app_label . try ,
call the method executor.loader.get_migration_by_prefix [ executor . loader . get_migration_by_prefix ] with arguments app_label , migration_name , substitute the result for migration .
if AmbiguityError exception is caught ,
raise an CommandError with an argument string _STR:0_ ,
where ' % s ' is replaced with migration_name and app_label . if KeyError exception is caught ,
raise an CommandError with an argument string _STR:0_ ,
where ' % s ' is replaced with migration_name and app_label . migrations_to_squash is a list created dynamically with elements : return value of the method executor.loader.get_migration [ executor . loader . get_migration ] called ,
with arguments al and mn , for every al , mn in executor.loader.graph.forwards_plan [ executor . loader . graph . forwards_plan ] method return value called with 2 arguments : migration.app_label [ migration . app_label ] , migration.name [ migration . name ] , only if al equals migration.app_label [ migration . app_label ] . if self.verbosity [ self . verbosity ] is greater than integer 0 or self.interactive [ self . interactive ] is true ,
call the method self.style.MIGRATE_HEADING [ self . style . MIGRATE_HEADING ] with an argument string _STR:0_ ,
write it to self.stdout [ self . stdout ] . for every migration in migrations_to_squash ,
append migration.name [ migration . name ] to string _STR:0_ , write it to self.stdout [ self . stdout ] stream .
if self.interactive [ self . interactive ] is true ,
answer is None .
while answer is false or answer is not contained in string _STR:0_ , perform the following ,
call the method six.moves.input [ six . moves . input ] with an argument string _STR:0_ , substitute the result for answer .
if answer is false ,
substitute _STR:0_ for answer .
break from the loop execution ,
if not ,
convert first element of answer to lowercase and substitute it for answer .
if answer equals a string _STR:0_ ,
return nothing .
operations is an empty list .
for every smigration in migrations_to_squash ,
call the method operations.extend [ operations . extend ] with an argument smigration.operations [ smigration . operations ] .
if self.verbosity [ self . verbosity ] is greater than integer 0 ,
call the method self.style.MIGRATE_HEADING [ self . style . MIGRATE_HEADING ] with an argument string _STR:0_ , write it to self.stdout [ self . stdout ] .
optimizer is an instance of MigrationOptimizer class .
call the method optimizer.optimize [ optimizer . optimize ] with 2 arguments operations and migration.app_label [ migration . app_label ] , substitute the result for new_operations .
if self.verbosity [ self . verbosity ] is greater than integer 0 ,
if lengths of new_operations and operations are the same ,
write string _STR:0_ to self.stdout [ self . stdout ] stream .
if not ,
replace ' % s ' in string _STR:0_ with lengths of operations and ew_operations , respectively ,
write it to self.stdout [ self . stdout ] stream . replaces is an empty list .
for every migration in migrations_to_squash ,
if migration.replaces [ migration . replaces ] is true ,
extend replaces list with migration.replaces [ migration . replaces ] ,
if not ,
append tuple with 2 elements : migration.app_label [ migration . app_label ] and migration.name [ migration . name ] to replaces .
subclass is a class named Migration , sub classed from migrations.Migration [ migrations . Migration ] base class , with fields dependencies set to an empty list ,
dependencies set to new_operations and replaces set to replaces . call the function subclass with 2 arguments string _STR:0_ , where ' % s ' is replaced with migration.name [ migration . name ] and app_label ,
substitute the result for new_migration . writer is an instance of a class MigrationWriter , created with an argument new_migration .
open writer.path [ writer . path ] file in write mode , with file descriptor as fh , perform the following ,
call the method writer.as_string [ writer . as_string ] , write the result to file fh .
if self.verbosity [ self . verbosity ] is greater than integer 0 ,
replace ' % s ' in a string _STR:0_ with writer.path [ writer . path ] , use it as an argument for the call to the method ,
self.style.MIGRATE_HEADING [ self . style . MIGRATE_HEADING ] , write the result to self.stdout [ self . stdout ] . write string _STR:0_ to self.stdout [ self . stdout ] .
write string _STR:0_ to self.stdout [ self . stdout ] .
write string _STR:0_ to self.stdout [ self . stdout ] .
write string _STR:0_ to self.stdout [ self . stdout ] .
from importlib import import_module into default name space .
from django.core.management.base [ django . core . management . base ] import CommandError into default name space .
from django.core.management.templates [ django . core . management . templates ] import TemplateCommand into default name space .
derive the class Command from the TemplateCommand base class .
help is a tuple containing a string _STR:0_ .
missing_args_message is a string _STR:0_ .
define the method handle with 2 arguments : self and unpacked dictionary options .
remove values under the keys _STR:0_ and _STR:1_ of the options dictionary and substitute it for app_name and target , respectively .
call the method self.validate_name [ self . validate_name ] with 2 arguments : app_name and string _STR:0_ .
try ,
call the function import_module with an argument app_name .
if ImportError exception is caught ,
do nothing .
in not ,
raise an CommandError exception with an argument string _STR:0_
_STR:0_ , where _STR:1_ is replaced with app_name . call the method handle from the base class of Command class , with 4 arguments : string _STR:2_ , app_name , target and unpacked dictionary options .
from importlib import import_module into default name space .
from django.core.management.base [ django . core . management . base ] import CommandError into default name space .
from django.core.management.templates [ django . core . management . templates ] import TemplateCommand into default name space .
from django.utils.crypto [ django . utils . crypto ] import get_random_string into default name space .
derive class Command from the TemplateCommand base class .
help is a tuple containing string _STR:0_
_STR:0_ . missing_args_message is a string _STR:1_ .
define the method handle with arguments self and unpacked dictionary options .
remove the elements from the _STR:0_ and _STR:1_ keys of the options dictionary , substitute them for project_name and target , respectively .
call the method self.validate_name [ self . validate_name ] with arguments project_name and string _STR:0_ .
try ,
call the function import_module with an argument project_name .
if ImportError exception is caught ,
do nothing .
if not ,
raise an exception CommandError , with argument string _STR:0_ , where _STR:1_ is replaced with project_name .
chars is a string _STR:0_ .
call the function get_random_string with 2 arguments : integer 50 and chars , substitute it for value under the _STR:0_ of the options dictionary .
call the handle method of the base class of the Command class , with 4 arguments : string _STR:0_ , project_name , target ,
import module warnings .
from django.apps [ django . apps ] import apps into default name space .
from django.contrib.auth [ django . contrib . auth ] import get_user_model into default name space .
from django.db [ django . db ] import DEFAULT_DB_ALIAS into default name space .
from django.core.management [ django . core . management ] import call_command into default name space .
from django.core.management.base [ django . core . management . base ] import BaseCommand into default name space .
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
from django.utils.six.moves [ django . utils . six . moves ] import input into default name space .
derive class Command from the BaseCommand base class .
help is a string _STR:0_ .
define the method add_arguments with self and parser as arguments .
call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:0_ , action set to string _STR:1_ ,
dest set to string _STR:0_ , default set to boolean True and help as _STR:1_ call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:2_ , action set to string _STR:3_ ,
dest set to string _STR:0_ , default set to boolean True , and help as a string _STR:1_ call the method parser.add_argument [ parser . add_argument ] with 3 arguments : string _STR:2_ , default set to DEFAULT_DB_ALIAS ,
and help set to string _STR:0_ . define the method handle with 2 arguments : self and unpacked dictionary options .
call the method warnings.warn [ warnings . warn ] with 2 arguments : string _STR:0_ and RemovedInDjango19Warning .
call the function call_command with 2 arguments : string migrate and unpacked dictionary options .
try ,
call the method apps.get_model [ apps . get_model ] with 2 arguments : string _STR:0_ and string _STR:1_ .
if LookupError exception is caught .
return nothing .
call the function get_user_model , substitute the result for UserModel .
if return value of the method UserModel._default_manager.exists [ UserModel . _default_manager . exists ] is false and value under the _STR:0_ key of the options dictionary is true ,
msg is a tuple containing string _STR:0_ .
call the method input with an argument msg and store the result in confirm .
endless loop ,
if confirm is not equal to string _STR:0_ or string _STR:1_ ,
query a string _STR:0_ and store the result in confirm .
skip this loop iteration .
if confirm equals string _STR:0_ ,
call the function call_command with 3 arguments : string _STR:0_ , interactive is boolean True ,
and database set to value under the _STR:0_ key of the options dictionary . break the loop execution .
import module logging .
import module sys .
import module os .
from django.conf [ django . conf ] import settings into default name space .
from django.core.management.base [ django . core . management . base ] import BaseCommand into default name space .
from django.test.utils [ django . test . utils ] import get_runner into default name space .
derive class Command from the BaseCommand base class .
help is a string _STR:0_ .
requires_system_checks is boolean False .
define the method __init__ with an argument self .
self.test_runner [ self . test_runner ] is None .
call the method __init__ form the base class of the Command class .
define the method run_from_argv with arguments self and argv .
option is a string _STR:0_ .
for arg in argv list without the first two elements ,
if arg starts with options ,
get the length of the options , use it as a starting index for the slicing arg list , substitute it for self.test_runner [ self . test_runner ] .
break the loop execution .
call the run_from_argv function from the base class of the Command class with argv as a argument , .
define the method add_arguments with arguments self and parser .
call the method parser.add_argument [ parser . add_argument ] with 4 arguments : string _STR:0_ , metavar set to string _STR:1_ , nargs set to string _STR:2_ ,
and help is a string _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:1_ , action set to _STR:2_ , dest set to _STR:3_ ,
default set to boolean True , help set to string _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:1_ , action set to string _STR:2_ , dest set to _STR:3_ ,
default set to boolean False and help set to string _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 4 arguments : string _STR:1_ , action set to string _STR:2_ , dest set to _STR:3_ ,
and help set to a string _STR:0_ . call the method parser.add_argument [ parser . add_argument ] with 5 arguments : string _STR:1_ , action set to string _STR:2_ , dest set to _STR:3_ ,
default set to None and help set to string _STR:0_ _STR:1_ call the function get_runner with arguments settings and self.test_runner [ self . test_runner ] , substitute the result for test_runner_class .
if test_runner_class has an _STR:0_ attribute ,
raise an RuntimeError exception with an argument string _STR:0_
_STR:0_ if test_runner_class has an attribute _STR:1_ ,
call the method test_runner_class.add_arguments [ test_runner_class . add_arguments ] with an argument parser .
define the method execute with 3 arguments self , unpacked list args and unpacked dictionary options .
if value under the _STR:0_ key of the options dictionary is greater than zero ,
call the method logging.getLogger [ logging . getLogger ] with an argument string _STR:0_ , substitute the result for logger .
call the method logging.StreamHandler [ logging . StreamHandler ] , substitute the result for handler .
call the method logger.addHandler [ logger . addHandler ] with an argument handler .
call the method execute form the base class of the class Command , with 2 arguments : unpacked list args and unpacked dictionary options .
if value under the _STR:0_ key of the options dictionary is greater than zero ,
call the method logger.removeHandler [ logger . removeHandler ] with an argument handler .
define the method handle with 3 arguments : self , unpacked list test_labels and unpacked dictionary options .
from django.conf [ django . conf ] import settings into default namespace .
from django.test.utils [ django . test . utils ] import get_runner into default namespace .
call the method get_runner with 2 arguments : settings and value under the _STR:0_ key of the options dictionary , substitute it for the TestRunner .
if value under the _STR:0_ key of the options dictionary is not None ,
substitute value under the _STR:0_ key of the options dictionary for value under the _STR:1_ key of the os.environ [ os . environ ] dictionary .
delete the value under the _STR:0_ key of the options dictionary .
test_runner is an instance of TestRunner class , called with an argument unpacked dictionary options .
call the method test_runner.run_tests [ test_runner . run_tests ] with an argument test_labels , substitute it for failures .
if failures is true ,
exit the program with failures converted to boolean as a message .
from django.core.management [ django . core . management ] import call_command into default name space .
from django.core.management.base [ django . core . management . base ] import BaseCommand into default name space .
from django.db [ django . db ] import connection into default name space .
derive class Command from the BaseCommand base class .
help is a string _STR:0_ .
args is a string _STR:0_ .
requires_system_checks is boolean False .
define the method with self class instance and parser as arguments .
call parser.add_argument [ parser . add_argument ] method with _STR:0_ , metavar set to string _STR:1_ , nargs set to string _STR:2_ and help set to string _STR:3_ .
call parser.add_argument [ parser . add_argument ] method with _STR:0_ , action set to string _STR:1_ , dest set to string _STR:2_ ,
default set to boolean True and help set to string _STR:0_ . call the parser.add_argument [ parser . add_argument ] with string _STR:1_ , default set to an empty string and help as string _STR:2_ .
call parser.add_argument [ parser . add_argument ] method with _STR:0_ , string _STR:1_ , action set to string _STR:2_ , dest set to string _STR:3_ ,
default set to boolean False and help set to string _STR:0_ . define the method handle with self class instance , list of arguments fixture_labels and dictionary options as arguments .
get the value under the key _STR:0_ of options dictionary , substitute it for verbosity .
get the value under the key _STR:0_ of options dictionary , substitute it for interactive .
call the method connection.creation.create_test_db [ connection . creation . create_test_db ] with verbosity set to verbosity , autoclobber set to inverse value of interactive ,
serialize set to boolean False , substitute the return value for db_name . call the method call_command with 3 arguments , string _STR:0_ , unpacked list fixture_labels and unpacked dictionary containing 1 element : verbosity for _STR:1_ .
replace _STR:0_ from string _STR:1_ , with db_name , substitute it for shutdown_message .
substitute connection.features.test_db_allows_multiple_connections [ connection . features . test_db_allows_multiple_connections ] for use_threading .
call the function call_command with 6 arguments , string _STR:0_ , addrport as the value under the _STR:1_ key of options dictionary ,
from __future__ import unicode_literals into default name space .
import module warnings .
from django.core.management.commands.check [ django . core . management . commands . check ] import Command as CheckCommand into default name space .
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
derive class Command from CheckCommand base class .
concatenate CheckCommand.help [ CheckCommand . help ] to string _STR:0_ , substitute it for help .
define the method handle with self class instance and dictionary pair of elements options as arguments .
call the method warnings.warn [ warnings . warn ] with string _STR:0_ and RemovedInDjango19Warning as arguments .
call the handle function with dictionary pair of elements options from the base class of the class Command .
from __future__ import unicode_literals into default name space .
import module codecs .
import module os .
import module re .
import module warnings .
from django.apps [ django . apps ] import apps into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.core.management.base [ django . core . management . base ] import CommandError into default name space .
from django.db [ django . db ] import models and router into default name space .
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
define the function check_for_migrations with 2 arguments : app_config and connection .
from django.db.migrations.loader [ django . db . migrations . loader ] import MigrationLoader into default name space .
loader is an instance of MigrationLoader class , created with an argument connection .
if app_config.label [ app_config . label ] is contained in loader.migrated_apps [ loader . migrated_apps ] ,
raise an CommandError exception , with an arguent : string _STR:0_ , where ' % s ' is replaced for app_config.label [ app_config . label ] .
define the function sql_create with 3 arguments : app_config , style and connection .
call the function check_for_migrations with an arguments app_config , connection .
if value under the _STR:0_ key of the connection.settings_dict [ connection . settings_dict ] dictionary equals a string _STR:1_ ,
raise an CommandError exception with an argument string _STR:0_
_STR:0_ . call the method app_config.get_models [ app_config . get_models ] with an argument include_auto_created set to boolean True , substitute it for app_models .
final_output is an empty list .
call the method connection.introspection.table_names [ connection . introspection . table_names ] , substitute the result for tables .
if model is not contained in app_models for every model in return value of the connection.introspection.installed_models [ connection . introspection . installed_models ] function return value ,
add model to a set , substitute the result for known_models . pending_references is an empty dictionary .
for every model in return value of the function router.get_migratable_models [ router . get_migratable_models ] , called with arguments :
app_config , connection.alias [ connection . alias ] and include_auto_created set to boolean True . call the method connection.creation.sql_create_model [ connection . creation . sql_create_model ] with arguments model , style and known_models , substitute the result for output and references .
call the method final_output.extend [ final_output . extend ] with an argument output .
for every refto and refs in return value of the method references.items [ references . items ] ,
call the method pending_references.setdefault [ pending_references . setdefault ] with 2 arguments : refto and an empty list , extend the result with refs .
if refto is contained in known_models ,
call the method connection.creation.sql_for_pending_references [ connection . creation . sql_for_pending_references ] with 3 arguments : refo , style and pending_references ,
use the result as an argument for the call to the method final_output.extend [ final_output . extend ] . call the method connection.creation.sql_for_pending_references [ connection . creation . sql_for_pending_references ] with 3 arguments : refo , style and pending_references ,
use the result as an argument for the call to the method final_output.extend [ final_output . extend ] . add model to known_models set .
call the method pending_references.keys [ pending_references . keys ] , put the result into a set and substitute it for not_installed_models .
if not_installed_models is true ,
alter_sql is an empty list .
for every model in not_installed_models ,
for every sql in return value of the function connection.creation.sql_for_pending_references [ connection . creation . sql_for_pending_references ] called with arguments : model , style ,
and pending_references append sql to the string _STR:0_ , put the results in a list , extend alter_sql with the result . if alter_sql ,
append string _STR:0_ to the final_output .
extend final_output with alter_sql .
return final_output .
define the function sql_delete with 4 arguments : app_config , style , connection and close_connection set to boolean True .
call the function check_for_migrations with arguments app_config and connection .
try ,
call the method connection.cursor [ connection . cursor ] , substitute the result for cursor .
if Exception exception is caught ,
cursor is None .
try ,
if cursor is true ,
call the method connection.introspection.table_names [ connection . introspection . table_names ] with an argument cursor , substitute the result for table_names .
if not ,
table_names is an empty list .
output is an empty list .
to_delete is an empty set .
references_to_delete is an empty dictionary .
call the method router.get_migratable_models [ router . get_migratable_models ] with argument : app_config , connection.alias [ connection . alias ] and include_auto_created set to True , substitute the result for app_models .
for every model in app_models ,
if cursor is true and return value of the function connection.introspection.table_name_converter [ connection . introspection . table_name_converter ] called with an arugment : model._meta.db_table [ model . _meta . db_table ] is contained in table_names ,
substitute model._meta [ model . _meta ] for opts .
for every f in opts.local_fields [ opts . local_fields ] ,
if f.rel [ f . rel ] and f.rel.to [ f . rel . to ] are not contained in to_delete ,
call the method references_to_delete.setdefault [ references_to_delete . setdefault ] with arguments : r.rel.to [ r . rel . to ] and an empty list , append to the result tuple with 2 entries : model and f .
call the method to_delete.add [ to_delete . add ] with an argument model .
for every model in app_models ,
if return value of the function connection.introspection.table_name_converter [ connection . introspection . table_name_converter ] called with an arugment : model._meta.db_table [ model . _meta . db_table ] is contained in table_names
call the method connection.creation.sql_destroy_model [ connection . creation . sql_destroy_model ] with arguments : model , references_to_delete and style , extend with the result the list output .
finally perform ,
if both cursor and close_connection are true ,
call the method cursor.close [ cursor . close ] ,
call the method connection.close [ connection . close ] ,
return reversed list output .
define the function sql_flush with 4 arguments : style , connection , only_django set to boolean False ,
if only_django ,
call the method connection.introspection.django_table_names [ connection . introspection . django_table_names ] with an argument boolean true , substitute the result for tables .
if not ,
call the method connection.introspection.table_names [ connection . introspection . table_names ] , substitute the result for tables .
call the method connection.introspection.sequence_list [ connection . introspection . sequence_list ] if reset_sequences is true , substitute the result for seqs , if not , seqs is an empty tuple .
call the method connection.ops.sql_flush [ connection . ops . sql_flush ] with arguments : style , tables , seqs and allow_cascade , substitute the result for statements .
return statements .
define the function sql_custom with 3 arguments : app_config , style and connection .
call the method check_for_migrations with arguments : app_config and connection .
output is an empty list .
call the method router.get_migratable_models [ router . get_migratable_models ] with arguments app_config and connection.alias [ connection . alias ] .
for every model in app_models ,
call the function custom_sql_for_model with 3 arguments : model , style and connection , extend the output with the result .
return output .
define the function sql_indexes with 3 arguments : app_config , style and connection .
call the function check_for_migrations with an arguments app_config and connection .
outut is an empty list .
for model in router.get_migratable_models [ router . get_migratable_models ] method return value , called with 3 arguments : app_config , connection.alias [ connection . alias ] ,
and include_auto_created set to boolean True , call the method connection.creation.sql_indexes_for_model [ connection . creation . sql_indexes_for_model ] with arguments model and style , extend output with the result .
return output .
define the function sql_destroy_indexes with 3 arguments : app_config , style and connection .
call the function check_for_migrations with arguments app_config and connection .
output is an empty list .
for model in return value of the method router.get_migratable_models [ router . get_migratable_models ] with arguments app_config , connection.alias [ connection . alias ] ,
and include_auto_created set to boolean True , call the method connection.creation.sql_destroy_indexes_for_model [ connection . creation . sql_destroy_indexes_for_model ] with arguments model and style , extend the output with the result .
return output .
define the function sql_all with 3 arguments : app_config , style and connection .
call the function check_for_migrations with arguments app_config and connection .
use the app_config , style and connection as arguments for the call to the sql_create , sql_custom and sql_indexes functions , append the results respectively , return the result .
define the function _split_statements with an argument content .
call the function re.compile [ re . compile ] with an argument raw string _STR:0_ , substitute the result for comment_re .
statements is an empty list .
statement is an empty list .
split content by newline character , for every line in result ,
call the method comment_re.sub [ comment_re . sub ] with an arguments : raw string _STR:0_ and line , strip the whitespaces surrounding the result , return it .
if cleaned_line is false ,
skip this loop iteration ,
append cleaned_lien to statement .
if cleaned_line ends with _STR:0_ character ,
join statements into a string , separated by white spaces , append it to statements .
statement is an empty list .
return statements .
define the function custom_sql_for_model with 3 arguments : app_config , style and connection .
substitute model._meta [ model . _meta ] for opts .
app_dirs is an empty list .
call the method apps.get_app_config [ apps . get_app_config ] with an argument model._met.app_label [ model . _met . app_label ] , substitute path field of the result for app_dir .
join app_dir and string _STR:0_ into a file path , use the result as an argument for the call to the function os.path.normpath [ os . path . normpath ] ,
append the result to app_dirs . join app_dir and string _STR:0_ into a file path , use the result as an argument for the call to the function os.path.normpath [ os . path . normpath ] ,
append the result to old_app_dirs . if file path old_app_dir exists ,
call the function warnings.warn [ warnings . warn ] with 2 arguments : string _STR:0_ and RemovedInDjango19Warning .
append old_app_dir to app_dirs .
output is an empty list .
if opts.managed [ opts . managed ] is true ,
for every f in opts.local_fields [ opts . local_fields ] that has an _STR:0_ attribute , append f to a list , substitute the resulting list for post_sql_fields .
for every f in post_sql_fields ,
call the method f.post_create_sql [ f . post_create_sql ] with arguments : style and model._meta.db_table [ model . _meta . db_table ] , extend the output with the result .
once split at the _STR:0_ value under the _STR:1_ key of the connection.settings_dict [ connection . settings_dict ] dictionary , substitute last element of the result for backend_name .
sql_files is an empty list .
for every app_dir in app_dirs ,
join into a file path : app_dir and string % s. % s.sql [ s . sql ] , where ' % s ' is replaced by opts.model_name [ opts . model_name ] and backend_name , respectively ,
append the result to sql_files . join into a file path : app_dir and string % s. % s.sql [ s . sql ] , where ' % s ' is replaced by opts.model_name [ opts . model_name ] , append the result to sql_files .
for every sql_file in sql_files ,
if file path sql_file exists ,
call the function codecs.open [ codecs . open ] with 3 arguments : sql_file , string _STR:0_ and encoding set to settings.FILE_CHARSET [ settings . FILE_CHARSET ] , with the result renamed to fp ,
call the method connection.ops.prepare_sql_script [ connection . ops . prepare_sql_script ] with 2 arguments : return value of the function fp.read [ fp . read ] ,
and _allow_fallback set to boolean True , extend the output with the result . return output .
define the function emit_pre_migrate_signal with 4 arguments : create_models , verbosity , interactive and db .
for app_config in return value of the method apps.get_app_configs [ apps . get_app_configs ] ,
if app_config.models_module [ app_config . models_module ] is None ,
skip this loop iteration ,
if verbosity is greater or equal to integer 2 ,
replace ' % s ' in string _STR:0_ with app_config.label [ app_config . label ] , print it to the standard output .
call the method models.signals.pre_migrate.send [ models . signals . pre_migrate . send ] with 5 arguments : sender set to app_config , app_config set to app_config ,
verbosity set to verbosity , interactive set to interactive and using set to db . call the method models.signals.pre_syncdb.send [ models . signals . pre_syncdb . send ] with 6 arguments : sender set to app_config.models_module [ app_config . models_module ] ,
app set to app_config.models_module [ app_config . models_module ] , create_models set to create_models , verbosity set to verbosity , interactive set to interactive , and db set to db . define the function emit_post_migrate_signal with 4 arguments : created_models , verbosity , interactive and db .
for app_config in return value of the method apps.get_app_configs [ apps . get_app_configs ] ,
if app_config.models_module [ app_config . models_module ] is None ,
skip this loop iteration ,
if verbosity is greater or equal to integer 2 ,
replace ' % s ' in string _STR:0_ with app_config.label [ app_config . label ] , print it to the standard output .
call the method models.signals.post_migrate.send [ models . signals . post_migrate . send ] with 5 arguments : sender set to app_config , app_config set to app_config ,
verbosity set to verbosity , interactive set to interactive and using set to db . call the method models.signals.post_syncdb.send [ models . signals . post_syncdb . send ] with 6 arguments : sender set to app_config.models_module [ app_config . models_module ] ,
import module cgi .
import module errno .
import module mimetypes .
import module os .
import module posixpath .
import module re .
import module shutil .
import module stat .
import module sys .
import module tempfile .
from os import path into default name space .
import module django .
from django.template [ django . template ] import Template and Context into default name space .
from django.utils [ django . utils ] import archive into default name space .
from django.utils.six.moves.urllib.request [ django . utils . six . moves . urllib . request ] import urlretrieve into default name space .
from django.utils._os [ django . utils . _os ] import rmtree_errorhandle into default name space .
from django.core.management.base [ django . core . management . base ] import BaseCommand and CommandError into default name space .
from django.core.management.utils [ django . core . management . utils ] import handle_extensions into default name space .
call the function re.compile [ re . compile ] with 2 arguments : string _STR:0_ and re.I [ re . I ] , substitute the result for _drive_re .
call the function re.compile [ re . compile ] with 2 arguments : string _STR:0_ and re.I [ re . I ] , substitute the result for _url_drive_re .
derive the class TemplateCommand from the BaseCommand base class .
requires_system_checks is boolean False .
can_import_settings is boolean False .
url_schemes is list of strings _STR:0_ , _STR:1_ and _STR:2_ .
leave_locale_alone is boolean True .
define the method add_aguments with arguments self and parser .
call the method parser.add_argument [ parser . add_argument ] with 2 arguments : string _STR:0_ and help set to string _STR:1_ .
call the method parser.add_argument [ parser . add_argument ] with 3 arguments : string _STR:0_ , nargs set to _STR:1_ and help set to string _STR:2_ .
call the method parser.add_argument [ parser . add_argument ] with 2 arguments : string _STR:0_ and help set to string _STR:1_ .
call the method parser.add_argument [ parser . add_argument ] with 6 arguments : string _STR:0_ , string _STR:1_ , dest set to string _STR:2_ ,
action set to _STR:0_ , default is a list containing string _STR:1_ and help set to string : _STR:2_ . call the method parser.add_argument [ parser . add_argument ] with 6 arguments : string _STR:3_ , string _STR:4_ , dest set to string _STR:5_ ,
action set to string _STR:0_ , default as an empty list and help set to a string : _STR:1_ . define the method handle with 5 arguments : self , app_or_project , name , target set to None and unpacked dictionary options .
substitute app_or_project for self.app_or_project [ self . app_or_project ] .
self.paths_to_remove [ self . paths_to_remove ] is an empty list .
substitute value under the _STR:0_ key of the options dictionary for self.verbosity [ self . verbosity ] .
call the method self.validate_name [ self . validate_name ] with 2 arguments name and app_or_project .
if target is None ,
join the current working directory and name into a file path , substitute it for top_dir .
try ,
make a directory top_dir .
if OSError renamed to e , exception is caught ,
if e.errno [ e . errno ] equals errno.EEXIST [ errno . EEXIST ] ,
replace ' % s ' in string _STR:0_ with top_dir , substitute it for message .
if not ,
substitute e for message .
raise an CommandError exception with an argument message .
if not ,
ge the absolute path of the return value of the function path.expanduser [ path . expanduser ] with the argument target , substitute it for top_dir .
if file path top_dir doesnt exists ,
raise an CommandError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with top_dir . call the function handle_extensions with 2 arguments : value under the _STR:0_ key of the options dictionary ,
and ignored as an empty tuple , convert the result into a tuple and substitute it for extensions . extra_files is an empty list .
for every file in value under the _STR:0_ key of the options dictionary .
split file by _STR:0_ character , apply on its every element a lambda function which takes an argument x ,
and returns x striped of the surrounding whitespaces , extend the extra_files with the mapped list . if self.verbosity [ self . verbosity ] is greater or equal to integer 2 ,
call the method self.stdout.write [ self . stdout . write ] , with an argument string _STR:0_ ,
where ' % s ' is replaced with app_or_project and extensions joined into a string , separated by a string _STR:0_ . call the method self.stdout.write [ self . stdout . write ] , with an argument string _STR:1_ ,
where ' % s ' is replaced with app_or_project and extra_files joined into a string , separated by a string _STR:0_ . append string _STR:1_ to app_or_project , substitute it for base_name .
append string _STR:0_ to app_or_project , substitute it for base_subdir .
append string _STR:0_ to app_or_project , substitute it for base_directory .
if second last element of django.VERSION [ django . VERSION ] is not equal to a string _STR:0_ ,
docs_version is a string _STR:0_ .
if not ,
convert first 2 elements of django.VERSION [ django . VERSION ] into a strings , join them together , separated by a _STR:0_ , substitute the result for docs_version .
context is an instance of a class Context , created with 2 arguments : dictionary created by apllying options to unpacked dictionary containing 3 entries :
name for base_name , top_dir for base_directory and docs_version for _STR:0_ and autoescape set to boolean False . from django.conf [ django . conf ] import settings into a default name space ,
if settings.configured [ settings . configured ] is false ,
call the method settings.configure [ settings . configure ] .
call the method self.handle_template [ self . handle_template ] with 2 arguments : value under the _STR:0_ key of the options dictionary and base_subdir .
increment length of template_dir by one and substitute it for prefix_length .
for every root , dirs and files in subdirectory tree starting from the base dir template_dir ,
slice root starting from the prefix_length index to the end , substitute it for path_rest .
call the method path_rest.replace [ path_rest . replace ] with arguments base_name and name , substitute the result for relative_dir .
if relative_dir is true ,
join top_dir and relative_dir into a file path , substitute it for target_dir .
if target_dir path doesnt exists ,
make target_dir directory ,
for dirname in dirs ,
if dirname starts with character _STR:0_ or dirname equals a string _STR:1_ ,
remove dirname key from dirs .
for every filename in files ,
if filename ends with _STR:0_ , _STR:1_ or _STR:2_ ,
skip this loop iteration ,
join root and filename into a file path , substitute it for old_path .
join top_dir , relative_dir and return value of the function filename.replace [ filename . replace ] called with 2 arguments : base_name and name ,
into a file path , substitute it for new_path . if new_path file path exists ,
raise a CommandError exception with an argument :
string _STR:0_ , where _STR:1_rb ' mode , with file descriptor renamed to template_file ,
call the method template_file.read [ template_file . read ] , substitute it for content .
if filename ends with extensions or filename is contained in extra_files ,
call the method content.decode [ content . decode ] with an argument string _STR:0_ , substitute it for content .
template is an instance of Template class , created with an argument content .
call the method template.render [ template . render ] with an argument context , substitute it for content .
call the method content.encode [ content . encode ] with an argument string _STR:0_ , substitute it for content .
open new_path file in _STR:0_ mode , with file descriptor renamed to new_file ,
write content to new_file file .
if self.verbosity [ self . verbosity ] is greater or equal to integer 2 ,
replace ' % s ' in string _STR:0_ with new_path , write it to the self.stdout [ self . stdout ] stream .
try ,
call the function shutil.copymode [ shutil . copymode ] with arguments old_path and new_path .
call the method self.make_writeable [ self . make_writeable ] with an argument new_path .
if OSError exception is caught ,
replace ' % s ' in string _STR:0_ ,
with new_path and self.style.NOTICE [ self . style . NOTICE ] , respectively , write it to self.stderr [ self . stderr ] stream . if self.paths_to_remove [ self . paths_to_remove ] is true ,
if self.verbosity [ self . verbosity ] is greater or equal to integer 2 ,
write string _STR:0_ to self.stdout [ self . stdout ] stream .
for every path_to_remove in self.paths_to_remove [ self . paths_to_remove ] ,
if path_to_remove is file ,
remove file path_to_remove ,
if not ,
call the function shutil.rmtree [ shutil . rmtree ] with 2 arguments : path_to_remove and onerror set to rmtree_errorhandler .
define the method handle_template with 3 arguments : self , template and subdir .
if template is None ,
join first element of django.__path__ [ django . __path__ ] , string _STR:0_ and subdir into a valid file path , return it .
if not ,
if template starts with a string _STR:0_ ,
remove first 7 elements form template .
call the method path.expanduser [ path . expanduser ] with an argument template , substitute it for expanded_template .
call the method path.normpath [ path . normpath ] with an argument expanded_template , substitute it for expanded_template .
if expanded_template is a directory ,
return expanded_template .
call the method self.is_url [ self . is_url ] with an argument template , if it evaluates to true ,
call the method self.download [ self . download ] with an argument template , substitute the result for absolute_path .
if not ,
get the absolute file path of the expanded_template , substitute it for absolute_path .
if file path absolute_path exists ,
call the method self.extract [ self . extract ] with an argument absolute_path , return the result .
raise an CommandError exception with an argument string _STR:0_ , replace ' % s ' with self.app_or_project [ self . app_or_project ] and template .
define validate_name with 3 arguments : self , name and app_or_project .
if name is None ,
raise an CommandError exception with an argument string _STR:0_ , where ' % s ' is replaced with string _STR:1_ ,
and app_or_project if app_or_project equals to string _STR:0_ , if not , it is replaced with _STR:1_ and app_or_project . call the method re.search [ re . search ] with 2 arguments : raw string _STR:2_ and name , if it evaluates to false ,
call the method re.search [ re . search ] with 2 arguments : raw string _STR:0_ and name , if it evaluates to false ,
message is a string _STR:0_ .
if not ,
message is a string _STR:0_ .
raise an CommandError with an argument string _STR:0_ , were _STR:1_ is replaced with name ,
and ' % s ' is replaced with app_or_project and message , respectively . define the method download with arguments self and url .
define the function cleanup_url with an argument url .
strip url of surrounding _STR:0_ characters , substitute it for tmp .
split tmp at _STR:0_ character , substitute the last element of the result for filename .
if url ends with _STR:0_ character ,
append _STR:0_ to tmp , substitute it for display_url .
if not ,
substitute url for display_url .
return filename and display_url .
replace ' % s ' in string _STR:0_ with self.app_or_project [ self . app_or_project ] .
call the function tempfile.mkdtemp [ tempfile . mkdtemp ] with arguments : prefix set to prefix and suffix set to string _STR:0_ .
append the tempdir to self.paths_to_remove [ self . paths_to_remove ] .
call the function cleanup_url with an argument url , assign the result to filename and display_url , respectively .
if self.verbosity [ self . verbosity ] is greater or equal to integer 2 ,
replace ' % s ' in string _STR:0_ , with display_url , write it to self.stdout [ self . stdout ] stream .
try ,
call the function urlretrieve with arguments url and tempdir and filename joined into a file path , assign the result to the_path , and info , respectively .
if IOErro , renamed to e , exception is caught ,
raise an CommandError exception with an argument string _STR:0_ , where ' % s ' is replaced with url ,
filename and e. split the_path at the _STR:0_ character , substitute last element of the result for used_name .
get the value under the _STR:0_ key of the info dictionary , substitute it for content_disposition .
if content_disposition is true ,
call the method cgi.parse_header [ cgi . parse_header ] with an argument content_disposition , assign the result to _ and params , respectively .
get the value under the _STR:0_ key of the params dictionary , if the key exists substitute it for guessed_filename ,
if not , substitute used_name for guessed_filename . if not ,
substitute used_name for guessed_filename .
call the method self.splitext [ self . splitext ] with an argument guessed_filename , substitute the second element of the result for ext .
get the value under the _STR:0_ key of the info dictionary , substitute it for content_type .
if ext is false and content_type is true ,
call the method mimetypes.guess_extension [ mimetypes . guess_extension ] with an argument content_type , substitute result for ext .
if ext is true ,
append ext to guessed_filename .
if used_name is not equal to guessed_filename ,
join tempdir and guessed_filename into a file path , substitute it for guessed_path .
call the function shutil.move [ shutil . move ] with arguments the_path and guessed_path .
return guessed_path .
return the_path .
define the method splitext with arguments self and the_path .
call the method posixpath.splitext [ posixpath . splitext ] with an argument the_path .
convert base to lowercase , if it ends with string _STR:0_ ,
take last four elements of base and append ext to it , substitute result for ext .
substitute last four elements of base for base .
return base and ext .
define the function with arguments self and filename .
replace ' % s ' in string _STR:0_ with self.app_or_project [ self . app_or_project ] , substitute it for prefix .
call the method tempfile.mkdtemp [ tempfile . mkdtemp ] with 2 arguments : prefix set to prefix , suffix set to string _STR:0_ , substitute the result for tempdir .
append tempdir to self.self.paths_to_remove [ self . self . paths_to_remove ] .
if self.verbosity [ self . verbosity ] is greater or equal to integer 2 .
substitute ' % s ' in string _STR:0_ with filename , write it to self.stdout [ self . stdout ] stream .
try ,
call the method archive.extract [ archive . extract ] with arguments : filename and tempdir .
return tempdir .
if archive.ArchiveException [ archive . ArchiveException ] or IOError , renamed to e , exception are caught ,
raise an CommandError with an argument string _STR:0_ , where ' % s ' is replaced with filename , tempdir and e .
define the method is_url with arguments self and template .
if character _STR:0_ is not contained in template ,
return boolean False .
split template once at the first character _STR:0_ , convert the first element to lowercase and substitute it for scheme .
if scheme is countaine in self.url_schemes [ self . url_schemes ] return boolean True , otherwise return False .
define the method make_writeable with arguments self and filename .
if sys.platform [ sys . platform ] starts with string _STR:0_ ,
return nothing .
if call to the method os.access [ os . access ] with arguments : filename and os.W_OK [ os . W_OK ] , evaluates to false ,
call the function os.stat [ os . stat ] with an argument filename , substitute the result for st .
call the method stat.S_IMODE [ stat . S_IMODE ] with an argument st.st_mode [ st . st_mode ] , calculate binary OR with the result and stat.S_IWUSR [ stat . S_IWUSR ] , as operands ,
substitute the result for new_permission . call the function os.chmod [ os . chmod ] wiht arguments filename and new_permissions .
from __future__ import unicode_literals into default name space .
import module os .
from subprocess import PIPE and Popen into default name space .
import module sys .
from django.utils.encoding [ django . utils . encoding ] import force_text and DEFAULT_LOCALE_ENCODING into default name space .
from django.utils [ django . utils ] import six into default name space .
from .base import CommandError into default name space .
define the function popen_wrapper with 2 arguments : args and os_err_exc_type set to CommandError .
try ,
p is a instance of Popen class , created with 6 arguments : args , shell set to boolean False , stdout set to PIPE ,
stderr set to PIPE , close_fds set to boolean True is os.name [ os . name ] is not equal to _STR:0_ , universal_newlines set to boolean True . if OSError , renamed to e , exception is caught ,
call the force_text function with 3 arguments : e.strerror [ e . strerror ] , DEFAULT_LOCALE_ENCODING and strings_only set to boolean True .
call the method six.reraise [ six . reraise ] 3 with arguments : os_err_exc_type , return value of the function os_err_exc_type ,
called with string as an argument _STR:0_ , where ' % s ' is replaced by : first element of args and strerror , respective , and third element of the result of the function sys.exc_info [ sys . exc_info ] . call the method p.communicate [ p . communicate ] , assign the result to output and errors , respectively .
return a tuple containing 3 entries : output , result of the function force_text , called with 3 arguments : errors ,
DEFAULT_LOCALE_ENCODING and strings_only set to boolean True and p.returncode [ p . returncode ] . define the function handle_extensions with 2 arguments : extensions set to tuple containing string _STR:0_ and ignored set to tuple containing string _STR:1_ .
ext_list is an empty list ,
for every ext in extensions ,
delete all the whitespaces from ext , split it by _STR:0_ character , extend ext_list with the result .
for every i and ext in enumerated iterable ext_list ,
if ext doesnt start with _STR:0_ character ,
prepend _STR:0_ to the i-th element of the ext_list .
if striped x by _STR:0_ character is not contained in ignored , for every x in ext_list put x into a set , return the resulting set .
define the function find_command with 3 arguments : cmd , path set to None and pathext set to None .
if path is None ,
call the function os.environ.get [ os . environ . get ] with 2 arguments : string _STR:0_ and an empty string , split the result at the os.pathsep [ os . pathsep ] , substitute the result for path .
if path is an instance of six.string_types [ six . string_types ] ,
path is an list containing path .
if pathext is None ,
call the method os.environ.get [ os . environ . get ] with 2 arguments : strings _STR:0_ and _STR:1_ , split the result at os.pathsep [ os . pathsep ] , substitute it for pathext .
for ext in pathext ,
if cmd ends with ext ,
pathext is an list containing an empty string .
break the loop execution .
for every p in path ,
join p and cmd into a file path , substitute it for f .
if f is a file ,
return f .
for every ext in pathext ,
add ext to f , substitute the result for fext .
if fext is a file ,
return fext .
return None .
import module collections .
from math import ceil into default name space .
from django.utils [ django . utils ] import six into default name space .
derive the class InvalidPage from the Exception base class .
do nothing .
derive the class PageNotAnInteger from the InvalidPage base class .
do nothing .
derive the class EmptyPage from the InvalidPage base class .
do nothing .
derive the class Paginator from the object base class .
def the method __init__ with 5 arguments : self , object_list , per_page , orphans set to integer 0 and allow_empty_first_page set to boolean True .
substitute object_list for self.object_list [ self . object_list ] .
convert per_page into an integer and substitute it for self.per_page [ self . per_page ] .
convert orphans into an integer and substitute it for self.orphans [ self . orphans ] .
substitute allow_empty_first_page for self.allow_empty_first_page [ self . allow_empty_first_page ] .
self._num_pages [ self . _num_pages ] and self._count [ self . _count ] are None .
define the method validate_number with self class instance and number as arguments .
try ,
convert number into an integer and substitute it for number
if TypeError or ValueError exceptions are caught ,
raise an exception PageNotAnInteger with string _STR:0_ as an argument .
if number is lesser than integer 1 ,
raise an EmptyPage exception with string _STR:0_ as an argument .
if number is greater than self.num_pages [ self . num_pages ] ,
if number equals a integer 1 and self.allow_empty_first_page [ self . allow_empty_first_page ] is true ,
do nothing .
if not ,
raise an EmptyPage exception with string _STR:0_ as an argument .
return number .
define the method page with self class instance and number as arguments .
call the method self.validate_number [ self . validate_number ] with an argument number , substitute it for number .
decrement number by one , multiply it with self.per_page [ self . per_page ] , substitute the result for bottom .
sum bottom and self.per_page [ self . per_page ] , substitute the result for top .
if sum of the top and self.orphans [ self . orphans ] is greater or equal to self.count [ self . count ] ,
substitute self.count [ self . count ] for top .
call the self._get_pages [ self . _get_pages ] method with 3 arguments : self.object_list [ self . object_list ] from the bottom to the top index , number and self , return the result .
define the method _get_page with self class instance , unpacked list args and unpacked dictionary kwargs as arguments .
return a instance of the class Page , created with 2 arguments : unpacked list args and unpacked dictionary kwargs .
define the method _get_count with an argument self .
if self._count [ self . _count ] is None ,
try ,
substitute the return value of the method self.object_list.count [ self . object_list . count ] for self._count [ self . _count ] .
if TypeError or AttributeError exceptions are caught ,
substitute length of self.object_list [ self . object_list ] for self._count [ self . _count ] .
return self._count [ self . _count ] .
count is a property object with _get_count as a getter method .
define the method _get_num_pages with an argument self .
if self._num_pages [ self . _num_pages ] is None ,
if self.count [ self . count ] equals a integer 0 and self.allow_empty_first_page [ self . allow_empty_first_page ] is false ,
self._num_pages [ self . _num_pages ] is a integer 0 .
if not ,
get greater value between integer 1 and result of subtraction of self.orphans [ self . orphans ] from self.count [ self . count ] , substitute it for hits .
divide hits by a floating point number self.per_page [ self . per_page ] , convert its ceiling value to an integer and substitute it for self._num_pages [ self . _num_pages ] .
return self._num_pages [ self . _num_pages ] .
num_pages is a property object with _get_num_pages as a getter method .
define the method _get_page_range with an argument self .
return all the integers from the integer 1 to the self.num_pages [ self . num_pages ] .
page_range is a property object with _get_page_range as a getter method .
substitute Paginator for QuerySetPaginator .
derive the class Page from the collections.Sequence [ collections . Sequence ] base class .
define the method __init__ with 4 arguments : self , object_list , number , and paginator .
substitute object_list for self.object_list [ self . object_list ] .
substitute number for self.number [ self . number ] .
substitute paginator for self.paginator [ self . paginator ] .
define the method __repr__ with an argument self .
return the string _STR:0_ , with occurrences of ' % s ' replaced by self.number [ self . number ] and self.paginator.num_pages [ self . paginator . num_pages ] , respectively .
define the method __len__ with an argument self .
return the length of self.object_list [ self . object_list ] .
define the method __getitem__ with arguments self and index .
if index is not an instance of six.integer_types [ six . integer_types ] or tuple type ,
raise a TypeError exception ,
if self.object [ self . object ] is not an instance of list type ,
convert self.object_list [ self . object_list ] to a list .
return self.object_list [ self . object_list ] element at index .
define the method has_next with an argument self .
if self.number [ self . number ] is lesser than self.paginator.num_pages [ self . paginator . num_pages ] , return boolean True , otherwise return boolean False .
define the method has_previous with an argument self .
if self.number [ self . number ] is greater than integer 1 , return boolean True , otherwise return boolean False .
define the method has_other_pages with an argument self .
call the method self.has_previous [ self . has_previous ] , if it evaluate to false , call the self.has_next [ self . has_next ] method , return the result .
define the method next_page_number with an argument self .
call the method self.paginator.validate_number [ self . paginator . validate_number ] with self.number [ self . number ] incremented by 1 as argument , return the result .
define the method previous_page_number with an argument self .
call the method self.paginator.validate_number [ self . paginator . validate_number ] with self.number [ self . number ] decremented by 1 as argument , return the result .
define the method start_index with an argument self .
if self.paginator.count [ self . paginator . count ] equals a integer 0 ,
return integer 0 .
decrement self.number [ self . number ] by one , multiply it by self.paginator.per_page [ self . paginator . per_page ] , increment the result by one , return it .
define the method end_index with an argument self .
if self.number [ self . number ] equals to self.paginator.num_pages [ self . paginator . num_pages ] ,
return self.paginator.count [ self . paginator . count ] .
multiply self.number [ self . number ] and self.paginator.per_page [ self . paginator . per_page ] , return the result .
import module importlib .
from django.conf [ django . conf ] import settings into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.core.serializers.base [ django . core . serializers . base ] import SerializerDoesNotExist into default name space .
BUILTIN_SERIALIZERS is a dictionary containing 4 inital entries : _STR:0_ for _STR:1_ ,
_STR:0_ for _STR:1_ , _STR:2_ for _STR:3_ , and _STR:4_ for _STR:5_ . _serializers is an empty dictionary .
derive the class BadSerializer from the object base class .
internal_use_only is boolean False .
define the __init__method with arguments self and exception .
substitute exception for self.exception [ self . exception ] .
define the __call__method with arguments self , unpacked list args and unpacked dictionary kwargs .
raise an self.exception [ self . exception ] exception .
define the function register_serializer with 3 arguments : format , serializer_module and serializers set to None .
if serializers is None and _serializers is false ,
call the function _load_serializers .
try ,
call the function importlib.import_module [ importlib . import_module ] with an argument serializer_module , substitute it for module .
if ImportError , renamed to exc , exception is caught ,
ba_serializer is a instance of BadSerializer class , created with an argument exc .
create a instance of a class BadSerializerModule from the object base class , with elements Deserializer set to bad_serializer and Serializer set to bad_serializer .
if serializers is None ,
substitute module for the value under the format key of the _serializers dictionary .
if not ,
substitute module for the value under the format key of the serializers dictionary .
define the function unregister_serializer with an argument format .
if _serializers is false ,
call the function _load_serializers .
if format is not contained in _serializers ,
raise a SerializerDoesNotExist exception with an argument format .
delete the _serializers dictionary entry at the format key .
define the function get_serializer with an argument format .
if _serializers is false ,
call the function _load_serializers .
if format is not contained in _serializers ,
raise a SerializerDoesNotExist exception with an argument format .
get the value under the format key of the _serializers dictionary , return the Serializer filed of the result .
define the function get_serializer_formats .
if _serializers is false ,
call the function _load_serializers .
convert _serializers into a list , return it .
define the function get_public_serializer_formats .
f _serializers is false ,
call the function _load_serializers .
append k into a list for every k and v in return value of the six.iteritems [ six . iteritems ] function with an argument _serializers ,
only if v.Serializer.internal_use_only [ v . Serializer . internal_use_only ] is false , return the resulting list . define the function get_deserializer with an argument format .
f _serializers is false ,
call the function _load_serializers .
if format is not contained in _serializers ,
raise a SerializerDoesNotExist exception with an argument format .
get the value under the format key of the _serializers dictionary , return the Deserializer filed of the result .
define the function serializer with 3 arguments : format , queryset and unpacked dictionary options .
call the get_serializer function with an argument format , call the return value object and substitute it for s .
call the s.serialize [ s . serialize ] method with arguments queryset and unpacked dictionary options .
evaluate the method s.getvalue [ s . getvalue ] , return the result .
define the function deserialize with 3 arguments : format , stream_or_string and unpacked dictionary options .
call the get_deserializer function with an argument format , substitute the result for d .
call the object d with arguments stream_or_string and unpacked dictionary options , return the result .
define the function _load_serializers .
use the global variable _serializers .
serializers is an empty dictionary .
for every format in BUILTIN_SERIALIZERS ,
call the function register_serializer with 3 arguments : format , value under the format key of the BUILTIN_SERIALIZERS dictionary and serializers .
if setting has an _STR:0_ attribute ,
for every format in settings.SERIALIZATION_MODULES [ settings . SERIALIZATION_MODULES ] ,
call the function register_serializer with 3 arguments : format , value under the format key of the settings.SERIALIZATION_MODULES [ settings . SERIALIZATION_MODULES ] dictionary and serializers .
substitute serializers for _serializers .
import module warnings .
from django.db [ django . db ] import models into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
derive the class SerializerDoesNotExist from the KeyError base class .
do nothing .
derive the class SerializationError from the Exception base class .
do nothing .
derive the class DeserializationError from the Exception base class .
do nothing .
derive the class Serializer from the object base class .
internal_use_only is a boolean False .
define the method serialize with 3 arguments : self , queryset and unpacked dictionary options .
substitute options for self.options [ self . options ] .
remove the _STR:0_ key from the options dictionary and substitute it for self.stream [ self . stream ] ,
if the key doesnt exists call the six.String [ six . String ] function and substitute the result for self.stream [ self . stream ] . remove the _STR:0_ key from the options dictionary and substitute it for self.selected_fields [ self . selected_fields ] ,
if the key doesnt exists substitute None for self.selected_fields [ self . selected_fields ] . remove the _STR:0_ key from the options dictionary and substitute it for self.use_natural_keys [ self . use_natural_keys ] ,
if the key doesnt exists substitute boolean False for self.use_natural_keys [ self . use_natural_keys ] . if self.use_natural_keys [ self . use_natural_keys ] is true ,
call the function warnings.warn [ warnings . warn ] with 2 arguments : string _STR:0_ and RemovedInDjango19Warning .
remove the _STR:0_ key from the options dictionary and substitute it for self.use_natural_foreign_keys [ self . use_natural_foreign_keys ] ,
if the key doesnt exists substitute self.use_natural_keys [ self . use_natural_keys ] for self.use_natural_foreign_keys [ self . use_natural_foreign_keys ] . remove the _STR:0_ key from the options dictionary and substitute it for self.use_natural_primary_keys [ self . use_natural_primary_keys ] ,
if the key doesnt exists substitute boolean False for self.use_natural_primary_keys [ self . use_natural_primary_keys ] . call the method self.start_serialization [ self . start_serialization ]
self.first [ self . first ] is boolean True .
for every obj in queryset ,
call the self.start_object [ self . start_object ] with an argument obj .
substitute obj._meta.concrete_model [ obj . _meta . concrete_model ] for concrete_model .
for every field in concrete_model._meta.local_fields [ concrete_model . _meta . local_fields ] ,
if field.serialize [ field . serialize ] is true ,
if field.rel [ field . rel ] is None ,
if self.selected_fields [ self . selected_fields ] is None or field.attname [ field . attname ] is contained in self.selected_fields [ self . selected_fields ]
call the method self.handle_field [ self . handle_field ] with arguments obj and filed .
if not ,
if self.selected_fields [ self . selected_fields ] is None or last three elements of field.attname [ field . attname ] are contained in self.selected_fields [ self . selected_fields ] :
call the method self.handle_fk_field [ self . handle_fk_field ] with arguments obj and field .
for every field in concrete_model._meta.many_to_many [ concrete_model . _meta . many_to_many ] ,
if field.serialize [ field . serialize ] is true ,
if self.selected_fields [ self . selected_fields ] is None or field.attname [ field . attname ] is contained in self.selected_fields [ self . selected_fields ] ,
call the method self.handle_m2m_field [ self . handle_m2m_field ] with arguments obj and filed .
call the method self.end_object [ self . end_object ] with an argument obj .
if self.first [ self . first ] is true ,
self.first [ self . first ] is boolean False .
call the method self.end_serialization [ self . end_serialization ] .
call the method self.getvalue [ self . getvalue ] , return the result .
define the method start_serialization with an argument self .
raise a NotImplementedError with an argument string _STR:0_ .
define the method end_serialization with an argument self .
do nothing .
define the method start_object with argument self and obj .
raise a NotImplementedError with an argument string _STR:0_ .
define the method end_object with argument self and obj .
do nothing .
define the method handle_field with argument self , obj and field .
raise a NotImplementedError with an argument string
define the method handle_fk_field with argument self , obj and field .
raise a NotImplementedError with an argument string
define the method handle_m2m_field with argument self , obj and field .
raise a NotImplementedError with an argument string _STR:0_ .
define the method getvalue with an argument self .
get _STR:0_ attribute of the self.stream [ self . stream ] object , if it exists and is callable ,
evaluate self.stream.getvalue [ self . stream . getvalue ] method , return the result .
derive the class Deserializer from the six.Iterator [ six . Iterator ] base class .
define the method __init__ , with 3 arguments : self , stream_or_string and unpacked dictionary options .
substitute options for self.options [ self . options ] .
if stream_or_string is an instance of six.string_types [ six . string_types ] type .
call the function six.StringIO [ six . StringIO ] with an argument stream_or_string , substitute the result for self.stream [ self . stream ] .
if not ,
substitute stream_or_string for self.stream [ self . stream ] .
define the method __iter__ with an argument self .
return self .
define the method __next__ with an argument self .
raise a NotImplementedError with an argument string _STR:0_ .
derive the class DeserializedObject from the object base class .
define the method __init__ , with 3 arguments : self , m2m and data set None .
substitute obj for self.object [ self . object ] .
substitute m2m_data for self.m2m_data [ self . m2m_data ] .
define the method __repr__ with an argument self .
return a string _STR:0_ , where ' % s ' are replaced with self.object._meta.app_label [ self . object . _meta . app_label ] ,
self.object._meta.object_name [ self . object . _meta . object_name ] and self.object.pk [ self . object . pk ] , respectively . define the method save , with 3 arguments : self , save_m2m set to boolean True and using set to boolean True .
call the models.Model.save_base [ models . Model . save_base ] method with arguments self.object [ self . object ] , using as using and raw set to boolean True .
if self.m2m.data [ self . m2m . data ] and save_m2m are true ,
for every accessor_name and object_list is return value of the method self.m2m_data.items [ self . m2m_data . items ] .
set accessor_name of the self.object [ self . object ] to object_list .
self.m2m_data [ self . m2m_data ] is None .
define the function build_instance with 3 arguments : Model , data and db .
obj is an instance of Model class , created with an unpacked dictionary data as argument .
if obj.pk [ obj . pk ] is None , and Model has an _STR:0_ attribute , and Model._default_manager [ Model . _default_manager ] has and _STR:1_ ,
call the method obj.natural_key [ obj . natural_key ] , substitute the result for natural_key .
try ,
call the method Model._default_manager.db_manager [ Model . _default_manager . db_manager ] with an argument db , on the result call the get_by_natural_key with ,
an unpacked list natural_key as argument , substitute the pk filed of the resulting object for obj.pk [ obj . pk ] . if Model.DoesNotExist [ Model . DoesNotExist ] exception is caught ,
do nothing .
return obj .
from __future__ import absolute_import into default name space .
from __future__ import unicode_literals into default name space .
import module datetime .
import module decimal .
import module json .
import module sys .
from django.core.serializers.base [ django . core . serializers . base ] import DeserializationError into default name space .
from django.core.serializers.python [ django . core . serializers . python ] import Serializer as PythonSerializer into default name space .
from django.core.serializers.python [ django . core . serializers . python ] import Deserializer as PythonDeserializer into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.timezone [ django . utils . timezone ] import is_aware into default name space .
define the class Serializer from the PythonSerializer base class .
internal_use_only is boolean False .
define the method start_serialization with an argument self .
call the method json.__version__.split [ json . __version__ . split ] with an argument _STR:0_ , if the result is respectively greater than list containing strings _STR:1_ , _STR:2_ and _STR:3_ ,
call the method self.options.update [ self . options . update ] with dictionary as an argument , containing 1 element : boolean False for _STR:0_ .
self._current [ self . _current ] is None .
call the method self.options.copy [ self . options . copy ] , substitute the result for self.json_kwargs [ self . json_kwargs ] .
remove the entry under the _STR:0_ key of the self.json_kwargs [ self . json_kwargs ] dictionary .
remove the entry under the _STR:0_ key of the self.json_kwargs [ self . json_kwargs ] dictionary .
get the value under the _STR:0_ key of self.options [ self . options ] dictionary , if it is true ,
substitute a tuple with 2 elements : characters _STR:0_ and _STR:1_ for value under the _STR:2_ key of the self.json_kwargs [ self . json_kwargs ] dictionary .
write a _STR:0_ to the self.stream [ self . stream ] file stream .
define the method end_serialization with an argument self .
if value under the _STR:0_ key of the self.options [ self . options ] dictionary is true ,
write a new line to the self.stream [ self . stream ] file stream .
write _STR:0_ to the self.stream [ self . stream ] file stream .
if value under the _STR:0_ key of the self.options [ self . options ] dictionary is true ,
write a new line to the self.stream [ self . stream ] file stream .
define the method end_object with arguments self and obj .
get the value under the _STR:0_ key of the self.options [ self . options ] dictionary , substitute it for indent .
if self.first [ self . first ] is false ,
write _STR:0_ to the self.stream [ self . stream ] file stream .
if indent is false ,
write a white space to the self.stream [ self . stream ] file stream .
if indent is true ,
write new line to the self.stream [ self . stream ] file stream .
call the json.dump [ json . dump ] function with 4 arguments : return value of the method self.get_dump_object [ self . get_dump_object ] called with an argument obj , self.stream [ self . stream ] , cls set to DjangoJSONEncoder and unpacked dictionary self.json_kwargs [ self . json_kwargs ] .
self._current [ self . _current ] is None .
define the method getvalue with an argument self .
call the getvalue method from the base class of the class PythonSerializer , return the result .
define the function Deserializer with arguments stream_or_string and unpacked dictionary options .
if stream_or_string is not an instance of bytes or six.string_types [ six . string_types ] ,
call the stream_or_string.read [ stream_or_string . read ] function , substitute the result for stream_or_string .
if stream_or_string is instance of bytes type ,
call the method stream_or_string.decode [ stream_or_string . decode ] with an argument string _STR:0_ , substitute the result for stream_or_string .
try ,
call the function json.loads [ json . loads ] with an argument stream_or_string , substitute the result for objects .
for every obj in PythonDeserializer called with arguments objects and unpacked dictionary options ,
yield obj as generator return value ,
if GeneratorExit exception is caught ,
raise an exception ,
if Exception , renamed to e , exception is caught ,
call the six.reraise [ six . reraise ] function with 3 arguments : DeserializationError , DeserializationError called with an argument e ,
third element of the return value of the function sys.exc_info [ sys . exc_info ] . define the class DjangoJSONEncoder from the json.JSONEncoder [ json . JSONEncoder ] base class .
define the method defalt with arguments self and o .
if o is an instance of datetime.datetime [ datetime . datetime ] object .
call the method o.isoformat [ o . isoformat ] substitute the result for r .
if o.microsecond [ o . microsecond ] is true ,
remove 3 elements from r starting at the index 23 .
if r ends with string _STR:0_ ,
cut the last 6 elemetns from r , append character _STR:0_ to it , substitute the result for r .
return r .
otherwise if o is an instance of datetime.date [ datetime . date ] object ,
call the method o.isoformat [ o . isoformat ] , return the result .
otherwise if o is an instance of datetime.time [ datetime . time ] object ,
call the function is_aware with an argument o , if it evaluates to true ,
raise a ValueError exception with an argument string _STR:0_ .
call the method o.isoformat [ o . isoformat ] substitute the result for r .
if o.microsecond [ o . microsecond ] is true ,
substitute first 12 elements of r for r .
return r .
otherwise if o is an instance of decimal.Decimal [ decimal . Decimal ] object ,
convert o to an string , return it .
if not ,
call the method default with an argument o from the base class of the class DjangoJSONEncoder , return the result .
substitute DjangoJSONEncoder for DateTimeAwareJSONEncoder .
from __future__ import unicode_literals into default name space .
from django.apps [ django . apps ] import apps into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.core.serializers [ django . core . serializers ] import base into default name space .
from django.db [ django . db ] import models and DEFAULT_DB_ALIAS into default name space .
from django.utils.encoding [ django . utils . encoding ] import smart_text and is_protected_type into default name space .
from django.utils [ django . utils ] import six into default name space .
derive Serializer from the base.Serializer [ base . Serializer ] base class .
internal_use_only is boolean True .
define the method start_serialization with an argument self .
self._current [ self . _current ] is None .
self.objects [ self . objects ] is an empty list .
define the method end_serialization with an argument self .
do nothing .
define the method start_object with arguments self and obj .
self.current [ self . current ] is an empty dictionary .
define the method end_object with arguments self and obj .
call the self.get_dum_object [ self . get_dum_object ] method with an argument obj , use the result as an argument for the self.objects.append [ self . objects . append ] method .
self._current [ self . _current ] is None .
define the method get_dump_object with arguments self and obj .
data is an dictionary with 2 initial entries : return value of the smart_text function with the argument obj._meta [ obj . _meta ] for _STR:0_ ,
and self._current [ self . _current ] for _STR:0_ . if self.use_natural_primary_keys [ self . use_natural_primary_keys ] is false or obj doesnt have a _STR:1_ attribute .
call the smart_text function with 2 arguments : return value of the obj._get_pk_val [ obj . _get_pk_val ] function and string_only set to boolean True ,
substitute it for value under the _STR:0_ key of data dictionary . return data .
define handle_field method with self , obj and field arguments .
call the method field._get_val_from_obj [ field . _get_val_from_obj ] with obj argument , substitute the result for value .
call the function is_protected_type with an argument value , if it evaluates to true ,
substitute value for field.name [ field . name ] key of self._current [ self . _current ] dictionary .
if not ,
call the function field.value_to_string [ field . value_to_string ] with an argument obj , substitute the result for value under the field.name [ field . name ] key of self._current [ self . _current ] dictionary .
define the method handle_fk_field with self , obj and field arguments .
if self.use_natural_foreign_keys [ self . use_natural_foreign_keys ] is true and field.rel.to [ field . rel . to ] has an _STR:0_ attribute .
get field.name [ field . name ] from the obj , substitute it for related .
if related is true ,
call the method related.natural_key [ related . natural_key ] , substitute the result for value .
if not ,
value is None .
if not ,
get return value of the field.get_attname [ field . get_attname ] function attribute of the obj object , substitute it for value .
substitute value for value under the field.name [ field . name ] key of the self._current [ self . _current ] dictionary .
define the method handle_m2m_field with self , obj and field arguments .
if field.rel.through._meta.auto_created [ field . rel . through . _meta . auto_created ] is true ,
if self.use_natural_foreign_keys [ self . use_natural_foreign_keys ] is true and field.rel.to [ field . rel . to ] has an _STR:0_ attribute ,
m2m_value is an lambda function with value as an argument , return value is the result of the method value.natural_key [ value . natural_key ] .
if not ,
m2m_value is a lambda function with an argument value , return value is the result of the function smart_text called with arguments :
return value of the value._get_pk_val [ value . _get_pk_val ] method and strings_only set to boolean True . call the function m2m_value with the argument related , for every related in itterator object generated from the attribute field.name [ field . name ] ,
of the obj object , append the results in a list , substitute it for value under the field.name [ field . name ] key of the self._current [ self . _current ] dictionary . define the method getvalue with an argument self .
return self.objects [ self . objects ] .
define the function Deserializer with arguments object_list and unpacked dictionary options .
remove the value under the _STR:0_ key from the options dictionary , assign it to the db , if the entry doesnt exists ,
substitute DEFAULT_DB_ALIAS for db . remove the value under the _STR:0_ key from the options dictionary , assign it to the ignore , if the entry doesnt exists ,
substitute boolean False for ignore . for every d in object_list ,
try ,
call the function _get_model with an argument value under the _STR:0_ key of the d dictionary , substitute the result for Model .
if base.DeserializationError [ base . DeserializationError ] exception is caught ,
if ignore is true ,
skip this loop iteration ,
if not ,
raise an exception .
data is an empty dictionary ,
if _STR:0_ is contained in d ,
call the method Model._meta.pk.to_python [ Model . _meta . pk . to_python ] with one argument : value under the _STR:0_ key of dictionary d , or None if previous doesnt exists ,
substitute the result for the value under the Model._meta.pk.attname [ Model . _meta . pk . attname ] key of data dictionary . m2m_data is an empty dictionary .
call the method Model._meta.get_all_field_names [ Model . _meta . get_all_field_names ] , substitute the result for model_fields .
for every field_name and field_value in return value of the function six.iteritems [ six . iteritems ] called with value under the _STR:0_ key of dictionary d ,
if ignore is true and field_name is not contained in model_fields ,
skip this loop iteration ,
if field_value is an instance of the str type ,
call the smart_text function with 3 arguments : field_value , value under the _STR:0_ key of the options dictionary or ,
settings.DEFAULT_CHARSET [ settings . DEFAULT_CHARSET ] if the key doesnt exists and strings_only set to boolean True . call the Model._meta.get_field [ Model . _meta . get_field ] method with an argument field_name , substitute the result for field .
if field.rel [ field . rel ] is true , and field.rel [ field . rel ] is an instance of models.ManyToManyRel [ models . ManyToManyRel ] ,
if field.rel.to._default_manager [ field . rel . to . _default_manager ] has an attribute _STR:0_ ,
define the function m2m_convert with an argument value .
if value has an attribute _STR:0_ and value is not an instance of six.text_type [ six . text_type ] ,
call the method field.rel.to._default_manager.db_manager [ field . rel . to . _default_manager . db_manager ] with an argument db on the return value call the method get_by_natural_key ,
with unpacked list value as an argument , return the pk field of the result . if not ,
call the method field.rel.to._meta.pk.to_python [ field . rel . to . _meta . pk . to_python ] with an argument value , use the result as an argument for the call to the ,
smart_text function , return the result . if not ,
m2m_convert is a lambda function with an argument v , return value is the result of the function smart_text called with an argument :
return value of the method field.rel.to._meta.pk.to_python [ field . rel . to . _meta . pk . to_python ] called with an argument v. call the m2m_convert function with pk as argument , for every pk in field_value , substitute the value under the field.name [ field . name ] key of the m2m_data dictionary .
otherwise if field.rel [ field . rel ] is true and field.rel [ field . rel ] is an instance of the models.ManyToOneRel [ models . ManyToOneRel ] object ,
if field_value is not None ,
if field.rel.to._default_manager [ field . rel . to . _default_manager ] has an _STR:0_ attribute ,
if field_value has an attribute _STR:0_ and is not an instance of six.text_type [ six . text_type ] object ,
call the method field.rel.to._default_manager.db_manager [ field . rel . to . _default_manager . db_manager ] with db as argument , call the get_by_natural_key method on the result with ,
unpacked list field_value as an argument , substitute the result for obj . get field.rel.field_name [ field . rel . field_name ] attribute of the object obj , substitute it for value .
if field.rel.to._meta.pk.rel [ field . rel . to . _meta . pk . rel ] is true ,
substitute value.pk [ value . pk ] for value .
if not ,
all the method field.rel.to._meta.get_field [ field . rel . to . _meta . get_field ] with field.rel.field_name [ field . rel . field_name ] as argument , call the to_python method on the result with ,
unpacked list field_value as an argument , substitute the result for value . substitute value for value under the field.attname [ field . attname ] key of the data dictionary .
if not ,
all the method field.rel.to._meta.get_field [ field . rel . to . _meta . get_field ] with field.rel.field_name [ field . rel . field_name ] as argument , call the to_python method on the result with ,
unpacked list field_value as an argument , substitute the result for value of under the field.attname [ field . attname ] key of the data dictionary . if not ,
value under the field.attname [ field . attname ] key of the data dictionary is None .
if not ,
call the field.to_python [ field . to_python ] method with field_value , substitute the result for field.name [ field . name ] key of the data dictionary .
call the method base.build_instance [ base . build_instance ] with arguments Model , data and db , substitute the result for obj .
call the function base.DeserializedObject [ base . DeserializedObject ] with obj and m2m_data as arguments , yield the result as the generator return value .
define the function _get_model with an argument model_identifier .
try ,
call the method apps.get_model [ apps . get_model ] with an argument model_identifier .
if LookupError or TypeError exceptions are caught ,
raise an base.DeserializationError [ base . DeserializationError ] exception with an argument string _STR:0_ , where ' % s ' is replaced with model_identifier .
import module decimal .
import module yaml .
import module sys .
from io import StringIO into default name space .
from django.db [ django . db ] import models into default name space .
from django.core.serializers.base [ django . core . serializers . base ] import DeserializationError into default name space .
from django.core.serializers.python [ django . core . serializers . python ] import Serializer as PythonSerializer into default name space .
from django.core.serializers.python [ django . core . serializers . python ] import Deserializer as PythonDeserializer into default name space .
from django.utils [ django . utils ] import six into default name space .
try ,
from yaml import CSafeLoader as SafeLoader into default name space .
yaml import CSafeDumper as SafeDumper into default name space .
if ImportError exception is caught ,
from yaml import SafeLoader , SafeDumper into default name space .
derive the class DjangoSafeDumper from the SafeDumper base class .
define the method represent_decimal with arguments self and data .
call the method self.represent_scalar [ self . represent_scalar ] with 2 arguments : string _STR:0_ and data converted into a string , return the result .
call the method DjangoSafeDumper.add_representer [ DjangoSafeDumper . add_representer ] with arguments decimal.Decimal [ decimal . Decimal ] and DjangoSafeDumper.represent_decimal [ DjangoSafeDumper . represent_decimal ] .
derive the class Serializer from the PythonSerializer base class .
internal_use_only is a boolean False .
define the method handle_field with arguments self , obj and field .
if field is an instance of models.TimeField [ models . TimeField ] and filed.name [ filed . name ] attribute of obj is not None ,
get field.name [ field . name ] attribute of obj , convert it to a string , substitute it for the value under the filed.name [ filed . name ] key of self._current [ self . _current ] dictionary .
if not ,
call the handle_filed method of the base class of the Serializer class , with arguments obj and field .
define the method end_serialization with an argument self .
call the function yaml.dump [ yaml . dump ] with 4 arguments : self.objects [ self . objects ] , self.stream [ self . stream ] , Dumper=DjangoSafeDumper and unpacked dictionary self.options [ self . options ] .
define the method getvalue with an argument self .
call the getvalue method of the base class of the PythonSerializer class , return the result .
define the function Deserializer with 2 arguments : stream_or_string and unpacked dictionary options .
if stream_or_string is an instance of bytes ,
call the method stream_or_string.decode [ stream_or_string . decode ] with string _STR:0_ as argument , substitute the result for stream_or_string .
if stream_or_string is an instance of the six.string_types [ six . string_types ] ,
call the function StringIO with an argument stream_or_string , substitute the result for stream .
if not ,
substitute stream_or_string for stream .
try ,
for every obj in return value of the PythonDeserializer created with 2 arguments : return value of the function yaml.load [ yaml . load ] ,
with 2 arguments : stream and Loader set to SafeLoader , and unpacked dictionary options , yield one element of the itterable obj .
if exception GeneratorExit is caught ,
raise an exception .
if Exception , renamed to e , exception is caught ,
call the function six.reraise [ six . reraise ] with 3 arguments : DeserializationError , return value of the DeserializationError called with an argument e ,
from __future__ import unicode_literals into default name space .
from django.apps [ django . apps ] import apps into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.core.serializers [ django . core . serializers ] import base into default name space .
from django.db [ django . db ] import models and DEFAULT_DB_ALIAS into default name space .
from django.utils.xmlutils [ django . utils . xmlutils ] import SimplerXMLGenerator into default name space .
from django.utils.encoding [ django . utils . encoding ] import smart_text into default name space .
from xml.dom [ xml . dom ] import pulldom into default name space .
from xml.sax [ xml . sax ] import handler into default name space .
from xml.sax.expatreader [ xml . sax . expatreader ] import ExpatParser as _ExpatParser into default name space .
derive the class Serializer from the base.Serializer [ base . Serializer ] base class .
define the method indent with argument self and level .
if value under the _STR:0_ key of the options dictionary exists and is not None ,
get the value under the _STR:0_ key of the options dictionary , multiply it with level , create a string containing number of whitespaces equal to the previous result , append it to the string containing newline character , use the result as the argument for the call to the self.xml.ignorableWhitespace [ self . xml . ignorableWhitespace ] method .
define the method start_serialization with an argument self .
self.xml [ self . xml ] is a instance of SimplerXMLGenerator class created with 2 arguments : self.stream [ self . stream ] and value under the _STR:0_ key of the
options dictionary , if the key doesnt exists use settings.DEFAULT_CHARSET [ settings . DEFAULT_CHARSET ] instead . call the self.xml.startDocument [ self . xml . startDocument ] method .
call the method self.xml.startElement [ self . xml . startElement ] with 2 arguments , string _STR:0_ and a dictionary containing 1 element : _STR:1_ for _STR:2_ .
define the method end_serialization with an argument self .
call the self.indent [ self . indent ] method with integer 0 as an argument .
call the method self.xml.endElement [ self . xml . endElement ] with an argument string _STR:0_ .
call the self.xml.endDocument [ self . xml . endDocument ] method .
define the method start_object with arguments self and obj .
if _STR:0_ is not an attribute of obj ,
raise an base.SerializationError [ base . SerializationError ] exception with argument string _STR:0_ ,
replace ' % s ' with type of the obj object . call the method self.indent [ self . indent ] with argument integer 1 .
attrs is a dictionary containing 1 entry : return value of the smart_text function with argument obj._meta [ obj . _meta ] for _STR:0_ .
if self.use_natural_primary_keys [ self . use_natural_primary_keys ] is false and obj doesnt have _STR:0_ argument .
substitute return value of the method obj._get_pk_val [ obj . _get_pk_val ] for obj_pk .
if obj_pk is not None ,
substitute the return value of the smart_text function with an argument obj_pk for the value under the _STR:0_ key of the attrs dictionary .
call the method self.xml.startElement [ self . xml . startElement ] with arguments string _STR:0_ and attrs .
define the method end_object with arguments self and obj .
call the method self.indent [ self . indent ] with argument integer 1 .
call the method self.xml.endElement [ self . xml . endElement ] with an argument string _STR:0_ .
define the method handle_field with arguments self , obj and field .
call the method self.indent [ self . indent ] with argument integer 2 .
call the method self.xml.startElement [ self . xml . startElement ] with 2 arguments : string _STR:0_ and a dictionary containing 2 entries : field.name [ field . name ] for _STR:1_ ,
and return value of the field.get_internal_type [ field . get_internal_type ] method for _STR:0_ . if field.name [ field . name ] attribute of obj is not None ,
call the method field.value_to_string [ field . value_to_string ] with an argument obj , use the result as an argument for the call the method self.xml.characters [ self . xml . characters ] .
if not ,
call the method self.xml.addQuickElement [ self . xml . addQuickElement ] with an argument string _STR:0_ .
call the method self.xml.endElement [ self . xml . endElement ] with an argument string _STR:0_
define the method handle_fk_field with arguments self , obj and field .
call the method self._start_relational_field [ self . _start_relational_field ] with an argument field .
evaluate the field.get_attname [ field . get_attname ] , use the result as the name of the obj attribute to get , substitute it for related_att .
if related_att is not None ,
if self.use_natural_foreign_keys [ self . use_natural_foreign_keys ] is true and field.rel.to [ field . rel . to ] has an attribute _STR:0_ ,
get field.name [ field . name ] attribute of the obj , substitute it for related .
call the method related.natural_key [ related . natural_key ] , substitute the result for related .
for every key_value in related ,
call the method self.xml.startElement [ self . xml . startElement ] with arguments string _STR:0_ and an empty dictionary .
call the function smart_text with argument key_value , use the result as an argument for the call to the self.xml.characters [ self . xml . characters ] method .
call the method self.xml.endElement [ self . xml . endElement ] with an argument string _STR:0_
if not ,
call the function smart_text with argument related_att , use the result as an argument for the call to the self.xml.characters [ self . xml . characters ] method .
if not ,
call the method self.xml.addQuickElement [ self . xml . addQuickElement ] with an argument string _STR:0_ .
call the method self.xml.endElement [ self . xml . endElement ] with an argument string _STR:0_ .
define the method handle_m2m_field with arguments self , obj and field .
if field.rel.through._meta.auto_created [ field . rel . through . _meta . auto_created ] is true ,
call the method self._start_relational_field [ self . _start_relational_field ] with the argument field .
if self.use_natural_foreign_keys [ self . use_natural_foreign_keys ] is true and field.rel.to [ field . rel . to ] has an attribute _STR:0_ ,
define the function handle_m2m with an argument value ,
call the value.natural_key [ value . natural_key ] method , substitute the result for natural .
call the method self.xml.startElement [ self . xml . startElement ] with argument string _STR:0_ and an empty dictionary .
for every key_value in natural ,
call the method self.xml.startElement [ self . xml . startElement ] with argument string _STR:0_ and an empty dictionary .
call the function smart_text with argument key_value , use the result as an argument for the call to the self.xml.characters [ self . xml . characters ] method .
call the method self.xml.startElement [ self . xml . startElement ] with an argument string _STR:0_ .
call the method self.xml.startElement [ self . xml . startElement ] with an argument string _STR:0_ .
if not ,
define the function handle_m2m with an argument value ,
call the self.xml.addQuickElement [ self . xml . addQuickElement ] method with 2 arguments : string _STR:0_ and attr dictionary containing 1 entry :
return value of the function smart_text with return value of the method value._get_pk_val [ value . _get_pk_val ] as an argument for _STR:0_ . for every relobj in iterator generated from the field.name [ field . name ] attribute of the obj object .
call the function handle_m2m with an argument relobj .
call the method self.xml.endElement [ self . xml . endElement ] with an argument string _STR:0_ .
define the method _start_relational_field with arguments self and field .
call the method self.indent [ self . indent ] with argument integer 2 .
call the method self.xml.startElement [ self . xml . startElement ] with 2 arguments : string _STR:0_ and dictionary containing 3 entries : field.name [ field . name ] for _STR:1_ ,
field.rel.__class__.__name__ [ field . rel . __class__ . __name__ ] for _STR:0_ and return value of the function smart_text with an argument field.rel.to._meta [ field . rel . to . _meta ] for _STR:1_ . derive the class Deserializer from the base.Deserializer [ base . Deserializer ] base class .
define the method __init__ with 3 arguments : self , stream_or_string and unpacked dictionary options .
call the method __init__ from the base class of the Deserializer class with arguments stream_or_string and unpacked dictionary options .
call the method pulldom.parse [ pulldom . parse ] with arguments : self.stream [ self . stream ] and return value of the method self._make_parser [ self . _make_parser ] ,
substitute the result for self.event_stream [ self . event_stream ] . remove the _STR:0_ key from the options dictionary , substitute the return value for self.db [ self . db ] , if the key doesnt exists substitute
DEFAULT_DB_ALIAS for self.db [ self . db ] . remove the _STR:0_ key from the options dictionary , substitute the return value for self.db [ self . db ] ,
if the key doesnt exists substitute boolean False for self.ignore [ self . ignore ] . define the method _make_parser with an argument self .
return the instance of DefusedExpatParser class .
define the method __next__ with an argument self .
for every event and node in self.event_stream [ self . event_stream ] ,
if event equals a string _STR:0_ and node.nodeName [ node . nodeName ] equals a string _STR:1_ ,
call the method self.event_stream.expandNode [ self . event_stream . expandNode ] with an argument node .
call the method self._handle_object [ self . _handle_object ] with an argument node , return the result .
raise an StopIteration exception .
define the method _handle_object with arguments self and node .
call the method self._get_model_from_node [ self . _get_model_from_node ] with arguments node and string _STR:0_ .
data is an empty dictionary .
call the method node.hasAttribute [ node . hasAttribute ] with string _STR:0_ as an argument , if it evaluates to true ,
call the method node.getAttribute [ node . getAttribute ] with an argument string _STR:0_ , use the result as the argument for the call to the method , Model._meta.pk.to_python [ Model . _meta . pk . to_python ] with , substitute the result for value under the Model._meta.pk.attname [ Model . _meta . pk . attname ] key of the data dictionary .
m2m_data is an empty dictionary .
call the method Model._meta.get_all_field_names [ Model . _meta . get_all_field_names ] , substitute the result for model_fields .
for every field_node in return value of the method node.getElementsByTagName [ node . getElementsByTagName ] with an argument string _STR:0_ .
call the method field_node.getAttribute [ field_node . getAttribute ] with an argument string _STR:0_ , substitute the result for field_name .
if field_name is false ,
raise an base.DeserializationError [ base . DeserializationError ] exception with string _STR:0_ as argument .
if self.ignore [ self . ignore ] is true and field_name is not contained in model_fields ,
skip this loop iteration .
call the method Model._meta.get_field [ Model . _meta . get_field ] with an argument field_name , substitute it for field .
if field.rel [ field . rel ] is true and field.rel [ field . rel ] is an instance of models.ManyToManyRel [ models . ManyToManyRel ] ,
call the method self._handle_m2m_field_node [ self . _handle_m2m_field_node ] with an argument field_node and field , substitute the result for value under the field.name [ field . name ] key of m2m_data dictionary .
otherwise , if field.rel [ field . rel ] is true and field.rel [ field . rel ] is an instance of models.ManyToOneRel [ models . ManyToOneRel ] ,
call the method self._handle_fk_field_node [ self . _handle_fk_field_node ] with field_node and field as arguments , substitute the result for the value under the
field.attname [ field . attname ] of the data dictionary . if not ,
call the method field_node.getElementsByTagName [ field_node . getElementsByTagName ] with an argument string _STR:0_ , if it evaluates to true ,
value is None .
if not ,
call the function getInnerText with argument field_node , on the result call the method strip , use the result as an argument for the
call to the field.to_python [ field . to_python ] method , substitute the result for value . substitute value for value under the field.name [ field . name ] key of the data dictionary .
call the method base.build_instance [ base . build_instance ] with arguments Model , data and self.db [ self . db ] , substitute the result for obj .
call the method base.DeserializedObject [ base . DeserializedObject ] with arguments obj and m2m_data , return the result .
define the method _handle_fk_field_node with arguments self , node and field .
call the method node.getElementsByTagName [ node . getElementsByTagName ] with an argument string _STR:0_ , if it evaluates to true ,
return None .
if not ,
if field.rel.to._default_manager [ field . rel . to . _default_manager ] has an atttribute _STR:0_ ,
call the method node.getElementsByTagName [ node . getElementsByTagName ] with the argument string _STR:0_ , substitute the result for keys .
if keys is true ,
call the function getInnerText with argument k , on the result call the method strip , for every k in keys , append the results to field_value list .
call the method field.rel.to._default_manager.db_manager [ field . rel . to . _default_manager . db_manager ] with an argument self.db [ self . db ] , on the result call the method get_by_natural_key ,
with unpacked list field_value as an argument , substitute the result for obj . get the field.rel.field_name [ field . rel . field_name ] from the obj , substitute it for obj_pk .
if field.rel.to._meta.pk.rel [ field . rel . to . _meta . pk . rel ] is true ,
substitute obj_pk.pk [ obj_pk . pk ] for obj_pk .
if not ,
call the function getInnerText with an argument node , call the strip method on the result , substitute the result for field_value .
call the field.rel.to._meta.get_field [ field . rel . to . _meta . get_field ] method with an field.rel.field_name [ field . rel . field_name ] argument , on the result call the method to_python ,
with field_value as an argument , substitute the result for obj_pk . return obj_pk .
if not ,
call the function getInnerText with an argument node , call the strip method on the result , substitute the result for field_value .
call the field.rel.to._meta.get_field [ field . rel . to . _meta . get_field ] method with an field.rel.field_name [ field . rel . field_name ] argument , on the result call the method to_python ,
with field_value as an argument , return the result . define the method _handle_m2m_field_node with arguments self , node and field .
if field.rel.to._default_manager [ field . rel . to . _default_manager ] has an attribute _STR:0_ ,
define the function m2m_convert with an argument n ,
call the method n.getElementsByTagName [ n . getElementsByTagName ] with string _STR:0_ as argument , substitute result for keys .
if keys is true ,
call the function getInnerText with argument k , on the result call the method strip , for every k in keys , append the results to field_value list .
call the method field.rel.to._default_manager.db_manager [ field . rel . to . _default_manager . db_manager ] with an argument self.db [ self . db ] , on the result call the method get_by_natural_key ,
with unpacked list field_value as an argument , substitute the field pk of the result for obj_pk . if not ,
call the method n.getAttribute [ n . getAttribute ] with string _STR:0_ as argument , use the result as an argument for the call to the field.rel.to._meta.pk.to_python [ field . rel . to . _meta . pk . to_python ] method , substitute the result for obj_pk .
return obj_pk .
if not ,
m2m_convert is an lambda function with an argument n , return value is the return value of the method field.rel.to._meta.pk.to_python [ field . rel . to . _meta . pk . to_python ] ,
called with n.getAttribute [ n . getAttribute ] ( _STR:0_ ) method . call the m2m_convert function with an argument c , for every c in return value of the method node.getElementsByTagName [ node . getElementsByTagName ] ,
with an argument string _STR:0_ , return the result . define the method _get_model_from_node with arguments self , node and attr .
call the method node.getAttribute [ node . getAttribute ] with an argument attr , substitute the result for model_identifier .
if model_identifier is false ,
raise an base.DeserializationError [ base . DeserializationError ] exception with an argument string _STR:0_ ,
where ' % s ' is replaced with node.nodeName [ node . nodeName ] and attr . try ,
call the method apps.get_model [ apps . get_model ] with an argument model_identifier , return the result .
if LookupError or TypeError exceptions are caught ,
raise an base.DeserializationError [ base . DeserializationError ] exception with an argument string _STR:0_ ,
where ' % s ' is replaced with node.nodeName [ node . nodeName ] and attr . define the function getInnerText with an argument node .
inner_text is an empty list .
for every child in node.childNodes [ node . childNodes ] ,
if child.nodeType [ child . nodeType ] equals to child.TEXT_NODE [ child . TEXT_NODE ] or child.nodeType [ child . nodeType ] equals to child.CDATA_SECTION_NODE [ child . CDATA_SECTION_NODE ] ,
append child.data [ child . data ] to the inner_text list .
otherwise if child.nodeType [ child . nodeType ] equals to child.ELEMENT_NODE [ child . ELEMENT_NODE ] ,
call the function getInnerText with an argument child , use the result as an argument for the call to the method inner_text.extend [ inner_text . extend ] .
if not ,
do nothing .
join inner_text elements into a string .
derive the class DefusedExpatParser from the _ExpatParser base class .
define the method __init__ with arguments self , unpacked list args and unpacked dictionary kwargs .
call the method _ExpatParser.__init__ [ _ExpatParser . __init__ ] with arguments self , unpacked list args and unpacked dictionary kwargs .
call the method self.setFeature [ self . setFeature ] with 2 arguments : handler.feature_external_ges [ handler . feature_external_ges ] and boolean False .
call the method self.setFeature [ self . setFeature ] with 2 arguments : handler.feature_external_pes [ handler . feature_external_pes ] and boolean False .
define the method start_doctype_decl with an arguments self , name , sysid , pubid and has_internal_subset .
raise an DTDForbidden exception with arguments name , sysid and pubid .
define the method entity_decl with arguments self , name , is_parameter_entity , value , base , sysid , pubid and notation_name .
raise an EntitiesForbidden exception with arguments name , value , base , sysid , pubid and notation_name .
define the method unparsed_entity_decl with arguments self , name , base , sysid , pubid and notation_name .
raise an EntitiesForbidden exception with arguments name , None , base , sysid , pubid and notation_name .
define the method external_entity_ref_handler with arguments self , context , base , sysid and pubid .
raise an ExternalReferenceForbidden exception with arguments context , base , sysid and pubid .
define the method reset with an argument self .
call the method _ExpatParser.reset [ _ExpatParser . reset ] with an argumen sefl .
substitute self._parser [ self . _parser ] for parser .
substitute self.start_doctype_decl [ self . start_doctype_decl ] for parser.StartDoctypeDeclHandler [ parser . StartDoctypeDeclHandler ] .
substitute self.entity_decl [ self . entity_decl ] for parser.EntityDeclHandler [ parser . EntityDeclHandler ] .
substitute self.unparsed_entity_decl [ self . unparsed_entity_decl ] for parser.UnparsedEntityDeclHandler [ parser . UnparsedEntityDeclHandler ] .
substitute self.external_entity_ref_handler [ self . external_entity_ref_handler ] for parser.ExternalEntityRefHandler [ parser . ExternalEntityRefHandler ] .
derive the class DefusedXmlException from the ValueError base class .
define the method __repr__ with an argument self .
convert self into a string and return it .
derive the class DTDForbidden from the DefusedXmlException base class .
define the method __init__ with arguments self , name , sysid and pubid .
call the method __init__ from the base class of the DTDForbidden class .
substitute name for self.name [ self . name ] .
substitute sysid for self.sysid [ self . sysid ] .
substitute pubid for self.pubid [ self . pubid ] .
define the method __str__ with an argument self .
tpl is an string _STR:0_ .
call the method tpl.format [ tpl . format ] with an arguments self.name [ self . name ] , self.sysid [ self . sysid ] and self.pubid [ self . pubid ] .
derive the class EntitiesForbidden from the DefusedXmlException base class .
define the method __init__ with arguments self , name , value , base , sysid , pubid and notation_name .
call the method __init__ from the base class of the EntitiesForbidden class .
substitute name for self.name [ self . name ] .
substitute value for self.value [ self . value ] .
substitute base for self.base [ self . base ] .
substitute sysid for self.sysid [ self . sysid ] .
substitute pubid for self.pubid [ self . pubid ] .
substitute notation_name for self.notation_name [ self . notation_name ] .
define the method __str__ with an argument self .
tpl is an string _STR:0_ .
call the method tpl.format [ tpl . format ] with an arguments self.name [ self . name ] , self.sysid [ self . sysid ] and self.pubid [ self . pubid ] .
derive the class ExternalReferenceForbidden from the DefusedXmlException base class .
define the method __init__ with arguments self , context , base , sysid and pubid .
call the method __init__ from the base class of the ExternalReferenceForbidden class .
substitute context for self.context [ self . context ] .
substitute base for self.base [ self . base ] .
substitute sysid for self.sysid [ self . sysid ] .
substitute pubid for self.pubid [ self . pubid ] .
define the method __str__ with an argument self .
tpl is an string _STR:0_ .
call the method tpl.format [ tpl . format ] with an arguments self.sysid [ self . sysid ] and self.pubid [ self . pubid ] .
from __future__ import unicode_literals into default name space .
import module socket .
import module sys .
from wsgiref import simple_server into default name space .
from wsgiref.util [ wsgiref . util ] import FileWrapper
from django.core.exceptions [ django . core . exceptions ] import ImproperlyConfigured into default name space .
from django.core.management.color [ django . core . management . color ] import color_style into default name space .
from django.core.wsgi [ django . core . wsgi ] import get_wsgi_application into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.module_loading [ django . utils . module_loading ] import import_string into default name space .
from django.utils.six.moves [ django . utils . six . moves ] import socketserver into default name space .
__all__ is a tuple containing 2 initial elements : strigs _STR:0_ and _STR:1_ .
define the funtion get_internal_wsgi_application .
from django.conf [ django . conf ] import settings into default name space .
get _STR:0_ attribute from the settings , substitute it for app_path .
if app_path is None ,
call the function get_wsgi_application , return the result .
try ,
call the import_string with app_path as an argument , return the result .
if ImportError , rename it to e , exception is caught ,
msg is a tuple containing one initial entry : a string _STR:0_ , where _STR:1_ is replaced by app_path and _STR:2_ is replaced by e .
call the function six.reraise [ six . reraise ] with 3 arguments : ImproperlyConfigured , ImproperlyConfigured ( msg ) and third element of return value of the function sys.exc_info [ sys . exc_info ] .
derive the class WSGIServer from simple_server.WSGIServer [ simple_server . WSGIServer ] and object base classes .
request_queue_size is integer 10 .
define the __init__ method with 3 arguments : self , unpacked list args and unpacked dictionary **kwargs .
pop value under the _STR:0_ key of the kwargs dictionary , if it is true ,
substitute socket.AF_INET6 [ socket . AF_INET6 ] for self.address_family [ self . address_family ] .
call the __init__ method from the base class of the WSGIServer class , with 2 arguments : unpacked list args and unpacked dictionary kwargs .
define the function server_bind with an argument self .
call the server_bind method from the base class of the WSGIServer class .
call the self.setup_environ [ self . setup_environ ] method .
derive the class WSGIRequestHandler from simple_server.WSGIRequestHandler [ simple_server . WSGIRequestHandler ] and object base classes .
define the __init__ method with 3 arguments : self , unpacked list args and unpacked dictionary **kwargs .
call the color_style method , substitute the result for self.style [ self . style ] .
call the __init__ method from the base class of the WSGIRequestHandler class , with 2 arguments : unpacked list args and unpacked dictionary kwargs .
define the function address_string with an argument self .
return the first element of self.client_address [ self . client_address ] .
define the function server_bind with an argument self .
msg is a string _STR:0_ , where ' % s ' are replaced with return value of the method self.log_date_time_string [ self . log_date_time_string ] and formated args .
if first element of the second row of args equals a string _STR:0_ ,
call the self.style.HTTP_SUCCESS [ self . style . HTTP_SUCCESS ] with an argument msg , substitute it for msg .
otherwise if first element of second row of args equals a string _STR:0_ ,
call the self.style.HTTP_INFO [ self . style . HTTP_INFO ] with an argument msg , substitute it for msg .
otherwise if second element of args equals a string _STR:0_ ,
call the self.style.HTTP_NOT_MODIFIED [ self . style . HTTP_NOT_MODIFIED ] with an argument msg , substitute it for msg .
otherwise if first element of second row of args equals a string _STR:0_ ,
call the self.style.HTTP_REDIRECT [ self . style . HTTP_REDIRECT ] with an argument msg , substitute it for msg .
otherwise if second element of args equals a string _STR:0_ ,
call the self.style.HTTP_NOT_FOUND [ self . style . HTTP_NOT_FOUND ] with an argument msg , substitute it for msg .
otherwise if first element of second row of args equals a string _STR:0_ ,
call the self.style.HTTP_BAD_REQUEST [ self . style . HTTP_BAD_REQUEST ] with an argument msg , substitute it for msg .
if not ,
call the self.style.HTTP_SERVER_ERROR [ self . style . HTTP_SERVER_ERROR ] with an argument msg , substitute it for msg .
call the sys.stderr.write [ sys . stderr . write ] function with an argument msg .
define the function run with 5 arguments : addr , port , wsgi_handler , ipv6 set to boolean False and threading set to boolean False .
server_address is a tuple containing 2 initial elements : addr and port .
if threading is true ,
call the function type with 3 arguments : string _STR:0_ , tuple containing 2 elements : socketserver.ThreadingMixIn [ socketserver . ThreadingMixIn ] and WSGIServer ,
and an empty dictionary , substitute the result for httpd_cls . if not ,
substitute WSGIServer for httpd_cls .
call the httpd_cls function with 4 arguments : server_address , WSGIRequestHandler and ipv6 set to ipv6 , substitute the result for httpd .
if threading is true ,
httpd.daemon_threads [ httpd . daemon_threads ] is boolean True .
call the method httpd.set_app [ httpd . set_app ] with an argument wsgi_handler .
call the method httpd.serve_forever [ httpd . serve_forever ] .
import module importlib .
import module os .
import module sys .
__version__ is a string _STR:0_ .
__all__ is a list containing a string _STR:0_ .
FASTCGI_OPTIONS is a dictionary containing 16 initial entries : _STR:0_ for _STR:1_ , None for _STR:2_ , None for _STR:3_ ,
define the method fastcgi_help with an argument message set to None .
print FASTCGI_HELP to the standard output .
if message is true ,
print message to the standard output .
return boolean False .
define the function runfastcgi with 2 arguments : argset set to an empty list and unpacked dictionary kwargs .
call the method FASTCGI_OPTIONS.copy [ FASTCGI_OPTIONS . copy ] , substitute the result for options .
call the options.update [ options . update ] method with an argument kwargs .
for every x in argset ,
if character _STR:0_ is contained in x ,
call the x.split [ x . split ] method with arguments : character _STR:0_ and integer 1 , store the result in k and v , respectively .
if not ,
substitute x for k and boolean True for v .
substitute v for value under the k converted to lower case key of options dictionary .
if string _STR:0_ is contained in options ,
call the fastcgi_help function , return the result .
try ,
import flup
if ImportError , renamed to e , exception is caught ,
call the method sys.stderr.write [ sys . stderr . write ] with an argument string _STR:0_ , where ' % s ' is replaced by e .
call the method sys.stderr.write [ sys . stderr . write ] with an argument string _STR:0_ .
call the method sys.stderr.write [ sys . stderr . write ] with an argument string _STR:0_ .
call the method sys.stderr.write [ sys . stderr . write ] with an argument string _STR:0_ .
call the method sys.stderr.write [ sys . stderr . write ] with an argument string _STR:0_ .
return boolean False .
append value under the _STR:0_ key of the options dictionary to the string _STR:1_ , substitute it for flup_module .
if value under the _STR:0_ key of the options dictionary equals to string _STR:1_ or _STR:2_ ,
wsgi_opts is a dictionary with 4 initial entries : value under the key _STR:0_ of options dictionary converted to an integer ,
for _STR:0_ , value under the key _STR:1_ of options dictionary converted to an integer for _STR:2_ , value under the key _STR:3_ of options dictionary converted to an integer , for _STR:4_ , and value under the key _STR:5_ of options dictionary converted to an integer , for _STR:6_ . append string _STR:7_ to flup_module .
otherwise if value under the _STR:0_ key of optins dictionary equals to string _STR:1_ or _STR:2_ ,
wsgi_opts is a dictionary with 4 initial entries : value under the key _STR:0_ of options dictionary converted to an integer ,
for _STR:0_ , value under the key _STR:1_ of options dictionary converted to an integer for _STR:2_ , and value under the key _STR:3_ of options dictionary converted to an integer , for _STR:4_ . if not ,
call the function fastcgi_help with an argument string _STR:0_ , return the result .
if value under the _STR:0_ key of options dictionary is not None , substitute it for value under the _STR:0_ key of wsgi_opts dictionary .
try ,
call the function importlib.import_module [ importlib . import_module ] with 2 arguments : flup_module converted to string and appended to _STR:0_ character , and string _STR:1_ , substitute the result for module .
substitute module.WSGIServer [ module . WSGIServer ] for WSGIServer .
if Exception exception is caught ,
append flup_module to string _STR:0_ , print it to the standard output .
return boolean False .
from django.core.servers.basehttp [ django . core . servers . basehttp ] import get_internal_wsgi_application into default name space .
if value under the _STR:0_ key of the options dictionary is false and values under the _STR:1_ and _STR:2_ keys of the options dictionary are true ,
set the value under the _STR:0_ key of the wsgi_opts dictionary to a tuple containing 2 elements : value under the _STR:1_ key ,
of the options dictionary and value under the _STR:0_ key of the options dictionary converted into an integer . if value under the _STR:1_ key of the options dictionary is true and values under the _STR:2_ and _STR:0_ keys of the options dictionary are false ,
substitute the value under the _STR:0_ key of options dictionary for value under the _STR:1_ key of wsgi_opts dictionary .
if values under the _STR:0_ , _STR:1_ and _STR:2_ keys of the options dictionary are false ,
set value under the _STR:0_ key of wsgi_opts to None .
if not ,
call the fastcgi_help function with an argument string _STR:0_ , return it .
if value under the _STR:0_ of options dictionary is None ,
if the value under the _STR:0_ key of the wsgi_opts dictionary is not None , set daemonize to boolean True , if not , set it to boolean False .
if not ,
convert the value under the _STR:0_ key of options dictionary to lowercase , if it equals to string _STR:1_ , _STR:2_ or _STR:3_ ,
daemonize is boolean True .
convert the value under the _STR:0_ key of options dictionary to lowercase , if it equals to string _STR:1_ , _STR:2_ or _STR:3_ ,
daemonize is boolean False .
if not ,
call the fastcgi_help function with an argument string _STR:0_ , return it .
daemon_kwargs is an empty dictionary .
if value under the _STR:0_ key of options dictionary is true ,
substitute the value under the _STR:0_ key of options dictionary for value under the _STR:1_ key of daemon_kwargs dictionary .
if value under the _STR:0_ key of options dictionary is true ,
substitute the value under the _STR:0_ key of options dictionary for value under the _STR:1_ key of daemon_kwargs dictionary .
if value under the _STR:0_ key of options dictionary is true ,
convert the value under the _STR:0_ key of options dictionary into an integer of base 8 , substitute it for value under the _STR:0_ key of daemon_kwargs dictionary .
if daemonize is true ,
from django.utils.daemonize [ django . utils . daemonize ] import become_daemon into default name space .
call the function become_daemon with 2 arguments : our_home_dir set to the value under the _STR:0_ key of options dictionary and ,
unpacked dictionary daemon_kwargs . if value under the _STR:0_ of options dictionary exists ,
open the file whose name is stored in the value under the _STR:0_ key of options dictionary and mode _STR:1_ , with the file descriptor as fp ,
call the method fp.write [ fp . write ] with an argument string _STR:0_ % d ' replaced by os.getpid [ os . getpid ] function return value .
create the object WSGIServer with 2 arguments : get_internal_wsgi_application return value and unpacked dictionary wsgi_opts , call the method run on it .
if __name__ equals a string _STR:0_ .
call the function runfastcgi with an argument all the elements , except the first from the sys.argv [ sys . argv ] list .
from django.dispatch [ django . dispatch ] import Signal into default name space .
request_started is a instance of a Signal class .
request_finished is a instance of a Signal class .
got_request_exception is a instance of a Signal class , created with an argument providing_args as the list containing string _STR:0_ .
from __future__ import unicode_literals into default name space .
import module base64 .
import module json .
import module time .
import module zlib .
from django.conf [ django . conf ] import settings into default name space .
from django.utils [ django . utils ] import baseconv into default name space .
from django.utils.crypto [ django . utils . crypto ] import constant_time_compare and salted_hmac into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_bytes , force_str and force_text into default name space .
from django.utils.module_loading [ django . utils . module_loading ] import import_string into default name space .
derive the class BadSignature from the Exception base class .
do nothing .
derive the class SignatureExpired from the BadSignature base class .
do nothing .
define the function b64_encode with an argument s .
call the method base64.urlsafe_b64encode [ base64 . urlsafe_b64encode ] with an argument s , on the result call the strip function with _STR:0_ as the argument , return the result .
define the function b64_decode with an argument s .
calculate negative length of s , by modulus integer 4 , use the result as the number of _STR:0_ characters to be stored in pad .
call the method base64.urlsafe_b64decode [ base64 . urlsafe_b64decode ] with sum of s and pad as argument .
define the function b64_hmac with arguments salt , value and key .
call the salted_hmac with 3 arguments : salt , value and key , call the digest method on the result ,
use the result as an argument for the call to the b64_encode function , return the result . define the function get_cookie_signer with an argument salt set to string _STR:0_ .
call the import_string function with an argument settings.SIGNING_BACKEND [ settings . SIGNING_BACKEND ] , substitute the result for Signer .
call the force_bytes function with an argument settings.SECRET_KEY [ settings . SECRET_KEY ] , substitute the result for key .
create the Singer class with 2 arguments : key appended to string _STR:0_ and salt set to salt , return it .
derive the class JSONSerializer from the object base class .
define the method dumps with arguments self and obj .
call the json.dumps [ json . dumps ] function with 2 arguments : obj and separators set to tuple containing _STR:0_ and _STR:1_ characters ,
call the encode method on the result with string _STR:0_ as an argument , return the result . define the method loads with arguments self and data .
call the data.decode [ data . decode ] method with a string _STR:0_ as an argument , use the result as an argument for the call to the json.load [ json . load ] function , return the result .
define the function dumps with 5 arguments : obj , key set to None , salt set to string _STR:0_ ,
call the serializer function , call the dumps method on the result with an argument obj , substitute result for data .
is_compressed is boolean False .
if compress is true ,
call the function zlib.compress [ zlib . compress ] with an argument data , substitute the result for compressed .
if length of compressed is lesser than length of data decremented by 1 ,
substitute compressed for data .
is_compressed is boolean True .
call the b64_encode function with an argument data , substitute the result for base64d .
if is_compressed is true ,
prefix the base64d with a _STR:0_ character .
instantiate the TimestampSigner object with arguments key and salt set to salt , call its method sign with an argument base64 , return it .
define the function loads with 5 arguments : s , key set to None , salt set to string _STR:0_ ,
instantiate TimestampSigner object with arguments key and salt set to salt , call its method unsign with arguments :
s and max_age set to max_age , use it as an argument for the force_bytes function , substitute the result for base64d . decompress is boolean False .
if first element of base64d equals to a _STR:0_ character ,
substitute first element of base64d for base64d .
decompress is boolean True .
call the method b64_decode with an argument base64 , substitute the result for data .
if decompress is true ,
call the function zlib.decompress [ zlib . decompress ] with an argument data , substitute the result for data .
call the serializer function , call the loads method on the return value with an argument data , return the result .
derive the class Signer from the object base class .
define the method __init__ with 4 arguments : self , key set to None , sep set to _STR:0_ and salt set to None .
call the function force_str with an argument sep , substitute the result for self.sep [ self . sep ] .
if key exists , substitute it for self.key [ self . key ] , if not substitute settings.SECRET_KEY [ settings . SECRET_KEY ] for key .
call the force_str function with an argument : salt , if it exists , if not with a string _STR:0_ , with ' % s ' replaced by ,
self.__class__.__module__ [ self . __class__ . __module__ ] and self.__class__.__name__ [ self . __class__ . __name__ ] , respectively , substitute the result for self.salt [ self . salt ] . define the method signature with arguments self and value .
call the function base64_hmac with 3 arguments : string _STR:0_ appended to self.salt [ self . salt ] , value and self.key [ self . key ] , substitute the result for signature .
call the function force_str with an argument signature , return the result .
define the method sign with arguments self and value .
call the function force_str with an argument value , substitute the result for value .
convert value , self.sep [ self . sep ] and return value of a method self.signature [ self . signature ] called with an argument value , concatenate them together , return the result .
define the method unsign with arguments self and signed_value .
call the function signed_value with an argument value , substitute the result for signed_value .
if self.sep [ self . sep ] is not contained in signed_value ,
raise an BadSignature exception with an argument string _STR:0_ , where ' % s ' is replaced by self.sep [ self . sep ] .
call the signed_value.rsplit [ signed_value . rsplit ] method with arguments self.sep [ self . sep ] and integer 1 , substitute the result for value and sig , respectively .
call the function constant_time_compare with 2 arguments : sig and return value of the self.signature [ self . signature ] method with an argument value , if it evaluates to true ,
call the force_text function with an argument value , return the result .
raise an BadSignature exception with an argument string _STR:0_ , where ' % s ' is replaced by sig .
derive the class TimestampSigner from the Signer base class .
define the method timestamp with an argument self .
call the method baseconv.base62.encode [ baseconv . base62 . encode ] with result of the time.time [ time . time ] function converted to an integer , as an argument , return the result .
define the method sign with arguments self and value .
call the force_str function with an argument value , substitute the result for value .
convert value , self.sep [ self . sep ] and return value of the function timestamp , concatenate them , substitute the result for value .
call the sign method from the base class of the TimestampSigner class with an argument value , return the result
define the method unsign with arguments self , value and max_age set to None .
call the unsign method from the base class of the TimestampSigner class with an argument value , substitute the result for result .
call the result.rsplit [ result . rsplit ] method with arguments self.sep [ self . sep ] and integer 1 , substitute the result for value and timestamp , respectively .
call the baseconv.base62.decode [ baseconv . base62 . decode ] method with an argument timestamp , substitute the result for timestamp .
if max_age is not None ,
subtract timestamp from the return value of the function time.time [ time . time ] , substitute the result for age .
if age is greater than max_age ,
raise an SignatureExpired exception with an argument string _STR:0_ , where ' % s ' is replaced by age and max_age , respectively .
return value .
from __future__ import unicode_literals into default name space .
import module functools .
from importlib import import_module into default name space .
import module re .
from threading import local into default name space .
import module warnings .
from django.http [ django . http ] import Http404 into default name space .
from django.core.exceptions [ django . core . exceptions ] import ImproperlyConfigured and ViewDoesNotExist into default name space .
from django.utils.datastructures [ django . utils . datastructures ] import MultiValueDict into default name space .
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango20Warning into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_str , force_text and iri_to_uri into default name space .
from django.utils.functional [ django . utils . functional ] import lazy into default name space .
from django.utils.http [ django . utils . http ] import urlquote into default name space .
from django.utils.module_loading [ django . utils . module_loading ] import module_has_submodule into default name space .
from django.utils.regex_helper [ django . utils . regex_helper ] import normalize into default name space .
from django.utils [ django . utils ] import six and lru_cache into default name space .
from django.utils.translation [ django . utils . translation ] import get_language into default name space .
call the function local , substitute the result for _prefixes .
call the function local , substitute the result _urlconf .
derive the class ResolverMatch with object as base class .
define the __init__ method with 7 arguments : self , func , args , kwargs , url_name set to None , app_name set to None and namespaces set to None .
substitute func for self.func [ self . func ] .
substitute args for self.args [ self . args ] .
substitute kwargs for self.kwargs [ self . kwargs ] .
substitute url_name for self.url_name [ self . url_name ] .
substitute app_name for self.app_name [ self . app_name ] .
if namespaces is true ,
append x to self.namespaces [ self . namespaces ] list for every x in namespaces , only if x is true .
if not ,
self.namespaces [ self . namespaces ] is an empty list .
join self.namespaces [ self . namespaces ] into a string separated with character _STR:0_ , substitute it for self.namespace [ self . namespace ] .
if func doesnt have a attribute _STR:0_ ,
join func.__class__.__module__ [ func . __class__ . __module__ ] and func.__class__.__name__ [ func . __class__ . __name__ ] into a string , separated by character _STR:0_ , substitute it for self._func_path [ self . _func_path ] .
if not ,
join func.__module__ [ func . __module__ ] and func.__name__ [ func . __name__ ] into a string , separated by character _STR:0_ , substitute it for self._func_path [ self . _func_path ] .
if url_name exists substitute it for view_path , if not substitute .self._func_path for view_path .
append list containing view_path to self.namespaces [ self . namespaces ] list , join all the elements into a string separated by character _STR:0_ ,
substitute it for self.view_name [ self . view_name ] . define the method __getitem__ with arguments self and index .
return the element at the index index of the tuple containing 3 elements : self.func [ self . func ] , self.args [ self . args ] and self.kwargs [ self . kwargs ] .
define the method __repr__ with an argument self .
in the string _STR:0_ , replace all the occurrences of :
string ' % s ' with self._func_path [ self . _func_path ] , self.args [ self . args ] , self.kwargs [ self . kwargs ] , self.url_name [ self . url_name ] , self.app_name [ self . app_name ] and self.namespaces [ self . namespaces ] , respectively . derive the class Resolver404 with Http404 as base class .
do nothing .
derive the class NoReverseMatch with Exception as base class .
do nothing .
method lru_cache.lru_cache [ lru_cache . lru_cache ] with an argument maxsize set to None , as a decorator ,
define the function get_callable with arguments lookup_view and can_fail set to boolean False .
if lookup_view is a callable object ,
return lookup_view .
call the function get_mod_func with an argument lookup_view , store the result in mod_name and func_name , respectively .
if func_name is false ,
if can_fail is true ,
return lookup_view .
if not ,
raise an ImportError exception with an argument string _STR:0_ ,
where ' % s ' is replaced by lookup_view . try ,
call the function import_module with an argument mod_name .
if ImportError exception is caught .
if can_fail is true ,
return lookup_view
if not ,
call the function get_mod_func with an argument mod_name , store the result in parentmod and submod , respectively .
if submod is true and return value of the function module_has_submodule called with 2 arguments : result of the function :
import_module called with an argument parentmod and submod , evaluates to false . raise an ViewDoesNotExist exception with an argument string _STR:0_ ,
where string ' % s ' is replaced by lookup_view and mod_name , respectively . if not ,
raise an exception .
if not ,
try ,
get func_name attribute from the mod object , substitute it for view_func .
if AttributeError exception is caught .
if can fail is true ,
return lookup_view
if not ,
raise an ViewDoesNotExist exception with an argument string _STR:0_ ,
where string ' % s ' is replaced by lookup_view and mod_name , respectively . if not ,
if view_function is not a callable function ,
raise an ViewDoesNotExist exception with an argument string _STR:0_ ,
where string ' % s ' is replaced by mod_name and func_name , respectively . return view_func .
method lru_cache.lru_cache [ lru_cache . lru_cache ] with an argument maxsize set to None , as a decorator ,
define the function get_resolver with an argument urlconf .
if urlconf is None ,
from django.conf [ django . conf ] import settings into default name space .
substitute settings.ROOT_URLCONF [ settings . ROOT_URLCONF ] for urlconf .
return an instance of a class RegexURLResolver created with arguments : raw string _STR:0_ and urlconf .
method lru_cache.lru_cache [ lru_cache . lru_cache ] with an argument maxsize set to None , as a decorator ,
define the function get_ns_resolver with arguments ns_pattern and resolver .
ns_resolver is class instance of a class RegexURLResolver , created with 2 arguments : ns_pattern and resolver.url_patterns [ resolver . url_patterns ] .
return an instance of a class RegexURLResolver created with arguments : raw string _STR:0_ and a list containing an element ns_resolver .
define the function get_mod_func with an argument callback .
try ,
call the method callback.rindex [ callback . rindex ] with an argument character _STR:0_ , substitute the result for dot .
if ValueError exception is caught ,
return callback and a empty string .
return callback split into two lists at the dot index , without the element at the dot index .
derive the class LocaleRegexProvider with object as base class .
define the method __init__ with arguments self and regex .
substitute regex for self._regex [ self . _regex ] .
self._regex_dict [ self . _regex_dict ] is an empty dictionary .
property decorator ,
define the method regex with an argument self .
call the function get_language , substitute the result for language_code .
if language_code is not contained in self._regex_dict [ self . _regex_dict ] ,
if self.regex [ self . regex ] is not an instance of six.string_types [ six . string_types ] ,
substitute self._regex [ self . _regex ] for regex .
if not ,
call the function force_text with arguments self and _regex , substitute the result for regex .
try ,
call the function re.compile [ re . compile ] with arguments regex and re.UNICODE [ re . UNICODE ] , substitute the result for compiled_regex .
if re.error [ re . error ] , renamed to e , is caught ,
raise an ImproperlyConfigured exception with argument string _STR:0_ ,
where ' % s ' is replace by regex and return value of the function six.text_type [ six . text_type ] with an argument e. substitute the compiled_regex for value under the language_code key of the self._regex_dict [ self . _regex_dict ] dictionary .
return the value under the language_code key of the self._regex_dict [ self . _regex_dict ] dictionary .
derive the class RegexURLPattern with LocaleRegexProvider as base class .
define the method __init__ with 5 arguments : self , regex , callback , default_args set to None and name set to None .
call the method LocaleRegexProvider.__init__ [ LocaleRegexProvider . __init__ ] with arguments self and regex .
if callback is an callable object ,
substitute callback for self._callback [ self . _callback ] .
if not ,
self._callback [ self . _callback ] is None .
substitute callback for self._callback_str [ self . _callback_str ] .
if default_args exists substitute it for self.default_args [ self . default_args ] , if not , self.default_args [ self . default_args ] is an empty dictionary .
substitute name for self.name [ self . name ] .
define the method __repr__ with an argument self .
substitute ' % s ' in string _STR:0_ with self.__class__.__name__ [ self . __class__ . __name__ ] , self.name [ self . name ] and self.regex.pattern [ self . regex . pattern ] , respectively ,
use it as an argument for the call to the force_str function , return the result . define the method add_prefix with arguments self and prefix .
if prefix is false , and self doesnt have _STR:0_ attribute ,
return nothing .
joint prefix , character _STR:0_ and self._callback_str [ self . _callback_str ] together , substitute the result for self._callback_str [ self . _callback_str ] .
define the method resolve with arguments self and path .
call the method self.regex.search [ self . regex . search ] with an argument path , substitute the result for match .
if match is true ,
call the method match.groupdict [ match . groupdict ] , substitute the result for kwargs .
if kwargs is true ,
args is an empty tuple .
if not ,
call the method match.groups [ match . groups ] , substitute the result for args .
call the method kwargs.update [ kwargs . update ] with an argument self.default_args [ self . default_args ] .
return an instance of a ResolverMatch class , crated with arguments self.callback [ self . callback ] , args , kwargs and self.name [ self . name ] .
property decorator ,
define the method callback with an argument self .
if self._callback [ self . _callback ] is not None ,
return self._callback [ self . _callback ] .
call the function get_callable with an argument self._callback_str [ self . _callback_str ] , substitute the result for self._callback [ self . _callback ] .
return self._callback [ self . _callback ] .
derive the class RegexURLResolver with LocaleRegexProvider as base class .
define the method __init__ with 6 arguments : self , regex , urlconf_name , default_kwargs set to None , app_name set to None and namespace set to None .
call the method LocaleRegexProvider.__init__ [ LocaleRegexProvider . __init__ ] with arguments self and regex .
substitute urlconf_name for self.urlconf_name [ self . urlconf_name ] .
if urlconf_name is not an instance of six.string_types [ six . string_types ] class ,
substitute self.urlconf_name [ self . urlconf_name ] for self.urlconf_module [ self . urlconf_module ] .
self.callback [ self . callback ] is None .
if default_kwargs exists , substitute it for self.default_kwargs [ self . default_kwargs ] , otherwise self.default_kwargs [ self . default_kwargs ] is an empty dictionary .
substitute namespace for self.namespace [ self . namespace ] .
substitute app_name for self.app_name [ self . app_name ] .
self._reverse_dict [ self . _reverse_dict ] is an empty dictionary .
self._namespace_dict [ self . _namespace_dict ] is an empty dictionary .
self._app_dict [ self . _app_dict ] is an empty dictionary .
self._callback_strs [ self . _callback_strs ] is an empty set .
self._populated [ self . _populated ] is boolean False .
define the method __repr__ with an argument self .
if self.urlconf_name [ self . urlconf_name ] is an instance of a list type and its length is not zero .
replace ' % s ' in string _STR:0_ with __class__.__name__ [ __class__ . __name__ ] field of first element of self.urlconf_name [ self . urlconf_name ] , substitute it for urlconf_repr .
if not ,
create a printable representation of self.urlconf_name [ self . urlconf_name ] object , substitute it for urlconf_repr .
replace all ' % s ' in string _STR:0_ with self.__class__.__name__ [ self . __class__ . __name__ ] , urlconf_repr , self.app_name [ self . app_name ] ,
self.namespace [ self . namespace ] and self.regex.pattern [ self . regex . pattern ] , respectively . return it . define the method _populate with an argument self .
lookups is an instance of the MultiValueDict class .
namespaces is an empty dictionary .
apps is an empty dictionary .
call the function get_language , substitute the result for language_code .
for every pattern in reversed list self.url_patterns [ self . url_patterns ] ,
if pattern has an attribute _STR:0_ ,
call the method self._callback_strs.add [ self . _callback_strs . add ] with an argument pattern._callback_str [ pattern . _callback_str ] .
otherwise , if pattern has an _STR:0_ attribute .
substitute pattern._callback [ pattern . _callback ] for callback .
if callback is an instance of functools.partial [ functools . partial ] object ,
substitute callback.func [ callback . func ] for callback .
if callback doesnt have _STR:0_ attribute ,
join callback.__module__ [ callback . __module__ ] , character _STR:0_ and callback.__class__.__name__ [ callback . __class__ . __name__ ] together , substitute the result for lookup_str .
if not ,
join together callback.__module__ [ callback . __module__ ] , character _STR:0_ and callback.__name__ [ callback . __name__ ] , substitute the result for lookup_str .
call the method self._callback_strs.add [ self . _callback_strs . add ] with an argument lookup_str .
substitute pattern.regex.pattern [ pattern . regex . pattern ] for p_pattern .
if p_pattern starts with a string _STR:0_ ,
remove the first element from p_pattern .
if pattern is an instance of RegexURLResolver class ,
if pattern.namespace [ pattern . namespace ] is true ,
substitute the tuple containing 2 elements p_pattern and pattern for value under the pattern.namespace [ pattern . namespace ] key of the namespaces dictionary .
if pattern.app_name [ pattern . app_name ] is true ,
call the method apps.setdefault [ apps . setdefault ] with 2 arguments : pattern and an empty list , append to the resulting object pattern.namespace [ pattern . namespace ] .
if not ,
substitute pattern.regex.pattern [ pattern . regex . pattern ] for parent_pat .
for every name in pattern.reverse_dict [ pattern . reverse_dict ] ,
for every matches , pat and defaults in return value of the method pattern.reverse_dict.getlist [ pattern . reverse_dict . getlist ] called with an argument name ,
call the method normalize with sum of parent_pat and pat as an argument , substitute the result for new_matches .
call the method lookups.appendlist [ lookups . appendlist ] with 2 arguments : name and a tuple containing 3 elements : new_matches , sum of p_pattern and pat ,
and dictionary created by applying defaults mapping on the pattern.default_kwargs [ pattern . default_kwargs ] dictionary . for every namespace and tuple containing : prefix and sub_pattern , in return value of the method pattern.namespace_dict.items [ pattern . namespace_dict . items ] ,
substitute tuple containing 2 elements : sum of p_pattern and prefix , and sub_pattern for value under the namespace key of the namespace dictionary .
for every app_name and namespace_list in pattern.app_dict.items [ pattern . app_dict . items ] method return value ,
call the method apps.setdefault [ apps . setdefault ] with 2 arguments : app_name and an empty list , extend the resulting list with namespaces_list .
call the method self._callback_strs.update [ self . _callback_strs . update ] with an argument pattern._callback_strs [ pattern . _callback_strs ] .
if not ,
call the function normalize with an argument p_pattern , substitute the result for bits .
call the method lookups.appendlist [ lookups . appendlist ] with 2 arguments : pattern.callback [ pattern . callback ] and a tuple containing 3 elements : bits , p_pattern ,
and pattern.default_args [ pattern . default_args ] . if pattern.name [ pattern . name ] is not None ,
call the method lookups.appendlist [ lookups . appendlist ] with 2 arguments : pattern.name [ pattern . name ] and a tuple containing 3 elements : bits , p_pattern ,
and pattern.default_args [ pattern . default_args ] . substitute lookups for the value under language_code key of the self._reverse_dict [ self . _reverse_dict ] dictionary .
substitute namespaces for the value under language_code key of the self._namespace_dict [ self . _namespace_dict ] dictionary .
substitute apps for the value under language_code key of the self._app_dict [ self . _app_dict ] dictionary .
self._populated [ self . _populated ] is boolean True .
property decorator ,
define the method reverse_dict with an argument self .
call the function get_language , substitute the result for language_code .
if language_code is not contained in self._reverse_dict [ self . _reverse_dict ]
call the method self._populate [ self . _populate ] .
return the value under the language_code key of the self._reverse_dict [ self . _reverse_dict ] dictionary .
property decorator ,
define the method namespace_dict with an argument self .
call the method get_language , substitute the result for language_code .
if language_code is not contained in self._namespace_dict [ self . _namespace_dict ] ,
call the method self._populate [ self . _populate ] .
return the value under the language_code key of the self._namespace_dict [ self . _namespace_dict ] dictionary .
property decorator ,
define the method app_dict with an argument self .
call the method get_language , substitute the result for language_code .
if language_code is not containsed in self._app_dict [ self . _app_dict ]
call the method self._populate [ self . _populate ] .
return the value under the language_code key of the self._app_dict [ self . _app_dict ] dictionary .
define the method resolve with an argument self .
call the function force_text with an argument path , substitute the result for path .
tried is an empty list .
call the function self.regex.search [ self . regex . search ] with an argument path , substitute the result for match .
if match is true ,
slice the path list from the result of the match.end [ match . end ] method as the start index to the end , substitute it for new_path .
for every pattern in self.url_patterns [ self . url_patterns ] ,
try ,
call the method pattern.resolve [ pattern . resolve ] with an argument new_path , substitute the result for sub_match .
if Resolver404 , renamed to e , exception is caught ,
call the get method with an argument string _STR:0_ on the first element of the e.args [ e . args ] , substitute the result for sub_tried .
if sub_tried is not None ,
call the method tried.extend [ tried . extend ] with an argument : t added to a list containing element pattern , for every t in sub_tried .
if not ,
append list containing pattern to tried .
if not ,
if sub_match is true ,
sub_match_dict is a dictionary created from self.default_kwargs [ self . default_kwargs ] dictionary using mapping function match.groupdict [ match . groupdict ] .
call the method sub_match_dict.update [ sub_match_dict . update ] with an argument sub_match.kwargs [ sub_match . kwargs ] .
return an instance of a class ResolverMatch created with 6 arguments : sub_match.func [ sub_match . func ] , sub_match.args [ sub_match . args ] , sub_match_dict ,
sub_match.url_name [ sub_match . url_name ] , self.app_name [ self . app_name ] if it exists or if not sub_match.app_name [ sub_match . app_name ] and sub_match.namespaces [ sub_match . namespaces ] list appended to self.name [ self . name ] . append pattern to tried list .
raise an Resolver404 exception with an argument dictionary containing 2 entries : new_path for _STR:0_ and tried for _STR:1_ .
raise an Resolver404 exception with an argument dictionary containing 1 entry : path for _STR:0_ .
property decorator ,
define the method urlconf_module with an argument self .
try ,
return self._urlconf_module [ self . _urlconf_module ] .
if AttributeError exception is caught .
call the function import_module with argument self.urlconf_name [ self . urlconf_name ] , substitute the result for self._urlconf_module [ self . _urlconf_module ] .
return self._urlconf_module [ self . _urlconf_module ] .
property decorator ,
define the method url_patterns with an argument self .
get attribute _STR:0_ form the self.urlconf_module [ self . urlconf_module ] , substitute it for patterns , if the attribute doesnt exist ,
substitute self.urlconf_module [ self . urlconf_module ] for self.urlconf_module [ self . urlconf_module ] . try ,
call the function iter with an argument patterns .
if TypeError exception is caught ,
msg is a string _STR:0_The included urlconf _STR:1_ does not appear to have any patterns in it .
If you see valid patterns in the file then the issue is probably caused by a circular import . '' raise an ImproperlyConfigured exception with an argument : return value of the method msg.format [ msg . format ] , called with an argument name set to self.urlconf_name [ self . urlconf_name ] .
return patterns .
define the method resolve_error_handler with arguments self and view_type .
replace ' % s ' in the string _STR:0_ with view_type , use it as an name of the attribute to get from the self.urlconf_module [ self . urlconf_module ] ,
substitute it for callback , if the attribute doesnt exists , callback is None . if not callback ,
from django.conf [ django . conf ] import urls into default name space ,
replace ' % s ' in the string _STR:0_ with view_type , use it as an name of the attribute to get from the urls , substitute it for callback .
call the function get_callable with an argument callback , return the result and an empty dictionary .
define the method reverse with arguments self , lookup_view , unpacked list args and unpacked dictionary kwargs .
call the method self._reverse_with_prefix [ self . _reverse_with_prefix ] with 4 arguments : lookup_view , an empty string , unpacked list args and unpacked dictionary kwargs .
define the method _reverse_with_prefix with arguments self , lookup_view , _prefix , unpacked list args and unpacked dictionary kwargs .
if args and kwargs are both true ,
raise an ValueError exception with an argument string _STR:0_ .
call the function force_text with an argument v , for every v in args , put the results in a text_args list .
text_kwargs is a dictionary created from the result of the function force_text with an argument v , mapped through function k , for every k and v in return value of the kwargs.items [ kwargs . items ] .
if self._populated [ self . _populated ] is false ,
call the method self._populate [ self . _populate ] ,
substitute lookup_view for original_lookup ,
try ,
if lookup_view is contained in self._callback_strs [ self . _callback_strs ] ,
call the function get_callable with arguments lookup_view and boolean True , substitute the result for lookup_view .
if ImportError , AttributeError , renamed to e , exceptions are caught ,
raise an NoReverseMatch exception with an argument string _STR:0_ , where ' % s ' is replaced with lookup_view and e , respectively .
if not ,
if original_lookup and lookup_view are not callable objects ,
call the function warnings.warn [ warnings . warn ] with 3 arguments : string _STR:0_ , with ' % s ' replaced with
original_lookup , RemovedInDjango20Warning and stacklevel set to integer 3. call the method self.reverse_dict.getlist [ self . reverse_dict . getlist ] with an argument lookup_view , substitute the result for possibilities .
call the function urlquote with an argument _prefix , use the result as an argument for the call to the normalize function ,
substitute the fitst element of the result for prefix_norm and prefix_args , respectively . for every possibility , pattern and defaults in possibilities ,
for every result and params in possibility ,
if args is true ,
if length of args is not equal to the sum of the lengths of params and prefix_args ,
skip this loop iteration .
create a list of tuples out of 2 lists : appended params list to prefix_args and text_args , covert the result into a dictionary ,
substitute it for candidate_subs . if not ,
if the union of the kwargs and defaults dictionary keys converted into sets is not the same as the union of the defaults and prefix
dictionary keys converted into sets , skip this loop iteration ,
matches is boolean True ,
for every k and v in return value of the function defaults.items [ defaults . items ] ,
if the value of the kwargs dictionary under the key k is not equal to v ,
matches is boolean False .
break from this loop execution .
if matches is false ,
skip this loop iteration ,
substitute text_kwargs for candidate_subs .
replace all the occurrences of the _STR:0_ string for _STR:1_ , append result to the previous result , substitute it for candidate_pat .
call the function re.search [ re . search ] with 3 arguments : string _STR:0_ , with ' % s ' replaced for prefix_norm and pattern , respectively ,
candidate_pat formated with candidate_subs and re.UNICODE [ re . UNICODE ] . candidate_subs is dictionary created from elements in return value of the function urlquote called with argument v ,
mapped with a function k , for every k and v in return value of the method candidate_subs.items [ candidate_subs . items ] . format candidate_pat with candidate_subs , return the result .
get the attribute _STR:0_ from the getattr , if it exists substitute it for m , if not , m is None .
get the attribute _STR:0_ from the getattr , if it exists substitute it for m , if not , m is None .
if m and n are not None ,
join m and n into a string , separated by _STR:0_ , substitute the result for lookup_view_s .
if not ,
substitute lookup_view for lookup_view_s .
append pattern into a list patterns , for every possibility , pattern and defaults in possibilities .
raise an NoReverseMatch exception with an argument string _STR:0_ ,
_STR:0_ , replace ' % s ' with lookup_view_s , args , kwargs , length of patterns , patterns , and respectively . derive the class LocaleRegexURLResolver with RegexURLResolver as base class .
define the __init__ method with 5 arguments : self , urlconf_name , default_kwargs set to None , app_name set to None and namespace set to None .
call the __init__ method of the base class of the class LocaleRegexURLResolver , with arguments : None , urlconf_name , default_kwargs , app_name and namespace .
property decorator ,
define the method regex with an argument self .
call the function get_language , substitute the result for language_code .
if language_code is not contained in self._regex_dict [ self . _regex_dict ] ,
call the function re.compile [ re . compile ] with 2 arguments , string _STR:0_ , where ' % s ' is replaced with language_code and re.UNICODE [ re . UNICODE ] , substitute the result for regex_compiled .
substitute the regex_compiled for value under the language_code key of the self._regex_dict [ self . _regex_dict ] dictionary .
return the value under the language_code of the self._regex_dict [ self . _regex_dict ] dictionary .
define the function resolve with arguments path and urlconf set to None .
if urlconf is None ,
call the function get_urlconf with an argument urlconf .
call the function get_resolver with an argument urlconf , on the result call the method resolve with an argument path , return it .
define the function reverse with 6 arguments : viewname , urlconf set to None , args set to None , kwargs set to None ,
prefix set to None , current_app set to None . if urlconf is None ,
call the function get_urlconf with an argument urlconf .
call the function get_resolver with an argument urlconf , substitute the result for resolver .
if args in None of boolean False , substitute it for an empty list .
if args in None of boolean False , substitute it for an empty dictionary .
if prefix is None ,
call the function get_script_prefix , substitute the result for prefix .
if viewname is not an instance of the six.string_types [ six . string_types ] object ,
substitute viewname for view .
if not ,
call the method viewname.split [ viewname . split ] , with an argument _STR:0_ , substitute the result for parts .
call the method parts.reverse [ parts . reverse ] .
substitute first element of parts for view .
substitute parts , without the first element , for path .
resolved_path is an empty list .
ns_pattern is an empty string .
while path is true ,
pop the element form the path as substitute the result for ns .
try ,
get the value under the ns key of the resolver.app_dict [ resolver . app_dict ] dictionary , substitute it for app_list .
if current_app and is true and current_app is contained in app_list ,
substitute current_app for ns .
otherwise if ns is not contained in app_list ,
substitute first element of app_list for ns .
if KeyError exception is caught ,
do nothing .
try ,
substitute the value under the ns key of the resolver.namespace_dict [ resolver . namespace_dict ] dictionary for extra and resolver , respectively .
call the method resolved_path.append [ resolved_path . append ] with an argument ns .
add ns_pattern and extra , substitute the result for ns_pattern .
if KeyError , renamed to key , exception is caught ,
if resolved_path is true ,
raise an NoReverseMatch exception with an argument string _STR:0_ ,
respectively replace ' % s ' with key and elements of the resolved_path joined into a string , separated by _STR:0_ . if not ,
raise an NoReverseMatch exception with an argument string _STR:0_ , with ' % s ' replaced with key .
if ns_pattern is true ,
call the function get_ns_resolver with arguments ns_pattern and resolver , substitute the result for resolver .
call the method resolver._reverse_with_prefix [ resolver . _reverse_with_prefix ] with 4 arguments : view , prefix , unpacked list args , unpacked dictionary kwargs ,
use the result as an argument for the call to the function iri_to_uri , return the result . call the function lazy with arguments reverse and str , substitute the results for reverse_lazy .
define the function clear_url_caches .
call the function get_callable.cache_clear [ get_callable . cache_clear ] .
call the function get_resolver.cache_clear [ get_resolver . cache_clear ] .
call the function get_ns_resolver.cache_clear [ get_ns_resolver . cache_clear ] .
define the function set_script_prefix with an argument prefix .
if prefix doesnt end with character _STR:0_ ,
append _STR:0_ to prefix .
substitute prefix for _prefixes.values [ _prefixes . values ] .
define the function get_script_prefix .
get _STR:0_ attribute of the _prefixes , if it exists , return it , otherwise return _STR:1_ .
define the function clear_script_prefix .
try ,
delete _prefixes.values [ _prefixes . values ] .
if AttributeError exception is caught ,
do nothing .
define the function set_urlconf with an argument urlconf_name .
if urlconf_name is true ,
substitute urlconf_name for _urlconfs.value [ _urlconfs . value ] .
if not ,
if _urlconfs has an attribute _STR:0_ ,
delete _urlconfs.value [ _urlconfs . value ] .
define the function get_urlconf with an argument default set to None .
get the _STR:0_ attribute of the _urlconfs , if it exists return it , otherwise return defaults .
define the function is_valid_path with arguments path and urlconf set to None .
try ,
call the function resolve with arguments path and urlconf .
return boolean True .
if Resolver404 exception is caught ,
return boolean False .
from __future__ import unicode_literals into default name space .
import module re .
from django.core.exceptions [ django . core . exceptions ] import ValidationError into default name space .
from django.utils.deconstruct [ django . utils . deconstruct ] import deconstructible into default name space .
from django.utils.translation [ django . utils . translation ] import ugettext_lazy as _ and ungettext_lazy into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_text into default name space .
from django.utils.ipv6 [ django . utils . ipv6 ] import is_valid_ipv6_address into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.six.moves.urllib.parse [ django . utils . six . moves . urllib . parse ] import urlsplit and urlunsplit into default name space .
EMPTY_VALUES is a tuple containing 5 initial elements : None , empty string , empty list , empty tuple and an empty dictionary .
decorator deconstructible ,
derive the class RegexValidator form the object base class .
regex is an empty string .
call a function _ with a string _STR:0_ as an argument , substitute the result for message .
code is a string _STR:0_
inverse_match is boolean False .
flags is a integer 0 .
define the method __init__ with 6 arguments : self , regex set to None , message set to None , code set to None ,
inverse_match set to None and flags set to None . if regex is not None ,
substitute regex for self.regex [ self . regex ] .
if message is not None ,
substitute message for self.message [ self . message ] .
if code is not None ,
substitute code for self.code [ self . code ] .
if inverse_match is not None ,
substitute inverse_match for self.inverse_match [ self . inverse_match ] .
if flags is not None ,
substitute flags for self.flags [ self . flags ] .
if self.flags [ self . flags ] is true and self.regex [ self . regex ] is not an instance of a six.string_types [ six . string_types ] type ,
raise an TypeError exception with an argument string _STR:0_ .
if self.regex [ self . regex ] is not an instance of a six.string_types [ six . string_types ] type ,
call the re.compile [ re . compile ] function with self.regex [ self . regex ] and self.flags [ self . flags ] as arguments , substitute the result for self.regex [ self . regex ] .
define the method __call__ with arguments self and value .
if self.inverse_match [ self . inverse_match ] equals to return value of the self.regex.search [ self . regex . search ] method converted to boolean , called with argument force_text ( value ) ,
raise a ValidationError exception with arguments self.message [ self . message ] and code set to self.code [ self . code ] .
define the method __eq__ with arguments self and other .
evaluate the logical expression , if other is an instance of RegexValidator and self.regex.pattern [ self . regex . pattern ] equals to other.regex.pattern [ other . regex . pattern ] ,
and self.regex.flags [ self . regex . flags ] equals to other.regex.flags [ other . regex . flags ] and self.message [ self . message ] equals to other.message [ other . message ] and self.code [ self . code ] equals to other.code [ other . code ] , and self.inverse_match [ self . inverse_match ] equals to other.inverse_match [ other . inverse_match ] , return the result . define the method __ne__ with arguments self and other .
if self equals to other return boolean False , otherwise return boolean True .
decorator deconstructible ,
derive the class URLValidator form the RegexValidator base class .
call the re.compile [ re . compile ] function with 2 arguments : raw string _STR:0_ ,
_STR:0_ , _STR:1_ and re.IGNORECASE [ re . IGNORECASE ] , substitute the result for regex . call a function _ with a string _STR:2_ as an argument , substitute the result for message .
schemes is a list containing 4 initial elements : _STR:0_ , _STR:1_ , _STR:2_ and _STR:3_ .
define the method __init__ with 3 arguments : self , schemes set to None and unpacked dictionary kwargs .
call the __init__ method of the base class of the class URLValidator , with unpacked dictionary kwargs as argument .
if schemes is not None ,
substitute schemes for self.schemes [ self . schemes ] .
define the method __call__ with arguments self and value .
call the function force_text with an argument value , substitute the result for value .
call the value.split [ value . split ] method with _STR:0_ as argument , convert first element of the result to lower case , substitute the result for scheme .
if scheme is not contained in self.schemes [ self . schemes ] ,
raise a ValidationError exception with arguments self.message [ self . message ] and code set to self.code [ self . code ] .
try ,
call the __call__ method from the base class of the class URLValidator , with an argument value .
if ValidationError , renamed to e , is caught ,
if value is true ,
call the function urlsplit with an argument value , assign the result to scheme , netloc , path , query and fragment , respectively .
try ,
call the method netloc.encode [ netloc . encode ] with an argument string _STR:0_ , on the return value call the decode method with string _STR:1_ as argument , substitute the result for netloc .
if UnicodeError exception is caught ,
raise an exception e .
call the function urlunsplit with a tuple containing 5 elements : scheme , netloc , path , query and fragment , as an argument , substitute the result for url .
call the __call__ method from the base class of the URLValidator class , with an argument url .
if not ,
raise an exception .
if not ,
substitute value for url .
define the function validate_integer with an argument value .
try ,
convert value into an integer .
if ValueError or TypeError exceptions are caught ,
raise a ValidationError exception with 2 arguments : return value of the function _ with an string argument _STR:0_ ,
and code set to string _STR:0_ . decorator deconstructible ,
derive the class EmailValidator form the object base class .
call a function _ with a string _STR:0_ as an argument , substitute the result for message .
code is a string _STR:0_ .
call the re.compile [ re . compile ] function with 2 arguments : raw string _STR:0_ ,
_STR:0_ ( [ \001-\010\013\014\016-\037 ! # -\ [ \ ] -\177 ] |\\ [ \001-\011\013\014\016-\177 ] ) *_STR:1_ and re.IGNORECASE [ re . IGNORECASE ] , substitute the result for user_regex . call the re.compile [ re . compile ] function with 2 arguments : raw string _STR:2_ ,
and re.IGNORECASE [ re . IGNORECASE ] , substitute the result for domain_regex . call the re.compile [ re . compile ] function with 2 arguments : raw string _STR:0_ and re.IGNORECASE [ re . IGNORECASE ] , substitute the result for literal_regex .
domain_whitelist is a list containing string _STR:0_ .
define the __init__ method with 4 arguments : self , message set to None , code set to None and whitelist set to None .
if message is not None
substitute message for self.message [ self . message ] .
if code is not None
substitute code for self.code [ self . code ] .
if whitelist is not None
substitute whitelist for self.domain_whitelist [ self . domain_whitelist ] .
define the method __call__ with arguments self and value .
call the function force_text with an argument value , substitute the result for value .
if value is false or character _STR:0_ is not contained in value ,
raise a ValidationError exception with arguments self.message [ self . message ] and code set to self.code [ self . code ] .
call the method value.rsplit [ value . rsplit ] with arguments character _STR:0_ and integer 1 , assign the result to user_part and domain_part , respectively .
call the self.user_regex.match [ self . user_regex . match ] method with an argument user_part , if it evaluates to false ,
raise a ValidationError exception with arguments self.message [ self . message ] and code set to self.code [ self . code ] .
if domain_part is not contained in self.domain_whitelist [ self . domain_whitelist ] and method self.validate_domain_part [ self . validate_domain_part ] with an argument domain_part evaluates to false ,
try ,
call the method domain_part.encode [ domain_part . encode ] with an argument string _STR:0_ , on the return value call the decode method with string _STR:1_ as argument , substitute the result for domain_part .
if method self.validate_domain_part [ self . validate_domain_part ] with an argument domain_part evaluates to true ,
return nothing .
if UnicodeError exception is caught ,
do nothing .
raise a ValidationError exception with arguments self.message [ self . message ] and code set to self.code [ self . code ] .
define the method validate_domain_part with arguments self and domain_part .
call the self.domain_regex.match [ self . domain_regex . match ] method with an argument domain_part , if it evaluates to true ,
return boolean True .
evaluate method self.literal_regex.match [ self . literal_regex . match ] with an argument domain_part , substitute the result for literal_match .
if literal_match is true ,
call the method literal_match.group [ literal_match . group ] with an integer 1 , substitute the result for ip_address .
try ,
call the function validate_ipv46_address with an argument ip_address .
return boolean True .
if ValidationError exception is caught ,
do nothing .
return boolean False .
define the method __eq__ with arguments self and other .
if other is instance of EmailValidator and , self.domain_whitelist [ self . domain_whitelist ] equals to other.domain_whitelist [ other . domain_whitelist ] ,
and self.message [ self . message ] equals to other.message [ other . message ] , and self.code [ self . code ] equals to other.code [ other . code ] , return boolean True , otherwise return boolean False . validate_email is an instance of EmailValidator class .
call the re.compile [ re . compile ] function with an argument raw string _STR:0_ , substitute the result for slug_re .
validate_slug is a instance of a RegexValidator class , created with 3 arguments : slug_re , return value of the call to the function ,
_ with an argument string _STR:0_ , and string _STR:1_ . call the re.compile [ re . compile ] function with an argument raw string _STR:2_ ,
substitute the result for ipv4_re . validate_ipv4_address is a instance of a RegexValidator class , created with 3 arguments : ipv4_re ,
return value of the call to the function _ with an argument string _STR:0_ and string _STR:1_ . define the function validate_ipv6_address with an argument value .
call the function is_valid_ipv6_address with an argument value , if it evaluates to false ,
raise a ValidationError exception with 2 arguments : return value of the function _ called with an argument string _STR:0_ , and code set to string _STR:1_ .
define the function validate_ipv46_address with an argument value .
try ,
call the function validate_ipv4_address with an argument value .
if ValidationError exception is caught ,
try ,
call the function validate_ipv6_address with an argument value .
if ValidationError exception is caught ,
raise a ValidationError exception with 2 arguments : return value of the function _ called with an argument string _STR:0_ , and code set to string _STR:1_ .
ip_address_validator_map is a dictionary containing 3 initial entries : tuple containing 2 elements : list with an element , validate_ipv46_address and return value of the function _ with an argument string _STR:0_ for _STR:1_ ,
tuple containing 2 elements : list with an element validate_ipv4_address and return value of the function _ with an argument string , _STR:0_ for _STR:1_ and tuple containing 2 elements : list with an element validate_ipv6_address , and return value of the function _ with an argument string _STR:2_ for _STR:3_ . define the function ip_address_validators with arguments protocol and unpack_ipv4 .
if protocol is not equal to string _STR:0_ and unpack_ipv4 is true ,
raise a ValueError exception with an argument _STR:0_ .
try ,
convert protocol to lowercase , use it as a key to get a value from the ip_address_validator_map dictionary , return it .
if KeyError exception is caught ,
raise a ValueError exception with an argument _STR:0_ , replace ' % s ' with protocol ,
and ip_address_validator_map converted to a list , respectively . call the re.compile [ re . compile ] function with an argument raw string _STR:0_ , substitute the result for comma_separated_int_list_re .
validate_comma_separated_integer_list is a instance of a RegexValidator class , created with 3 arguments : comma_separated_int_list_re ,
return value of the call to the function _ with an argument string _STR:0_ and string _STR:1_ . decorator deconstructible ,
derive the class BaseValidator form the object base class .
compare is a lambda function with arguments self , a and b , return value is boolean True if a is not b , otherwise it is False .
clean is a lambda function with arguments self and x , return value is x .
call the function _ with the argument string _STR:0_ , substitute the result for message .
code is a string _STR:0_
define the method __init__ with self and limit_value as arguments .
substitute the limit_value for self.limit_value [ self . limit_value ] .
define the method __call__ with arguments self and value .
call the method self.clean [ self . clean ] with value as argument , substitute the result for cleaned .
params is a dictionary with 2 initial entries : self.limit_value [ self . limit_value ] for _STR:0_ and cleaned for _STR:1_ .
call the self.compare [ self . compare ] method with arguments cleaned and self.limit_value [ self . limit_value ] , if it evaluates to true ,
raise a ValidationError exception with arguments self.message [ self . message ] , code set to self.code [ self . code ] and params set to params .
define the method __eq__ with arguments self and other .
if other is an instance of self.__class__ [ self . __class__ ] and , self.limit_value [ self . limit_value ] equals to other.limit_value [ other . limit_value ] , and self.message [ self . message ] equals to other.message [ other . message ] ,
and self.code [ self . code ] equals to other.code [ other . code ] , return boolean True , otherwise return boolean False . decorator deconstructible ,
derive the class MaxValueValidator form the BaseValidator base class .
compare is a lambda function with arguments self , a and b , return value is boolean true if a is greater than b , otherwise is false .
call the function _ with an argument string _STR:0_ , substitute the result for message .
code is a string _STR:0_
decorator deconstructible ,
derive the class MinValueValidator form the BaseValidator base class .
compare is a lambda function with arguments self , a and b , return value is boolean true if a is lesser than b , otherwise is false .
call the function _ with an argument string _STR:0_ , substitute the result for message .
code is a string _STR:0_
decorator deconstructible ,
derive the class MinLengthValidator form the BaseValidator base class .
compare is a lambda function with arguments self , a and b , return value is boolean true if a is lesser than b , otherwise is false .
clean is a lambda function with self and x as arguments , return value is length of x .
call the function ungettext_lazy with 3 arguments : string 'Ensure this value has at least % ( limit_value ) d character ( it has % ( show_value ) d ) ,
string _STR:0_ and string _STR:1_ , substitute the result for message . code is a string _STR:2_
decorator deconstructible ,
derive the class MaxLengthValidator form the BaseValidator base class .
compare is a lambda function with arguments self , a and b , return value is boolean true if a is greater than b , otherwise is false .
clean is a lambda function with self and x as arguments , return value is length of x .
call the function ungettext_lazy with 3 arguments : string 'Ensure this value has at most % ( limit_value ) d character ( it has % ( show_value ) d ) ,
string _STR:0_ and string _STR:1_ , substitute the result for message . code is a string _STR:2_
import module django .
from django.core.handlers.wsgi [ django . core . handlers . wsgi ] import WSGIHandler into default name space .
define the function get_wsgi_application .
call the django.setup [ django . setup ] method .
return WSGIHandler object .
from django.core.exceptions [ django . core . exceptions ] import ValidationError into default name space .
from django.forms.fields [ django . forms . fields ] import everything into default name space .
from django.forms.forms [ django . forms . forms ] import everything into default name space .
from django.forms.formsets [ django . forms . formsets ] import everything into default name space .
from django.forms.models [ django . forms . models ] import everything into default name space .
from django.forms.widgets [ django . forms . widgets ] import everything into default name space .
from django.forms.extras.widgets [ django . forms . extras . widgets ] import SelectDateWidget into default name space .
__all__ is an list containing string _STR:0_ .
from __future__ import unicode_literals into default name space .
import module datetime .
import module re .
from django.forms.widgets [ django . forms . widgets ] import Widget and Select into default name space .
from django.utils [ django . utils ] import datetime_safe into default name space .
from django.utils.dates [ django . utils . dates ] import MONTHS into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_str into default name space .
from django.utils.safestring [ django . utils . safestring ] import mark_safe into default name space .
from django.utils.formats [ django . utils . formats ] import get_format into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.conf [ django . conf ] import settings into default name space .
__all__ is an tuple containing string _STR:0_ .
compile regex from the raw string _STR:0_ , substitute it for RE_DATE .
define the function _parse_date_fmt .
call the function get_format with an argument string _STR:0_ , substitute it for fmt .
escaped is boolean False .
for every char in fmt ,
if escaped is true ,
escaped is boolean False .
otherwise if cahr equals a string '\\ ' ,
escaped is boolean True .
otherwis if char is contained in string _STR:0_ ,
yield string _STR:0_ as an return value of the generator .
otherwise if char is contained in string _STR:0_ ,
yield string _STR:0_ as an return value of the generator .
otherwise if char is contained in string _STR:0_ ,
yield string _STR:0_ as an return value of the generator .
derive the class SelectDateWidget for the Widget base class .
none_value is a tuple containing 2 elements : integer 0 and string _STR:0_ .
month_field is a string _STR:0_ .
day_field is a string _STR:0_ .
year_field is a string _STR:0_ .
define the method __init__ with 5 arguments : self , attrs set to None , years set to None , months set to None and empty_label set to None .
if attrs is not None substitute it for self.attrs [ self . attrs ] , or if not self.attrs [ self . attrs ] is an empty dictionary .
if years is true ,
substitute years for self.years [ self . years ] .
if not ,
call the function datetime.date.today [ datetime . date . today ] , substitute the year field of the result for this_year .
self.years [ self . years ] is list containing 10 successive integers from this_year .
if months is true ,
substitute months for self.months [ self . months ] .
if not ,
substitute MONTHS for self.months [ self . months ] .
if empty_label is an instance of list or tuple type ,
if length of empty_label is not equal to integer 3 .
raise an ValueError with an argument string _STR:0_ .
self.year_none_value [ self . year_none_value ] is a tuple containing 2 elements : integer 0 and first element of empty_label .
self.month_none_value [ self . month_none_value ] is a tuple containing 2 elements : integer 0 and second element of empty_label .
self.day_none_value [ self . day_none_value ] is a tuple containing 2 elements : integer 0 and third element of empty_label .
if not ,
if empty_label is not None ,
self.none_value [ self . none_value ] is a tuple containing 2 elements : integer 0 and empty_label .
substitute self.none_value [ self . none_value ] for self.year_none_value [ self . year_none_value ] .
substitute self.none_value [ self . none_value ] for self.month_none_value [ self . month_none_value ] .
substitute self.none_value [ self . none_value ] for self.day_none_value [ self . day_none_value ] .
define the method render with 4 arguments : self , name , value and attrs set to None .
try ,
substitute value.year [ value . year ] , value.month [ value . month ] and value.day [ value . day ] for year_val , month_val and day_val , respectively .
if AttributeError exception is caught ,
year_val and month_val and day_val are set to None .
if value is an instance of six.string_types [ six . string_types ] ,
if settings.USE_L10N [ settings . USE_L10N ] is true ,
try ,
call the function get_format with an argument string _STR:0_ , substitute the first element of the result for input_format .
call the method datetime.datetime.strptime [ datetime . datetime . strptime ] with 2 arguments : return value of the function force_str called with an argument value ,
and input_format , substitute the result for v. substitute v.year [ v . year ] , v.month [ v . month ] and v.day [ v . day ] for year_val , month_val and day_val , respectively .
if ValueError exception is caught ,
do nothing .
if not ,
call the method RE_DATE.match [ RE_DATE . match ] with an argument value , substitute the result for match .
if match is true ,
for v in return value of the function match.groups [ match . groups ] , convert v into an integer and append i to a list ,
assign the result for year_val , month_val and day_val , respectively . html is an empty dictionary .
for every i in self.years [ self . years ] append tuple containing i and i elements into a list , substitute the resulting string for choices .
call the method self.create_select [ self . create_select ] with 6 arguments : name , self.year_field [ self . year_field ] , value , year_val , choices and self.year_none_value [ self . year_none_value ] ,
substitute the result for the value under the _STR:0_ key of the html dictionary . call the function six.iteritems [ six . iteritems ] with an argument self.months [ self . months ] , convert the result to a list and substitute it for choices .
call the method self.create_select [ self . create_select ] with 6 arguments : name , self.month_field [ self . month_field ] , value , month_val , choices and self.month_none_value [ self . month_none_value ] ,
substitute the result for the value under the _STR:0_ key of the html dictionary . for every i in successive list of integers from 1 to 30 , append tuple containing i and i elements into a list ,
substitute the resulting string for choices . call the method self.create_select [ self . create_select ] with 6 arguments : name , self.year_field [ self . year_field ] , value , day_val , choices and self.day_none_value [ self . day_none_value ] ,
substitute the result for the value under the _STR:0_ key of the html dictionary . output is an empty list .
for every field in return value of the function _parse_date_fmt ,
get the value under the field key of the html dictionary , append it to output .
join output into a string , separated by newline characters , use it as an argument for the call to the mark_safe , return the result .
define the method id_for_label with arguments self and id .
for every first_select in return value of the function _parse_date_fmt .
substitute ' % s ' in string _STR:0_ with id_ and first_select , return it .
if not ,
convert if into a string append to it a string _STR:0_ , return the result .
define the method id_for_label with arguments self , data , files and name .
format self.year_field [ self . year_field ] string with name , use it as the key for the data dictionary , substitute the result for y .
format self.month_field [ self . month_field ] string with name , use it as the key for the data dictionary , substitute the result for m .
format self.day_field [ self . day_field ] string with name , use it as the key for the data dictionary , substitute the result for d .
if y , m and d are all equal to string _STR:0_ ,
return None .
if y and m and d are all true ,
if settings.USE_L10N [ settings . USE_L10N ] is true ,
call the function get_format with an argument string _STR:0_ , substitute the first element of the result for input_format .
try ,
call the function datetime.date [ datetime . date ] with 3 arguments : y , m and d all converted into a integers , substitute the result for date_value .
if ValueError exception is caught ,
substitute ' % s ' in string _STR:0_ with y , m and d , return the result .
if not ,
call the method datetime_safe.new_date [ datetime_safe . new_date ] with an argument date_value , substitute the result for date_value .
call the method date_value.strftime [ date_value . strftime ] with an argument input_format , return the result .
if not ,
substitute ' % s ' in string _STR:0_ with y , m and d , return the result .
get the name key of the data dictionary , if the key exists return it , if not return None .
define the method id_for_label with arguments self , name , field , value , val , choices and none_value .
if _STR:0_ is contained in self.attrs [ self . attrs ] ,
get the value under the _STR:0_ key of the attrs dictionary , substitute the return value field of the self object for id_ .
if not ,
substitute ' % s ' in string _STR:0_ with name , return it .
if self.is_required [ self . is_required ] is false ,
insert none_value at the beginning of the choices list .
call the method self.build_attrs [ self . build_attrs ] with an argument id set to field modulus id_ , substitute the result for local_attrs .
s is an instance of the Select class , created with choices set to choices .
call the method s.render [ s . render ] with 3 arguments : field string formated with name , val and local_attrs , substitute the result for select_html .
return select_html .
from __future__ import unicode_literals into default name space .
import module copy .
import module datetime .
import module os .
import module re .
import module sys .
import module warnings .
from decimal import Decimal and DecimalException into default name space .
from io import BytesIO into default name space .
from django.core [ django . core ] import validators into default name space .
from django.core.exceptions [ django . core . exceptions ] import ValidationError into default name space .
from django.forms.utils [ django . forms . utils ] import from_current_timezone and to_current_timezone into default name space .
from django.forms.widgets [ django . forms . widgets ] import TextInput , NumberInput , EmailInput , URLInput , HiddenInput , MultipleHiddenInput , ClearableFileInput ,
CheckboxInput , Select , NullBooleanSelect , SelectMultiple , DateInput , DateTimeInput , TimeInput , SplitDateTimeWidget , SplitHiddenDateTimeWidget and FILE_INPUT_CONTRADICTION . from django.utils [ django . utils ] import formats into default name space .
from django.utils.encoding [ django . utils . encoding ] import smart_text , force_str and force_text into default name space .
from django.utils.ipv6 [ django . utils . ipv6 ] import clean_ipv6_address into default name space .
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.six.moves.urllib.parse [ django . utils . six . moves . urllib . parse ] import urlsplit and urlunsplit into default name space .
from django.utils.translation [ django . utils . translation ] import ugettext_lazy as _ and ungettext_lazy into default name space .
from django.core.validators [ django . core . validators ] import EMPTY_VALUES into default name space .
__all__ a tuple containing strings : _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ , _STR:5_ , _STR:6_ ,
_STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ , _STR:5_ , _STR:6_ , _STR:7_ , _STR:8_ , _STR:9_ , _STR:10_ , _STR:11_ , _STR:12_ , _STR:13_ , _STR:14_ , _STR:15_ , _STR:16_ , _STR:17_ , _STR:18_ . derive the class Field from the base class object .
substitute substitute TextInput for widget .
substitute HiddenInput for hidden_widget .
default_validators is an empty list .
default_error_messages is an dictionary containing entry : return value of the function _ called with an string _STR:0_ for _STR:1_ .
put elements of validators.EMPTY_VALUES [ validators . EMPTY_VALUES ] to a list , substitute the result for empty_values .
creation_counter is an integer 0 .
define the function __init__ with 11 arguments : self , required set to boolean True , widget set to None , label set to None ,
initial set to None , help_text set to an empty string , error_messages set to None , show_hidden_initial set to boolean False , validators is an empty , localize set to boolean False , label_suffix set to None . substitute required , label and initial for self.required [ self . required ] , self.label [ self . label ] and self.initial [ self . initial ] .
substitute show_hidden_initial for self.show_hidden_initial [ self . show_hidden_initial ] .
substitute help_text for self.help_text [ self . help_text ] .
substitute label_suffix for self.label_suffix [ self . label_suffix ] .
substitute self.widget [ self . widget ] if the widget is false , otherwise substitute widget for widget .
if widget is an instance of type class ,
call the function widget , substitute the result for widget .
substitute localize for self.localize [ self . localize ] .
if self.localize [ self . localize ] is true ,
widget.is_localized [ widget . is_localized ] is boolean True .
substitute self.required [ self . required ] for widget.is_required [ widget . is_required ] .
call the method self.widget_attrs [ self . widget_attrs ] with an argument widget , substitute the result for extra_attrs .
if extra_attrs is true ,
update widget.attrs [ widget . attrs ] dictionary with extra_attrs .
substitute widget for self.widget [ self . widget ] .
substitute Field.creation_counter [ Field . creation_counter ] for self.creation_counter [ self . creation_counter ] .
increment Field.creation_counter [ Field . creation_counter ] by one .
messages is an empty dictionary .
for every c in reversed order of self.__class__.__mro__ [ self . __class__ . __mro__ ] ,
get _STR:0_ from the c object , if it doesnt exists return an empty dictionary ,
use the result as the argument for the call to the messages.update [ messages . update ] function . update messages dictionary with error_messages , if it exists , if not do n't update it .
substitute messages for self.error_messages [ self . error_messages ] .
add self.default_validators [ self . default_validators ] and validators , substitute the result for self.validators [ self . validators ] .
call the method __init__ from the base class of the Field class .
define the method prepare_value with arguments : self and value .
return value .
define the method to_python with arguments self and value .
return value .
define the method to_python with arguments self and value .
if value is contained in self.empty_values [ self . empty_values ] and self.required [ self . required ] is true ,
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to string _STR:0_ .
define the method run_validators with arguments self and value .
if value is contained in self.empty_values [ self . empty_values ] ,
return nothing ,
errors is an empty list .
for every v in self.validators [ self . validators ] ,
try
call the function v with an argument value .
if ValidationError , substituted for e , exception is caught ,
if e has an attribute _STR:0_ and e.code [ e . code ] is contained in self.error_messages [ self . error_messages ] ,
get the value under the e.code [ e . code ] key of the self.error_messages [ self . error_messages ] dictionary , substitute the result for e.message [ e . message ] .
extend errors list with e.error_list [ e . error_list ] .
if errors is true ,
raise an ValidationError exception with an argument errors ,
define the method clean with arguments self and value .
call the method self.to_python [ self . to_python ] with an argument value , substitute it for value .
call the method self.validate [ self . validate ] with an argument value .
call the method self.run_validators [ self . run_validators ] with an argument value .
return value .
define the method bound_data with arguments self , data and initial .
return data .
define the method widget_attrs with arguments self and widget .
return is empty dictionary .
define the method get_limit_choices_to with arguments self .
if self.limit_choices_to [ self . limit_choices_to ] object is callable ,
call the method self.limit_choices_to [ self . limit_choices_to ] , return the result ,
return self.limit_choices_to [ self . limit_choices_to ] .
define the method _has_changed with arguments self , initial and data .
substitute initial for initial_value , if initial is not None , if not , initial_value is an empty string .
try ,
call the function self.to_python [ self . to_python ] with an argument data , substitute the result for data .
if self has an attribute _STR:0_ ,
call the method self._coerce [ self . _coerce ] with an argument data , substitute the result for data .
if ValidationError exception is caught ,
return boolean True .
substitute data for data_value if data is not None , otherwise data_value is an empty list .
if initial_value is not equal to data_value , return boolean True , otherwise return boolean False .
define the method __deepcopy__ with arguments self and memo .
call the method copy.copy [ copy . copy ] with an argument self , substitute the result for result .
substitute result for the value of the memo dictionary , with identity of the self object as an key .
call the method copy.deepcopy [ copy . deepcopy ] with arguments self.widget [ self . widget ] and memo , substitute the result for result.widget [ result . widget ] .
substitute elements of self.validators [ self . validators ] list for result.validators [ result . validators ] .
return result .
derive the class CharField from the base class Field class .
define the method __init__ with 5 arguments : self , max_length set to None , min_length set to None , unpacked list args ,
and unpacked dictionary kwargs . substitute max_length and min_length for self.max_length [ self . max_length ] for self.min_length [ self . min_length ] .
call the method __init__ from the base class of the class CharField , with arguments unpacked list args and unpacked dictionary kwargs .
if min_length is not None ,
call the method validators.MinLengthValidator [ validators . MinLengthValidator ] with min_length converted into an integer , append the result to list self.validators [ self . validators ] .
if max_length is not None ,
call the method validators.MaxLengthValidator [ validators . MaxLengthValidator ] with max_length converted into an integer , append the result to list self.validators [ self . validators ] .
define the method to_python with arguments self and value .
if value in self.empty_values [ self . empty_values ] ,
return an empty string .
evaluate the function smart_text with an argument value , return the result .
define the method widget_attrs with arguments self and widget .
call the method widget_attrs from the base class of the class CharField , with an argument widget , substitute the result for attrs .
if self.max_length [ self . max_length ] is not None ,
update attrs dictionary with entry : self.max_length [ self . max_length ] converted into a string for _STR:0_ .
return attrs .
derive the class IntegerField from the base class Field class .
substitute NumberInput for widget .
default_error_messages is an dictionary with an initial entry : result of the function _ called with an argument string ,
_STR:0_ for _STR:1_ . define the method __init__ with 5 arguments : self , max_value set to None , min_value set to None , unpacked list args and unpacked dictionary kwargs .
substitute max_value and min_value for self.max_value [ self . max_value ] and self.min_value [ self . min_value ] .
get the value under the _STR:0_ key of the kwargs dictionary , if it is true and self.widget [ self . widget ] equals to NumberInput ,
if _STR:0_ key of the kwargs dictionary doesnt exists assign it widget field of the base class of the IntegerField class value .
call the method __init__ from the base class of the class IntegerField , with arguments unpacked list args and unpacked dictionary kwargs .
if max_value is not None ,
call the method validators.MaxValueValidator [ validators . MaxValueValidator ] with max_value converted into an integer , append the result to list self.validators [ self . validators ] .
if min_value is not None ,
call the method validators.MinValueValidator [ validators . MinValueValidator ] with min_value converted into an integer , append the result to list self.validators [ self . validators ] .
define the method to_python with arguments self and value .
call the method to_python with an argument value , from the base class of the IntegerField class , substitute the result for value .
if value is contained in self.empty_values [ self . empty_values ] ,
return None .
if self.localize [ self . localize ] is true ,
call the method formats.sanitize_separators [ formats . sanitize_separators ] with an argument value , substitute the result for value .
try ,
convert value into an string , convert the result into an integer and substitute it for value .
if ValueError or TypeError exceptions are caught ,
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to _STR:0_ .
return value
define the method widget_attrs with arguments self and widget .
call the method widget_attrs with an argument widget , from the base class of the class IntegerField , substitute it for attrs .
if widget is an instance of the NumberInput ,
if self.min_value [ self . min_value ] is not None ,
substitute self.min_value [ self . min_value ] for the value under the _STR:0_ key of the attrs dictionary .
if self.max_value [ self . max_value ] is not None ,
substitute self.max_value [ self . max_value ] for the value under the _STR:0_ key of the attrs dictionary .
return attrs .
derive the class FloatField from the base class IntegerField class .
default_error_messages is an dictionary with an initial entry : result of the function _ called with an argument string ,
_STR:0_ for _STR:1_ . define the method to_python with arguments self and value .
call the method to_python with an argument value , from the base class of the IntegerField class , substitute the result for value .
if value is contained in self.empty_values [ self . empty_values ] ,
return None .
if self.localize [ self . localize ] is true ,
call the method formats.sanitize_separators [ formats . sanitize_separators ] with an argument value , substitute the result for value .
try ,
convert value into an floating point number , substitute it for value .
if ValueError or TypeError exceptions are caught ,
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to _STR:0_ .
return value .
define the method validate with arguments self and value .
call the method validate with an argument value , from the base class of the FloatField class .
if value is Nan , or value is contained in return value of the Decimal called twice with string _STR:0_ and with string _STR:1_ ,
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to _STR:0_ .
return value .
define the method widget_attrs with arguments self and widget .
call the method widget_attrs with an argument widget , from the base class of the FloatField class , substitute the result for attrs .
if widget is an instance of the NumberInput class , and string _STR:0_ is not contained in widget.attrs [ widget . attrs ] ,
if _STR:0_ attribute of attrs dictionary does not exists , set it to to string _STR:1_ .
return attrs .
derive the class DecimalField from the base class IntegerField class .
default_error_messages is a dictionary with 4 initial entries : return value of the function _ called with string as an argument ,
_STR:0_ for _STR:1_ , return value of the function ungettext_lazy called with 3 string arguments : _STR:2_ , _STR:3_ , and _STR:4_ for _STR:5_ , return value of the function ungettext_lazy called with 3 string arguments : _STR:6_ , _STR:7_ and _STR:4_ , for _STR:8_ and return value of the function ungettext_lazy called with 3 string arguments : _STR:9_ , _STR:10_ and _STR:4_ for _STR:11_ . define the method __init__ with 7 arguments : self , max_value set to None , min_value set to None , max_digits set to None ,
decimal_places set to None , unpacked list args and unpacked dictionary kwargs . substitute max_digits and decimal_places for self.max_digits [ self . max_digits ] and self.decimal_places [ self . decimal_places ] .
call the method __init__ from the base class of the class DecimalField , with 4 arguments : max_value , min_value ,
unpacked list args and unpacked dictionary kwargs . define the method to_python with arguments self and value .
if value is contained in self.empty_values [ self . empty_values ] ,
return None .
if self.localize [ self . localize ] is true ,
call the method formats.sanitize_separators [ formats . sanitize_separators ] with an argument value , substitute the result for value .
call the function smart_text with an argument value , strip the result of whitespaces from both ends and substitute it for value .
try ,
value is an instance of a class Decimal created with value as an argument .
if DecimalException exception is caught ,
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to _STR:0_ .
return value .
define the method validate with arguments self and value .
call the method validate with an argument value from the base class of the DecimalField class .
if value is contained in self.empty_values [ self . empty_values ] ,
return nothing .
if value is not equal to value or value equals return value of the call to Decimal with argument _STR:0_ ,
or value equals return value of the call to Decimal with argument _STR:0_ raise an ValidationError with 2 arguments : value under the _STR:1_ key of the self.error_messages [ self . error_messages ] dictionary and code set to _STR:1_ .
call the method value.as_tuple [ value . as_tuple ] , assign the result to sign , digittuple and exponent , respectively .
substitute absolute value of the exponent for decimals .
substitute length of digittuple for digits .
if decimals is greater than digits ,
substitute decimals for digits .
subtract decimals from digits , substitute the result for whole_digits .
if self.max_digits [ self . max_digits ] is not None and digits is grater than self.max_digits [ self . max_digits ] ,
raise an ValidationError with 3 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary ,
code set to string _STR:0_ and params set to a dictionary with an entry : self.max_digits [ self . max_digits ] for _STR:1_ . if self.decimal_places [ self . decimal_places ] is not None and decimals is grater than self.decimal_places [ self . decimal_places ] :
raise an ValidationError with 3 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary ,
code set to string _STR:0_ and params set to a dictionary with an entry : self.decimal_places [ self . decimal_places ] for _STR:1_ . if self.max_digits [ self . max_digits ] is not None and self.decimal_places [ self . decimal_places ] is not None and whole_digits is grater than the difference of ,
self.max_digits [ self . max_digits ] and self.decimal_places [ self . decimal_places ] , raise an ValidationError with 3 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary ,
code set to string _STR:0_ and params set to a dictionary with an entry : difference of the self.max_digits [ self . max_digits ] and self.decimal_places [ self . decimal_places ] , for _STR:1_ . return value .
define the method widget_attrs with arguments self and widget .
call the method widget_attrs with an argument widget , from the base class of the DecimalField class , substitute the result for attrs .
if widget is an instance of NumberInput and string _STR:0_ is not contained in widget.attrs [ widget . attrs ] .
if self.decimal_places [ self . decimal_places ] is not None ,
call the object Decimal with string _STR:0_ as an argument , divide it by 10 , bring the result to the power of self.decimal_places [ self . decimal_places ] ,
convert the result to a lowercase string , substitute it for step . if not ,
step is an string _STR:0_ .
if _STR:0_ key of the attrs dictionary doesnt exists assign it step as an value .
return attrs .
derive the class BaseTemporalField from the base class Field class .
define the method __init__ with arguments self , input_formats set to None , unpacked list args and unpacked dictionary kwargs .
call the method __init__ from the base class of the BaseTemporalField class , with arguments : unpacked list args and unpacked dictionary kwargs .
if input_formats is not None ,
substitute input_formats for self.input_formats [ self . input_formats ] .
define the method to_python with arguments self and value .
call the function force_text with arguments value and strings_only set to boolean True , substitute the result for unicode_value .
if unicode_value is an instance of six.text_type [ six . text_type ] ,
strip whitespaces from both ends of unicode_value , substitute the result for value .
if value is an instance of six.text_type [ six . text_type ] class ,
for every format in self.input_formats [ self . input_formats ] ,
try ,
call the method self.strptime [ self . strptime ] with arguments value and format , return the result .
if ValueError or TypeError exceptions are caught ,
skip this loop iteration .
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to _STR:0_ .
define the method strptime with arguments self , value and format .
raise an NotImplementedError with an argument string _STR:0_ .
derive the class DateField from the base class BaseTemporalField class .
substitute DateInput for widget .
call the method formats.get_format_lazy [ formats . get_format_lazy ] with an argument string _STR:0_ , substitute the result for input_formats .
default_error_messages is an dictionary with an entry : return value of the function _ called with an argument string _STR:0_ for _STR:1_ .
define the method to_python with arguments self and value .
if value is contained in self.empty_values [ self . empty_values ] ,
return None .
if value is an instance of datetime.datetime [ datetime . datetime ] class ,
call the method value.date [ value . date ] , return the result .
if value is an instance of datetime.date [ datetime . date ] class ,
return value .
call the method to_python with an argument value from the base class of the DateField class , return the result .
define the method strptime with arguments self , value and format .
call the method datetime.datetime.strptime [ datetime . datetime . strptime ] with 2 arguments : result of the function force_str called with an argument value ,
and format , call the method date on the result , return the result . derive the class TimeField from the base class BaseTemporalField class .
substitute TimeInput for widget .
call the method formats.get_format_lazy [ formats . get_format_lazy ] with an argument string _STR:0_ , substitute the result for input_formats .
default_error_messages is an dictionary with an entry : return value of the function _ called with an argument string _STR:0_ for _STR:1_ .
define the method to_python with arguments self and value .
if value is contained in self.empty_values [ self . empty_values ] ,
return None .
if value is an instance of datetime.time [ datetime . time ] ,
return value ,
call the method to_python with an argument value from the base class of the TimeField class , return the result .
define the method strptime with arguments self , value and format .
call the method datetime.datetime.strptime [ datetime . datetime . strptime ] with 2 arguments : result of the function force_str called with an argument value ,
and format , call the method time on the result , return the result . derive the class DateTimeField from the base class BaseTemporalField class .
substitute DateTimeInput for widget .
call the method formats.get_format_lazy [ formats . get_format_lazy ] with an argument string _STR:0_ , substitute the result for input_formats .
default_error_messages is an dictionary with an entry : return value of the function _ called with an argument string _STR:0_ for _STR:1_ .
define the method prepare_value with arguments self and value .
if value is an instance of datetime.datetime [ datetime . datetime ] ,
call the function to_current_timezone with an argument value , substitute the result for value .
return value .
define the method to_python with arguments self and value .
if value is contained in self.empty_values [ self . empty_values ] ,
return None .
if value is an instance of datetime.datetime [ datetime . datetime ] ,
call the function __current_timezone with an argument value , return the result .
if value is an instance of datetime.date [ datetime . date ] ,
call the function datetime.datetime [ datetime . datetime ] with 3 arguments : value.year [ value . year ] , value.month [ value . month ] and value.day [ value . day ] , substitute the result for result .
call the function from_current_timezone with an argument result , return the result .
if value is an instance of list type ,
call the function warnings.warn [ warnings . warn ] with 3 arguments : string _STR:0_
_STR:0_ , RemovedInDjango19Warning and stacklevel set to integer 2. if length of value is not equal to integer 2 ,
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to _STR:0_ .
if first and second elements of value are contained in self.empty_values [ self . empty_values ] ,
return None .
substitute ' % s ' in string _STR:0_ with the elements of value converted into a tuple , substitute the result for value .
call the method to_python with an argument value from the base class of the DateTimeField class , substitute the result for result .
call the function from_current_timezone with an argument , return the result .
define the method strptime with arguments self , value and format .
call the method datetime.datetime.strptime [ datetime . datetime . strptime ] with 2 arguments : result of the function force_str called with an argument value ,
and format , return the result . derive the class RegexField from the base class CharField class .
define the method __init__ with 7 arguments : self , regex , max_length set to None , min_length set to None , error_message set to None ,
if error_message is not None ,
get the value under the _STR:0_ key of the kwargs dictionary , if it exists substitute it for error_messages , if not ,
error_messages is an empty dictionary . substitute error_message for value under the _STR:0_ key of the error_messages dictionary .
substitute error_messages for value under the _STR:0_error_messages ' key of the kwargs dictionary .
call the method __init__ from the base class of the class RegexField , with 4 arguments : max_length , min_length , unpacked list args ,
unpacked dictionary kwargs . call the method self._set_regex [ self . _set_regex ] with an argument regex .
define the method _get_regex an argument self .
return self._regex [ self . _regex ] .
define the method _set_regex with arguments self and regex .
if regex is an instance of six.string_types [ six . string_types ] class ,
call the function re.compile [ re . compile ] with 2 arguments regex , re.UNICODE [ re . UNICODE ] and substitute the result for regex .
substitute regex for self._regex [ self . _regex ] .
if self has an _STR:0_ attribute and self._regex_validator [ self . _regex_validator ] is contained in self.validators [ self . validators ] ,
remove self._regex_validator [ self . _regex_validator ] from self.validators [ self . validators ] .
call the method validators.RegexValidator [ validators . RegexValidator ] with an argument regex set to regex , substitute it for self._regex_validator [ self . _regex_validator ] .
append self._regex_validator [ self . _regex_validator ] to self.validators [ self . validators ] .
regex is an property object of this class , with _get_regex getter and _set_regex setter function .
derive the class EmailField from the base class CharField class .
substitute EmailInput for widget .
default_validators is a list with an element validators.validate_email [ validators . validate_email ] .
define the method clean with 2 arguments self and value .
call the method self.to_python [ self . to_python ] with an argument value , strip the whitespaces from the both ends of the result and substitute it for value .
call the method clean with an argument value from the base class of the EmailField class .
derive the class FileField from the base class Field class .
substitute ClearableFileInput for widget .
default_error_messages is an dictionary with 5 initial entries : return value of the function _ called with an argument string ,
_STR:0_ for _STR:1_ , return value of the function _ called with an argument , string _STR:2_ for _STR:3_ , return value of the function _ called with an argument _STR:4_ , for _STR:5_ , return value of the function ungettext_lazy called with 3 arguments : string _STR:6_ , string _STR:7_ and string _STR:8_ for _STR:9_ , and return value of the function _ called with an argument string , _STR:10_ for _STR:11_ . define the method __init__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
remove the value under _STR:0_ key from the kwargs dictionary and if the key exists substitute it for self.max_length [ self . max_length ] ,
if not self.max_length [ self . max_length ] is None . remove the value under _STR:0_ key from the kwargs dictionary and if the key exists ,
substitute it for self.allow_empty_file [ self . allow_empty_file ] , if not self.allow_empty_file [ self . allow_empty_file ] is boolean False . call the method __init__ from the base class of the FileField class , with 2 arguments : unpacked list args and unpacked dictionary .
define the method to_python with arguments self and data .
if data in self.empty_values [ self . empty_values ] is true ,
return None .
try ,
substitute data.name [ data . name ] for file_name .
substitute data.size [ data . size ] for file_name .
if AttributeError exception is caught ,
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to _STR:0_ .
if self.max_length [ self . max_length ] is not None and length of file_name is grater than self.max_length [ self . max_length ] ,
params is a dictionary with 2 initial entries : self.max_length [ self . max_length ] for _STR:0_ and length of file_name for _STR:1_ .
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to _STR:0_ .
if file_name is false ,
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to _STR:0_ .
if self.allow_empty_file [ self . allow_empty_file ] and file_size are both false ,
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to _STR:0_ .
return data .
define the method clean with arguments self , data and initial set to None .
if data is bound to the same object as FILE_INPUT_CONTRADICTION ,
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to _STR:0_ .
if data is boolean False ,
if self.required [ self . required ] is false ,
return boolean False .
data is None .
if data is false and initial is true ,
return initial .
call the method clean with an argument data from the base class of the class FileField , return the result .
define the method bound_data with arguments self , data and initial .
if data is not None or FILE_INPUT_CONTRADICTION ,
return initial .
return data .
define the method _has_changed with arguments self , data and initial .
if data is None ,
return is boolean False .
return is boolean True .
derive the class ImageField from the base class FileField class .
default_error_messages is an dictionary with an entry : return value of the function _ called with an argument string ,
_STR:0_ for _STR:1_ . define the method to_python with arguments self and data .
call the method to_python with an argument data from the base class of the class ImageField , substitute the result for f .
if f is None ,
return None .
from PIL import Image into default namespace .
if data has an _STR:0_ attribute ,
substitute the result of the function data.temporary_file_path [ data . temporary_file_path ] for file .
if not ,
if data has an attribute _STR:0_ ,
file is an instance of BytesIO class created with an argument : return value of the method data.read [ data . read ] .
if not ,
file is an instance of BytesIO class created with an argument : value under the _STR:0_ key of the data dictionary .
try ,
call the method Image.open [ Image . open ] with an argument file , on the result call the verify method
if Exception exception is caught ,
call the function six.reraise [ six . reraise ] with 3 arguments : ValidationError , ValidationError created with 2 arguments :
value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to a string _STR:0_ , and third element of the return value of the function sys.exc_info [ sys . exc_info ] . if f has an attribute _STR:1_ and if f.seek [ f . seek ] is an callable object ,
call the method f.seek [ f . seek ] with an argument integer 0 .
return f .
derive the class URLField from the base class CharField class .
substitute URLInput for widget .
default_error_messages is an dictionary with an entry : return value of the function _ called with an argument string _STR:0_ for _STR:1_ .
default_validators is a list with an element , return value of the validators.URLValidator [ validators . URLValidator ] method .
define the method to_python with arguments self and data .
define the function split_url with an argument url .
try ,
call the urlsplit with an argument url , convert the result into a list and return it .
if ValueError exception is caught ,
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to _STR:0_ .
call the method to_python with an argument data from the base class of the class URLField , substitute the result for value .
if value is true ,
call the function split_url with an argument value , substitute the result for url_fields .
if first element of the url_fields is false ,
first element of url_fields is string _STR:0_ .
if second element of url_fields is false ,
substitute third element of url_fields for second element of url_fields .
third element of url_fields is an empty string .
call the function urlunsplit with an argument url_fields , use the result as an argument for the call to the function split_url ,
substitute the result for url_fields . call the function urlunsplit with an argument url_fields , substitute the result for value .
return value .
define the method clean with arguments self and value .
call the method self.to_python [ self . to_python ] with an argument value , strip the whitespaces from the result , substitute it for value .
call the method clean with an argument data from the base class of the class URLField , return the result .
derive the class BooleanField from the base class Field class .
substitute CheckboxInput for widget .
define the method to_python with arguments self and value .
if value is an instance of six.string_types [ six . string_types ] and value converted to lowercase is not equal to strings _STR:0_ or _STR:1_ ,
value is boolean False .
if not ,
convert value into boolean and substitute it for value .
call the method to_python with an argument data from the base class of the class BooleanField , return the result .
define the method validate with arguments self and value .
if value is false and self.required [ self . required ] is true ,
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to _STR:0_ .
define the method _has_changed with arguments self , initial and data .
if initial equals a string _STR:0_ ,
initial is boolean False .
convert initial and data into boolean , if they are not equal return boolean True , if they are return boolean False .
derive the class NullBooleanField from the base class BooleanField class .
substitute NullBooleanSelect for widget .
define the method to_python with arguments self and value .
if value is boolean True , string _STR:0_ or string _STR:1_ ,
return boolean True .
otherwise if value is boolean False , string _STR:0_ or string _STR:1_
return boolean False ,
if not ,
return None .
define the method validate with arguments self and value .
do nothing .
define the method _has_changed with arguments self , initial and data .
if initial is not None ,
convert initial into boolean and substitute it for initial .
if data is not None ,
convert data into boolean and substitute it for data .
if initial is not equal to data , return boolean True , if it is return boolean False .
derive the class ChoiceField from the base class Field class .
substitute Select for widget .
default_error_messages is an dictionary with an entry : return value of the function _ called with an argument string ,
_STR:0_ for _STR:1_ . define the method __init__ with 9 arguments : self , choices set to an empty tuple , required set to boolean True , widget set to None ,
label set to None , initial set to None , help_text set to an empty string , unpacked list args and unpacked dictionary kwargs . call the __init__ method of the base class of the class ChoiceField , called with 7 arguments : required set to required ,
widget set to widget , label set to label , initial set to initial , help_text set to help_text , unpacked list args , and unpacked dictionary kwargs . substitute choices for self.choices [ self . choices ] .
define the method __deepcopy__ with arguments self and memo .
call the method __deepcopy__ with an argument memo from the base class of the class ChoiceField , substitute the result for result .
call the method copy.deepcopy [ copy . deepcopy ] with arguments self._choices [ self . _choices ] and memo , substitute the result for result._choices [ result . _choices ] .
return result .
define the method _get_choices with an argument self .
return self._choices [ self . _choices ] .
define the method _set_choices with arguments self and value .
self._choices [ self . _choices ] and self.widget.choices [ self . widget . choices ] are assigned value converted into a list .
choices is an property object of this class where _get_choices is a getter and _set_choices is a setter function .
define the method to_python with arguments self and value .
if value is contained in self.empty_values [ self . empty_values ] ,
return an empty string .
call the function smart_text with an argument value , return the result .
define the method validate with arguments self and value .
call the method validate with an argument value from the base class of the class ChoiceField .
if value is true and method self.valid_value [ self . valid_value ] called with an argument value evaluates to false ,
raise an ValidationError with 3 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary ,
code set to an string _STR:0_ and dictionary params with an entry : value for _STR:1_ . define the method valid_value with arguments self and value .
call the function force_text with an argument value , substitute the result for text_value .
for every k and v in self.choices [ self . choices ] ,
if v is an instance of list or tuple type ,
for every k2 and v2 in v ,
if value equals k2 or text_value equals return value of the function force_text called with argument k2 ,
return boolean True .
if not ,
if value equals k or text_value equals return value of the function force_text called with argument k ,
return boolean True .
return boolean False .
derive the class TypedChoiceField from the base class ChoiceField class .
define the method __init__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
if _STR:0_ key of the kwargs dictionary exists remove it and substitute its value for self.coerce [ self . coerce ] ,
if not , self.coerce [ self . coerce ] is an identity lambda function with an argument val . if _STR:0_ key of the kwargs dictionary exists remove it and substitute its value for self.empty_value [ self . empty_value ] ,
if not , sself.empty_value [ sself . empty_value ] is an empty string . call the method __init__ with 2 arguments : unpacked list args and unpacked dictionary kwargs ,
from the base class of the class TypedChoiceField . define the method _coerce with arguments self and value .
if value equals self.empty_value [ self . empty_value ] or value is contained in self.empty_values [ self . empty_values ] ,
return self.empty_value [ self . empty_value ] .
try ,
call the function self.coerce [ self . coerce ] with an argument value , substitute it for value .
if ValueError , TypeError or ValidationError exception is caught ,
raise an ValidationError with 3 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary ,
code set to an string _STR:0_ and dictionary params with an entry : value for _STR:1_ . return value .
define the method clean with arguments self and value .
call the method clean with an argument value from the base class of the class TypedChoiceField , substitute the result for value .
call the method self._coerce [ self . _coerce ] with an argument value , return the result .
derive the class MultipleChoiceField from the base class ChoiceField class .
substitute MultipleHiddenInput for hidden_widget .
substitute SelectMultiple for widget .
default_error_messages is an dictionary with an entry : return value of the function _ called with an argument string ,
_STR:0_ for _STR:1_ , and return value of the function _ called with an argument string _STR:2_ for _STR:3_ . define the method to_python with arguments self and value .
if value is false ,
return an empty list .
otherwise if value is not an instance of list ot tuple type ,
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to _STR:0_ .
for every val in value call the function smart_text with an argument val , return the results in a lit .
define the method validate with arguments self and value .
if self.required [ self . required ] is true and value is false ,
raise an ValidationError with 3 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary ,
and code set to an string _STR:0_ . for every val in value ,
call the method self.valid_value [ self . valid_value ] with an argument val , if it evaluates to false ,
raise an ValidationError with 3 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary ,
code set to an string _STR:0_ and dictionary params with an entry : val for _STR:1_ . define the method _has_changed with arguments self , initial and data .
if initial is None ,
initial is an empty list .
if data is None ,
data is an empty list .
if lengths of initial and data are not the same ,
return boolean True .
for every value in initial call the function force_text with an argument value , add the results into a set , substitute the resulting set for initial_set .
for every value in data call the function force_text with an argument value , add the results into a set , substitute the resulting set for data_set .
if data_set is not equal to initial_set , return boolean True , otherwise return boolean False .
derive the class TypedMultipleChoiceField from the base class MultipleChoiceField class .
define the method __init__ with 3 arguments : self unpacked list args and unpacked dictionary kwargs .
if _STR:0_ key of the kwargs dictionary exists remove it and substitute its value for self.coerce [ self . coerce ] ,
if not , self.coerce [ self . coerce ] is an identity lambda function with an argument val . if _STR:0_ key of the kwargs dictionary exists remove it and substitute its value for self.empty_value [ self . empty_value ] ,
if not , self.empty_value [ self . empty_value ] is an empty list . call the method __init__ with 2 arguments : unpacked list args and unpacked dictionary kwargs ,
from the base class of the class TypedMultipleChoiceField . define the method _coerce with arguments self and value .
if value equals self.empty_value [ self . empty_value ] or value is contained in self.empty_values [ self . empty_values ] ,
return self.empty_value [ self . empty_value ] .
new_value is an empty list .
for every choice in value ,
try ,
call the method self.coerce [ self . coerce ] with an argument choice , append the result to new_value .
if ValueError , TypeError or ValidationError exception is caught ,
raise an ValidationError with 3 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary ,
code set to an string _STR:0_ and dictionary params with an entry : choice for _STR:1_ . return new_value .
define the method clean with arguments self and value .
call the method clean with an argument value from the base class of the class TypedMultipleChoiceField , substitute the result for value .
call the method self._coerce [ self . _coerce ] with an argument value , return the result .
define the method validate with arguments self and value .
if value is not equal self.empty_value [ self . empty_value ] ,
call the method validate with an argument value from the base class of the class TypedMultipleChoiceField .
otherwise if self.required [ self . required ] is true ,
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to _STR:0_ .
derive the class ComboField from the base class Field class .
define the method __init__ with arguments : self , fields set to an empty tuple , unpacked list args and unpacked dictionary kwargs .
call the method __init__ with 2 arguments : unpacked list args and unpacked dictionary kwargs , from the base class of the class ComboField .
for every f in fields ,
f.required [ f . required ] is boolean False .
substitute fields for self.fields [ self . fields ] .
define the method clean with arguments self and value .
call the method clean with an argument value from the base class of the class ComboField .
for every field in self.fields [ self . fields ] ,
call the method field.clean [ field . clean ] with an argument value , substitute the result for value .
return value .
derive the class MultiValueField from the base class Field class .
default_error_messages is an dictionary with 2 entries : return value of the function _ called with an argument string ,
_STR:0_ for _STR:1_ and return value of the function _ called with an argument string , _STR:2_ for _STR:3_ . define the method __init__ with arguments self , fields set to an empty ilst , unpacked list args and unpacked dictionary kwargs .
if _STR:0_ key of the kwargs dictionary exists remove it and substitute its value for self.require_all_fields [ self . require_all_fields ] ,
if not , self.require_all_fields [ self . require_all_fields ] is boolean True . call the method __init__ with 2 arguments : unpacked list args and unpacked dictionary kwargs , from the base class of the class MultiValueField .
for every f in fields ,
if _STR:0_ key of the f.error_messages [ f . error_messages ] doesnt exists , assign it the value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary .
if self.require_all_fields [ self . require_all_fields ] is true ,
f.required [ f . required ] is boolean False .
substitute fields for self.fields [ self . fields ] .
define the method __deepcopy__ with arguments self and memo .
call the method __deepcopy__ with an argument memo , from the base class of the class MultiValueField , substitute the result for result .
for every x in self.fields [ self . fields ] call the method x.__deepcopy__ [ x . __deepcopy__ ] with an argument memo , put the result into a tuple , substitute it for result.fields [ result . fields ] .
return result .
define the method validate with arguments self and value .
do nothing .
define the method clean with arguments self and value .
clean_data is an empty list .
errors is an empty list .
if value is false or value is not an instance of list or tuple types ,
if value is false or for every v in value every v is contained in self.empty_values [ self . empty_values ] ,
if self.required [ self . required ] is true ,
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to _STR:0_ .
if not ,
call the function self.compress [ self . compress ] with empty list as an argument , return the result .
if not ,
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to _STR:0_ .
for every i and field in enumerated iterable self.fields [ self . fields ] ,
try ,
substitute i-th element of value for field_value .
if IndexError exception is caught ,
field_value is None .
if field_value is cotained in self.empty_values [ self . empty_values ] ,
if self.require_all_fields [ self . require_all_fields ] is boolean true ,
if self.required [ self . required ] is boolean true ,
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to _STR:0_ .
otherwise if field.required [ field . required ] is true ,
get the value under the _STR:0_ key of the field.error_messages [ field . error_messages ] dictionary , if it is not contained in errors ,
get the value under the _STR:0_ key of the field.error_messages [ field . error_messages ] dictionary , append it to errors .
skip this loop iteration ,
try ,
call the method field.clean [ field . clean ] with an argument field_value , append the result to clean_data .
if ValidationError , renamed to e , is caught ,
extend errors list with m for every m in e.error_list [ e . error_list ] , only if m is not in errors .
if errors is true ,
raise an ValidationError with an argument errors .
call the method self.compress [ self . compress ] with an argument clean_data , substitute the result for out .
call the method self.validate [ self . validate ] with an argument out .
call the method self.run_validators [ self . run_validators ] with an argument out .
return out .
define the method compress with arguments self and data_list .
raise an NotImplementedError with an argument string _STR:0_ .
define the method has_changed with arguments self , initial and data .
if initial is None ,
for every x in sequence of integer from integer 0 to length of data , append an empty string to a list , substitute the resulting list for initial .
if not ,
if initial is not an instance of the list type ,
call the method self.widget.decompress [ self . widget . decompress ] with an argument initial , substitute the result for initial .
for every field , initial and data in list of tuples tuple containing elements of self.fields [ self . fields ] , initial and data , respectively ,
call the method field._has_changed [ field . _has_changed ] with 2 arguments : return value of the function field.to_python [ field . to_python ] called with an argument initial ,
and data , if it evaluates to true , return boolean True .
return boolean False .
derive the class FilePathField from the base class ChoiceField class .
define the method __init__ with 13 arguments : self , path , match set to None , recursive set to boolean False ,
allow_files set to boolean True , allow_folders set to boolean False , required set to boolean True , widget set to None , label set to None , initial set to None , help_text set to an empty string , unpacked list args , unpacked dictionary kwargs . substitute path , match and recursive for self.path [ self . path ] , self.match [ self . match ] and self.recursive [ self . recursive ] .
substitute allow_files and allow_folders for self.allow_files [ self . allow_files ] and self.allow_folders [ self . allow_folders ] .
call the __init__ method of the base class of the class FilePathField , with arguments : choices set to an empty tuple,4
required set to required , widget set to widget , label set to label , initial st to initial , help_text set to help_text , unpacked list args , unpacked dictionary kwargs . if self.required [ self . required ] is true ,
self.choices [ self . choices ] is an empty list .
if not ,
self.choices [ self . choices ] is an list containing an tuple with 2 elements : an empty string and string _STR:0_ .
if self.match [ self . match ] is not None ,
compile self.match [ self . match ] regular expression , substitute it for self.match_re [ self . match_re ] .
if recursive is true ,
for root , dirs and files in sorted list of the directory tree starting from the directory self.path [ self . path ] ,
if self.allow_files [ self . allow_files ] is true ,
for every f in files ,
if self.match [ self . match ] is None or call to the method self.match_re.search [ self . match_re . search ] with an argument f , evaluated to true ,
join root and f into a file , substitute it for f .
append a tuple with 2 elements : f and f with first occurrence of the path replaced with an empty string , to self.choices [ self . choices ] .
if self.allow_folders [ self . allow_folders ] is true ,
for every f in files ,
if f equals to string _STR:0_ ,
skip this loop execution .
if self.match [ self . match ] is None or call to the method self.match_re.search [ self . match_re . search ] with an argument f , evaluated to true ,
join root and f in path , substitute the result for f .
append a tuple with 2 elements : f and f with first occurrence of the path replaced with an empty string , to self.choices [ self . choices ] .
if not ,
try ,
for f in sorted list of the files in the self.path [ self . path ] directory ,
if f equals to string _STR:0_ ,
skip this loop execution .
join self.path [ self . path ] and f in path , substitute the result for full_file .
if self.allow_files [ self . allow_files ] is true and full_file is a file , or if self.allow_folders [ self . allow_folders ] is true and full_file is an directory ,
and only if self.match [ self . match ] is None or return value of the method self.match_re.search [ self . match_re . search ] called with an argument f is true . append a tuple containing 2 elements : full_file and f to self.choices [ self . choices ] list .
if OSError exception is caught ,
do nothing .
substitute self.choices [ self . choices ] for self.widgetchoices [ self . widgetchoices ] .
derive the class SplitDateTimeField from the base class MultiValueField class .
substitute SplitDateTimeWidget for widget .
substitute SplitHiddenDateTimeWidget for hidden_widget .
default_error_messages is an dictionary with 2 entries : return value of the function _ called with an string _STR:0_ ,
for _STR:0_ and return value of the function _ called with an string _STR:1_ , for 'invalid_time . define the method __init__ with 3 arguments : self , input_date_formats set to None , input_time_formats set to None ,
and errors set to the result of self.default_error_messages.copy [ self . default_error_messages . copy ] .
if _STR:0_ is contained in kwargs ,
get the value under the _STR:0_ key of the kwargs dictionary , update errors dictionary with it .
get the value under the _STR:0_ key of the kwargs dictionary , substitute it for localize , if the key doesnt exists , substitute the result for localize .
fields is an tuple containing instances of the class DateField , created with 3 arguments : input_formats set to input_date_formats ,
error_messages as an dictionary with an entry : value under the _STR:0_ of errors dictionary for _STR:1_ , localize set to localize , and an instance of the class TimeField created with 3 arguments : input_formats set to input_time_formats , error_messages as an dictionary with an entry : value under the _STR:2_ of errors dictionary for _STR:1_ , localize set to localize call the __init__ method with fields , unpacked list args and unpacked dictionary kwargs from the base class of the SplitDateTimeField class .
define the method compress with arguments self and data_list .
if data_list is true ,
if first element of data_list is contained in self.empty_values [ self . empty_values ] ,
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to string _STR:0_ .
if second element of data_list is contained in self.empty_values [ self . empty_values ] ,
raise an ValidationError with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary and code set to string _STR:0_ .
call the method datetime.datetime.combine [ datetime . datetime . combine ] with unpacked list data_list , substitute the result for result .
call the method from_current_timezone with an argument result , return the result .
return None .
derive the class IPAddressField from the base class CharField class .
default_validators is an list containing validators.validate_ipv4_address [ validators . validate_ipv4_address ] .
define the method __init__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
call the function warnings.warn [ warnings . warn ] with 2 arguments string _STR:0_ ,
and RemovedInDjango19Warning . call the __init__ method with unpacked list args and unpacked dictionary kwargs from the base class of the IPAddressField class .
define the method to_python with arguments self and value .
if value is contained in self.empty_values [ self . empty_values ] ,
return an empty string .
strip whitespaces from both sides of the value , return the result .
derive the class GenericIPAddressField from the base class CharField class .
define the method __init__ with 5 arguments : self , protocol set to string _STR:0_ , unpack_ipv4 set to boolean False ,
unpacked list args , unpacked dictionary kwargs . substitute unpack_ipv4 for self.unpack_ipv4 [ self . unpack_ipv4 ] .
call the method validators.ip_address_validators [ validators . ip_address_validators ] with arguments protocol , unpack_ipv4 , substitute first element of the result for self.default_validators [ self . default_validators ] .
call the __init__ method with unpacked list args and unpacked dictionary kwargs from the base class of the GenericIPAddressField class .
define the method to_python with arguments self and value .
if value is contained in self.empty_values [ self . empty_values ] ,
return an empty string .
strip whitespaces from both sides of the value , substitute it for value .
if value is true and character _STR:0_ is contained in value ,
call the function clean_ipv6_address with arguments value and self.unpack_ipv4 [ self . unpack_ipv4 ] , return the result .
return value .
derive the class SlugField from the base class CharField class .
default_validators is an list containing validators.validate_slug [ validators . validate_slug ] .
define the method clean with arguments self and value .
call the self.to_python [ self . to_python ] method with an argument value , strip the result of the whitespaces from the sides , substitute the result for value .
call the clean method wiht value argument from the base class of the SlugField class , return the result .
from __future__ import unicode_literals into default name space .
from collections import OrderedDict into default name space .
import module copy .
import module datetime .
import module warnings .
from django.core.exceptions [ django . core . exceptions ] import ValidationError and NON_FIELD_ERRORS into default name space .
from django.forms.fields [ django . forms . fields ] import Field and FileField into default name space .
from django.forms.utils [ django . forms . utils ] import flatatt , ErrorDict and ErrorList into default name space .
from django.forms.widgets [ django . forms . widgets ] import Media , MediaDefiningClass , TextInput and Textarea into default name space .
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
from django.utils.encoding [ django . utils . encoding ] import smart_text , force_text and python_2_unicode_compatible into default name space .
from django.utils.html [ django . utils . html ] import conditional_escape and format_html into default name space .
from django.utils.safestring [ django . utils . safestring ] import mark_safe into default name space .
from django.utils.translation [ django . utils . translation ] import ugettext as _ into default name space .
from django.utils [ django . utils ] import six into default name space .
__all__is an tuple with 2 elements : strings _STR:0_ and _STR:1_ .
define the function pretty_name with an argument name .
if name is false ,
return an empty string .
replace all the occurrences of character _STR:0_ in name with a whitespace , capitalize the first letter and return the result .
define the function get_declared_fields with 3 arguments : bases , attrs and with_base_fields set to boolean True .
call the function warnings.warn [ warnings . warn ] with 3 arguments : string _STR:0_ ,
RemovedInDjango19Warning , stacklevel set to integer 2. for field_name every obj in list created from the elements of the return value of the function six.iteritems [ six . iteritems ] with an argument attrs .
if obj is an instance of Field , append to a list a tuple with 2 elements : field_name , and poped value under the field_name key of the attrs dictionary , substitute the resulting list for fields . sort fields elements with key being a lambda function with argument x and return value creation_counter filed of first element of x .
if with_base_fields is true ,
for every base in reversed order of bases ,
if base has an attribute _STR:0_ .
call the method six.iteritems [ six . iteritems ] with an argument base.base_fields [ base . base_fields ] , convert it to a list and append fields to it , substitute the result for fields .
if not ,
for every base in reversed order of bases ,
if base has an _STR:0_ attribute ,
call the method six.iteritems [ six . iteritems ] with an argument base.declared_fields [ base . declared_fields ] , convert it to a list and append fields to it , substitute the result for fields .
return an instance of OrderedDict class , created with an argument fields .
derive the class DeclarativeFieldsMetaclass from the base class MediaDefiningClass .
define the method __new__ with 4 arguments : mcs , name , bases and attrs .
current_fields is an empty list .
for every key and value in list created out of the elements of the result of the call to the method attrs.items [ attrs . items ] ,
if value is an instance of Field class ,
append a tuple with elements key and value to current_fields .
remove entry at the key key of the attrs dictionary .
sort current_fields elements with key being a lambda function with argument x and return value creation_counter filed of first element of x .
value under the _STR:0_ key of the attrs dictionary is an instance of OrderedDict class , created with an argument current_fields .
call the method __new__ from the base class of the class DeclarativeFieldsMetaclass , with 4 arguments : mcs , name , bases and attrs .
declared_fields is an instance of OrderedDict class .
for every base in new_class.__mro__ [ new_class . __mro__ ] in reversed order ,
if base has an attribute _STR:0_ ,
update declared_fields dictionary with entry base.declared_fields [ base . declared_fields ] .
call the method base.__dict__.items [ base . __dict__ . items ] , for every attr and value in the result ,
if value is None and attr is contained in declared_fields ,
remove entry at the attr key of the declared_fields dictionary .
substitute declared_fields for new_class.base_fields [ new_class . base_fields ] .
substitute declared_fields for new_class.declared_fields [ new_class . declared_fields ] .
return new_class .
python_2_unicode_compatible decorator ,
derive the class BaseForm from the base class object .
define the method __init__ with 4 arguments : self , data set to None , files set to None , auto_id is an string _STR:0_ , prefix is None ,
initial set to None , error_class set to ErrorList , label_suffix set to None , empty_permitted set to boolean False . if data is not None or files is not None , self.is_bound [ self . is_bound ] is boolean True , otherwise it is boolean False .
if data is true , substitute it for self.data [ self . data ] , if not self.data [ self . data ] is an empty dictionary .
if files is true , substitute it for self.files [ self . files ] , if not self.files [ self . files ] is an empty dictionary .
substitute auto_id for self.auto_id [ self . auto_id ] .
substitute prefix for self.prefix [ self . prefix ] .
if initial is true , substitute it for self.initial [ self . initial ] , if not self.files [ self . files ] is an empty dictionary .
substitute .error_class for self.error_class [ self . error_class ] .
if label_suffix is not None substitute label_suffix for self.label_suffix [ self . label_suffix ] ,
otherwise substitute return value of the function _ called with an argument _STR:0_ for self.label_suffix [ self . label_suffix ] . substitute empty_permitted for self.empty_permitted [ self . empty_permitted ] .
self._errors [ self . _errors ] is None .
self._changed_data [ self . _changed_data ] is None .
call the function copy.deepcopy [ copy . deepcopy ] with an argument self.base_fields [ self . base_fields ] , substitute the result for self.fields [ self . fields ] .
define the method __str__ with an argument self .
call the method self.as_table [ self . as_table ] , return the result .
define the method __iter__ with an argument self .
for every name in self.fields [ self . fields ] ,
get the value under the name key of the self dictionary , yield it as the return value of the generator .
define the method __getitem__ with 2 arguments : self and name .
try ,
get the value under the name key of the self.fields [ self . fields ] dictionary , substitute it for field .
if KeyError exception is caught ,
raise an KeyError with an argument string _STR:0_ , substitute ' % s ' with name and self.__class__.__name__ [ self . __class__ . __name__ ] .
return an instance of BoundField class , created with arguments self , field and name .
property decorator ,
define the method errors with an argument self .
if self._errors [ self . _errors ] is None ,
call the method self.full_clean [ self . full_clean ] .
return self._errors [ self . _errors ] .
define the method is_valid with an argument self .
if self.is_bound [ self . is_bound ] is true and self.errors [ self . errors ] is false , return boolean True , otherwise return boolean False .
define the method add_prefix with 2 arguments : self and field_name .
substitute ' % s ' in string _STR:0_ with self.prefix [ self . prefix ] and field_name and return it , if self.prefix [ self . prefix ] is true , if not return field_name .
define the method add_initial_prefix with 2 arguments : self and field_name .
return string _STR:0_ where ' % s ' is replaced with return value of the self.add_prefix [ self . add_prefix ] method called with an argument field_name .
define the method _html_output with 6 arguments : self , normal_row , error_row , row_ender , help_text_html and errors_on_separate_row .
call the method self.non_field_errors [ self . non_field_errors ] , substitute the result for top_errors .
output and hidden_fields are both empty lists .
call the method self.fields.items [ self . fields . items ] , for every name and field in return value ,
html_class_attr is an empty string .
substitute value under the name key for bf .
call the method self.error_class [ self . error_class ] with an argument list containing results of the function conditional_escape ,
called with an argument error , for every error in bf.errors [ bf . errors ] , substitute the result for bf_errors . if bf.is_hidden [ bf . is_hidden ] is true ,
if bf_errors is true ,
call the function _ with an argument string _STR:0_ , where _STR:1_ is replaced with name ,
and _STR:0_ is replaced with return value of the force_text function called with an argument e , extend the top_errors with the result . call the function six.text_type [ six . text_type ] with an argument bf , append the result to hidden_fields .
if not ,
call the method bf.css_classes [ bf . css_classes ] , substitute the result for css_classes .
if css_classes is true ,
replace `` % s '' from the string _STR:0_ with css_classes , substitute it for html_class_attr .
if errors_on_separate_row and bf_errors are both true ,
call the function force_text with an argument bf_errors , format the error_row string with the result , append it to the output .
if bf.label [ bf . label ] is true ,
call the function force_text with an argument bf.label [ bf . label ] , use the result as an argument for the call to the function conditional_escape , substitute the result label .
call the function bf.label_tag [ bf . label_tag ] with an argument label , if the result is true substitute it for label , otherwise label is an empty string .
if not ,
label is an empty string .
if field.help_text [ field . help_text ] is true ,
call the function force_text with an argument field.help_text [ field . help_text ] , format help_text_html with it , substitute the result for help_text .
if not ,
label is an empty string .
format string normal_row with an dictionary containing 6 entries : return value of the function force_text with an argument bf_errors ,
for _STR:0_ , return value of the function force_text with an argument label for _STR:1_ , return value of the function six.text_type [ six . text_type ] , with an argument bf , for _STR:2_ , help_text for help_text , html_class_attr for _STR:3_ and bf.html_name [ bf . html_name ] for _STR:4_ . if top_errors is true ,
call the function force_text with an argument top_errors , format error_row with it , insert it at the beginning of output .
if hidden_fields is true ,
join hidden_fields elements into a string , without separation , substitute the result for str_hidden .
if output is true ,
substitute last element of output for last_row .
if last_row doesnt ends with row_ender ,
format string normal_row with an dictionary containing 5 entries : an empty string for _STR:0_ , empty string for _STR:1_ ,
empty string for _STR:0_ , empty string for _STR:1_ and html_class_attr for html_class_attr . append last_row to output .
create list out of last_row elements from the start to the last length of row_ender element , append str_hidden and row_ender to it ,
substitute the result for last element of output . if not ,
append str_hidden to output .
join elements of output into a string with newline as separator , use it as an argument for the call to the function mark_safe , return it .
define the method as_table with an argument self .
return the result of the method self._html_output [ self . _html_output ] , called with 5 arguments : normal_row to a string ,
_STR:0_ , error_row set to a a string , _STR:1_ , row_ender set to a string _STR:2_ , help_text_html set to a string , _STR:3_ and errors_on_separate_row set to boolean False . define the method as_ul with an argument self .
return the result of the method self._html_output [ self . _html_output ] , called with 5 arguments : normal_row to a string ,
_STR:0_ , error_row set to a a string _STR:1_ , row_ender set to a string _STR:2_ , help_text_html set to a string , _STR:3_ , and errors_on_separate_row set to boolean False . define the method as_p with an argument self .
return the result of the method self._html_output [ self . _html_output ] , called with 5 arguments : normal_row to a string ,
_STR:0_ , error_row set to a a string ' % s ' , row_ender set to a string _STR:1_ , help_text_html set to a string , < span class=_STR:2_ > % s < /span > ' and errors_on_separate_row set to boolean True . define the method non_field_errors with an argument self .
return the result of the method self.errors.get [ self . errors . get ] called with 2 arguments : NON_FIELD_ERRORS and return value of the method ,
self.error_class [ self . error_class ] called with an argument error_class set to string _STR:0_ . define the method _raw_value with 2 arguments : self and fieldname .
substitute the value under the fieldname key of the self.fields [ self . fields ] dictionary for field .
call the method self.add_prefix [ self . add_prefix ] with an argument fieldname , substitute it for prefix .
return the result of the method field.widget.value_from_datadict [ field . widget . value_from_datadict ] called with 3 arguments : self.data [ self . data ] , self.files [ self . files ] and prefix .
define the method add_error with 3 arguments : self , field and errors .
if error is not an instance of ValidationError ,
error is an instance of ValidationError created with an argument error .
if error has an attribute _STR:0_ ,
if field is not None ,
raise an TypeError with an argument string _STR:0_ .
if not ,
substitute error.error_dict [ error . error_dict ] for error .
if not ,
error is an dictionary with an initial entry error.error_list [ error . error_list ] for filed if true , or NON_FIELD_ERRORS if not .
call the method error.items [ error . items ] , for every field and error_list in the result ,
if field is not contained in self.errors [ self . errors ] ,
if field is not equal to NON_FIELD_ERRORS and field is not contained in self.fields [ self . fields ] ,
raise an ValueError with an argument string _STR:0_ , with ' % s ' replaced with self.__class__.__name__ [ self . __class__ . __name__ ] and field , respectively .
if field equals NON_FIELD_ERRORS ,
call the method self.error_class [ self . error_class ] with an argument error_class as an string _STR:0_ ,
substitute the result for value under the field key of the self._errors [ self . _errors ] dictionary . if not ,
call the method self.error_class [ self . error_class ] , substitute the result for value under the field key of the self._errors [ self . _errors ] dictionary .
extend the value under the field key of the self._errors [ self . _errors ] dictionary with error_list .
if field is contained in self.cleaned_data [ self . cleaned_data ] ,
delete the entry of self.cleaned_data [ self . cleaned_data ] dictionary under the key field .
define the method has_error with 3 arguments : self , field and code set to None .
if code is None ,
if field is contained in self.errors [ self . errors ] return boolean True , if not , return boolean False .
if field is contained in self.errors [ self . errors ] ,
call the method self.errors.as_data [ self . errors . as_data ] , for every error for value under the filed key of the returned dictionary ,
if error.code [ error . code ] equals code ,
return boolean True .
return boolean False .
define the method full_clean with an argument self .
self._errors [ self . _errors ] is an instance of ErrorDict .
if self.is_bound [ self . is_bound ] is false ,
return nothing .
self.cleaned_data [ self . cleaned_data ] is an empty dictionary .
if self.empty_permitted [ self . empty_permitted ] is true and call to the method self.has_changed [ self . has_changed ] evaluates to false ,
return nothing .
call the method self._clean_fields [ self . _clean_fields ] .
call the method self._clean_form [ self . _clean_form ] .
call the method self._post_clean [ self . _post_clean ] .
define the method _clean_fields with an argument self .
call the method self.fields.items [ self . fields . items ] , for every name and field in result ,
call the method field.widget.value_from_datadict [ field . widget . value_from_datadict ] with 3 arguments : self.data [ self . data ] , self.files [ self . files ] and return value of the method ,
self.add_prefix [ self . add_prefix ] called with an argument name , substitute the result for value . try ,
if field is an instance of FileField ,
get the value under the name key of the self.initial [ self . initial ] dictionary , if it exists substitute it for initial ,
if not substitute field.initial [ field . initial ] for initial . call the method filed.clean [ filed . clean ] with arguments value and initial , substitute the result for value .
if not ,
call the method field.clean [ field . clean ] with an argument value , substitute the result for value .
substitute value for the value under the name key of the self.cleaned_data [ self . cleaned_data ] dictionary .
if self has an attribute _STR:0_ , where ' % s ' is replaced with name ,
get _STR:0_ , where ' % s ' is replaced with name ' attribute of the self object , call the result as an function ,
substitute the result for value . substitute value for the value under the name key of the self.cleaned_data [ self . cleaned_data ] dictionary .
if ValidationError renamed to e , exception is caught ,
call the method self.add_error [ self . add_error ] with 2 arguments name and e .
define the method _clean_form with an argument self .
try ,
call the method self.clean [ self . clean ] , substitute the result for cleaned_data .
if ValidationError renamed to e , exception is caught ,
call the method self.add_error [ self . add_error ] with 2 arguments None and e .
if not ,
if cleaned_data is not None ,
substitute cleaned_data for self.cleaned_data [ self . cleaned_data ] .
define the method _post_clean with an argument self .
do nothing .
define the method clean with an argument self .
return self.cleaned_data [ self . cleaned_data ] .
define the method has_changed with an argument self .
convert self.changed_data [ self . changed_data ] into boolean , return it .
property decorator ,
define the method changed_data with an argument self .
if self._changed_data [ self . _changed_data ] is None ,
self._changed_data [ self . _changed_data ] is an empty list .
call the method self.fields.items [ self . fields . items ] , for every name and field in the result ,
call the method self.add_prefix [ self . add_prefix ] with an argument name , substitute the result for prefixed_name .
call the method field.widget.value_from_datadict [ field . widget . value_from_datadict ] with 3 arguments : self.data [ self . data ] , self.files [ self . files ] , prefixed_name , substitute the result for data_value .
if field.show_hidden_initial [ field . show_hidden_initial ] is false ,
get the value under the name key of the self.initial [ self . initial ] dictionary , if it exists substitute it for initial_value ,
if not substitute field.initial [ field . initial ] for initial_value . if initial_value is an callable object ,
call the function initial_value , substitute the result for initial_value .
if not ,
call the method self.add_initial_prefix [ self . add_initial_prefix ] with an argument name , substitute the result for initial_prefixed_name .
call the method field.hidden_widget [ field . hidden_widget ] , substitute the result for field.hidden_widget [ field . hidden_widget ] .
try ,
call the method ( hidden_widget.value_from_datadict [ hidden_widget . value_from_datadict ] with 3 arguments : self.data [ self . data ] , self.files [ self . files ] and initial_prefixed_name ,
use the result as an argument for the call to the field.to_python [ field . to_python ] method , substitute the result for initial_value . if ValidationError exception is caught ,
append name to self._changed_data [ self . _changed_data ] .
skip this loop iteration .
call the method field._has_changed [ field . _has_changed ] with 2 arguments : initial_value and data_value , if it evaluates to true ,
append name to self._changed_data [ self . _changed_data ] list .
return self._changed_data [ self . _changed_data ] .
property decorator ,
define the method media with an argument self .
media is an instance of Media class .
call the method self.fields.values [ self . fields . values ] , for every field in result ,
append field.widget.media [ field . widget . media ] to media , substitute the result for media .
return media .
define the method is_multipart with an argument self .
call the method self.fields.values [ self . fields . values ] , for every field in result ,
if field.widget.needs_multipart_form [ field . widget . needs_multipart_form ] is true ,
return boolean True .
return boolean False .
define the method hidden_fields with an argument self .
for field in self if field.is_hidden [ field . is_hidden ] is true , append field to a list , return the resulting list .
define the method visible_fields with an argument self .
for field in self if field.is_hidden [ field . is_hidden ] is false , append field to a list , return the resulting list .
derive the class Form from the base classes DeclarativeFieldsMetaclass and BaseForm .
decorator python_2_unicode_compatible ,
derive the class BoundField from the base class object .
define the method __init__ with 4 arguments : self , form , field and name .
substitute form for self.form [ self . form ] .
substitute field for self.field [ self . field ] .
substitute name for self.name [ self . name ] .
call the method form.add_prefix [ form . add_prefix ] with an argument self , substitute the result for self.html_name [ self . html_name ] .
call the method form.add_initial_prefix [ form . add_initial_prefix ] with an argument name , substitute the result for self.html_initial_name [ self . html_initial_name ] .
call the method form.add_initial_prefix [ form . add_initial_prefix ] with an argument self.auto_id [ self . auto_id ] , substitute the result for self.html_initial_id [ self . html_initial_id ] .
if self.field.label [ self . field . label ] is None ,
call the method pretty_name with an argument name , substitute the result for self.label [ self . label ] .
if not ,
substitute self.field.label [ self . field . label ] for self.label [ self . label ] .
if field.help_text [ field . help_text ] is true , substitute field.help_text [ field . help_text ] for self.help_text [ self . help_text ] , if not self.help_text [ self . help_text ] is an empty string .
define the method __str__ with an argument self .
if self.field.show_hidden_initial [ self . field . show_hidden_initial ] is true ,
call the method self.as_hidden [ self . as_hidden ] with an argument only_initial set to boolean True ,
append the result to the result of the method , self.as_widget [ self . as_widget ] , return the resulting string . call the method self.as_widget [ self . as_widget ] , return the result .
define the method __iter__ with an argument self .
get the value under the _STR:0_ key of the self.field.widget.attrs [ self . field . widget . attrs ] dictionary , if the key exists substitute it for id_ ,
if not , substitute self.auto_id [ self . auto_id ] for id_ . if if_is true attrs is an dictionary with initial entry : id_ for _STR:0_ , if not , attrs is an empty dictionary .
call the method self.field.widget.subwidgets [ self . field . widget . subwidgets ] with 3 arguments : self.html_name [ self . html_name ] , return value of the method self.value [ self . value ] and attrs ,
for every subwidget in the result , yield subwidget , as the result of the generator .
define the method __len__ with an argument self .
convert result of the method self.__iter__ [ self . __iter__ ] into a list , return its length .
define the method __getitem__ with 2 arguments : self and idx .
convert result of the method self.__iter__ [ self . __iter__ ] into a list , return element at the idx index .
property decorator ,
define the method errors with an argument self .
get the value under the self.name [ self . name ] key of the self.form.errors [ self . form . errors ] dictionary , if the key exists , return it ,
if not evaluate the method self.form.error_class [ self . form . error_class ] and return the result . define the method as_widget with 4 arguments : self , widget set to None , attrs set to None , only_initial set to boolean False .
if widget is false ,
substitute self.field.widget [ self . field . widget ] for widget .
if self.field.localize [ self . field . localize ] is true ,
widget.is_localized [ widget . is_localized ] is boolean True .
if attrs is false , make it an empty dictionary .
substitute self.auto_id [ self . auto_id ] for auto_id .
if auto_id is true and _STR:0_ is not contained in attrs and _STR:0_ is not contained in widget.attrs [ widget . attrs ] ,
if only_initial is false ,
substitute auto_id for value under the _STR:0_ key of the attrs dictionary .
if not ,
substitute self.html_initial_id [ self . html_initial_id ] for value under the _STR:0_ key of the attrs dictionary .
if only_initial is false ,
substitute self.html_name [ self . html_name ] for name .
if not ,
substitute self.html_initial_name [ self . html_initial_name ] for name .
call the method widget.render [ widget . render ] with 3 arguments : name , return value of the method self.value [ self . value ] , attrs set to attrs ,
use it as an argument for the call to the function force_text , return the result . define the method as_text with 3 arguments : self , attrs set to None and unpacked dictionary kwargs .
call the method self.as_widget [ self . as_widget ] with 3 arguments : instance of a class TextInput , attrs and unpacked dictionary kwargs , return the result .
define the method as_textarea with 3 arguments : self , attrs set to None and unpacked dictionary kwargs .
call the method self.as_widget [ self . as_widget ] with 3 arguments : instance of a class Textarea , attrs and unpacked dictionary kwargs , return the result .
define the method as_hidden with 3 arguments : self , attrs set to None and unpacked dictionary kwargs .
call the method self.as_widget [ self . as_widget ] with 3 arguments : return value of the method self.field.hidden_widget [ self . field . hidden_widget ] , attrs ,
and unpacked dictionary kwargs , return the result . property decorator ,
define the method data with an argument self .
call the method self.field.widget.value_from_datadict [ self . field . widget . value_from_datadict ] with 3 arguments : self.form.data [ self . form . data ] , self.form.files [ self . form . files ] , self.html_name [ self . html_name ] , return the result .
define the method value with an argument self .
if self.form.is_bound [ self . form . is_bound ] is false ,
get the value under the self.name [ self . name ] key of the self.form.initial [ self . form . initial ] dictionary , if it exists , substitute it for data ,
if not , substitute self.field.initial [ self . field . initial ] for data . if data is an callable object ,
call the method data , substitute the result for data .
if data is an instance of datetime.datetime [ datetime . datetime ] or datetime.time [ datetime . time ] classes , and supports_microseconds field of self.field.widget [ self . field . widget ] is false ,
call the method data.replace [ data . replace ] with an argument microsecond set to integer 0 , substitute the result for data .
if not ,
call the method self.field.bound_data [ self . field . bound_data ] with 2 arguments : self.data [ self . data ] and value under the self.name [ self . name ] key of the dictionary ,
self.form.initial [ self . form . initial ] , if it exists , or self.field.initial [ self . field . initial ] if not , substitute the result for data . call the method self.field.prepare_value [ self . field . prepare_value ] with an argument data , return the result .
define the method label_tag with 4 arguments : self , contents set to None , attrs set to None and label_suffix set to None .
if contents is false , substitute self.label [ self . label ] for contents .
if label_suffix is None ,
if self.field.label_suffix [ self . field . label_suffix ] is not None , substitute self.field.label_suffix [ self . field . label_suffix ] for label_suffix ,
otherwise substitute self.form.label_suffix [ self . form . label_suffix ] for label_suffix . if label_suffix and contents are both true and last element of contents is not contained in the result of the function _ ,
called with an argument string _STR:0_ . call the method format_html with 3 arguments : string _STR:1_ , contents and label_suffix , substitute the result for contents .
substitute self.field.widget [ self . field . widget ] for widget .
get the value under the _STR:0_ key of the widget.attrs [ widget . attrs ] dictionary , if the key exists substitute it for id_ ,
if not , substitute self.auto_id [ self . auto_id ] for id_ . if id_ is true ,
call the method widget.id_for_label [ widget . id_for_label ] with an argument id_ , substitute the result for id_for_label .
if id_for_label is true ,
unpack a dictionary with an entry id_for_label for _STR:0_ , map it through attrs mapping if attrs is true ,
and convert it again to the dictionary , if attrs is false , leave it alone , substitute the result for attrs . if self.field.required [ self . field . required ] is true and self.form [ self . form ] has an attribute _STR:0_ ,
if attrs is false , make attrs an empty dictionary .
if _STR:0_ is contained in attrs ,
append self.form.required_css_class [ self . form . required_css_class ] to a whitespace character , append it to the value under the _STR:0_ key of the attrs dictionary .
if not ,
substitute self.form.required_css_class [ self . form . required_css_class ] for the value under the _STR:0_ key of the attrs dictionary .
if attrs is true , call the function flatatt with an argument attrs , substitute the result for attrs , if not attrs is an empty string .
call the function format_html with 3 arguments string _STR:0_ , attrs and contents , substitute the result for contents .
if not ,
call the function conditional_escape with an argument contents , substitute the result for contents .
call the function mark_safe with an argument contents , return the result .
define the method css_classes with 2 arguments : self and extra_classes set to None .
if extra_classes has an attribute _STR:0_ ,
split extra_classes into words , by whitespaces , substitute the result for extra_classes .
if extra_classes is not empty put its elements into a set , substitute it for extra_classes , if not extra_classes is an empty set .
if self.errors [ self . errors ] is true and self.form [ self . form ] has an attribute _STR:0_ ,
add self.form.error_css_class [ self . form . error_css_class ] to extra_classes set .
if self.field.required [ self . field . required ] is true and self.form [ self . form ] has an attribute _STR:0_ ,
add self.form.required_css_class [ self . form . required_css_class ] to extra_classes set .
join elements of extra_classes into a string separated by whitespaces , return it .
property decorator ,
define the method is_hidden with an argument self .
return self.field.widget.is_hidden [ self . field . widget . is_hidden ] ,
property decorator ,
define the method auto_id with an argument self .
substitute self.form.auto_id [ self . form . auto_id ] for auto_id .
if auto_id is true and ' % s ' is contained in result of the call to the function smart_text with an argument auto_id ,
call the function smart_text with an argument auto_id , format the result with self.html_name [ self . html_name ] , return it .
otherwise if auto_id is true ,
return self.html_name [ self . html_name ] .
return an empty string .
property decorator ,
define the method id_for_label with an argument self .
substitute self.field.widget [ self . field . widget ] for widget .
get the value under the _STR:0_ key of the widget.attrs [ widget . attrs ] dictionary , if the key exists substitute it for id_ ,
if not , substitute self.auto_id [ self . auto_id ] for id_ . call the method widget.id_for_label [ widget . id_for_label ] with an argument id_ , return the result .
from __future__ import unicode_literals into default name space .
from django.core.exceptions [ django . core . exceptions ] import ValidationError into default name space .
from django.forms [ django . forms ] import Form into default name space .
from django.forms.fields [ django . forms . fields ] import IntegerField and BooleanField into default name space .
from django.forms.utils [ django . forms . utils ] import ErrorList into default name space .
from django.forms.widgets [ django . forms . widgets ] import HiddenInput into default name space .
from django.utils.encoding [ django . utils . encoding ] import python_2_unicode_compatible into default name space .
from django.utils.functional [ django . utils . functional ] import cached_property into default name space .
from django.utils.safestring [ django . utils . safestring ] import mark_safe into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.six.moves [ django . utils . six . moves ] import xrange into default name space .
from django.utils.translation [ django . utils . translation ] import ungettext and ugettext as _ into default name space .
__all__ is a tuple containing strings _STR:0_ , _STR:1_ and _STR:2_ .
TOTAL_FORM_COUNT is a string _STR:0_ .
INITIAL_FORM_COUNT is a string _STR:0_ .
MIN_NUM_FORM_COUNT is a string _STR:0_ .
MAX_NUM_FORM_COUNT is a string _STR:0_ .
ORDERING_FIELD_NAME is a string _STR:0_ .
DELETION_FIELD_NAME is a string _STR:0_ .
DEFAULT_MIN_NUM is an integer 0 .
DEFAULT_MAX_NUM is an integer 1000 .
derive the class ManagementForm from the Form base class .
define the method __init__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
value under the TOTAL_FORM_COUNT of the self.base_fields [ self . base_fields ] dictionary is an instance of IntegerField class ,
created with an argument widget set to HiddenInput . value under the INITIAL_FORM_COUNT of the self.base_fields [ self . base_fields ] dictionary is an instance of IntegerField class ,
created with an argument widget set to HiddenInput . value under the MIN_NUM_FORM_COUNT of the self.base_fields [ self . base_fields ] dictionary is an instance of IntegerField class ,
created with 2 arguments : required as boolean False and widget set to HiddenInput . value under the MAX_NUM_FORM_COUNT of the self.base_fields [ self . base_fields ] dictionary is an instance of IntegerField class ,
created with 2 arguments : required as boolean False and widget set to HiddenInput . call the method __init__ from the base class of the class ManagementForm , called with 2 arguments : unpacked list args ,
and unpacked dictionary kwargs . python_2_unicode_compatible decorator ,
derive the class BaseFormSet from the object base class .
define the method __init__ with 7 arguments : self , data set to None , files set to None , auto_id set to an string _STR:0_ ,
if data is not None or files is not None , self.is_bound [ self . is_bound ] is boolean True , otherwise it is boolean False .
if prefix is true , substitute it for self.prefix [ self . prefix ] , otherwise call the method self.get_default_prefix [ self . get_default_prefix ] ,
and substitute the result for self.prefix [ self . prefix ] . substitute auto_id for self.auto_id [ self . auto_id ] .
if data is true , substitute it for self.data [ self . data ] , otherwise self.data [ self . data ] is an empty dictionary .
if data is true , substitute it for self.files [ self . files ] , otherwise self.files [ self . files ] is an empty dictionary .
substitute initial_id for self.auto_id [ self . auto_id ] .
substitute error_class for self.error_class [ self . error_class ] .
self._errors [ self . _errors ] is None .
self._non_form_errors [ self . _non_form_errors ] is None .
define the method __str__ with an argument self .
call the method self.as_table [ self . as_table ] , return the result .
define the method __iter__ with an argument self .
convert self.forms [ self . forms ] into an iterable , return it .
define the method __getitem__ with an argument self .
return self.forms [ self . forms ] element at the index index .
define the method __len__ with an argument self .
return the length of self.forms [ self . forms ] .
define the method __bool__ with an argument self .
return boolean True .
define the method __nonzero__ with an argument self .
get the type of self object , call the __bool__ method on the result with an argument self , return the result .
property decorator ,
define the method management_form with an argument self .
if self.is_bound [ self . is_bound ] is true ,
form is an instance of ManagementForm class , created with 3 arguments : self.data [ self . data ] , auto_id as self.auto_id [ self . auto_id ] and prefix as self.prefix [ self . prefix ] .
call the form.is_valid [ form . is_valid ] method , if it evaluates to false ,
raise ValidationError with 2 arguments : return value of the function _ called with an argument string ,
_STR:0_ and code as a string _STR:1_ . if not ,
form is an instance of ManagementForm class , created with 3 arguments : auto_id as self.auto_id [ self . auto_id ] , prefix as self.prefix [ self . prefix ] ,
and initial as a dictionary with 4 entries : result of self.total_form_count [ self . total_form_count ] method for TOTAL_FORM_COUNT , result of self.initial_form_count [ self . initial_form_count ] method for INITIAL_FORM_COUNT , self.min_num [ self . min_num ] for MIN_NUM_FORM_COUNT and self.max_num [ self . max_num ] for MAX_NUM_FORM_COUNT . return form .
define the method total_form_count with an argument self .
if self.is_bound [ self . is_bound ] is true ,
get the element with minimal value between the value under the TOTAL_FORM_COUNT key of self.management_form.cleaned_data [ self . management_form . cleaned_data ] dictionary ,
and self.absolute_max [ self . absolute_max ] , return the result . if not ,
call the method self.initial_form_count [ self . initial_form_count ] , return the result initial_forms .
get the element with maximal value between initial_forms and self.min_num [ self . min_num ] , add self.extra [ self . extra ] to it , substitute the result for total_forms .
if initial_forms is grater than self.max_num [ self . max_num ] is grater or equal to integer 0 ,
substitute initial_forms for total_forms .
otherwise if total_forms is grater than self.max_num [ self . max_num ] is grater or equal to integer 0 ,
substitute self.max_num [ self . max_num ] for total_forms .
return total_forms .
define the method initial_form_count with an argument self .
if self.is_bound [ self . is_bound ] is true ,
return the value under the INITIAL_FORM_COUNT key of the self.management_form.cleaned_data [ self . management_form . cleaned_data ] dictionary .
if not ,
if self.initial [ self . initial ] is true , substitute the length of self.initial [ self . initial ] for initial_forms , if not , initial_forms is integer 0 .
return initial_forms .
cached_property decorator ,
define the method forms with an argument self .
for every i in sequence of integers from 0 to result of the method self.total_form_count [ self . total_form_count ] , call the method self._construct_form [ self . _construct_form ] ,
with an argument i , append the result to a list , substitute the resulting list for forms . return forms .
define the method _construct_form with 3 arguments : self , i and unpacked dictionary kwargs .
defaults is an dictionary with 3 initial entries : self.auto_id [ self . auto_id ] for _STR:0_ , result of the call to the method self.add_prefix [ self . add_prefix ] ,
with an argument i , for _STR:0_ and self.error_class [ self . error_class ] for _STR:1_ . if self.is_bound [ self . is_bound ] is true ,
substitute self.data [ self . data ] for value under the _STR:0_ key of the defaults dictionary .
substitute self.files [ self . files ] for value under the _STR:0_ key of the defaults dictionary .
if self.initial [ self . initial ] is true and _STR:0_ key is not contained in kwargs ,
try ,
substitute i-th element of self.initial [ self . initial ] for value under the _STR:0_ key of the defaults dictionary .
if IndexError exception is caught ,
do nothing .
if i is greater than , or equal to the result of the call to the method self.initial_form_count [ self . initial_form_count ] ,
and i is greater than or equal to self.min_num [ self . min_num ] , value under the _STR:0_ key of the defaults dictionary is boolean True .
update defaults dictionary with kwargs .
call the method self.form [ self . form ] with unpacked dictionary defaults as an argument , substitute it for form .
call the method self.add_fields [ self . add_fields ] with arguments form and i ) .
return form .
property decorator ,
define the method initial_forms with an argument self .
call the self.initial_form_count [ self . initial_form_count ] method , return the sublist of self.forms [ self . forms ] from the beginning to the previous result as the end index .
property decorator ,
define the method extra_forms with an argument self .
call the self.initial_form_count [ self . initial_form_count ] method , return the sublist of self.forms [ self . forms ] , using previous result as start index to the end .
property decorator ,
define the method empty_form with an argument self .
call the function empty_form with 3 arguments : auto_id as self.auto_id [ self . auto_id ] , prefix set to the return value of the self.add_prefix [ self . add_prefix ] method ,
called with string _STR:0_ as an argument and empty_permitted as boolean True , substitute the result for form . call the method self.add_fields [ self . add_fields ] with arguments form and None .
return form .
property decorator ,
define the method cleaned_data with an argument self .
call the method self.is_valid [ self . is_valid ] , if it evaluates to false ,
raise an AttributeError exception with an argument string : _STR:0_ ,
where ' % s ' is replaced with self.__class__.__name__ [ self . __class__ . __name__ ] . for form in self.forms [ self . forms ] append form.cleaned_data [ form . cleaned_data ] to a list , return the resulting list .
property decorator ,
define the method deleted_forms with an argument self .
if call to the method self.is_valid [ self . is_valid ] , evaluates to false or self.can_delete [ self . can_delete ] is boolean false ,
return an empty list .
if self doesnt have an _STR:0_ attribute ,
self._deleted_form_indexes [ self . _deleted_form_indexes ] is an empty list .
call the method self.total_form_count [ self . total_form_count ] , for every i in sequence of integers , from 0 to the previous result ,
substitute i-th element of self.forms [ self . forms ] for form .
if i is greater than or equal to the result of the method self.initial_form_count [ self . initial_form_count ] ,
and call to the method form.has_changed [ form . has_changed ] evaluates to false , skip this loop iteration ,
call the method self._should_delete_form [ self . _should_delete_form ] with an argument form , if it evaluates to true ,
call the method self._deleted_form_indexes.append [ self . _deleted_form_indexes . append ] with an argument i .
for i in self._deleted_form_indexes [ self . _deleted_form_indexes ] append i-th element of self.forms [ self . forms ] into a list , return the resulting list .
property decorator ,
define the method ordered_forms with an argument self .
if call to the self.is_valid [ self . is_valid ] method evaluates to false or self.can_order [ self . can_order ] is false ,
raise an AttributeError exception with an argument string : _STR:0_ ,
where ' % s ' is replaced with self.__class__.__name__ [ self . __class__ . __name__ ] . if self doesnt have an _STR:0_ attribute ,
self._ordering [ self . _ordering ] is an empty list .
for every i in sequence of integers , from 0 to the result of the method self.total_form_count [ self . total_form_count ] ,
substitute i-th element of self.forms [ self . forms ] for form .
if i is greater than or equal to the result of the method self.initial_form_count [ self . initial_form_count ] ,
and call to the method form.has_changed [ form . has_changed ] evaluates to false , skip this loop iteration ,
if self.can_delete [ self . can_delete ] is true and call to the method self._should_delete_form [ self . _should_delete_form ] with an argument form , evaluates to true ,
skip this loop iteration ,
append tuple with 2 elements : i and value under the ORDERING_FIELD_NAME key of form.cleaned_data [ form . cleaned_data ] dictionary to self._ordering [ self . _ordering ] .
define the function compare_ordering_key with an argument k .
if second element of k is None ,
return a tuple with 2 elements : integers 1 and 0 .
return a tuple with 2 elements : integer 0 and second element of k .
call the method self._ordering.sort [ self . _ordering . sort ] with an argument key as compare_ordering_key .
for i in self._ordering [ self . _ordering ] append to a list value under the first element of i key of the self.forms [ self . forms ] dictionary , return resulting list .
classmethod decorator ,
define the method get_default_prefix with an argument cls .
return string _STR:0_ .
define the method non_form_errors with an argument self .
if self._non_form_errors [ self . _non_form_errors ] is None ,
call the method self.full_clean [ self . full_clean ] .
return self._non_form_errors [ self . _non_form_errors ] .
property decorator ,
define the method errors with an argument self .
if self._errors [ self . _errors ] is None ,
call the method self.full_clean [ self . full_clean ] .
return self._errors [ self . _errors ] .
define the method total_error_count with an argument self .
for every form_errors in self.errors [ self . errors ] sum length of return value of the method self.non_form_errors [ self . non_form_errors ] and length of form_errors , return the result .
define the method _should_delete_form with an argument self .
get the value under the DELETION_FIELD_NAME key of the form.cleaned_data [ form . cleaned_data ] dictionary , if it exists return it , if not , return boolean False .
define the method is_valid with an argument self .
if self.is_bound [ self . is_bound ] is false ,
return boolean False .
forms_valid is True .
call self.errors [ self . errors ] .
for every i in sequence of integers , from 0 to the result of the method self.total_form_count [ self . total_form_count ] ,
substitute i-th element of self.forms [ self . forms ] for form .
if self.can_delete [ self . can_delete ] is true ,
call the method self._should_delete_form [ self . _should_delete_form ] with an argument , if it evaluates to true ,
skip this loop iteration ,
call the method form.is_valid [ form . is_valid ] , perform bitwise and with the result and forms_valid as operands , substitute the result for forms_valid .
if forms_valid is true and call to the method self.non_form_errors [ self . non_form_errors ] , evaluates to false , return boolean True , otherwise return False .
define the method full_clean with an argument self .
self._errors [ self . _errors ] is an empty list .
call the method self.error_class [ self . error_class ] , substitute the result for self._non_form_errors [ self . _non_form_errors ] .
if self.is_bound [ self . is_bound ] is false ,
return nothing .
for every i in sequence of integers , from 0 to the result of the method self.total_form_count [ self . total_form_count ] ,
substitute i-th element of self.forms [ self . forms ] for form .
append form.errors [ form . errors ] to self._errors [ self . _errors ] .
try ,
if self.validate_max [ self . validate_max ] is true , and length of self.deleted_forms [ self . deleted_forms ] subtracted from the return value of the method self.total_form_count [ self . total_form_count ] ,
is greater than self.max_num [ self . max_num ] , or if value under the TOTAL_FORM_COUNT key of the self.management_form.cleaned_data [ self . management_form . cleaned_data ] dictionary , is grater than self.absolute_max [ self . absolute_max ] , raise an ValidationError with 2 arguments : return value of the function ungettext with 3 arguments :
strings _STR:0_ , _STR:0_ and self.max_num [ self . max_num ] , where _STR:1_ is replaced with self.max_num [ self . max_num ] , and code as a string _STR:2_ . if self.validate_min [ self . validate_min ] is true , and length of self.deleted_forms [ self . deleted_forms ] subtracted from the return value of the method self.total_form_count [ self . total_form_count ] ,
is smaller than self.min_num [ self . min_num ] , raise an ValidationError with 2 arguments : return value of the function ungettext with 3 arguments :
strings _STR:0_ , _STR:0_ and self.min_num [ self . min_num ] , where _STR:1_ is replaced with self.min_num [ self . min_num ] , and code as a string _STR:2_ . call the method self.clean [ self . clean ] .
if ValidationError , renamed to e , exception is caught ,
call the method self.error_class [ self . error_class ] with an argument e.error_list [ e . error_list ] , substitute the result for self._non_form_errors [ self . _non_form_errors ] .
define the method clean with an argument self .
do nothing .
define the method has_changed with an argument self .
for every form in self call the method form.has_changed [ form . has_changed ] if any of the results evaluates to true , return boolean True ,
if not return boolean False . define the method add_fields with 3 arguments : self , form and index .
if self.can_order [ self . can_order ] is true ,
if index is not None and index is smaller than return value of the method self.initial_form_count [ self . initial_form_count ] ,
value under the ORDERING_FIELD_NAME key of the form.fields [ form . fields ] is an instance of IntegerField class , created with 3 arguments :
label set to return value of the function _ called with an string _STR:0_ , initial set to index incremented by 1 , and required as boolean False . if not ,
value under the ORDERING_FIELD_NAME key of the form.fields [ form . fields ] is an instance of IntegerField class , created with 2 arguments :
label set to return value of the function _ called with an string _STR:0_ and required as boolean False . if self.can_delete [ self . can_delete ] is true ,
value under the DELETION_FIELD_NAME key of the form.fields [ form . fields ] is an instance of BooleanField class , created with 2 arguments :
label set to return value of the function _ called with an string _STR:0_ and required as boolean False . define the method add_prefix with an argument self .
replace ' % s ' in sting _STR:0_ with self.prefix [ self . prefix ] and index , return the result .
define the method is_multipart with an argument self .
if self.forms [ self . forms ] is true ,
call the method is_multipart on the first element of self.forms [ self . forms ] , return it .
if not ,
call the method self.empty_form.is_multipart [ self . empty_form . is_multipart ] , return the result
property decorator ,
define the method media with an argument self .
if self.forms [ self . forms ] is true ,
return the media field of the first element of self.forms [ self . forms ] .
if not ,
return self.empty_form.media [ self . empty_form . media ] .
define the method as_table with an argument self .
for every form in self call the form.as_table [ form . as_table ] method , join the results in a string , separated by an empty string .
join return value of the function six.text_type [ six . text_type ] called with an argument self.management_form [ self . management_form ] and forms into a string ,
separated by newline , use it as an argument for the call to the function mark_safe , return the result . define the method as_p with an argument self .
for every form in self call the form.as_p [ form . as_p ] method , join the results in a string , separated by an empty string .
join return value of the function six.text_type [ six . text_type ] called with an argument self.management_form [ self . management_form ] and forms into a string ,
separated by newline , use it as an argument for the call to the function mark_safe , return the result . define the method as_ul with an argument self .
for every form in self call the form.as_ul [ form . as_ul ] method , join the results in a string , separated by an empty string .
join return value of the function six.text_type [ six . text_type ] called with an argument self.management_form [ self . management_form ] and forms into a string ,
separated by newline , use it as an argument for the call to the function mark_safe , return the result . define the function formset_factory with 9 arguments : form , formset set to BaseFormSet , extra set to integer 1 ,
if min_num is None ,
substitute DEFAULT_MIN_NUM for min_num ,
if max_num is None ,
substitute DEFAULT_MAX_NUM for max_num ,
sum max_num and DEFAULT_MAX_NUM , substitute the result for absolute_max .
attrs is an dictionary with 9 initial entries : form for _STR:0_ , extra for _STR:1_ , can_order for _STR:2_ ,
can_delete for _STR:0_ , min_num for _STR:1_ , max_num for _STR:2_ , absolute_max for _STR:3_ , validate_min for _STR:4_ for validate_max for _STR:5_ . create a class class which name is generated by converting _STR:6_ into a string and appending it to form.__name__ [ form . __name__ ] ,
is derived from the formset base class and with fields contained in attrs , return an instance of the obtained class . define the function all_valid with an argument formsets .
valid is boolean True .
for every formset in formsets ,
call the function formset.is_valid [ formset . is_valid ] , if it evaluates to false ,
valid is boolean False .
return valid .
from __future__ import unicode_literals into default name space .
from collections import OrderedDict into default name space .
import module warnings .
django.core.exceptions [ django . core . exceptions ] import ImproperlyConfigured , ValidationError , NON_FIELD_ERRORS and FieldError into default namespace .
from django.forms.fields [ django . forms . fields ] import Field and ChoiceField into default name space .
from django.forms.forms [ django . forms . forms ] import DeclarativeFieldsMetaclass and BaseForm into default name space .
from django.forms.formsets [ django . forms . formsets ] import BaseFormSet and formset_factory into default name space .
from django.forms.utils [ django . forms . utils ] import ErrorList into default name space .
from django.forms.widgets [ django . forms . widgets ] import SelectMultiple , HiddenInput , MultipleHiddenInput into default namespace .
from django.utils [ django . utils ] import six into default name space .
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
from django.utils.encoding [ django . utils . encoding ] import smart_text and force_text into default name space .
from django.utils.text [ django . utils . text ] import get_text_list and capfirst into default name space .
from django.utils.translation [ django . utils . translation ] import ugettext_lazy as _ and ugettext into default name space .
__all__ is a tuple containing strings : _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ ,
_STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ , _STR:5_ , and _STR:6_ . ALL_FIELDS is a string _STR:7_ .
define the function construct_instance with 4 arguments : form , instance , fields set to None and exclude set to None .
from django.db [ django . db ] import models into default namespace .
substitute instance._meta [ instance . _meta ] for opts .
substitute form.cleaned_data [ form . cleaned_data ] for cleaned_data .
file_field_list is an empty list .
for every f in opts.fields [ opts . fields ] ,
if f.editable [ f . editable ] is true and f is an instance of models.AutoField [ models . AutoField ] , or f.name [ f . name ] is not contained in cleaned_data ,
skip this loop iteration .
if fields is not None and f.name [ f . name ] is not contained in fields ,
skip this loop iteration .
if exclude is true and f.name [ f . name ] is contained in exclude ,
skip this loop iteration .
if f is an instance of models.FileField [ models . FileField ] ,
append f to file_field_list .
if not ,
call the method f.save_form_data [ f . save_form_data ] with 2 arguments : instance and value under the f.name [ f . name ] key of cleaned_data dictionary .
for every f in file_field_list ,
call the method f.save_form_data [ f . save_form_data ] with 2 arguments : instance and value under the f.name [ f . name ] key of cleaned_data dictionary .
return instance .
define the function save_instance with 7 arguments : form , instance , fields set to None , fail_message as string _STR:0_ ,
if construct is true ,
call the function construct_instance with 4 arguments form , instance , fields , exclude and substitute the result for instance .
substitute instance._meta [ instance . _meta ] for opts .
if form.errors [ form . errors ] is true ,
raise an ValueError with an argument string _STR:0_ ,
where ' % s ' is replaced with opts.object_name [ opts . object_name ] and fail_message , respectively . define the function save_m2m .
substitute form.cleaned_data [ form . cleaned_data ] for cleaned_data .
append opts.virtual_fields [ opts . virtual_fields ] to opts.many_to_many [ opts . many_to_many ] , for every f in the result ,
if f doesnt has an _STR:0_ attribute ,
skip this loop iteration .
if fields is true and f.name [ f . name ] is not contained in fields ,
skip this loop iteration .
if exclude is true and f.name [ f . name ] is contained in exclude ,
skip this loop iteration .
if f.name [ f . name ] is contained in cleaned_data ,
call the method f.save_form_data [ f . save_form_data ] with 2 arguments : instance and value under the f.name [ f . name ] key of cleaned_data dictionary .
if commit is true ,
call the method instance.save [ instance . save ] .
call the function save_m2m .
if not ,
substitute save_m2m for form.save_m2m [ form . save_m2m ] .
return instance .
define the function model_to_dict with 3 arguments : instance , fields set to None and exclude set None .
from django.db.models.fields.related [ django . db . models . fields . related ] import ManyToManyField .
substitute instance._meta [ instance . _meta ] for opts .
data is an empty dictionary .
concatenate opts.concrete_fields [ opts . concrete_fields ] , opts.virtual_fields [ opts . virtual_fields ] and opts.many_to_many [ opts . many_to_many ] , for every f in the result ,
get _STR:0_ attribute from object f , if it doesnt exists or its true ,
skip this loop iteration .
if fields is true and f.name [ f . name ] is not contained in fields ,
skip this loop iteration .
if exclude is true and f.name [ f . name ] is contained in exclude ,
skip this loop iteration .
if f is an instance of ManyToManyField ,
if instance.pk [ instance . pk ] is None ,
value under f.name [ f . name ] key of the dta dictionary is an empty list .
if not ,
call the method f.value_from_object [ f . value_from_object ] with an argument instance , substitute the result for qs .
if qs._result_cache [ qs . _result_cache ] is not None ,
for every item in qu append item.pk [ item . pk ] to a list , substitute resulting list for value under f.name [ f . name ] key of the data dictionary .
if not ,
call the method qs.values_list [ qs . values_list ] with 2 arguments : string _STR:0_ and flat set to boolean True , put the results in a list ,
substitute the result for value under the f.name [ f . name ] key of data dictionary . if not ,
call the method f.value_from_object [ f . value_from_object ] with an argument instance , substitute the result for value under the f.name [ f . name ] key of the data dictionary .
return data .
define the function fields_for_model with 9 arguments : model , fields set to None , exclude set to None , widgets set to None ,
field_list is an empty list .
ignored is an empty list .
substitute model._meta [ model . _meta ] for opts .
from django.db.models.fields [ django . db . models . fields ] import Field as ModelField .
if f is an instance of ModelFiled , for every f in opts.virtual_fields [ opts . virtual_fields ] , append f to a list , substitute the resulting list for sortable_virtual_fields .
concatenate opts.concrete_fields [ opts . concrete_fields ] , sortable_virtual_fields and opts.many_to_many [ opts . many_to_many ] , for every f in sorted result ,
get _STR:0_ attribute from object f , if it doesnt exists or its true ,
skip this loop iteration .
if fields is not None and f.name [ f . name ] is not contained in fields ,
skip this loop iteration .
if exclude is true and f.name [ f . name ] is contained in exclude ,
skip this loop iteration .
kwargs is an empty dictionary ,
if widgets is true and f.name [ f . name ] is contained in widgets ,
substitute value under the f.name [ f . name ] key of the widgets dictionary for value under the _STR:0_ key of kwargs dictionary .
if localized_fields equals ALL_FIELDS , or if localized_fields is true and f.name [ f . name ] is contained in localized_fields ,
value under _STR:0_ key of kwargs dictionary is boolean True .
if labels is true and f.name [ f . name ] is contained in labels ,
substitute value under the f.name [ f . name ] key of the labels dictionary for value under the _STR:0_ key of kwargs dictionary .
if help_texts is true and f.name [ f . name ] is contained in help_texts ,
substitute value under the f.name [ f . name ] key of the help_texts dictionary for value under the _STR:0_ key of kwargs dictionary .
if error_messages is true and f.name [ f . name ] is contained in error_messages ,
substitute value under the f.name [ f . name ] key of the error_messages dictionary for value under the _STR:0_ key of kwargs dictionary .
if formfield_callback is None ,
call the method f.formfield [ f . formfield ] with an argument , unpacked dictionary kwargs , substitute the result for formfield .
otherwise if formfield_callback is not callable object ,
raise an TypeError with an string _STR:0_ .
if not ,
call the method formfield_callback with 2 arguments : f and unpacked dictionary kwargs , substitute the result for formfield .
if formfield is true ,
append a tuple with 2 elements : f.name [ f . name ] and formfield to field_list .
if not ,
append f.name [ f . name ] to ignored list .
field_dict is an instance of OrderedDict class , created with an argument field_list .
if fields is true ,
for every f in fields , if exclude is false , or if exclude is true and f is not contained in exclude , and only if f is not in ignored ,
append to list , a tuple with 2 elements : f and value under the f key of field_dict dictionary , use the resulting list as an argument , for the creation of the instance of OrderedDict class , substitute it for field_dict . return field_dict .
derive the class ModelFormOptions from object base class .
define the method __init__ with arguments : self and options set to None .
get _STR:0_ attribute from the options object , if it exists substitute it for self.model [ self . model ] , if not self.model [ self . model ] is None .
get _STR:0_ attribute from the options object , if it exists substitute it for self.fields [ self . fields ] , if not self.fields [ self . fields ] is None .
get _STR:0_ attribute from the options object , if it exists substitute it for self.exclude [ self . exclude ] , if not self.exclude [ self . exclude ] is None .
get _STR:0_ attribute from the options object , if it exists substitute it for self.widgets [ self . widgets ] , if not self.widgets [ self . widgets ] is None .
get _STR:0_ attribute from the options object , if it exists substitute it for self.localized_fields [ self . localized_fields ] ,
if not self.localized_fields [ self . localized_fields ] is None . get _STR:0_ attribute from the options object , if it exists substitute it for self.labels [ self . labels ] , if not self.labels [ self . labels ] is None .
get _STR:0_ attribute from the options object , if it exists substitute it for self.help_texts [ self . help_texts ] , if not self.help_texts [ self . help_texts ] is None .
get _STR:0_ attribute from the options object , if it exists substitute it for self.error_messages [ self . error_messages ] ,
if not self.error_messages [ self . error_messages ] is None . derive the class ModelFormMetaclass from the DeclarativeFieldsMetaclass base class .
define the method __new__ with 4 arguments : mcs , name , bases and attrs .
remove entry under the _STR:0_ key of the attrs dictionary , if it exists substitute if for formfield_callback ,
if not formfield_callback is None . call the method __new__ from the base class of the class ModelFormMetaclass , with 4 arguments : mcs , name , bases and attrs ,
substitute the result for new_class . if bases equals a tuple with an element : class BaseModelForm .
return new_class .
instantiate class ModelFormOptions with argument : attribute _STR:0_ of the new_class object . if it exists or None , if not ,
assign the result to opts and new_class._meta [ new_class . _meta ] . for every opt in list containing 3 elements : strings _STR:0_ , _STR:1_ and _STR:2_ ,
get opt attribute of the opts object , substitute it for value .
if value is an instance of six.string_types [ six . string_types ] and value is not equal to ALL_FIELDS ,
msg is a string _STR:0_ , where _STR:1_ is replaced ,
with new_class.__name__ [ new_class . __name__ ] , _STR:0_ is replaced with opt and _STR:1_ is replaced with value . raise an TypeError exception with an argument msg .
if opts.model [ opts . model ] is true ,
if opts.fields [ opts . fields ] is None and opts.exclude [ opts . exclude ] is None ,
raise an ImproperlyConfigured exception with an argument string `` Creating a ModelForm without either the _STR:0_ attribute ,
_STR:0_ , where ' % s ' is replaced with name . if opts.fields [ opts . fields ] equals ALL_FIELDS ,
opts.fields [ opts . fields ] is None .
call the function fields_for_model with 9 arguments : opts.model [ opts . model ] , opts.fields [ opts . fields ] , opts.exclude [ opts . exclude ] , opts.widgets [ opts . widgets ] , formfield_callback ,
opts.localized_fields [ opts . localized_fields ] , opts.labels [ opts . labels ] , opts.help_texts [ opts . help_texts ] and opts.error_messages [ opts . error_messages ] , substitute the result for fields . for every k and v in return value of the function six.iteritems [ six . iteritems ] called with an argument fields , if n is false , append it to a list ,
substitute the resulting list for none_model_fields . missing_fields is difference between set containing none_model_fields and set containing result of the method ,
new_class.declared_fields.keys [ new_class . declared_fields . keys ] . if missing_fields is true ,
message is an string _STR:0_ .
join missing_fields into a string separated by string _STR:0_ , use it and opts.model.__name__ [ opts . model . __name__ ] to format message , substitute the result for message .
raise an FieldError exception with an argument message .
update fields dictionary with new_class.declared_fields [ new_class . declared_fields ] .
if not ,
substitute new_class.declared_fields [ new_class . declared_fields ] for fields .
substitute fields for new_class.base_fields [ new_class . base_fields ] .
return new_class .
derive the class BaseModelForm from the BaseForm base class .
define the method __init__ with 10 arguments : self , data set to None , files set to None , auto_id set to string _STR:0_ ,
prefix set to None , initial set to None , error_class set to ErrorList , label_suffix set to None , empty_permitted set to boolean False , instance set to None . substitute self._meta [ self . _meta ] for opts .
if opts.model [ opts . model ] is None .
raise an ValueError with an argument string _STR:0_ .
if instance is None ,
call the method opts.model [ opts . model ] , substitute the result for self.instance [ self . instance ] .
object_data is an empty dictionary .
if not ,
substitute instance for self.instance [ self . instance ] .
call the method model_to_dict with 3 arguments : instance , opts.fields [ opts . fields ] , opts.exclude [ opts . exclude ] and substitute the result for object_data .
if initial is not None ,
update object_data dictionary with initial .
self._validate_unique [ self . _validate_unique ] is boolean False .
call the method __init__ from the base class of the class BaseModelForm , with 8 arguments : data , files , auto_id , prefix , object_data ,
error_class , label_suffix and empty_permitted . for every field_name in self.fields [ self . fields ] ,
substitute value under the field_name key of the self.fields [ self . fields ] dictionary for formfield .
if formfield has an attribute _STR:0_ ,
substitute formfield.limit_choices_to [ formfield . limit_choices_to ] for limit_choices_to .
if limit_choices_to is not None ,
if limit_choices_to is callable object ,
call the function limit_choices_to , substitute the result for limit_choices_to .
call the method formfield.queryset.complex_filter [ formfield . queryset . complex_filter ] with an argument limit_choices_to , substitute the result for formfield.queryset [ formfield . queryset ] .
define the method _get_validation_exclusions with an argument self .
exclude is an empty list .
for every f in self.instance._meta.fields [ self . instance . _meta . fields ] ,
substitute f.name [ f . name ] for field .
if field is not contained in self.fields [ self . fields ] ,
append f.name [ f . name ] to exclude .
otherwise if self._meta.fields [ self . _meta . fields ] is true and field is not contained in self._meta.fields [ self . _meta . fields ] ,
append f.name [ f . name ] to exclude .
otherwise if self._meta.exclude [ self . _meta . exclude ] is true and field is not contained in self._meta.exclude [ self . _meta . exclude ] ,
append f.name [ f . name ] to exclude .
otherwise if field is contained in the result of the call to the method self._errors.keys [ self . _errors . keys ] ,
append f.name [ f . name ] to exclude .
if not ,
substitute value under the field key of the self.fields [ self . fields ] dictionary for form_field .
get the value under the field key of the self.cleaned_data [ self . cleaned_data ] dictionary , if it exists substitute it for field_value ,
if not field_value is None . if f.blank [ f . blank ] is false and form_field.required [ form_field . required ] is false and field_value is contained in form_field.empty_values [ form_field . empty_values ] ,
append f.name [ f . name ] to exclude .
return exclude .
define the method clean with an argument self .
self._validate_unique [ self . _validate_unique ] is boolean True .
return self.cleaned_data [ self . cleaned_data ] .
define the method _update_errors with 2 arguments : self and errors .
substitute self._meta [ self . _meta ] for opts .
call the function errors.error_dict.items [ errors . error_dict . items ] , for every field and messages in the result ,
if field equals NON_FIELD_ERRORS and opts.error_messages [ opts . error_messages ] is true and NON_FIELD_ERRORS is contained in opts.error_messages [ opts . error_messages ] ,
substitute value under the NON_FIELD_ERRORS key of opts.error_messages [ opts . error_messages ] dictionary for error_messages .
otherwise if field is contained in self.fields [ self . fields ] ,
get the value under the field key of self.fields [ self . fields ] dictionary , substitute error_messages field of the result for error_messages .
if not ,
skip this loop iteration .
for every message in messages ,
if message is an instance of ValidationError class and message.code [ message . code ] is contained in error_messages ,
substitute error_messages under the message.code [ message . code ] key of error_messages dictionary for message.message [ message . message ] .
call the method self.add_error [ self . add_error ] with 2 arguments : None and errors .
define the method _post_clean with an argument self .
substitute self._meta [ self . _meta ] for opts .
call the method self._get_validation_exclusions [ self . _get_validation_exclusions ] , substitute the result for exclude .
convert exclude elements to list , substitute it for construct_instance_exclude .
call the method self.fields.items [ self . fields . items ] , for every name and field in result ,
if field is an instance of InlineForeignKeyField class ,
if value under the name key of self.cleaned_data [ self . cleaned_data ] dictionary is not None ,
and field _state.adding [ _state . adding ] of value under the name key of self.cleaned_data [ self . cleaned_data ] dictionary is true , append name to construct_instance_exclude list .
append name to exclude .
call the function construct_instance with 4 arguments : self , self.instance [ self . instance ] , opts.fields [ opts . fields ] and construct_instance_exclude ,
substitute the result for self.instance [ self . instance ] . try ,
call the method self.instance.full_clean [ self . instance . full_clean ] with 2 arguments : exclude set to exclude and validate_unique set to boolean False .
if ValidationError , renamed to e , exception is caught ,
call the method self._update_errors [ self . _update_errors ] with an argument e .
if self._validate_unique [ self . _validate_unique ] is true ,
call the method self.validate_unique [ self . validate_unique ] .
define the method validate_unique with an argument self .
call the method self._get_validation_exclusions [ self . _get_validation_exclusions ] , substitute the result for exclude .
try ,
call the method self.instance.validate_unique [ self . instance . validate_unique ] with an argument exclude set to exclude .
if ValidationError , renamed to e , exception is caught ,
call the method self._update_errors [ self . _update_errors ] with an argument e .
define the method save with 2 arguments : self and commit set to boolean True .
if self.instance.pk [ self . instance . pk ] is None ,
fail_message is a string _STR:0_ .
if not ,
fail_message is a string changed ' .
call the function with 7 arguments : self , self.instance [ self . instance ] , self._meta.fields [ self . _meta . fields ] , fail_message , commit , self._meta.exclude [ self . _meta . exclude ] ,
and construct as boolean False , return the result . save.alters_data [ save . alters_data ] is boolean True .
derive the class ModelForm from the base class in the return value of the method six.with_metaclass [ six . with_metaclass ] , called with 2 arguments :
ModelFormMetaclass and BaseModelForm . do nothing .
define the function modelform_factory with 10 arguments : model , form set to ModelForm , fields set to None , exclude set to None ,
attrs is a dictionary with model for _STR:0_ .
if fields is not None ,
substitute fields for value under the _STR:0_ key of attrs dictionary .
if exclude is not None ,
substitute exclude for value under the _STR:0_ key of attrs dictionary .
if widgets is not None ,
substitute widgets for value under the _STR:0_ key of attrs dictionary .
if localized_fields is not None ,
substitute localized_fields for value under the _STR:0_ key of attrs dictionary .
if labels is not None ,
substitute labels for value under the _STR:0_ key of attrs dictionary .
if help_texts is not None ,
substitute help_texts for value under the _STR:0_ key of attrs dictionary .
if error_messages is not None ,
substitute error_messages for value under the _STR:0_ key of attrs dictionary .
parent is a tuple with 1 element , object .
if form has an attribute _STR:0_ ,
parent is a tuple with 2 arguments : form.Meta [ form . Meta ] and object .
Meta is an instance of class with name _STR:0_ , parent base class and fields attrs .
append string _STR:0_ to model.__name__ [ model . __name__ ] , substitute the result for class_name .
form_class_attrs is a dictionary with 2 entries : Meta for _STR:0_ and formfield_callback for _STR:1_ .
if _STR:0_ attribute of Meta object is None and _STR:1_ attribute of Meta object is None ,
raise an ImproperlyConfigured with an argument string _STR:0_
get the type of form object , return an instance of resulting class created with 3 arguments : class_name , tuple with an element form ,
and form_class_attrs . derive the class BaseModelFormSet from the BaseFormSet base class .
model is None .
define the method __init__ with 7 arguments : self , data set to None , files set to None , auto_id set to string _STR:0_ ,
prefix set to None , queryset set to None and unpacked dictionary kwargs . substitute queryset for self.queryset [ self . queryset ] .
remove entry under _STR:0_ key of the kwargs dictionary , substitute it for self.initial_extra [ self . initial_extra ] if it exists ,
if not self.initial_extra [ self . initial_extra ] is None . defaults is a dictionary with 4 entries : data for _STR:0_ , files for _STR:1_ , auto_id for _STR:2_ and prefix for _STR:3_ .
update defaults dictionary with kwargs .
call the method __init__ from the base class of the class BaseModelFormSet , with an argument unpacked dictionary defaults .
define the method initial_form_count with an argument self .
if self.data [ self . data ] and self.files [ self . files ] are both False ,
call the method self.get_queryset [ self . get_queryset ] , return the length of the result .
call the method initial_form_count from the base class of the class BaseModelFormSet , return the result .
define the method _existing_object with 2 arguments : self and pk .
if self has an attribute _STR:0_ ,
call the function dict with an argument tuple with 2 elements : o.pk [ o . pk ] and o , for every o in result of the method self.get_queryset [ self . get_queryset ] ,
substitute the result for self._object_dict [ self . _object_dict ] . return the value under the pk key of self._object_dict [ self . _object_dict ] dictionary .
define the method _get_to_python with 2 arguments : self and field .
while field.rel [ field . rel ] is not None ,
call the method field.rel.get_related_field [ field . rel . get_related_field ] , substitute the result for field .
return field.to_python [ field . to_python ] .
define the method _construct_form with 3 arguments : self , i and unpacked dictionary kwargs .
if self.is_bound [ self . is_bound ] is true and i is smaller than self.initial_form_count [ self . initial_form_count ] ,
pk_key is a string _STR:0_ , where ' % s ' is replaced with : result of the method self.add_prefix [ self . add_prefix ] called with an argument i ,
and self.model._meta.pk.name [ self . model . _meta . pk . name ] . substitute the value under the pk_key key of the self.data [ self . data ] dictionary for pk .
substitute self.model._meta.pk [ self . model . _meta . pk ] for pk_field .
call the method self._get_to_python [ self . _get_to_python ] with an argument pk_field , substitute the result for to_python .
call the function to_python with an argument pk , substitute the result for pk .
call the method self._existing_object [ self . _existing_object ] with an argument pk , substitute the result for value under the _STR:0_ key of kwargs .
if i is smaller than result of the method self.initial_form_count [ self . initial_form_count ] and key _STR:0_ is not contained in kwargs ,
call the method self.get_queryset [ self . get_queryset ] , substitute i-th element of the result for value under the _STR:0_ key of kwargs dictionary .
if i is greater or equal to the result of the method self.initial_form_count [ self . initial_form_count ] and self.initial_extra [ self . initial_extra ] is true ,
try ,
subtract result of the method self.initial_form_count [ self . initial_form_count ] from i , use the result as an index to get the element from self.initial_extra [ self . initial_extra ] ,
substitute it for value under the _STR:0_ key of kwargs dictionary . if IndexError exception is caught ,
do nothing .
call the method _construct_form from the base class of the class BaseModelFormSet , with 2 arguments : i and unpacked dictionary kwargs .
define the method get_queryset with an argument self .
if self doesnt have _STR:0_ attribute ,
if self.queryset [ self . queryset ] is not None ,
substitute self.queryset [ self . queryset ] for qs .
if not ,
call the method self.model._default_manager.get_queryset [ self . model . _default_manager . get_queryset ] with an argument qs .
if qs.ordered [ qs . ordered ] is false ,
call the method qs.order_by [ qs . order_by ] with argument self.model._meta.pk.name [ self . model . _meta . pk . name ] , substitute the result for qs .
substitute qs for self._queryset [ self . _queryset ] .
return self._queryset [ self . _queryset ] .
define the method save_new with 3 arguments : self , form and commit set to boolean True .
call the method form.save [ form . save ] with an argument commit as commit , return the result .
define the method save_existing with 4 arguments : self , form , instance and commit set to boolean True .
call the method form.save [ form . save ] with an argument commit as commit , return the result .
define the method save with 2 arguments : self and commit set to boolean True .
if commit is true ,
self.saved_forms [ self . saved_forms ] is an empty list .
define the function save_m2m .
for every form in self.saved_forms [ self . saved_forms ] ,
call the function form.save_m2m [ form . save_m2m ] .
substitute save_m2m for self.save_m2m [ self . save_m2m ] .
sum results of method self.save_existing_objects [ self . save_existing_objects ] called with an argument commit and of method self.save_new_objects [ self . save_new_objects ] ,
called with an argument commit , return the result . save.alters_data [ save . alters_data ] is boolean True .
define the method clean with an argument self .
call the method self.validate_unique [ self . validate_unique ] .
define the method validate_unique with an argument self .
all_unique_checks is an empty set .
all_date_checks is an empty set .
substitute self.deleted_forms [ self . deleted_forms ] for forms_to_delete .
for every form in self.forms [ self . forms ] append form to a list , if function form.is_valid [ form . is_valid ] evaluates to true ,
and form is not contained in forms_to_delete , substitute the resulting list for valid_forms . for every form in valid_forms ,
call the method form._get_validation_exclusions [ form . _get_validation_exclusions ] , substitute the result for exclude .
call the method form.instance._get_unique_checks [ form . instance . _get_unique_checks ] with an argument exclude as exclude , substitute the result for unique_checks , and date_checks , respectively .
all_unique_checks is union of all_unique_checks set and unique_checks set .
all_date_checks is union of all_date_checks set and date_checks set .
errors is an empty list .
for every uclass , unique_check in all_unique_checks ,
seen_data is an empty set .
for every form in valid_forms ,
row_data is an generator object that returns value under the field key of form.cleaned_data [ form . cleaned_data ] dictionary ,
for every field in unique_check , if field is contained in form.cleaned_data [ form . cleaned_data ] . create a generator that for every d in row_data , if d has an _STR:0_ attribute ,
returns the result of the call the method d._get_pk_val [ d . _get_pk_val ] , if not return d , put all the generator items into a tuple row_data . if row_data is true and None is not contained in row_data ,
if row_data is contained in seen_data ,
call the method self.get_unique_error_message [ self . get_unique_error_message ] with an argument unique_check , append the result to errors .
call the method self.error_class [ self . error_class ] with an argument list with a element : result of the method self.get_form_error [ self . get_form_error ] ,
substitute the result for value under the NON_FIELD_ERRORS key of the form._errors [ form . _errors ] dictionary . for every field in unique_check ,
if field is contained in form.cleaned_data [ form . cleaned_data ] ,
delete the form.cleaned_data [ form . cleaned_data ] dictionary entry under the field key .
add row_data to seen_data set .
for every date_check in all_date_checks ,
seen_data is an empty set .
substitute date_check elements to uclass , lookup , field and unique_for , respectively .
for every form in valid_forms ,
if form.cleaned_data [ form . cleaned_data ] is true and value under the field key of form.cleaned_data [ form . cleaned_data ] dictionary is not None ,
and value under the unique_for key of form.cleaned_data [ form . cleaned_data ] dictionary is not None , if lookup equals a string _STR:0_ ,
substitute value under the unique_for key of form.cleaned_data [ form . cleaned_data ] dictionary for date .
date_data is a tuple with 3 elements : date.year [ date . year ] , date.month [ date . month ] and date.day [ date . day ] .
if not ,
date_data is a tuple with an entry : attribute lookup from the value under the unique_for key of the form.cleaned_data [ form . cleaned_data ] dictionary .
create a tuple out of elements under the key field of the form.cleaned_data [ form . cleaned_data ] dictionary , add elements of date_data to it ,
substitute it for data . if data is contained in seen_data ,
call the method self.get_date_error_message [ self . get_date_error_message ] with an argument date_check , append the result to errors .
call the method self.error_class [ self . error_class ] with an argument list with one element , return value of the method self.get_form_error [ self . get_form_error ] ,
substitute the result for the value under the NON_FIELD_ERRORS key of form._errors [ form . _errors ] dictionary . delete entry from form.cleaned_data [ form . cleaned_data ] dictionary under the field key .
add data to seen_data set .
if errors is true ,
raise an ValidationError exception with an argument errors .
define the method get_unique_error_message with 2 arguments : self and unique_check .
if length of unique_check equals integer 1 ,
call the function ugettext with an argument string _STR:0_ ,
where _STR:0_ is replaced with first element of unique_check , return the result . if not ,
call the function ugettext with an argument string _STR:0_ ,
where _STR:0_ is replaced with return value of the get_text_list function called with 2 arguments : unique_check and return value of the function six.text_type [ six . text_type ] called with return value of the function _ with an argument string _STR:1_ , return the result . define the method get_date_error_message with 2 arguments : self and date_check .
call the function ugettext with an argument string `` Please correct the duplicate data for % ( field_name ) s which must be unique for ,
the % ( lookup ) s in % ( date_field ) s. '' , where _STR:0_ is replaced with third element of data_check , _STR:1_ is replaced with fourth element of date_check and _STR:2_ is replaced with result of the function , six.text_type [ six . text_type ] called with second element of date_check as an argument , return the result . define the method get_form_error with an argument self .
call the function ugettext with an argument string _STR:0_ , return the result .
define the method save_existing_objects with 2 arguments : self and commit set to boolean True .
self.changed_objects [ self . changed_objects ] is an empty list .
self.deleted_objects [ self . deleted_objects ] is an empty list .
if self.initial_forms [ self . initial_forms ] is false ,
return an empty list .
saved_instances is an empty list .
substitute self.deleted_forms [ self . deleted_forms ] for forms_to_delete .
for every form in self.initial_forms [ self . initial_forms ] ,
substitute form.instance [ form . instance ] for obj .
if form is contained in forms_to_delete ,
if obj.pk [ obj . pk ] is None ,
skip this loop iteration .
append obj to self.deleted_objects [ self . deleted_objects ] list .
if commit is true ,
call the method obj.delete [ obj . delete ] .
otherwise if form.has_changed [ form . has_changed ] method evaluates to true ,
append a tuple with 2 elements : obj and form.changed_data [ form . changed_data ] to self.changed_objects [ self . changed_objects ] .
call the method self.save_existing [ self . save_existing ] with 3 arguments : form , obj and commit as commit , append the result to saved_instances .
if commit is false ,
append form to self.saved_forms [ self . saved_forms ] .
return saved_instances .
define the method save_new_objects with 2 arguments : self and commit set to boolean True .
self.new_objects [ self . new_objects ] is an empty list .
for every form in self.extra_forms [ self . extra_forms ] ,
if function form.has_changed [ form . has_changed ] evaluates to false ,
skip this loop iteration .
if self.can_delete [ self . can_delete ] is true and call to the function self._should_delete_form [ self . _should_delete_form ] with an argument form evaluates to true ,
skip this loop iteration .
call the method self.save_new [ self . save_new ] with 2 arguments : form and commit as commit , append the result to self.new_objects [ self . new_objects ] .
if commit is false ,
append form to self.saved_forms [ self . saved_forms ] .
return self.new_objects [ self . new_objects ] .
define the method add_fields with 2 arguments : self , form and index .
from django.db.models [ django . db . models ] import AutoField , OneToOneField and ForeignKey .
assign self.model._meta.pk [ self . model . _meta . pk ] to self._pk_field [ self . _pk_field ] and pk .
define the method pk_is_not_editable with an argument pk .
if pk.editable [ pk . editable ] is true , or pk.auto_created [ pk . auto_created ] is true or pk is an instance of AutoField class , or if pk.rel [ pk . rel ] is true ,
and pk.rel.parent_link [ pk . rel . parent_link ] is true and function pk_is_not_editable called with an argument pk.rel.to._meta.pk [ pk . rel . to . _meta . pk ] evaluates to true , if function pk_is_not_editable called with an argument pk evaluates to true , or pk.name [ pk . name ] is not contained in form.fields [ form . fields ] ,
if form.is_bound [ form . is_bound ] is true ,
substitute form.instance.pk [ form . instance . pk ] for pk_value .
if not ,
try ,
if index is not None ,
call the method self.get_queryset [ self . get_queryset ] , substitute field pk under the result at the index index for pk_value .
if not ,
pk_value is None .
if IndexError exception is caught ,
pk_value is None .
if pk is an instance of OneToOneField or ForeignKey classes ,
call the method pk.rel.to._default_manager.get_queryset [ pk . rel . to . _default_manager . get_queryset ] , substitute the result for qs .
if not ,
call the method self.model._default_manager.get_queryset [ self . model . _default_manager . get_queryset ] with an argument qs .
call the method qs.using [ qs . using ] with an argument form.instance._state.db [ form . instance . _state . db ] , substitute the result for qs .
if form._meta.widgets [ form . _meta . widgets ] is true ,
get the value under self._pk_field.name [ self . _pk_field . name ] key of form._meta.widgets [ form . _meta . widgets ] dictionary , if it exists substitute it for widget , if not ,
widget is an instance of HiddenInput class . if not ,
widget is an instance of HiddenInput class
value under the self._pk_field.name [ self . _pk_field . name ] key of form.fields [ form . fields ] dictionary is an instance of ModelChoiceField class ,
created with 4 arguments : qs , initial as pk_value , required as boolean False and widget as widget . call the method add_fields from the base class of the class BaseModelFormSet , with 2 arguments : form and index .
define the function modelformset_factory with 18 arguments : model , form set to ModelForm , formfield_callback set to None ,
get _STR:0_ attribute from form object , if it exists substitute it for meta , if not meta is None .
if meta is None ,
meta is an instance of a class named _STR:0_ , derived from the object base class , without any fields .
if _STR:0_ attribute of meta is None , or if it doesnt exists if fields is None and if _STR:1_ attribute of meta is None ,
or if it doesnt exists if exclude is None . raise an ImproperlyConfigured with an argument string `` Calling modelformset_factory without defining _STR:0_ or _STR:1_ ,
explicitly is prohibited . '' call the function modelform_factory with 10 arguments : model , form as form , fields as fields , exclude as exclude ,
formfield_callback as formfield_callback , widgets as widgets , localized_fields as localized_fields , labels as labels , help_texts as help_texts and error_messages as error_messages , substitute the result for form . call the function formset_factory with 10 arguments : form , formset , extra as extra , min_num as min_num , max_num as max_num ,
can_order as can_order , can_delete as can_delete , validate_min as validate_min , validate_max as validate_max , substitute the result for form . substitute model for FormSet.model [ FormSet . model ] .
return FormSet .
derive the class BaseInlineFormSet from the BaseModelFormSet base class .
define the method __init__ with 8 arguments : self , data set to None , files set to None , instance set to None ,
save_as_new set to boolean False , prefix set to None , queryset set to None and unpacked dictionary kwargs . if instance is None ,
call the method self.fk.rel.to [ self . fk . rel . to ] , substitute the result for self.instance [ self . instance ] .
if not ,
substitute instance for self.instance [ self . instance ] .
substitute save_as_new for self.save_as_new [ self . save_as_new ] .
if queryset is None ,
substitute self.model._default_manager [ self . model . _default_manager ] for queryset .
if self.instance.pk [ self . instance . pk ] is not None ,
call the method queryset.filter [ queryset . filter ] with an argument unpacked dictionary containing self.instance [ self . instance ] for self.fk.name [ self . fk . name ] , substitute the result for qs .
if not ,
call the method queryset.none [ queryset . none ] , substitute it for qs .
call the method __init__ from the base class of the class BaseInlineFormSet , with 5 arguments : data , files , prefix set to prefix ,
queryset set to qs and unpacked dictionary kwargs . define the method initial_form_count with an argument self .
if self.save_as_new [ self . save_as_new ] is true ,
return integer 0 .
call the method initial_form_count from the base class of the class BaseInlineFormSet , return the result .
define the method _construct_form with 3 arguments : self , i and unpacked dictionary kwargs .
call the method _construct_form from the base class of the class BaseInlineFormSet , with 2 arguments : i ,
and unpacked dictionary kwargs , substitute the result for form . if self.save_as_new [ self . save_as_new ] is true ,
call the method form.add_prefix [ form . add_prefix ] with an argument self._pk_field.name [ self . _pk_field . name ] ,
use the result as an key to get the value of the form.data [ form . data ] dictionary , assign it value None . call the method form.add_prefix [ form . add_prefix ] with an argument self.fk.name [ self . fk . name ] ,
use the result as an key to get the value of the form.data [ form . data ] dictionary , assign it value None . use return value of the self.fk.get_attname [ self . fk . get_attname ] as the name of the attribute of form.instance [ form . instance ] object to set , set it to self.instance.pk [ self . instance . pk ] .
return form .
classmethod decorator ,
define the method get_default_prefix with an argument cls .
from django.db.models.fields.related [ django . db . models . fields . related ] import RelatedObject into default namespace .
instantiate RelatedObject class with 3 arguments : cls.fk.rel.to [ cls . fk . rel . to ] , cls.model [ cls . model ] and cls.fk [ cls . fk ] ,
call the method get_accessor_name on the result , substitute all occurrences of _STR:0_ in the result with an empty string , return it . define the method save_new with 3 arguments : self , form and commit set to boolean True .
call the method form.save [ form . save ] , with an argument commit set to boolean False , substitute the result for obj .
get self.instance [ self . instance ]
get attribute _STR:0_ of the pk_value object , if it doesnt exists use pk_value , set to it self.fk.get_attname [ self . fk . get_attname ] return value attribute ,
of the obj object . if commit is true ,
call the method obj.save [ obj . save ] .
if commit is true and form has an attribute _STR:0_ ,
call the method form.save_m2m [ form . save_m2m ] .
return obj .
define the method add_fields with 3 arguments : self , form and index .
call the method add_fields from the base class of the class BaseInlineFormSet , with 2 arguments : form and index .
if self._pk_field [ self . _pk_field ] equals self.fk [ self . fk ] ,
substitute self._pk_field.name [ self . _pk_field . name ] for name .
kwargs is a dictionary with boolean True for _STR:0_ .
if not ,
substitute self.fk.name [ self . fk . name ] for name .
kwargs is a dictionary with an entry : attribute _STR:0_ of the object under the name key of the form.fields [ form . fields ] dictionary for _STR:0_ ,
if it doesnt exists return value of the function capfirst with an argument self.fk.verbose_name [ self . fk . verbose_name ] for _STR:0_ . if self.fk.rel.field_name [ self . fk . rel . field_name ] is not equal to self.fk.rel.to._meta.pk.name [ self . fk . rel . to . _meta . pk . name ] ,
substitute self.fk.rel.field_name [ self . fk . rel . field_name ] for value under the _STR:0_ key of the kwargs dictionary .
value under the name key of the form.fields [ form . fields ] dictionary is an instance of InlineForeignKeyField created with 2 arguments :
self.instance [ self . instance ] and unpacked dictionary kwargs . if form._meta.fields [ form . _meta . fields ] is true ,
if form._meta.fields [ form . _meta . fields ] is an instance of tuple type ,
form._meta.fields [ form . _meta . fields ] is a list created out of form._meta.fields [ form . _meta . fields ] elements .
append self.fk.name [ self . fk . name ] to form._meta.fields [ form . _meta . fields ] .
define the method get_unique_error_message with 2 arguments : self and unique_check .
unique_check is a list with elements field , for every field in unique_check if field is not equal to self.fk.name [ self . fk . name ] .
call the method get_unique_error_message from the base class of the class BaseInlineFormSet , with an argument unique_check , return the result .
define the function _get_foreign_key with 4 arguments : parent_model , model , fk_name set to None and can_fail set to boolean False .
from django.db.models [ django . db . models ] import ForeignKey .
substitute model._meta [ model . _meta ] for opts .
if fk_name is true ,
fks_to_parent is a list containing f , for every f in opts.fields [ opts . fields ] if f.name [ f . name ] equals fk_name .
if length of fks_to_parent equals integer 1 .
substitute first element of fks_to_parent for fk .
if fk is not an instance of ForeignKey class , or fk.rel.to [ fk . rel . to ] is not equal to parent_model ,
and fk.rel.to [ fk . rel . to ] is not contained in result of the call to the method parent_model._meta.get_parent_list [ parent_model . _meta . get_parent_list ] . raise an ValueError with an argument string _STR:0_ , where ' % s ' is replaced with ,
fk_name , parent_model._meta.app_label [ parent_model . _meta . app_label ] and parent_model._meta.object_name [ parent_model . _meta . object_name ] , respectively . otherwise if length of fks_to_parent is zero ,
raise an ValueError with an argument string _STR:0_ , where ' % s ' is replaced with ,
model._meta.app_label [ model . _meta . app_label ] , model._meta.object_name [ model . _meta . object_name ] , fk_name , respectively . if not ,
fks_to_parent is a list containing f for every f in opts.fields [ opts . fields ] , only if f is an instance of ForeignKey ,
and , if f.rel.toequals [ f . rel . toequals ] parent_model or f.rel.to [ f . rel . to ] is contained in result of the call to the method parent_model._meta.get_parent_list [ parent_model . _meta . get_parent_list ] . if length of fks_to_parent is integer 1 ,
substitute first element of fks_to_parent for fk .
otherwise if length of fks_to_parent is zero ,
if can_fail is true ,
return nothing .
raise an ValueError with an argument string _STR:0_ , where ' % s ' is replaced with ,
model._meta.app_label [ model . _meta . app_label ] , model._meta.object_name [ model . _meta . object_name ] , parent_model._meta.app_label [ parent_model . _meta . app_label ] , parent_model._meta.object_name [ parent_model . _meta . object_name ] , respectively . if not ,
raise an ValueError with an argument string _STR:0_ , where ' % s ' is replaced with ,
model._meta.app_label [ model . _meta . app_label ] , model._meta.object_name [ model . _meta . object_name ] , parent_model._meta.app_label [ parent_model . _meta . app_label ] , parent_model._meta.object_name [ parent_model . _meta . object_name ] , respectively . return fk .
define the function inlineformset_factory with 20 arguments : parent_model , model , form set to ModelForm ,
call the function _get_foreign_key with 3 arguments : parent_model , model and fk_name=fk_name , substitute the result for fk .
if fk.unique [ fk . unique ] is boolean true ,
max_num is integer 1 .
kwargs is a dictionary with 17 entries : form for _STR:0_ , formfield_callback for _STR:1_ , formset for _STR:2_ ,
extra for _STR:0_ , can_delete for _STR:1_ , can_order for _STR:2_ , fields for _STR:3_ , exclude for _STR:4_ , min_num for _STR:5_ , max_num for _STR:6_ , widgets for _STR:7_ , validate_min for _STR:8_ , validate_max for _STR:9_ , localized_fields for _STR:10_ , labels for _STR:11_ , help_texts for _STR:12_ , and error_messages for _STR:13_ . call the function modelformset_factory with 2 arguments : model and unpacked dictionary kwargs , substitute the result for FormSet .
substitute fk for FormSet.fk [ FormSet . fk ] .
return FormSet .
derive the class InlineForeignKeyField from the Field base class .
substitute HiddenInput for widget .
default_error_messages is an dictionary with an entry : return value of the function _ called with an argument ,
string _STR:0_ for _STR:1_ . define the method __init__ with 4 arguments : self , parent_instance , unpacked list args and unpacked dictionary kwargs .
substitute parent_instance for self.parent_instance [ self . parent_instance ] .
remove element from kwargs dictionary under the key _STR:0_ , substitute it for self.pk_field [ self . pk_field ] if it exists ,
if not self.pk_field [ self . pk_field ] is boolean False . remove element from kwargs dictionary under the key _STR:0_ , substitute it for self.to_field [ self . to_field ] if it exists ,
if not self.to_field [ self . to_field ] is None . if self.parent_instance [ self . parent_instance ] is not None ,
if self.to_field [ self . to_field ] is true ,
get self.to_field [ self . to_field ] attribute of self.parent_instance [ self . parent_instance ] object , substitute it for value under the _STR:0_ key of the kwargs dictionary .
if not ,
substitute self.parent_instance.pk [ self . parent_instance . pk ] for value under the _STR:0_ key of the kwargs dictionary .
value under the _STR:0_ key of the kwargs dictionary is boolean False .
call the method __init__ from the base class of the class InlineForeignKeyField , with 2 arguments unpacked list args ,
and unpacked dictionary kwargs . define the method clean with 2 arguments : self and value .
if value is contained in self.empty_values [ self . empty_values ] ,
if self.pk_field [ self . pk_field ] ,
return None .
return self.parent_instance [ self . parent_instance ] .
if self.to_field [ self . to_field ] is true ,
get self.to_field [ self . to_field ] attribute of self.parent_instance [ self . parent_instance ] , substitute it for orig .
if not ,
substitute self.parent_instance.pk [ self . parent_instance . pk ] for orig .
if return values of the function force_text called two times with 1 argument , with value , and with orig , are equal ,
raise an ValidationError with 2 arguments : self.error_messages [ self . error_messages ] dictionary value under the _STR:0_ key ,
and code set to a string _STR:0_ . return self.parent_instance [ self . parent_instance ] .
define the method _has_changed with 3 arguments : self , initial and data .
return boolean False .
derive the class ModelChoiceIterator from object base class .
define the method __init__ with 2 arguments : self and field .
substitute field for self.field [ self . field ] .
substitute field.queryset [ field . queryset ] for self.queryset [ self . queryset ] .
define the method __iter__ with an argument self .
if self.field.empty_label [ self . field . empty_label ] is not None ,
yield a tuple with 2 elements : an empty string and self.field.empty_label [ self . field . empty_label ] .
if self.field.cache_choices [ self . field . cache_choices ] is true ,
if self.field.choice_cache [ self . field . choice_cache ] is None ,
self.field.choice_cache [ self . field . choice_cache ] is a list containing results of the method self.choice [ self . choice ] called with an argument obj ,
for every obj in result of the method self.queryset.all [ self . queryset . all ] . for every choice in self.field.choice_cache [ self . field . choice_cache ] ,
yield choice .
if not ,
for every obj in result of the call to the method self.queryset.all [ self . queryset . all ] ,
call the method self.choice [ self . choice ] with an argument obj , yield the result .
define the method __len__ with an argument self .
sum length of self.quertset [ self . quertset ] and integer 1 if self.field.empty_label [ self . field . empty_label ] is not None , or integer 0 if not , return the result .
define the method choice with 2 arguments : self and obj .
return a tuple with 2 elements : result of the method self.field.prepare_value [ self . field . prepare_value ] called with an argument obj ,
and result of the method self.field.label_from_instance [ self . field . label_from_instance ] , called with an argument obj . derive the class ModelChoiceField from the ChoiceField base class .
default_error_messages is a dictionary with an entry , result of the call to the function _ with an argument ,
string _STR:0_ for _STR:1_ . define the method __init__ with 13 arguments : self , queryset , empty_label set to a string _STR:2_ , cache_choices set to None ,
required set to boolean True , widget set to None , label set to None , initial set to None , help_text set to an empty string , to_field_name set to None , limit_choices_to set to None , unpacked list args and unpacked dictionary kwargs . if required is true and initial is not None ,
self.empty_label [ self . empty_label ] is None .
if not ,
substitute empty_label for self.empty_label [ self . empty_label ] .
if cache_choices is not None ,
call the function warnings.warn [ warnings . warn ] with 3 arguments : string _STR:0_ ,
RemovedInDjango19Warning and stacklevel set to integer 2. if not ,
substitute boolean False for cache_choices .
substitute cache_choices for self.cache_choices [ self . cache_choices ] .
call the method Field.__init__ [ Field . __init__ ] with 8 arguments : self , required , widget , label , initial , help_text , unpacked list args ,
and unpacked dictionary kwargs . substitute queryset for self.queryset [ self . queryset ] .
substitute limit_choices_to for self.limit_choices_to [ self . limit_choices_to ] .
self.choice_cache [ self . choice_cache ] is None .
substitute to_field_name for self.to_field_name [ self . to_field_name ]
define the method __deepcopy__ with 2 arguments : self and memo .
call the method __deepcopy__ from the base class of the class ChoiceField , with an argument memo , substitute the result for result .
substitute result.queryset [ result . queryset ] for result.queryset [ result . queryset ] .
return result .
define the method _get_queryset with an argument self .
return self._queryset [ self . _queryset ] .
define the method _set_queryset with 2 arguments : self and queryset .
substitute queryset for self._queryset [ self . _queryset ] .
substitute self.choices [ self . choices ] for self.widget.choices [ self . widget . choices ] .
queryset is an property object of this class , with _get_queryset getter and _set_queryset setter functions .
define the method label_from_instance with 2 arguments : self and obj .
call the function smart_text with an argument obj , return the result .
define the method _get_choices with an argument self .
if self has an attribute _STR:0_ ,
return self._choices [ self . _choices ] .
return an instance of ModelChoiceIterator class , created with an argument self .
choices is an property property object of this class , with _get_choices getter and ChoiceField._set_choices [ ChoiceField . _set_choices ] setter functions .
define the method prepare_value with 2 arguments : self and value .
if value has an attribute _STR:0_ ,
if self.to_field_name [ self . to_field_name ] is true ,
call the method value.serializable_value [ value . serializable_value ] with an argument self.to_field_name [ self . to_field_name ] , return the result .
if not ,
return value.pk [ value . pk ] .
call the method prepare_value from the base class of the class ModelChoiceField , with an argument value , return the result .
define the method to_python with 2 arguments : self and value .
if value is contained in self.empty_values [ self . empty_values ] ,
return None .
try ,
substitute self.to_field_name [ self . to_field_name ] , if exists , for key , if not substitute string _STR:0_ for key .
call the method self.queryset.get [ self . queryset . get ] with an argument , unpacked dictionary with an element : value for key , substitute the result for value .
if ValueError or self.queryset.model.DoesNotExist [ self . queryset . model . DoesNotExist ] exception is caught ,
raise an ValidationError exception with 2 arguments : value under the _STR:0_ key of the self.error_messages [ self . error_messages ] dictionary ,
code set to a string _STR:0_ . return value .
define the method validate with 2 arguments : self and value .
call the method Field.validate [ Field . validate ] with 2 arguments : self and value , return the result .
define the method _has_changed with 3 arguments : self , initial and data .
if initial is not None , substitute initial for initial_value , otherwise initial_value is an empty string .
if data is not None , substitute data for initial_value , otherwise data_value is an empty string .
call the method self.prepare_value [ self . prepare_value ] with an argument initial_value , use it as the argument for the call to the function force_text ,
if the result is equal to the result of the call to the function force_text with data_value as an argument , return boolean True , otherwise return boolean False . derive the class ModelMultipleChoiceField from the ModelChoiceField base class .
substitute SelectMultiple for widget .
substitute MultipleHiddenInput for hidden_widget .
default_error_messages is an dictionary with 3 entries : return value of the function _ called with an argument ,
string _STR:0_ for _STR:1_ , return value of the function _ called with an argument , string _STR:2_ for _STR:3_ , and return value of the function _ called with an argument string _STR:4_ for _STR:5_ . define the method __init__ with 10 arguments : self , queryset , cache_choices set to None , required set to boolean True ,
widget set to None , label set to None , initial set to None , help_text set to an empty strign , unpacked list args and unpacked dictionary kwargs . call the method __init__ from the base class of the class ModelMultipleChoiceField , with 10 arguments : queryset , None ,
cache_choices , required , widget , label , initial , help_text , unpacked list args and unpacked dictionary kwargs . define the method to_python with 2 arguments : self and value .
if value is false ,
return an empty list .
instantiate base class of the class ModelMultipleChoiceField , substitute filed to_python of the result for to_py .
return a list containing return values of the function to_py called with an argument val , for every val in value .
define the method clean with 2 arguments : self and value .
if self.required [ self . required ] is true and value is false ,
raise an ValidationError with 2 arguments : dictionary self.error_messages [ self . error_messages ] value under the key _STR:0_ ,
and code set to string 'required . otherwise if self.required [ self . required ] is false and value is false ,
call the method self.queryset.none [ self . queryset . none ] , return the result .
if value is not an instance of list or tuple types ,
raise an ValidationError with 2 arguments : dictionary self.error_messages [ self . error_messages ] value under the key _STR:0_ ,
and code set to string _STR:0_pk ' for key .
for every pk in value ,
try ,
call the method self.queryset.filter [ self . queryset . filter ] with an argument , unpacked dictionary with an entry : pk for key .
if ValueError exception is caught ,
raise an ValidationError with 3 arguments : dictionary self.error_messages [ self . error_messages ] value under the key _STR:0_ ,
code set to string _STR:0_pk_STR:1___in ' appended to key ,
substitute the result for qs . pks is a set containing results of the call to the function force_text with an argument , key attribute of the o object ,
for every o in opts . for every val in value ,
call the function force_text with an argument val , if the result is not contained in pks ,
raise an ValidationError with 3 arguments : dictionary self.error_messages [ self . error_messages ] value under the key _STR:0_ ,
code set to string _STR:0_ and params as a dictionary with an entry , val for _STR:1_ . call the method self.run_validators [ self . run_validators ] with an argument value .
return qs .
define the method prepare_value with 2 arguments : self and value .
if value has an attribute _STR:0_ and value is not an instance of six.text_type [ six . text_type ] and value doesnt have an attribute _STR:1_ ,
call the method prepare_value from the base class of the class ModelMultipleChoiceField , with an argument v ,
for every v in value , return the list of results . call the method prepare_value the base class of the class ModelMultipleChoiceField , with an argument value , return the result .
define the method _has_changed with 3 arguments : self , initial and data .
if initial is None ,
initial is an empty list .
if data is None ,
data is an empty list .
if lengths of initial and data are equal ,
return boolean True .
initial_set is set created out of return values of the function force_text called with an argument value ,
for every value in result of the method self.prepare_value [ self . prepare_value ] called with an argument initial . data_set is set created out of return values of the function force_text called with an argument value ,
for every value in data . if data_set is not equal to initial_set return boolean True , otherwise return boolean False .
define the function modelform_defines_fields with an argument form_class .
only if form_class is not None , and if form_class has an attribute _STR:0_ and form_class._meta.fields [ form_class . _meta . fields ] is not None ,
import module warnings .
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
call the function warnings.warn [ warnings . warn ] with 3 arguments : string _STR:0_
_STR:0_ , RemovedInDjango19Warning and stacklevel set to an integer 2. from django.forms.utils [ django . forms . utils ] import everything into default name space .
from __future__ import unicode_literals into default name space .
import module json .
import module sys .
try ,
from collections import UserList into default namespace .
if ImportError exception is caught .
from UserList import UserList into default namespace .
from django.conf [ django . conf ] import settings into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_text and python_2_unicode_compatible into default name space .
from django.utils.html [ django . utils . html ] import format_html , format_html_join and escape into default name space .
from django.utils [ django . utils ] import timezone into default name space .
from django.utils.translation [ django . utils . translation ] import ugettext_lazy as _ into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.core.exceptions [ django . core . exceptions ] import ValidationError into default name space .
define the function flatatt with an argument attrs .
boolean_attrs is an empty list .
convert items of attrs dictionary to list of tuples , for every attr and value in it ,
if value is boolean True ,
append tuple containing element attr to boolean_attrs .
delete entry under the attr key of the attrs dictionary .
otherwise if value is boolean False ,
delete entry under the attr key of the attrs dictionary .
call the function format_html_join twice , first time with 3 elements : an empty string , string _STR:0_
and sorted return value of the items of the attrs dictionary , and second time with 3 arguments : an empty string , string _STR:0_ , and sorted list of boolean_attrs elements , concatenate the results and return the resulting list . python_2_unicode_compatible decorator ,
derive the class ErrorDict from the dict base class .
define the method as_data with an argument self .
return a dictionary generated with an expression , return value of the method e.as_data [ e . as_data ] for f ,
for every f and e in list of tuples of self dictionary key , pair entries . define the method as_json with 2 argumens self and escape_html set to boolean False .
call the method json.dumps [ json . dumps ] with a dictionary generate with an expression as an argument , return value of the function e.get_json_data [ e . get_json_data ] ,
with an argument escape_html for f , for every f and e in list of tuples of self dictionary key , pair entries , return the result . define the method as_ul with an argument self .
if self is false ,
return an empty string .
call the function format_html with 2 arguments : string _STR:0_ , and return value of the function ,
format_html_join , called with 3 arguments : empty string , string _STR:0_ , tuple containing tuples with 2 elements : k and result of the function force_text with an argument v , for every k and v in items of the dictionary self , return the result . define the method as_text with an argument self .
output is an empty list .
call the method self.items [ self . items ] , for every field and errors in the result .
convert field into a string and concatenate it to a string _STR:0_ , append the result to output .
for every e in errors convert e into a string and append it to a string _STR:0_ ,
join all the results into a string separated by newlines , append the result to output . join elements of output into a string , separated by newline characters , return the result .
define the method __str__ with an argument self .
call the method self.as_ul [ self . as_ul ] , return the result .
python_2_unicode_compatible decorator ,
derive the class ErrorList from the UserList and list base classes .
define the method __init__ with 3 arguments : self , initlist set to None and error_class set to None .
call the method __init__ with an argument initlist from the base class of the class ErrorList .
if error_class is None ,
self.error_class [ self . error_class ] is a string _STR:0_ .
if not ,
append error_class converted into a string to string _STR:0_ , substitute the result for self.error_class [ self . error_class ] .
define the method as_text with an argument self .
instantiate ValidationError class with an argument self.data [ self . data ] , return its field error_list .
define the method get_json_data with 2 arguments self and escape_html set to boolean False .
errors is an empty list .
call the method self.as_data [ self . as_data ] , for every error in the result .
convert elements of error into a list , substitute the first element for message .
append to errors list a dictionary created with 2 etries , if escape_html is true , return value of the function escape
with an argument message for _STR:0_ , or if not message for _STR:0_ and error.code [ error . code ] for _STR:1_ in error.code [ error . code ] is true , if not , an empty string for _STR:1_ . return errors .
define the method as_json with 2 arguments self and escape_html set to boolean False .
call the method self.get_json_data [ self . get_json_data ] with an argument escape_html ,
use the result as an argument for the call to the json.dumps [ json . dumps ] function , return the result . define the method as_text with an argument self .
if self.data [ self . data ] is false ,
return an empty string .
call the function format_html with 3 arguments : string _STR:0_ , self.error_class [ self . error_class ] and return value of the function ,
format_html_join , called with 3 arguments : empty string , string _STR:0_ , tuple containing results of the function , force_text with an argument e , for every e in self , return the result . define the method as_text with an argument self .
for every e in self , append convert e to an string and append it to string _STR:0_ ,
join all of the results into a string separated by newline character , return the result . define the method __str__ with an argument self .
call the method self.as_ul [ self . as_ul ] , return the result .
define the method __repr__ with an argument self .
convert elements of self into a list , return the its printable representation .
define the method __contains__ with an argument self .
if item is contained in the list of the elements of self , return boolean True , otherwise return boolean False .
define the method __eq__ with an argument self .
if other equals list containing elements of self , return boolean True , otherwise return boolean False .
define the method __ne__ with an argument self .
if other is not equal to list containing elements of self , return boolean True , otherwise return boolean False .
define the method __getitem__ with an argument self .
substitute i-th element of self.data [ self . data ] for error .
if error is an instance of ValidationError ,
return first element of the list containing elements of error .
call the function force_text with an argument error , return the result .
define the function from_current_timezone with an argument value .
if settings.USE_TZ [ settings . USE_TZ ] is true and value is not None and call to the function timezone.is_naive [ timezone . is_naive ] with an argument value , evaluates to true ,
call the method timezone.get_current_timezone [ timezone . get_current_timezone ] , substitute the result for current_timezone .
try ,
call the function timezone.make_aware [ timezone . make_aware ] with arguments value and current_timezone , return the result .
if Exception exception is caught ,
call the function _ with an argument string _STR:0_
_STR:0_ , substitute the result for message . params is an dictionary containing 2 initial entries : value for _STR:1_ and current_timezone for _STR:2_ .
call the function six.reraise [ six . reraise ] with 3 arguments : class ValidationError , class ValidationError , created with 3 arguments :
message , code as a string _STR:0_ and params as params , and third element of the return value of the function sys.exc_info [ sys . exc_info ] . return value .
define the function to_current_timezone with an argument value .
if settings.USE_TZ [ settings . USE_TZ ] is true and value is not None and call to the function timezone.is_aware [ timezone . is_aware ] with an argument value , evaluates to true ,
call the function timezone.get_current_timezone [ timezone . get_current_timezone ] , substitute the result for current_timezone .
call the function timezone.make_naive [ timezone . make_naive ] with 2 arguments value , current_timezone , return the result .
return value .
from __future__ import unicode_literals into default name space .
import module copy .
from itertools import chain into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.forms.utils [ django . forms . utils ] import flatatt and to_current_timezone into default name space .
from django.utils.datastructures [ django . utils . datastructures ] import MultiValueDict and MergeDict into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_text and python_2_unicode_compatible into default name space .
from django.utils.html [ django . utils . html ] import conditional_escape and format_html into default name space .
from django.utils.translation [ django . utils . translation ] import ugettext_lazy into default name space .
from django.utils.safestring [ django . utils . safestring ] import mark_safe into default name space .
from django.utils [ django . utils ] import formats and six into default name space .
from django.utils.six.moves.urllib.parse [ django . utils . six . moves . urllib . parse ] import urljoin into default name space .
__all__ is a tuple of strings : _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ , _STR:5_ , _STR:6_ ,
_STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ , _STR:5_ , _STR:6_ , _STR:7_ , _STR:8_ , _STR:9_ , _STR:10_ , _STR:11_ , _STR:12_ , _STR:13_ , _STR:14_ , _STR:15_ , _STR:16_ and _STR:17_ . MEDIA_TYPES is a tuple with 2 strings : _STR:18_ and _STR:19_ .
python_2_unicode_compatible decorator ,
derive the class Media from the object base class .
define the method __init__ with 3 arguments : self , media set to None and unpacked dictionary kwargs .
if media is true ,
substitute media.__dict__ [ media . __dict__ ] for media_attrs .
if not ,
substitute kwargs for media_attrs .
self._css [ self . _css ] is an empty dictionary .
self._js [ self . _js ] is an empty list .
for every name in MEDIA_TYPES ,
append name to string _STR:0_ use it as the name of the attribute to get from object self , call the result as an function ,
with an argument : value under the name key of the media_attrs dictionary , if it exists , if not use None as an argument . define the method __str__ with an argument self .
call the method self.render [ self . render ] , return the result .
define the method render with an argument self .
call the function chain with an argument unpacked list , append name to string _STR:0_ ,
and use it as the name of the attribute to get from the self object , call the result and append it to a list for every name in MEDIA_TYPES , join all the results into a string with newline separator , use the result as an argument for the call to the function mark_safe , return the result . define the method render_js with an argument self .
return a list containing results of the function format_html called with 2 arguments :
string _STR:0_ and absolute file path of the path , for every path is self._js [ self . _js ] . define the method render_css with an argument self .
call the method self._css.keys [ self . _css . keys ] , sort the result and substitute it for media .
return the result of the call to the function chain , with an argument unpacked list , containing the result of the function ,
format_html called with 3 arguments : string _STR:0_ , return value of the function self.absolute_path [ self . absolute_path ] called with an argument path and medium , for every medium in media and for every path in value under the medium key of the self._css [ self . _css ] dictionary . define the method absolute_path with 3 arguments self , path and prefix set to None .
if path starts with string _STR:0_ or string _STR:1_ or with string _STR:2_ ,
return path ,
if prefix is None ,
if settings.STATIC_URL [ settings . STATIC_URL ] is None ,
substitute settings.MEDIA_URL [ settings . MEDIA_URL ] for prefix .
if not ,
substitute settings.STATIC_URL [ settings . STATIC_URL ] for prefix .
join prefix and path into an url , return it .
define the method __getitem__ with arguments self and name .
if name is contained in MEDIA_TYPES ,
return an instance of the class Media , called with an unpacked dictionary with an entry : name appended to string _STR:0_ ,
attribute of the self object for name converted into a string . raise an KeyError with an argument string _STR:0_ , where ' % s ' is replaced with name .
define the method __getitem__ with arguments self and name .
if data is true ,
for every path in data ,
if path is not contained in self._js [ self . _js ] ,
append path to self._js [ self . _js ] .
define the method add_css with arguments self and data .
if data is true ,
call the method data.items [ data . items ] , for every medium and paths in the result .
for every path in paths ,
if call to the method self._css.get [ self . _css . get ] with an argument medium evaluates to false ,
or path is not contained in the value under the medium key of self._css [ self . _css ] dictionary . call the method self._css.setdefault [ self . _css . setdefault ] with 2 arguments medium and an empty string , append path to the result .
define the method __add__ with arguments self and other .
combined is an instance of Media class .
for every name in MEDIA_TYPES ,
append name to _STR:0_ use it as the name of the attribute to get from combined object , call the result with an argument :
name appended to string _STR:0_ , as the name of the attribute to get from self object , or if the previous doesnt exist , None . append name to _STR:1_ use it as the name of the attribute to get from combined object , call the result with an argument :
name appended to string _STR:0_ , as the name of the attribute to get from other object , or if the previous doesnt exist , None . return combined .
define the function media_property with an argument cls .
define the method _media with an argument self .
sup_cls is base class of the class cls .
try ,
substitute sup_cls.media [ sup_cls . media ] for base .
if AttributeError exception is caught ,
base is an instance of Media class .
get the attribute _STR:0_ of the cls object , if it exists substitute it for definition , if not definition is None .
if definition is true ,
get the attribute _STR:0_ of the cls object , if it exists substitute it for extend , if not extend is boolean True .
if extend is true ,
if extend is boolean True ,
substitute base for m .
if not ,
m is an instance of Media class .
for every medium in extend ,
sum m and value under the medium key of the base dictionary , substitute it for m .
sum m and class Media created with definition , return the result .
if not ,
return an instance of Media class , created with definition as an argument .
if not ,
return base .
return property object with _media as getter function .
derive the class MediaDefiningClass from the type base class .
define the method __new__ with 4 arguments mcs , name , bases and attrs .
call the method __new__ from the base class of the class MediaDefiningClass , called with 4 arguments : mcs , name , bases and attrs .
if _STR:0_ is not contained in attrs ,
call the method media_property with an argument new_class , substitute the result for new_class.media [ new_class . media ] .
return new_class .
python_2_unicode_compatible decorator
derive the class SubWidget from the object base class .
define the method __init__ with 6 arguments self , parent_widget , name , value , attrs and choices .
substitute parent_widget for self.parent_widget [ self . parent_widget ] .
substitute name and value for self.name [ self . name ] and self.value [ self . value ] .
substitute attrs and choices for self.attrs [ self . attrs ] and self.choices [ self . choices ]
define the method __str__ with an argument self .
args is an list with 3 initial elements self.name [ self . name ] , self.value [ self . value ] and self.attrs [ self . attrs ] .
if self.choices [ self . choices ] is true ,
append self.choices [ self . choices ] to args .
call the method self.parent_widget.render [ self . parent_widget . render ] with unpacked list args as an argument , return the result .
derive the class Widget from the base class in the return value of the six.with_metaclass [ six . with_metaclass ] called with an argument MediaDefiningClass .
needs_multipart_form is boolean False .
is_localized is boolean False .
is_required is boolean False .
define the method __init__ with arguments self and attrs set to None .
if attrs is not None ,
call the method attrs.copy [ attrs . copy ] , substitute the result for self.attrs [ self . attrs ] .
if not ,
self.attrs [ self . attrs ] is an empty dictionary .
define the method __deepcopy__ with arguments self and memo .
call the method copy.copy [ copy . copy ] , substitute the result for obj .
call the method self.attrs.copy [ self . attrs . copy ] , substitute the result for obj.attrs [ obj . attrs ] .
substitute obj for the value of the memo dictionary at the identity of the self object key .
return obj .
property decorator ,
define the method is_hidden with an argument self .
if self.input_type [ self . input_type ] equals string _STR:0_ and self has an attribute _STR:1_ , return boolean True , otherwise return boolean False .
define the method subwidgets with 5 arguments : self , name , value , attrs set to None and choices set to an empty tuple .
yield an instance of SubWidget class created with 5 arguments : self , name , value , attrs and choices .
define the method render with 4 arguments : self , name , value and attrs set to None .
raise an NotImplementedError with an argument string _STR:0_ .
define the method build_attrs with 3 arguments : self , extra_attrs set to None and unpacked dictionary kwargs .
unpack dictionary kwargs , map it through self.attrs [ self . attrs ] and convert to dictionary , substitute the result for attrs .
if extra_attrs is true ,
update attrs dictionary with extra_attrs entry .
return attrs .
define the method render with 4 arguments : self , name , value and attrs set to None .
get the value under the name key of the data dictionary , return it , if the previous doesnt exists , return None .
define the method id_for_label with 2 arguments : self and id .
return id_ .
derive the class Input from the Widget base class .
input_type is None .
define the method _format_value with 2 arguments : self and value .
if self.is_localized [ self . is_localized ] is true ,
call the method formats.localize_input [ formats . localize_input ] with an argument value , return the result .
return value .
define the method render with 4 arguments : self , name , value and attrs set to None .
if value is None ,
value is an empty string .
call the method self.build_attrs [ self . build_attrs ] with 3 arguments : attrs , type as self.input_type [ self . input_type ] , name as name , substitute the result for final_attrs .
if value is not equal to an empty string ,
call the method self._format_value [ self . _format_value ] with an argument value , use the result as an argument for the call to the function force_text ,
substitute the result for final_attrs dictionary value under the _STR:0_ key . call the function format_html with 2 arguments : string _STR:1_ ,
result of the function flatatt called with an argument final_attrs , return the result . derive the class TextInput from the Input base class .
input_type is a string _STR:0_ .
define the method __init__ with 2 arguments : self and attrs set to None .
if attrs is not None ,
remover the entry under the _STR:0_ key of the attrs dictionary , substitute it for self.input_type [ self . input_type ] , if the key doesnt exists ,
substitute self.input_type [ self . input_type ] for self.input_type [ self . input_type ] . call the method __init__ from the base class of the class TextInput , called with an argument attrs .
derive the class NumberInput from the TextInput base class .
input_type is a string _STR:0_ .
derive the class EmailInput from the TextInput base class .
input_type is a string _STR:0_ .
derive the class URLInput from the TextInput base class .
input_type is a string _STR:0_ .
derive the class PasswordInput from the TextInput base class .
input_type is a string _STR:0_ .
define the method __init__ with 3 arguments : self , attrs set to None and render_value set to boolean False .
call the method __init__ from the base class of the class PasswordInput , called with an argument attrs .
substitute render_value for self.render_value [ self . render_value ] .
define the method render with 4 arguments : self , name , value and attrs set to None .
if self.render_value [ self . render_value ] is false ,
value is None .
call the method render from the base class of the class PasswordInput , called with 3 arguments : name , value and attrs ,
return the result . derive the class HiddenInput from the Input base class .
input_type is a string _STR:0_ .
derive the class MultipleHiddenInput from the HiddenInput base class .
define the method __init__ with 3 arguments : self , attrs set to None and choices set to an empty tuple .
call the method __init__ from the base class of the class MultipleHiddenInput , called with an argument attrs .
substitute choices for self.choices [ self . choices ] .
define the method render with 5 arguments : self , name , value , attrs set to None and choices set to an empty tuple .
if value is None ,
value is an empty list .
call the method self.build_attrs [ self . build_attrs ] with 3 arguments : attrs , type set to self.input_type [ self . input_type ] , name set to name ,
substitute the result for final_attrs . get the value under the _STR:0_ key of final_attrs dictionary , substitute if for id_ if the key doesnt exists , id_ is None .
inputs is an empty list .
for every i and v in enumerated iterable value ,
unpack dictionary final_attrs , map the values through force_text function with an argument v and convert it to a dictionary , again ,
substitute the result input_attrs . if id_ ,
replace ' % s ' in string _STR:0_ with id_ and i , substitute the result for input_attrs dictionary value under the _STR:1_ key .
call the function format_html with 2 arguments : string _STR:0_ , return value of the function flatatt , called with an argument ,
input_attrs , append the result to inputs list . join inputs elements into a string , separated with newline character , use it as an argument for the call to the function mark_safe ,
return the result . define the method value_from_datadict with 4 arguments : self , data , files and name .
if data is an instance of MultiValueDict or MergeDict class ,
call the method data.getlist [ data . getlist ] with an argument name , return the result .
return value under the name key of the data dictionary , if it doesnt exists , return None .
derive the class FileInput from the Input base class .
input_type is a string _STR:0_ .
needs_multipart_form is boolean True .
define the method render with 4 arguments : self , name , value and attrs set to None .
call the method render from the base class of the class FileInput , called with 3 arguments : name , None and attrs as attrs .
define the method value_from_datadict with 4 arguments : self , data , files and name .
return value under the name key of the files dictionary , if it doesnt exists , return None .
FILE_INPUT_CONTRADICTION is an instance of object class .
derive the class ClearableFileInput from the FileInput base class .
call the function ugettext_lazy with an argument string _STR:0_ , substitute the result for initial_text .
call the function ugettext_lazy with an argument string _STR:0_ , substitute the result for input_text .
call the function ugettext_lazy with an argument string _STR:0_ , substitute the result for clear_checkbox_label .
template_with_initial is a string _STR:0_ .
template_with_clear is a string _STR:0_ .
url_markup_template is a string _STR:0_ .
define the method clear_checkbox_name with 2 arguments : self and name .
concatenate name and string _STR:0_ , return it .
define the method clear_checkbox_id with 2 arguments : self and name .
concatenate name and string _STR:0_ , return it .
define the method render with 4 arguments : self , name , value and attrs set to None .
substitutions is a dictionary with 4 initial entries : self.initial_text [ self . initial_text ] for _STR:0_ , self.input_text [ self . input_text ] for _STR:1_ ,
an empty string for _STR:0_ and self.clear_checkbox_label [ self . clear_checkbox_label ] for _STR:1_ . template is a string _STR:2_ .
call the method render from the base class of the class ClearableFileInput , called with 3 arguments : name , value and attrs ,
substitute the result for value under the _STR:0_ key of the substitutions dictionary . if value is true and value has an attribute _STR:1_ ,
substitute self.template_with_initial [ self . template_with_initial ] for template .
call the function format_html with 3 arguments : self.url_markup_template [ self . url_markup_template ] , value.url [ value . url ] and return value of the function force_text ,
called with an argument value , substitute the result for value under the _STR:0_ key of the substitutions dictionary . if self.is_required [ self . is_required ] is false ,
call the method self.clear_checkbox_name [ self . clear_checkbox_name ] with an argument name , substitute the result for checkbox_name .
call the method self.clear_checkbox_id [ self . clear_checkbox_id ] with an argument checkbox_name , substitute the result for checkbox_id .
call the function conditional_escape with an argument checkbox_name ,
substitute the result for value under the _STR:0_ key of the substitutions dictionary . call the function conditional_escape with an argument checkbox_id ,
substitute the result for value under the _STR:0_ key of the substitutions dictionary . call the method render from the instance of CheckboxInput class , with 3 arguments : checkbox_name , boolean False ,
attrs as a dictionary with an entry : checkbox_id for _STR:0_ , substitute the result for value under the _STR:1_ key of the substitutions dictionary . format self.template_with_clear [ self . template_with_clear ] with substitutions , substitute the result for value under the _STR:2_ key of ,
substitutions dictionary . call the function mark_safe with an argument template , formated with substitutions , return the result .
define the method value_from_datadict with 4 arguments : self , data , files and name .
call the method value_from_datadict from the base class of the class ClearableFileInput ,
called with 3 arguments : data , files and name , substitute the result for upload . if self.is_required [ self . is_required ] is boolean false and call to the method value_from_datadict from the instance of CheckboxInput class ,
with 3 arguments : data , files and return value of the function self.clear_checkbox_name [ self . clear_checkbox_name ] called with an argument name , evaluates to true , if upload is true ,
return FILE_INPUT_CONTRADICTION .
return boolean False .
return boolean upload .
derive the class Textarea from the Widget base class .
define the method __init__ with 2 arguments : self and attrs set to None .
default_attrs is an dictionary with 2 initial entries : string _STR:0_ for _STR:1_ and string _STR:2_ for _STR:3_ .
if attrs is true ,
update default_attrs dictionary with attrs entry .
call the method __init__ from the base class of the class Textarea , with an argument default_attrs .
define the method render with 4 arguments : self , name , value and attrs set to None .
if value is None ,
value is an empty string .
call the method self.build_attrs [ self . build_attrs ] with 2 arguments : attrs and name set to name , substitute the result for final_attrs .
call the function format_html with 3 arguments : string ( _STR:0_ , return value of the function flatatt ,
called with an argument final_attrs and return value of the function force_text called with an argument value , return the result . derive the class DateTimeBaseInput from the TextInput base class .
format key is an empty string .
supports_microseconds is boolean False .
define the method __init__ with 3 arguments : self , attrs set to None and format is None .
call the method __init__ from the base class of the class DateTimeBaseInput , with an argument attrs .
substitute format for self.format [ self . format ] if format is true , if not self.format [ self . format ] is None .
define the method _format_value with 2 arguments : self and value .
call the function formats.localize_input [ formats . localize_input ] with 2 arguments : value and self.format [ self . format ] if true , if not ,
then the first element of the result of the function formats.get_format [ formats . get_format ] called with an argument self.format_key [ self . format_key ] , return the result . derive the class DateInput from the DateTimeBaseInput base class .
format_key is a string _STR:0_ .
derive the class DateTimeInput from the DateTimeBaseInput base class .
format_key is a string _STR:0_ .
derive the class TimeInput from the DateTimeBaseInput base class .
format_key is a string _STR:0_ .
define the function boolean_check with an argument v .
if v is boolean False or v is None or v is an empty string , return boolean False , otherwise return boolean True .
derive the class CheckboxInput from the Widget base class .
define the method __init__ with 3 arguments : self , attrs set to None and check_test set to None .
call the method __init__ from the base class of the class CheckboxInput , with an argument attrs .
substitute boolean_check for self.check_test [ self . check_test ] if check_test is None , otherwise substitute check_test for self.check_test [ self . check_test ] .
define the method render with 4 arguments : self , name , value and attrs set to None .
call the method self.build_attrs [ self . build_attrs ] with 3 arguments : attrs , type as a string _STR:0_ , name as name , substitute the result for final_attrs .
call the method self.check_test [ self . check_test ] with an argument value , if it evaluates to true ,
substitute string _STR:0_ for value under the _STR:0_ key of final_attrs dictionary .
if value is boolean False or boolean True or value is None or value is an empty string , do not perform the following ,
call the function force_text with an argument value , substitute the result for value under the _STR:0_ key of the final_attrs .
return the result of the function format_html called with 2 arguments : string _STR:0_ ,
and result of the function flatatt , called with an argument final_attrs . define the method value_from_datadict with 4 arguments : self , data , files and name .
if name is not contained in data ,
return boolean False .
get the name key of the data dictionary , substitute it for value .
values is an dictionary with 2 arguments : boolean False for _STR:0_ and boolean True for _STR:1_ .
if value is an instance of six.string_types [ six . string_types ] class ,
get the value of the values dictionary under the value converted to lowercase key , substitute it for value , if the key doesnt exists ,
substitute value for value . return value converted into a boolean .
derive the class Select from the Widget base class .
allow_multiple_selected is boolean False .
define the method __init__ with 3 arguments : self , attrs set to None and choices set to an empty tuple .
call the method __init__ from the base class of the class Select , with an argument attrs .
convert elements of choices into a list , substitute it for self.choices [ self . choices ] .
define the method render with 5 arguments : self , name , value , attrs set to None and choices set to an empty tuple .
if value is None ,
value is an empty string .
call the method self.build_attrs [ self . build_attrs ] with arguments attrs , name as name , substitute the result for final_attrs .
output is a list containing an element : result of the function format_html called with 2 arguments : string _STR:0_ ,
and return value of the function flatatt called with an argument final_attrs , substitute the result for output . call the method self.render_options [ self . render_options ] with 2 arguments : choices and list with an entry , value , substitute the result for options .
if options is true ,
append options to output .
append string _STR:0_ to output .
join elements of output into a string , separated by newline characters , use it as the argument for the call the function mark_safe ,
return the result . define the method render_option with 4 arguments : self , selected_choices , option_value and option_label .
if option_value is None ,
option_value is an empty string .
call the function force_text with an argument option_value , substitute the result for option_value .
if option_value is contained in selected_choices ,
call the function mark_safe with an argument string _STR:0_ , substitute the result for selected_html .
if self.allow_multiple_selected [ self . allow_multiple_selected ] is false ,
call the method selected_choices.remove [ selected_choices . remove ] with an argument option_value .
if not ,
selected_html is an empty string .
call the function format_html with 4 arguments : string _STR:0_ , option_value , selected_html ,
result of the function force_text with an argument option_label , return the result . define the method render_options with 3 arguments : self , choices and selected_choices .
call the function force_text with an argument v , for every v in selected_choices , add results to a set ,
substitute the resulting set for selected_choices . output is an empty list .
call the function chain with arguments self.choices [ self . choices ] and choices , for every option_value and option_label in the result ,
if option_label is an instance of list or tuple ,
call the function format_html with 2 arguments : string _STR:0_ and return value of the function force_text ,
called with an argument option_value , append the result to output . for every option in option_label ,
call the method self.render_option [ self . render_option ] with 2 arguments : selected_choices and unpacked list option , append the result to output .
append string _STR:0_ to output .
if not ,
call the method self.render_option [ self . render_option ] with 3 arguments : selected_choices , option_value and option_label , append the result to output .
join elements of output in a string , separated by newlines , return it .
derive the class NullBooleanSelect from the Select base class .
define the method __init__ with 2 arguments : self and attrs set to None .
choices is a tuple with 3 elements : tuple with 2 elements : string _STR:0_ and return value of the function ugettext_lazy ,
called with an argument string _STR:0_ , tuple with 2 elements : string _STR:1_ and return value of the function ugettext_lazy , called with an argument string _STR:2_ and tuple with 2 elements : string _STR:3_ and return value of the function ugettext_lazy , called with an argument string _STR:4_ . call the method __init__ from the base class of the class NullBooleanSelect , with arguments attrs and choices .
define the method render with 5 arguments : self , name , value , attrs set to None and choices set to an empty tuple .
try ,
get the value under value key of a dictionary with 4 entries : _STR:0_ for boolean True , _STR:1_ for boolean False , _STR:0_ for _STR:0_ ,
and _STR:0_ for _STR:0_ , substitute it for value . if KeyError exception is caught ,
value is an string _STR:0_ .
call the method render from the base class of the class NullBooleanSelect , with 4 arguments : name , value , attrs and choices ,
return the result . define the method value_from_datadict with 4 arguments : self , data , files and name .
get the value under the name key of the data dictionary , if it exists substitute it for value , if not , value is None .
get the value under the value key of a dictionary with 6 entries : boolean True for _STR:0_ , boolean True for boolean True ,
boolean True for _STR:0_ , boolean False for _STR:1_ , boolean False for _STR:2_ and boolean False for boolean False , return it if the key exists , if not return None . derive the class SelectMultiple from the Select base class .
allow_multiple_selected is boolean True .
define the method render with 5 arguments : self , name , value , attrs set to None and choices set to an empty tuple .
if value is None ,
value is an empty list .
call the method self.build_attrs [ self . build_attrs ] with 2 arguments : attrs and name set to name , substitute the result for final_attrs .
output is a list containing an entry : result of the function format_html called with 2 arguments :
string _STR:0_ and result of the function flatatt called with an argument final_attrs . call the method self.render_options [ self . render_options ] with 2 arguments : choices and value , substitute the result for options .
if options is true ,
append options to output .
append string _STR:0_ to output .
join elements of output into a string , separated with newline character ,
use it as an argument for the call to the mark_safe function , return the result . define the method value_from_datadict with 4 arguments : self , data , files and name .
if data is an instance of MultiValueDict or MergeDict ,
call the method data.getlist [ data . getlist ] with an argument name , return the result .
get the value under the name key of the data dictionary , if it exists return it , if not return None .
python_2_unicode_compatible decorator ,
derive the class ChoiceInput from the SubWidget base class .
input_type is None .
define the method __init__ with 6 arguments : self , name , value , attrs , choice and index .
substitute name for self.name [ self . name ] .
substitute value for self.value [ self . value ] .
substitute attrs for self.attrs [ self . attrs ] .
call the function force_text with first element of choice as an argument , substitute the result for self.choice_value [ self . choice_value ] .
call the function force_text with second element of choice as an argument , substitute the result for self.choice_label [ self . choice_label ] .
substitute index for self.index [ self . index ] .
if string _STR:0_ is contained in self.attrs [ self . attrs ] ,
convert self.index [ self . index ] into a string and append it to _STR:0_ string , substitute it for value under the _STR:1_ key of self.attrs [ self . attrs ] dictionary .
define the method __str__ with an argument self .
call the method self.render [ self . render ] , return the result .
define the method render with 5 arguments : self , name set to None , value set to None , attrs set to None and choices set to an empty tuple .
self.id_for_label [ self . id_for_label ] is true ,
call the function format_html with 2 arguments : string _STR:0_ and self.id_for_label [ self . id_for_label ] , substitute the result for label_for .
if not ,
label_for is an empty string .
call the function format_html with 4 arguments : string _STR:0_ , label_for , result of the method self.tag [ self . tag ] ,
and self.choice_label [ self . choice_label ] , return the result . define the method is_checked with an argument self .
if self.value [ self . value ] equals self.choice_value [ self . choice_value ] , return boolean True , if not , return boolean False .
define the method tag with an argument self .
call the method dict with 4 : self.attrs [ self . attrs ] , type as self.input_type [ self . input_type ] , name as self.name [ self . name ] , value as self.choice_value [ self . choice_value ] ,
substitute the result for final_attrs . call the method self.is_checked [ self . is_checked ] , if it evaluates to true ,
substitute string _STR:0_ for value under the _STR:0_ key of final_attrs dictionary .
call the function format_html with 2 arguments : string _STR:0_ and result of the function flatatt ,
called with an argument final_attrs , return the result . property decorator ,
define the method id_for_label with an argument self .
get the value under the _STR:0_ key of the self.attrs [ self . attrs ] dictionary , return it , if the key doesnt exists return an empty string .
derive the class RadioChoiceInput from the ChoiceInput base class .
input_type is a string _STR:0_ .
define the method __init__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
call the method __init__ from the base class of the class RadioChoiceInput , with 2 arguments : unpacked list args ,
and unpacked dictionary kwargs . call the function force_text with an argument self.value [ self . value ] , substitute the result for self.value [ self . value ] .
derive the class CheckboxChoiceInput from the ChoiceInput base class .
input_type is a string _STR:0_ .
define the method __init__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
call the method __init__ from the base class of the class CheckboxChoiceInput , with 2 arguments : unpacked list args ,
and unpacked dictionary kwargs . for every v in self.value [ self . value ] call the function force_text with an argument v , add the result to a set ,
substitute set of the results for self.value [ self . value ] . define the method is_checked with an argument self .
if self.choice_value [ self . choice_value ] is contained in self.value [ self . value ] return boolean True , otherwise return boolean False .
python_2_unicode_compatible decorator ,
derive the class ChoiceFieldRenderer from the object base class .
choice_input_class is None .
outer_html is a string _STR:0_ .
inner_html is a string _STR:0_ .
define the method __init__ with 5 arguments : self , name , value , attrs and choices .
substitute name for self.name [ self . name ] .
substitute value for self.value [ self . value ] .
substitute attrs for self.attrs [ self . attrs ] .
substitute choices for self.choices [ self . choices ] .
define the method __getitem__ with 2 arguments : self and idx .
substitute idx-th element of self.choices [ self . choices ] for choice .
call the method self.choice_input_class [ self . choice_input_class ] with 5 arguments : self.name [ self . name ] , self.value [ self . value ] , result of the method self.attrs.copy [ self . attrs . copy ] ,
choice and idx , return the result . define the method __str__ with an argument self .
call the method self.render [ self . render ] , return the result .
define the method render with an argument self .
get the value under the _STR:0_ key of the self.attrs [ self . attrs ] dictionary , substitute it for id_ if the key exists , if not id_ is None .
output is an empty list .
for every i and choice in enumerated iterable self.choices [ self . choices ] ,
substitute choice for choice_value and choice_label , respectively .
if choice_label is an instance of tuple or list ,
call the method self.attrs.copy [ self . attrs . copy ] , substitute the result for attrs_plus .
if id_ is true ,
prepend string _STR:0_ to i converted to an string , append the result to the value under the _STR:1_ key of the attrs_plus .
sub_ul_renderer is an instance of ChoiceFieldRenderer class , created with 4 arguments : name as self.name [ self . name ] , value as self.value [ self . value ] ,
attrs as attrs_plus and choices as choice_label . substitute self.choice_input_class [ self . choice_input_class ] for sub_ul_renderer.choice_input_class [ sub_ul_renderer . choice_input_class ] .
call the function format_html with 3 arguments : self.inner_html [ self . inner_html ] , choice_value set to choice_value ,
and sub_widgets set to return value of the function sub_ul_renderer.render [ sub_ul_renderer . render ] , append the result to output . if not ,
call the method self.choice_input_class [ self . choice_input_class ] with 5 arguments : self.name [ self . name ] , self.value [ self . value ] , return value of the method self.attrs.copy [ self . attrs . copy ] ,
choice and i , substitute the result for w. call the function format_html with 3 arguments : self.inner_html [ self . inner_html ] , choice_value set to result of the function force_text ,
called with an argument w , and sub_widgets as an empty string , append the result to output . call the function format_html with 3 arguments : self.outer_html [ self . outer_html ] ,
if id_ is true id_attr set to return value of the function format_html , if not id_attr set to an empty string , content set to result of the function mark_safe with an argument : string created by joining elements of outputs , with _STR:0_ separator , return the result . derive the class RadioFieldRenderer from the ChoiceFieldRenderer base class .
substitute RadioChoiceInput for choice_input_class .
derive the class CheckboxFieldRenderer from the ChoiceFieldRenderer base class .
substitute CheckboxChoiceInput for choice_input_class .
derive the class RendererMixin from the object base class .
renderer is None .
_empty_value is None .
define the method __init__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
remove entry under _STR:0_ key of the kwargs dictionary and substitute it for renderer , if the key doesnt exists , renderer is None .
if renderer is true ,
substitute renderer for self.renderer [ self . renderer ] .
call the method __init__ from the base class of the class RendererMixin , with 2 arguments : unpacked list args ,
and unpacked dictionary kwargs . define the method subwidgets with 5 arguments : self , name , value , attrs set to None and choices set to an empty tuple .
call the method self.get_renderer [ self . get_renderer ] with 4 arguments : name , value , attrs and choices , for every widget in result ,
yield widget .
define the method get_renderer with 5 arguments : self , name , value , attrs set to None and choices set to an empty tuple .
if value is None ,
substitute self._empty_value [ self . _empty_value ] for value .
call the method self.build_attrs [ self . build_attrs ] with an argument attrs , substitute the result for final_attrs .
call the function chain with 2 arguments : self.choices [ self . choices ] and choices , convert the result into a list and substitute it for choices .
call the method self.renderer [ self . renderer ] with 4 arguments : name , value , final_attrs and choices , return the result .
define the method render with 5 arguments : self , name , value , attrs set to None and choices set to an empty tuple .
call the method self.get_renderer [ self . get_renderer ] with 4 arguments : name , value , attrs and choices , call the render method on the result , return the result .
define the method id_for_label with 2 arguments : self and id_ .
if id_ is true ,
append string _STR:0_ to id_ .
return id_ .
derive the class RadioSelect from the RendererMixin and Select base classes .
substitute RadioFieldRenderer for renderer .
_empty_value is an empty string .
derive the class CheckboxSelectMultiple from the RendererMixin and SelectMultiple base classes .
substitute CheckboxFieldRenderer for renderer .
_empty_value is an empty list .
derive the class MultiWidget from the Widget base class .
define the method __init__ with 3 arguments : self , widgets and attrs set to None .
for every w in widgets , call the function w and append the result to a list , if w is an instance of type class ,
if not append w to the list , substitute the resulting list for self.widgets [ self . widgets ] . call the method __init__ from the base class of the class MultiWidget , with an argument attrs .
property decorator ,
define the method is_hidden with an argument self .
for every w in self.widgets [ self . widgets ] , if all elements w.is_hidden [ w . is_hidden ] are true , return boolean True , otherwise return boolean False .
define the method render with 4 arguments : self , name , value and attrs set to None .
if self.is_localized [ self . is_localized ] is true ,
for every bwidget in self.widgets [ self . widgets ] ,
substitute self.is_localized [ self . is_localized ] for widget.is_localized [ widget . is_localized ] .
if value is not an instance of list type ,
call the method self.decompress [ self . decompress ] with an argument value , substitute the result for value .
output is an empty list .
call the method self.build_attrs [ self . build_attrs ] with an argument attrs , substitute the result for final_attrs .
get the value under the _STR:0_ key of the final_attrs dictionary , substitute it for id_ , if it doesnt exists , id_ is None .
for every i and widget in enumerated iterable self.widgets [ self . widgets ] ,
try ,
substitute i-th element of value for widget_value .
if IndexError exception is caught ,
widget_value is None .
if id_ is true ,
call the dict function with 2 arguments : final_attrs and id set to string _STR:0_ , where ' % s ' is replaced with id_ and i ,
substitute the result for final_attrs . call the method widget.render [ widget . render ] with 3 arguments : string created by concatenation from : name , string _STR:0_ and i , widget_value ,
and final_attrs , append the result to output . call the method self.format_output [ self . format_output ] with an argument output , use the result as an argument for the call to the function mark_safe ,
return the result . define the method id_for_label with 2 arguments : self and id_ .
if id_ is true ,
append string _STR:0_ to id_ .
return id_ .
define the method value_from_datadict with 2 arguments : self , data , files and name .
for every i and widget in enumerated iterable self.widgets [ self . widgets ] , call the function widget.value_from_datadict [ widget . value_from_datadict ] with 3 arguments : data ,
files and string created with concatenation of : name , string _STR:0_ and i converted into a string , return the results in a list . define the method format_output with 2 arguments : self and rendered_widgets .
join rendered_widgets into a string , return it .
define the method decompress with 2 arguments : self and value .
raise NotImplementedError exception with an argument string _STR:0_ .
define the method _get_media with an argument self .
media is an instance of Media class .
for every w in self.widgets [ self . widgets ] ,
sum media and w.media [ w . media ] , substitute the result for media .
return media .
media is a property object of the current class , with _get_media as getter function .
define the method __deepcopy__ with 2 arguments : self and memo .
call the method __deepcopy__ from the base class of the class MultiWidget , with an argument memo , substitute the result for obj .
call the method copy.deepcopy [ copy . deepcopy ] with an argument self.widgets [ self . widgets ] , substitute the result for obj.widgets [ obj . widgets ] .
return obj .
property decorator ,
define the method needs_multipart_form with an argument self .
if any w.needs_multipart_form [ w . needs_multipart_form ] for every w in self.widgets [ self . widgets ] is true , return boolean True , if not return boolean False .
derive the class SplitDateTimeWidget from the MultiWidget base class .
supports_microseconds is boolean False .
define the method __init__ with 4 arguments : self , attrs set to None , date_format set to None and time_format set to None .
widgets is a tuple with 2 elements : instance of DateInput class , created with 2 arguments : attrs as attrs and format as date_format ,
and instance of TimeInput class , created with 2 arguments : attrs set to attrs and format set to date_format . call the method __init__ from the base class of the class SplitDateTimeWidget , with 2 arguments : widgets and attrs .
define the method decompress with 2 arguments : self and value .
if value is true ,
call the function to_current_timezone with an argument , substitute the result for value .
return a list containing 2 elements : return value of the value.date [ value . date ] method and return value of the replace method ,
called with the argument microseconds set to integer 0 , on the result of the method value.time [ value . time ] . return list containing 2 elements : None and None .
derive the class SplitHiddenDateTimeWidget from the SplitDateTimeWidget base class .
define the method render with 4 arguments : self , attrs set to None , date_format set to None and time_format set to None .
call the method __init__ from the base class of the class SplitHiddenDateTimeWidget , with 3 arguments : attrs , date_format , and time_format .
for every widget in self.widgets [ self . widgets ] : ,
widget.input_type [ widget . input_type ] is a string _STR:0_ .
from django.http.cookie [ django . http . cookie ] import SimpleCookie and parse_cookie into default name space .
from django.http.request [ django . http . request ] import HttpRequest , QueryDict , RawPostDataException , UnreadablePostError and build_request_repr into default name space .
from django.http.response [ django . http . response ] import HttpResponse , StreamingHttpResponse , HttpResponseRedirect , HttpResponsePermanentRedirect ,
HttpResponseNotModified , HttpResponseBadRequest , HttpResponseForbidden , HttpResponseNotFound , HttpResponseNotAllowed , HttpResponseGone , HttpResponseServerError , Http404 , BadHeaderError , JsonResponse into default name space . from django.http.utils [ django . http . utils ] import fix_location_header and conditional_content_removal into default name space .
__all__ is a list of strings , _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ ,
from __future__ import unicode_literals into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_st into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.six.moves [ django . utils . six . moves ] import http_cookies into default name space .
call the function http_cookies.SimpleCookie [ http_cookies . SimpleCookie ] , on the return value call the value_encode method , with the argument character _STR:0_ ,
if the tuple result equals to tuple containing character _STR:0_ and string _STR:1_ , respectively , assign _cookie_encodes_correctly the boolean True value , otherwise assign it False . assign return value of the call to the http_cookies.SimpleCookie [ http_cookies . SimpleCookie ] function to _tc .
try ,
call the _tc.load [ _tc . load ] method with the _STR:0_ converted to string as an argument .
_cookie_allows_colon_in_names is a boolean True .
if http_cookies.CookieError [ http_cookies . CookieError ] exception is caught ,
_cookie_allows_colon_in_names is boolean False .
if _cookie_encodes_correctly and _cookie_allows_colon_in_names are boolean True ,
substitute http_cookies.SimpleCookie [ http_cookies . SimpleCookie ] for SimpleCookie .
if not ,
substitute http_cookies.Morsel [ http_cookies . Morsel ] for Morsel .
derive class SimpleCookie from the base class http_cookies.SimpleCookie [ http_cookies . SimpleCookie ] .
if _cookie_encodes_correctly is boolean False ,
define method value_encode with self class instance and val as arguments .
from the base class of the class SimpleCookie call the value_encode method with val as the argument , store the result in the val and encoded , respectively .
in encoded , replace all the occurrences of unicode character _STR:0_ with _STR:1_ character and _STR:2_ with _STR:3_ characters .
if encoded contains string `` \\ '' and if encoded doesnt start with the double quote symbol ,
put the double qoutes around encoded .
return val and encoded as a tuple .
if _cookie_allows_colon_in_names is False ,
define the method load with self class instance and rawdata as arguments .
self.bad_cookies [ self . bad_cookies ] is an empty set .
if six.PY2 [ six . PY2 ] is true and rawdata is an instance of the type six.text_type [ six . text_type ] .
call the function force_str with raw data as an argument and substitute it for rawdata .
from the base class of the SimpleCookie class call the method load with rawdata as argument .
for every key is self.bad_cookies [ self . bad_cookies ] ,
delete self entry under the key key .
define protected method _BaseCookie__set with self class instance , key , real_value and coded_value as arguments .
evaluate the function force_str with key as the argument , substitute it for key .
try ,
get the value under the key of the dictionary self , if key does not exists return evaluated result of the function Morsel , substitute it for M .
call the M.set [ M . set ] method with the key , real_value , coded_value as the arguments .
call the private dict.__setitem__ [ dict . __setitem__ ] method with self class instance , key and M as arguments .
if http_cookies.CookieError [ http_cookies . CookieError ] exception is raised .
if self does not have _STR:0_ attribute ,
self.bad_cookies [ self . bad_cookies ] is an empty set .
add key to the self.bad_cookies [ self . bad_cookies ] set .
call the private dict.__setitem__ [ dict . __setitem__ ] method with self class instance , key and result of the function http_cookies.Morsel [ http_cookies . Morsel ] ( ) as arguments .
define the function parse_cookie with cookie as the argument .
if cookie is an empty string ,
return an empty dictionary .
if cookie is not an instance of http_cookies.BaseCookie [ http_cookies . BaseCookie ] ,
try ,
c is an instance of the class SimpleCookie .
call the load method on the c class instance , with the cookie argument .
if http_cookies.CookieError [ http_cookies . CookieError ] exception is raised ,
return an empty dictionary .
if not ,
substitute cookie for c .
cookiedict is an empty dictionary .
for every key in return value of the method c.keys [ c . keys ] call ,
get the value filed from the return value of the call to the c.key [ c . key ] with the argument key , add the value to the cookiedict under the key key .
return cookiedict .
from __future__ import unicode_literals into default name space .
import module base64 .
import module binascii .
import module cgi .
import module sys .
from django.conf [ django . conf ] import settings into default name space .
from django.core.exceptions [ django . core . exceptions ] import SuspiciousMultipartF into default name space .
from django.utils.datastructures [ django . utils . datastructures ] import MultiValueDict into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_text into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.text [ django . utils . text ] import unescape_entities into default name space .
from django.core.files.uploadhandler [ django . core . files . uploadhandler ] import StopUpload , SkipFile and StopFutureHandlers into default name space .
__all__ is an tuple with 3 elements : strings _STR:0_ , _STR:1_ and _STR:2_ .
derive the class MultiPartParserError from the Exception base class .
do nothing .
derive the class InputStreamExhausted from the Exception base class .
do nothing .
RAW is a string _STR:0_ .
FILE is a file '' .
FIELD is a field '' .
if six.PY2 [ six . PY2 ] is true , _BASE64_DECODE_ERROR is TypeError , if not , _BASE64_DECODE_ERROR is binascii.Error [ binascii . Error ] .
derive the class MultiPartParser from the object base class .
define the method __init__ wiht 5 arguments : self , META , input_data , upload_handlers and encoding set to None .
get the value from META dictionary , under the _STR:0_ key , if the key doesnt exist ,
return the value under the _STR:0_ of the META dictionary , if it doesnt exist return an empty string , substitute the result for content_type . if content_type doesnt start with string _STR:1_ ,
raise an MultiPartParserError with an argument string _STR:0_ , where ' % s ' is replaced with content_type .
call the method boundary with an argument string _STR:0_ , use the result to call to the parse_header function ,
assign the result to ctypes and opts . get the value under the _STR:0_ key of the opts dictionary , substitute it for boundary .
if boundary is false or return value of the method cgi.valid_boundary [ cgi . valid_boundary ] called with an argument boundary evaluates to false ,
raise an MultiPartParserError with an argument string _STR:0_ is replaced with boundary .
try ,
convert value under the _STR:0_ key of the META dictionary to an integer of base of value under the _STR:1_ key of META dictionary , if the key doesnt exists use 0 as the base , substitute the result for content_length .
if ValueError or TypeError are caught ,
content_length is integer 0 .
if content_length is lesser than integer 0 ,
raise an MultiPartParserError with an argument string _STR:0_ , where _STR:1_ is replaced with content_length .
if boundary is an instance of six.text_type [ six . text_type ] class ,
call the method boundary.encode [ boundary . encode ] with an argument string _STR:0_ , substitute the result for boundary .
substitute boundary for self._boundary [ self . _boundary ] .
substitute input_data for self._input_data [ self . _input_data ] .
for every x in upload_handlers if x.chunk_size [ x . chunk_size ] is true , append x.chunk_size [ x . chunk_size ] to a list , substitute the result for possible_sizes .
bring integer 2 to the power of 31 , subtract the result by 4 , put the result into a list , append possible_sizes to it ,
substitute minimal element of the resulting list for self._chunk_size [ self . _chunk_size ] . substitute META for self._meta [ self . _meta ] .
if encoding is true , substitute it for self._encoding [ self . _encoding ] , if not substitute settings.DEFAULT_CHARSET [ settings . DEFAULT_CHARSET ] for self._encoding [ self . _encoding ] .
substitute content_length for self._content_length [ self . _content_length ] .
substitute _upload_handlers for self.__upload_handlers [ self . __upload_handlers ] .
define the method parse with an argument self .
from django.http [ django . http ] import QueryDict into default namespace .
substitute self._encoding [ self . _encoding ] for encoding .
substitute self._upload_handlers [ self . _upload_handlers ] for handlers .
if self._content_length [ self . _content_length ] equals integer 0 ,
instantiate QueryDict class with 2 arguments : an empty string and encoding set to self._encoding [ self . _encoding ] , instantiate a class MultiValueDict , return them .
for every handler in handlers ,
call the method handler.handle_raw_input [ handler . handle_raw_input ] with 5 arguments : self._input_data [ self . _input_data ] , self._meta [ self . _meta ] , self._content_length [ self . _content_length ] , self._boundary [ self . _boundary ] ,
and encoding , substitute the result for result . if result is not None ,
return first and second element of result .
self._post [ self . _post ] is an instance of QueryDict class , created with an empty string and mutable set to boolean True .
self._files [ self . _files ] is an instance of MultiValueDict class .
instantiate class ChunkIter with 2 arguments : self._input_data [ self . _input_data ] and self._chunk_size [ self . _chunk_size ] , use it to instantiate LazyStream class ,
assign the handle to stream . old_field_name is None .
counters is a list containing length of handlers number of zeros .
try ,
call the Parser object with stream and self._boundary [ self . _boundary ] , for every item_type , meta_data and field_stream in return value ,
if old_field_name is true ,
call the method self.handle_file_complete [ self . handle_file_complete ] with arguments old_field_name , counters .
old_field_name is None .
try ,
get the value under the _STR:0_ key of the meta_data dictionary , substitute second element of it for disposition .
get the value under the _STR:0_ key of the disposition dictionary , strip it of whitespaces , substitute the result for field_name .
if KeyError , IndexError and AttributeError exception is caught ,
skip this loop iteration ,
get the value under the _STR:0_ key of the disposition meta_data , substitute it for transfer_encoding .
if transfer_encoding is not None ,
strip of the whitespaces first element of transfer_encoding , substitute the result for transfer_encoding .
call the function force_text with 3 arguments : field_name , encoding and errors as a string _STR:0_ , substitute the result for field_name .
if item_type equals FIELD ,
if transfer_encoding equals a string _STR:0_ ,
call the method field_stream.read [ field_stream . read ] , substitute the result for raw_data .
try ,
call the function base64.b64decode [ base64 . b64decode ] with an argument raw_data , substitute the result for data .
if _BASE64_DECODE_ERROR exception is caught ,
substitute raw_data for data .
if not ,
call the method field_stream.read [ field_stream . read ] , substitute the result for data .
call the method self._post.appendlist [ self . _post . appendlist ] with 2 arguments : field_name and result of the function force_text called with 3 arguments :
data , encoding and errors as a string _STR:0_ . otherwise if item_type equals FILE ,
get the value under the _STR:0_ key of the disposition dictionary , substitute it for file_name .
if file_name is false ,
skip this loop execution .
call the function force_text with 3 arguments : file_name , encoding and errors set to string _STR:0_ ,
substitute the result for file_name . call the function unescape_entities with an argument file_name , use the result as an argument for the call to the self.IE_sanitize [ self . IE_sanitize ] ,
method , substitute the result for file_name . get the value under the _STR:0_ of the meta_data dictionary , if it exists assign it to content_type , content_type_extra ,
if not , content_type is an empty string and content_type_extra is an empty dictionary . strip the content_type of the whitespaces , substitute it for content_type .
get the value under the _STR:0_ key of the content_type_extra dictionary , substitute it for charset .
try ,
convert to an integer first element of the value under the _STR:0_ key of the meta_data dictionary , substitute it for content_length .
if IndexError , TypeError or ValueError exception is caught ,
content_length is None .
counters is a list containing length of handlers number of zeros .
try ,
for every handler in handlers ,
try ,
call the method handler.new_file [ handler . new_file ] with 6 arguments : field_name , file_name , content_type , content_length , charset and content_type_extra .
if StopFutureHandlers exception is caught .
break the loop execution .
for every chunk in field_stream ,
if transfer_encoding equals string _STR:0_ ,
calculate length of chunk modulo integer 4 , substitute the result for over_bytes .
if over_bytes is true ,
call the method field_stream.read [ field_stream . read ] with an argument : over_bytes subtracted from integer 4 , substitute the result for over_chunk .
increment chunk by over_chunk .
try ,
call the method base64.b64decode [ base64 . b64decode ] with an argument chunk , substitute the result for chunk .
if Exception , renamed to e , exception is caught ,
msg is a string _STR:0_ , where _STR:1_ is replace with e .
call the method six.reraise [ six . reraise ] with 3 arguments : MultiPartParserError , MultiPartParserError created with msg ,
and third element of the result of the function sys.exc_info [ sys . exc_info ] . for every i and handler in enumerated iterable handlers ,
substitute length of chunk for chunk_length .
call the method handler.receive_data_chunk [ handler . receive_data_chunk ] with 2 arguments : chunk and i-th element of counters , substitute the result for chunk .
increment i-th element of counters by chunk_length .
if chunk is None ,
break the loop execution .
if SkipFile exception is caught ,
call the method self._close_files [ self . _close_files ] .
call the function exhaust with an argument field_stream .
if not ,
substitute field_name for old_field_name .
if not ,
call the function exhaust with an argument stream .
if StopUpload , renamed to e , exception is caught ,
call the method self._close_files [ self . _close_files ] .
if e.connection_reset [ e . connection_reset ] is false ,
call the function exhaust with an argument self._input_data [ self . _input_data ] .
if not ,
call the function exhaust with an argument self._input_data [ self . _input_data ] .
for every handler in handlers ,
call the method handler.upload_complete [ handler . upload_complete ] , substitute the result for retval .
if retval is true ,
break the loop execution .
return self._post [ self . _post ] and self._files [ self . _files ] .
define the method handle_file_complete with 3 arguments : self , old_field_name and counters .
for every i and handler in enumerated iterator self._upload_handlers [ self . _upload_handlers ] ,
call the method handler.file_complete [ handler . file_complete ] with i-th element of counters as an argument , substitute the result for file_obj .
if file_obj is true ,
call the function force_text with 3 arguments : old_field_name , self._encoding [ self . _encoding ] and errors as a string _STR:0_ ,
use the result and file_obj as arguments for the call to the method self._files.appendlist [ self . _files . appendlist ] . break the loop execution .
define the method IE_sanitize with arguments self and filename .
call the method filename.rfind [ filename . rfind ] with an argument string `` \\ '' , increment the result by one ,
slice the filename from the previous result as start index to the end , strip it of white spaces from both ends , if the result is not an empty string and filename is not an empty string , return boolean True , otherwise return boolean False . define the method _close_files with an argument self .
for every handler in self._upload_handlers [ self . _upload_handlers ] ,
if handler has an attribute _STR:0_ ,
call the method handler.file.close [ handler . file . close ] .
derive the class LazyStream from the six.Iterator [ six . Iterator ] base class .
define the method __init__ with 3 arguments : self , producer and length set to None .
substitute producer for self._producer [ self . _producer ] .
self._empty [ self . _empty ] is boolean False .
self._leftover [ self . _leftover ] is an empty string .
substitute length for self._length [ self . _length ] .
self.position [ self . position ] is an integer 0 .
substitute length for self._remaining [ self . _remaining ] .
self._unget_history [ self . _unget_history ] is an empty list .
define the method tell with an argument self .
return self.position [ self . position ] .
define the method read with arguments self and size set to None .
define the function parts .
if size is None substitute self._remaining [ self . _remaining ] for remaining , if not , substitute size for remaining .
if remaining is None ,
join self into a bytes string , yield the result as the return value of the generator .
return nothing .
while remaining is not equal to integer 0 ,
if remaining is not greater than 0 , assert an error with the message string _STR:0_ .
get the next element of iterable self , substitute it for chunk .
create list of first remaining elements of chunk , substitute it for emitting .
call the method self.unget [ self . unget ] with list containing first remaining elements of chunk as an argument .
decrement remaining by length of emitting .
yield emitting as result of the generator .
join result of the parts function into a bytes string , substitute it for out .
return out .
define the method __next__ with an argument self .
if self._leftover [ self . _leftover ] is true ,
substitute self._leftover [ self . _leftover ] for output .
self._leftover [ self . _leftover ] is an empty string .
if not ,
get the next element of the self._producer [ self . _producer ] iterable , substitute it for output .
self._unget_history [ self . _unget_history ] is an empty list .
increment self.position [ self . position ] by length of output .
return output .
define the method close with an argument self .
self._producer [ self . _producer ] is an empty list .
define the method _iter with an argument self .
return self .
define the method unget with arguments self and bytes .
if bytes is false ,
return nothing .
call the method self._update_unget_history [ self . _update_unget_history ] with length of bytes as an argument .
decrement self.position [ self . position ] by length of bytes .
join bytes and self._leftover [ self . _leftover ] into a bytes string , substitute it for self._leftover [ self . _leftover ] .
define the method _update_unget_history with arguments self and num_bytes .
append first 49 elements of self._unget_history [ self . _unget_history ] to list containing num_bytes , substitute the result for self._unget_history [ self . _unget_history ] .
append current_number to a list for current_number in self._unget_history [ self . _unget_history ] , if current_number is equal to num_bytes ,
substitute the length of the resulting list for number_equal . if number_equal is greater than integer 40 ,
raise SuspiciousMultipartForm exception with an argument string , _STR:0_
_STR:0_ . derive the class ChunkIter from the six.Iterator [ six . Iterator ] base class .
define the method __init__ with arguments self , flo and chunk_size set to integer 64 multiplied by integer 1024 .
substitute flo for self.flo [ self . flo ] .
substitute chunk_size for self.chunk_size [ self . chunk_size ] .
define the method __next__ with an argument self .
try ,
call the method self.flo.read [ self . flo . read ] with an argument self.chunk_size [ self . chunk_size ] , substitute the result for data .
if InputStreamExhausted exception is caught ,
raise an StopIteration exception .
if data is true ,
return data .
if not ,
raise an StopIteration exception .
define the method __iter__ with an argument self .
return self .
derive the class InterBoundaryIter from the six.Iterator [ six . Iterator ] base class .
define the method __init__ with arguments self , stream and boundary .
substitute stream for self._stream [ self . _stream ] .
substitute boundary for self.boundary [ self . boundary ] .
define the method __iter__ with an argument self .
return self .
define the method __next__ with an argument self .
try ,
instantiate class BoundaryIter with 2 arguments : self._stream [ self . _stream ] and self._boundary [ self . _boundary ] , use it to instantiate LazyStream class , return it .
if InputStreamExhausted exception is caught ,
raise an StopIteration .
derive the class BoundaryIter from the six.Iterator [ six . Iterator ] base class .
define the method __init__ with arguments self , stream and boundary .
substitute stream for self._stream [ self . _stream ] .
substitute boundary for self._boundary [ self . _boundary ] .
self._done [ self . _done ] is boolean False .
increment length of boundary by integer 6 , substitute the result for self._rollback [ self . _rollback ] .
call the method self._stream.read [ self . _stream . read ] with an argument integer 1 , substitute the result for unused_char .
if unused_char is false ,
raise an InputStreamExhausted exception ,
call the method self._stream.unget [ self . _stream . unget ] with an argument unused_char .
define the method __iter__ with an argument self .
return self .
define the method __next__ with an argument self .
if self._done [ self . _done ] is true ,
raise an StopIteration exception ,
substitute self._stream [ self . _stream ] for stream .
substitute self._rollback [ self . _rollback ] for rollback .
bytes_read is integer 0 .
chunks is an empty list .
for every bytes in stream ,
increment bytes_read by length of bytes .
append bytes to chunks .
if bytes_read is greater than rollback ,
break the loop execution .
if bytes is false ,
break the loop execution .
if not ,
self._done [ self . _done ] is boolean True .
if chunks is false ,
raise an StopIteration exception .
join chunks into bytes string , substitute it for chunk .
call the method self._find_boundary [ self . _find_boundary ] with 2 arguments : chunk and boolean if length of chunks is lesser than self._rollback [ self . _rollback ] ,
or boolean False if not , substitute the result for boundary . if boundary is true ,
substitute elements of tuple boundary to end and next , respectively .
call the method stream.unget [ stream . unget ] with elements of list chunk from the index next to the end .
self._done [ self . _done ] is boolean True .
return first end elements of list chunk .
if not ,
slice chunk list to get the last rollback elements , if the new list is not empty ,
self._done [ self . _done ] is boolean True .
return chunk .
if not ,
call the method stream.unget [ stream . unget ] with last rollback elements of chunk as an argument .
return last rollback elements of chunk .
define the method _find_boundary with an arguments self , data and eof set to boolean False .
call the method data.find [ data . find ] with an argument self._boundary [ self . _boundary ] , substitute the result for index .
if index is lesser than integer 0 ,
return None .
if not ,
substitute index for end .
sum index and length of self._boundary [ self . _boundary ] , substitute the result for next .
substitute greater element between integer 0 and end decremented by one for last .
element of data at the index last equals to newline bytes character .
decrement end by one .
substitute greater element between integer 0 and end decremented by one for last .
element of data at the index last equals to carriage return bytes character .
decrement end by one .
return end ans next .
define the function exhaust with an argument stream_or_iterable .
iterator is None .
try ,
iterator is iterator created out of stream_or_iterable .
if TypeError exception is caught ,
iterator is an instance of ChunkIter class , created with arguments : stream_or_iterable and integer 16384 .
if iterator is None ,
raise an MultiPartParserError with an argument string _STR:0_ .
for every __ in iterator ,
do nothing .
define the function parse_boundary_stream with arguments stream and max_header_size .
call the method stream.read [ stream . read ] with an argument max_header_size , substitute the result for chunk .
call the method chunk.find [ chunk . find ] with an argument bytes string _STR:0_ , substitute the result for header_end .
define the method _parse_header with an argument line .
call the function parse_header with an argument line , substitute the result for main_value_pair and params , respectively .
try ,
split into two parts string main_value_pair at character _STR:0_ , substitute the parts for name and value , respectively .
if ValueError exception is caught ,
raise an ValueError with an argument string _STR:0_ , where ' % s ' is replaced with line .
return name and tuple containing 2 elements value and params .
if header_end equals integer negative 1 ,
call the method stream.unget [ stream . unget ] with an argument chunk .
return tuple containing 3 elements : RAW , an empty dictionary and stream .
substitute first header_end elements of chunk list for header .
call the method stream.unget [ stream . unget ] with list containing elements of chunk list from the header_end incremented by integer 4 as a start index to the end as argument .
substitute RAW for TYPE .
outdict is an empty dictionary .
split header string at string _STR:0_ , for every line in result ,
try ,
call the method _parse_header with an argument line , assign the result to name and tuple with 2 elements : value and params , respectively .
if ValueError exception is caught ,
skip this loop iteration .
if name equals a string _STR:0_ ,
substitute FIELD for TYPE ,
get the value under the _STR:0_ key of the params dictionary , if it is true ,
substitute FILE for TYPE .
assign value and params to the value under the name key of the outdict dictionary .
if TYPE equals to RAW ,
call the method stream.unget [ stream . unget ] with an argument chunk .
return a tuple with 3 elements : TYPE , outdict and stream .
derive the class Parser from the base class object .
define the method __init__ with arguments self , stream and boundary .
substitute stream for self._stream [ self . _stream ] .
append boundary to bytes string _STR:0_ , substitute the result for self._separator [ self . _separator ] .
define the method __iter__ with an argument self .
boundarystream is an instance of InterBoundaryIter class , created with self._stream [ self . _stream ] and self._separator [ self . _separator ] as arguments .
for every sub_stream in boundarystream ,
call the function parse_boundary_stream with 2 arguments : sub_stream and integer 1024 , yield the result as the return value of the generator .
define the function parse_header with an argument line .
append line to bytes string _STR:0_ , use it as an argument for the call to the function _parse_header_params , substitute the result for plist .
pop the first element from plist , convert it to lowercase , call the method decode on it , with string _STR:0_ as an argument ,
substitute the result for key . pdict is an empty dictionary .
for every p in plist ,
call the method p.find [ p . find ] with bytes string _STR:0_ as an argument , substitute the result for i .
if i is greater or equal to integer 0 ,
take the first i elements of string p , strip the whitespaces from the both sides , convert it to lowercase and apply on it the method ,
decode with an argument string _STR:0_ , substitute the result for name . take elements of p from index i incremented by 1 to the end , strip the result of the whitespaces , substitute it for value .
if length of value is greater or equal to integer 2 and first and last elements of value are an empty string ,
strip value of the first and last element .
replace all the occurrences of _STR:0_\\_STR:1_\\_STR:2_ ' , substitute the result for value .
substitute value for the vale under the name key of the pdict dictionary .
return key and pdict .
define the function _parse_header_params with an argument s .
plist is an empty list .
while first element of s is equal to bytes string _STR:0_ ,
substitute s without the first element for s .
call the method s.find [ s . find ] with an argument bytes string _STR:0_ , substitute the result for end .
while end is greater than integer 0 and return value of the s.count [ s . count ] called with 3 arguments : an empty string , integer 0 and end ,
is an even number , call the method s.find [ s . find ] with 2 arguments : bytes string _STR:0_ and end incremented by one , substitute the result for end .
if end is lesser than integer 0 ,
substitute length of s for end .
substitute first end elements of s for f .
strip f of whitespaces and append it to plist .
substitute elements of s from the end index to end for s .
return plist .
from __future__ import unicode_literals into default name space .
import module copy .
import module os .
import module re .
import module sys .
from io import BytesIO into default name space .
from itertools import chain into default name space .
from pprint import pformat into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.core [ django . core ] import signing into default name space .
from django.core.exceptions [ django . core . exceptions ] import DisallowedHost and ImproperlyConfigured into default name space .
from django.core.files [ django . core . files ] import uploadhandler into default name space .
from django.http.multipartparser [ django . http . multipartparser ] import MultiPartParser and MultiPartParserError into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.datastructures [ django . utils . datastructures ] import MultiValueDict and ImmutableList into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_bytes , force_text , force_str and iri_to_uri into default name space .
from django.utils.six.moves.urllib.parse [ django . utils . six . moves . urllib . parse ] import parse_qsl , urlencode , quote , urljoin and urlsplit into default name space .
RAISE_ERROR is an instance of object class .
compile the regex _STR:0_ with an argument re.I [ re . I ] , substitute it for absolute_http_url_re .
compile the regex _STR:0_ , substitute it for host_validation_re .
derive the class UnreadablePostError from the base class IOError .
do nothing .
derive the class RawPostDataException from the base class Exception .
do nothing .
derive the class HttpRequest from the object base class .
_encoding is None .
_upload_handlers is an empty list .
define the method __init__ with an argument self .
self.GET [ self . GET ] is an instance of QueryDict class created with an argument mutable set to boolean True .
self.POST [ self . POST ] is an instance of QueryDict class created with an argument mutable set to boolean True .
self.COOKIES [ self . COOKIES ] is an empty dictionary .
self.META [ self . META ] is an empty dictionary .
self.FILES [ self . FILES ] is an instance of MultiValueDict class .
self.path [ self . path ] is an empty string .
self.path_info [ self . path_info ] is an empty string .
self.method [ self . method ] is None .
self.resolver_match [ self . resolver_match ] is None .
self._post_parse_error [ self . _post_parse_error ] is boolen False .
define the method __repr__ with an argument self .
call the method build_request_repr with an argument self , return the result .
define the method get_host with an argument self .
if settings.USE_X_FORWARDED_HOST [ settings . USE_X_FORWARDED_HOST ] is true and _STR:0_ is contained in self.META [ self . META ] .
get the value under the _STR:0_ key of the self.META [ self . META ] dictionary , substitute the result for host .
if _STR:0_ is contained in self.META [ self . META ] ,
substitute the value under the _STR:0_ key of the self.META [ self . META ] dictionary , substitute it for host .
if not ,
substitute the value under the _STR:0_ key of the self.META [ self . META ] dictionary , substitute it for host .
convert the value under the _STR:0_ key of the self.META [ self . META ] dictionary to a string , substitute result for server_port .
if return value of the self.is_secure [ self . is_secure ] method is true and server_port is not equal to string _STR:0_ ,
if return value of the self.is_secure [ self . is_secure ] is false and server port is not equal to string _STR:0_ , join host and server_port into a string , separated with _STR:1_ , substitute the result for host .
if settings.DEBUG [ settings . DEBUG ] is true ,
return host .
call the function split_domain_port with an argument host , assign the result to domain and port , respectively .
if domain is true and return value of the function validate_host called with 2 arguments : domain and settings.ALLOWED_HOSTS [ settings . ALLOWED_HOSTS ] , evaluates to true ,
return host .
if not ,
msg is a string _STR:0_ , replace _STR:1_ with host .
if domain is true ,
append string _STR:0_ to msg , where ' % s ' is replaced with domain .
if not ,
append string _STR:0_ to msg .
raise an DisallowedHost exception with an argument msg .
define the method get_full_path with an argument self .
if the value under the _STR:0_ key of the self.META [ self . META ] dictionary is true , call the function iri_to_uri ,
called with value under the _STR:0_ key of the self.META [ self . META ] dictionary and append it to string _STR:1_ , append the result th the self.path [ self . path ] converted into a string and return it , if the value under the _STR:0_ key of the self.META [ self . META ] dictionary is false , return self.path [ self . path ] converted into a string . def the method get_signed_cookie with 5 arguments : self , key , default set to RAISE_ERROR , salt as an empty string ,
try ,
substitute value under the key key of the self.COOKIES [ self . COOKIES ] dictionary , substitute it for cookie_value .
if KeyError exception is caught ,
if default is true and RAISE_ERROR is false ,
return default .
if not ,
raise an exception .
try ,
call the method signing.get_cookie_signer [ signing . get_cookie_signer ] with an argument salt set to sum of key and salt , call the method unsign on the result ,
with arguments cookie_value and max_age set to max_age . if signing.BadSignature [ signing . BadSignature ] exception is caught ,
if default is true and RAISE_ERROR is false ,
return default .
if not ,
raise an exception .
return value .
define the method build_absolute_uri with an arguments self and location set to None .
if location is None ,
call the method self.get_full_path [ self . get_full_path ] , append the result to string _STR:0_ , substitute it for location .
call the function urlsplit with an argument location , substitute the result for bits .
do not perform the following only if bits.scheme [ bits . scheme ] and bits.netloc [ bits . netloc ] are both true ,
format the string _STR:0_ by replacing scheme with self.scheme [ self . scheme ] , host with return value of the self.get_host [ self . get_host ] method ,
and path with self.path [ self . path ] , substitute the result for current_uri . call the function urljoin with arguments current_uri and location , substitute the result for location .
call the function iri_to_uri with an argument location , return the result .
define the method _get_scheme with an argument self .
return string _STR:0_ if value under the _STR:1_ key of the os.environ [ os . environ ] dictionary equals string _STR:2_ , if not return _STR:3_ .
property decorator .
define the method scheme with an argument self .
if settings.SECURE_PROXY_SSL_HEADER [ settings . SECURE_PROXY_SSL_HEADER ] is true ,
try ,
assign the settings.SECURE_PROXY_SSL_HEADER [ settings . SECURE_PROXY_SSL_HEADER ] to header and value , respectively .
if ValueError exception is caught ,
raise an ImproperlyConfigured exception with an argument string _STR:0_ .
if value under the header key of the self.META [ self . META ] dictionary is equal to value ,
return string _STR:0_ .
call the method self._get_scheme [ self . _get_scheme ] , return the result .
define the method is_secure with an argument self .
if self.scheme [ self . scheme ] equals to string _STR:0_ , return boolean True , otherwise return boolean False .
define the method is_ajax with an argument self .
get the value under the _STR:0_ key of the self.META [ self . META ] dictionary , if it equals string _STR:1_ ,
return boolean True , otherwise return boolean False . property decorator .
define the method encoding with an argument self .
return self._encoding [ self . _encoding ] .
encoding.setter [ encoding . setter ] decorator ,
define the method encoding with arguments self and val .
substitute val for self._encoding [ self . _encoding ] .
if self has an _STR:0_ attribute ,
delete self._get [ self . _get ] .
if self has an _STR:0_ attribute ,
del self._post [ self . _post ]
define the method _initialize_handlers with an argument self .
for every handler in settings.FILE_UPLOAD_HANDLERS [ settings . FILE_UPLOAD_HANDLERS ] ,
add to a list result of the method uploadhandler.load_handler [ uploadhandler . load_handler ] called with arguments handler and self , substitute resulting list for self._upload_handlers [ self . _upload_handlers ] . property decorator ,
define the method upload_handlers with an argument self .
if self._upload_handlers [ self . _upload_handlers ] is false ,
call the method self._initialize_handlers [ self . _initialize_handlers ] ,
return self._upload_handlers [ self . _upload_handlers ] .
upload_handlers.setter [ upload_handlers . setter ] decorator .
define the method upload_handlers with arguments : self and upload_handlers .
if self has an _STR:0_ attribute .
raise an AttributeError exception with an argument string _STR:0_ .
substitute upload_handlers for self._upload_handlers [ self . _upload_handlers ] .
define the method parse_file_upload with 3 arguments : self , META and post_data .
self.upload_handlers [ self . upload_handlers ] is an instance of ImmutableList , created with 2 arguments : self.upload_handlers [ self . upload_handlers ] ,
and warning as a string _STR:0_ . parser is an instance of MultiPartParser class , created with 4 arguments : META , post_data , self.upload_handlers [ self . upload_handlers ] and self.encoding [ self . encoding ] .
call the method parser.parse [ parser . parse ] , return the result .
property decorator ,
define the method body with an argument self .
if self doesnt have an _STR:0_ attribute ,
if self._read_started [ self . _read_started ] is true ,
raise an RawPostDataException exception with an argument string _STR:0_ .
try ,
call the method self.read [ self . read ] , substitute the result or self._body [ self . _body ] .
if IOError , renamed to e , exception is caught ,
call the function six.reraise [ six . reraise ] with 3 arguments : UnreadablePostError , UnreadablePostError instantiated with unpacked list e.args [ e . args ] ,
third element of the result of the function sys.exc_info [ sys . exc_info ] . self._stream [ self . _stream ] is an instance of BytesIO class created with an argument self._body [ self . _body ] .
return self._body [ self . _body ] .
define the method_mark_post_parse_error with an argument self .
self._post [ self . _post ] is an instance of QueryDict class created with an empty string as argument .
self._files [ self . _files ] is an instance of MultiValueDict class .
self._post_parse_error [ self . _post_parse_error ] is boolean True .
define the method _load_post_and_files with an argument self .
if self.method [ self . method ] is not equal to string _STR:0_ ,
self._post [ self . _post ] is an instance of QueryDict created with arguments : an empty string and encoding set to self._encoding [ self . _encoding ] ,
self._files [ self . _files ] is an instance of class MultiValueDict . return nothing .
if self._read_started [ self . _read_started ] is true and self doesnt have an _STR:0_ attribute .
call the method self._mark_post_parse_error [ self . _mark_post_parse_error ] .
return nothing .
get the value under the _STR:0_ key of the self.META [ self . META ] dictionary , if it starts with a string _STR:1_ ,
if self has an attribute _STR:0_ ,
data is an instance of BytesIO class , created with an argument : self._body [ self . _body ] .
if not ,
substitute self for data .
try ,
call the method self.parse_file_upload [ self . parse_file_upload ] with arguments self.META [ self . META ] and data , assign the result to self._post [ self . _post ] and self._files [ self . _files ] .
if MultiPartParserError exception is caught ,
call the method self._mark_post_parse_error [ self . _mark_post_parse_error ] .
raise an exception .
otherwise if value under the _STR:0_ key of hte self.META [ self . META ] dictionary starts with _STR:1_ ,
self._post [ self . _post ] is an instance of QueryDict created with arguments : self.body [ self . body ] and encoding set to self._encoding [ self . _encoding ] ,
self._files [ self . _files ] is an instance of class MultiValueDict . if not ,
self._post [ self . _post ] is an instance of QueryDict created with arguments : an empty string and encoding set to self._encoding [ self . _encoding ] ,
self._files [ self . _files ] is an instance of class MultiValueDict . define the method close with an argument self .
if self has an attribute _STR:0_ ,
for every f in return value of the return value of the method chain.from_iterable [ chain . from_iterable ] called with argument :
second element of l for every l in return value of the self._files.lists [ self . _files . lists ] call the method f.close [ f . close ] .
define the method read with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
self._read_started [ self . _read_started ] is True .
try ,
call the method self._stream.read [ self . _stream . read ] with 2 arguments : unpacked list args and unpacked dictionary kwargs .
if IOError , renamed to e , exception is caught ,
call the function six.reraise [ six . reraise ] with 3 arguments : UnreadablePostError , UnreadablePostError instantiated with unpacked list e.args [ e . args ] ,
third element of the result of the function sys.exc_info [ sys . exc_info ] . define the method readline with 3 arguments : self , unpacked list args and unpacked list kwargs .
self._read_started [ self . _read_started ] is boolean True .
try ,
call the method self._stream.readline [ self . _stream . readline ] with 2 arguments : unpacked list args , unpacked dictionary kwargs .
if IOError , substituted to e , exception is caught ,
call the function six.reraise [ six . reraise ] with 3 arguments : UnreadablePostError , UnreadablePostError instantiated with unpacked list e.args [ e . args ] ,
third element of the result of the function sys.exc_info [ sys . exc_info ] . define the method __init__ with an argument self .
endless loop ,
read one line from self file stream , substitute the result for buf .
if buf is false ,
break the loop execution .
yield buf as return value of the generator .
substitute xreadlines for __iter__ .
define the method __init__ with an argument self .
append to a list elements of the iterator self , return the resulting list .
derive the class QueryDict from the base class MultiValueDict .
_mutable is boolean True .
_encoding is None .
define the method __init__ with 4 arguments : self , query_string is None , mutable is boolean False and encoding set to None .
call the __init__ method of the base class of the QueryDict class .
if encoding is false .
substitute settings.DEFAULT_CHARSET [ settings . DEFAULT_CHARSET ] for encoding .
substitute encoding for self.encoding [ self . encoding ] .
if six.PY3 [ six . PY3 ] is true ,
if query_string is an instance of bytes ,
call the method query_string.decode [ query_string . decode ] , substitute the result for query_string .
for every key and value in return value of the parse_qsl with 3 arguments : query_string is it exists or an empty string if not ,
keep_blank_values set to boolean True , encoding set to encoding . call the method appendlist with 2 arguments : key and value .
if not ,
for every key and value in parse_gsl with query_string is it exists or an empty string if not and keep_blank_values set to boolean True .
call the method self.appendlist [ self . appendlist ] with 2 arguments : return value of the function force_text with 3 arguments :
key , encoding and errors set to string _STR:0_ , and return value of the function force_text with 3 arguments : value , encoding and errors set to string _STR:0_ . call the method mutable substitute for self._mutable [ self . _mutable ] .
property decorator ,
define the method encoding with an argument self .
if self._encoding [ self . _encoding ] is None ,
substitute settings.DEFAULT_CHARSET [ settings . DEFAULT_CHARSET ] for self._encoding [ self . _encoding ] .
return self._encoding [ self . _encoding ] .
encoding.setter [ encoding . setter ] decorator ,
define the method encoding with arguments self and value .
substitute value for self._encoding [ self . _encoding ] .
define the method _assert_mutable with an argument self .
if not self._mutable [ self . _mutable ] ,
raise an AttributeError with an argument string _STR:0_ .
define the method __setitem__ with 3 arguments : self , key and value .
call the method self._assert_mutable [ self . _assert_mutable ] .
call the method bytes_to_text with 2 arguments : key and self.encoding [ self . encoding ] , substitute the result for key .
call the method bytes_to_text with 2 arguments : key and self.encoding [ self . encoding ] , substitute the result for value .
call the method __setitem__ from the base class of the QueryDict class , with arguments key and value .
define the method __delitem__ with 3 arguments : self and key .
call the method self._assert_mutable [ self . _assert_mutable ] .
call the method __delitem__ from the base class of the QueryDict class , with an argument key .
define the method __copy__ with an argument self .
call the method self.__class__ [ self . __class__ ] with 3 arguments : an empty string , mutable is boolean True , encoding is self.encoding [ self . encoding ] , substitute the result for result .
for key and value in return value of the six.iterlists [ six . iterlists ] function called with an argument self ,
call the method result.setlist [ result . setlist ] with the arguments : key and value .
return result .
define the method __deepcopy__ with 3 arguments : self and memo .
call the method self.__class__ [ self . __class__ ] with 3 arguments : an empty string , mutable is boolean True , encoding is self.encoding [ self . encoding ] , substitute the result for result .
get the identity of the self object , use it as a key to get the value of the memo dictionary , substitute result for it .
for key and value in result of the function six.iterlists [ six . iterlists ] called with an argument ,
call the method result.setlist [ result . setlist ] with 2 arguments : return value of the function copy.deepcopy [ copy . deepcopy ] called with 2 arguments : key and memo ,
and return value of the function copy.deepcopy [ copy . deepcopy ] called with 2 arguments : value and memo . return result .
define the method setlist with 3 arguments : self , key and list_ .
call the method self._assert_mutable [ self . _assert_mutable ] .
call the method bytes_to_text with an arguments key and self.encoding [ self . encoding ] , substitute the result for key .
for every elt in list_ call the method bytes_to_text with 2 argument : elt and self.encoding [ self . encoding ] , append the result into a list ,
substitute the resulting list for list_ . call the method setlist from the base class of the QueryDict class , with arguments key and list_ .
define the method setlistdefault with 3 arguments : self , key and default_list set to None .
call the method self._assert_mutable [ self . _assert_mutable ] .
call the method setlistdefault from the base class of the class QueryDict , with arguments key and default_list , return the result .
define the method appendlist with 3 arguments : self , key and value .
call the method self._assert_mutable [ self . _assert_mutable ] .
call the method bytes_to_text with 2 arguments : key and self.encoding [ self . encoding ] , substitute the result for key .
call the method bytes_to_text with 2 arguments : value and self.encoding [ self . encoding ] , substitute the result for value .
call the method appendlist from the base class of the QueryDict class , with arguments key and value .
define the method pop with 3 arguments : self , key and unpacked list args .
call the method self._assert_mutable [ self . _assert_mutable ] .
call the method pop from the base class of the class QueryDict , with arguments key and unpacked list args , return the result .
define the method popitem with an argument self .
call the method self._assert_mutable [ self . _assert_mutable ] .
call the method popitem from the base class of the class QueryDict , return the result .
define the method clear with an argument self .
call the method self._assert_mutable [ self . _assert_mutable ] .
call the method clear from the base class of the class QueryDict , return the result .
define the method setdefault with 3 arguments : self , key and default set to None .
call the method self._assert_mutable [ self . _assert_mutable ] .
call the method bytes_to_text with 2 arguments : key and self.encoding [ self . encoding ] , substitute the result for key .
call the method bytes_to_text with 2 arguments : default and self.encoding [ self . encoding ] , substitute the result for default .
call the method setlistdefault from the base class of the class QueryDict , with arguments key and default_list , return the result .
define the method copy with an argument self .
call the method self.__deepcopy__ [ self . __deepcopy__ ] with an empty dictionary as an argument .
define the method urlencode with 3 arguments : self and safe set to None .
output is an empty list .
if safe is true ,
call the function force_bytes with 2 arguments : safe and self.encoding [ self . encoding ] , substitute it for safe .
encode is an lambda function with arguments k and v , return value is string _STR:0_ , where ' % s ' is replaced with :
return value of the function quote called with arguments k and safe , and with return value of the function quote called with arguments v and safe . if not ,
encode is an lambda function with 2 arguments k and v , return value is the result of the function urlencode , called with an argument :
dictionary containing element v for k. for every k and list_ in return value of the method self.lists [ self . lists ] ,
call the function force_bytes with arguments k and self.encoding [ self . encoding ] , substitute the result for k .
for every v in list_ append to a list result of the function encode , called with arguments : k and result of the function force_bytes ,
called with arguments v and self.encoding [ self . encoding ] , extend the output with the result . join elements of the output into a string , separated with _STR:0_ , return the result .
define the function build_request_repr with arguments : request , path_override set to None , GET_override set to None ,
try ,
get is a tuple containing elements generated by the call to the function pformat with an argument GET_override ,
if GET_override is not None , or otherwise generated with the call to the function pformat with an argument request.GET [ request . GET ] . if Exception exception is caught ,
get is a string _STR:0_ .
if request._post_parse_error [ request . _post_parse_error ] is true ,
post is a string _STR:0_ .
if not ,
try ,
get is a tuple containing elements generated by the call to the function pformat with an argument POST_override ,
if POST_override is not None , or otherwise generated with the call to the function pformat with an argument request.POST [ request . POST ] . if Exception exception is caught ,
post is a string _STR:0_ .
try ,
get is a tuple containing elements generated by the call to the function pformat with an argument COOKIES_override ,
if COOKIES_override is not None , or otherwise generated with the call to the function pformat with an argument request.COOKIES [ request . COOKIES ] . if Exception exception is caught ,
cookies is a string _STR:0_ .
try ,
get is a tuple containing elements generated by the call to the function pformat with an argument META_override ,
if META_override is not None , or otherwise generated with the call to the function pformat with an argument request.META [ request . META ] . if Exception exception is caught ,
meta is a string _STR:0_ .
substitute path_override for path if path_override is not None , otherwise substitute request.path [ request . path ] for path
call the function force_str with an argument string _STR:0_ ,
where ' % s ' is replaced with request.__class__.__name__ [ request . __class__ . __name__ ] , path , return value of the function six.text_type [ six . text_type ] called with an argument get , return value of the function six.text_type [ six . text_type ] called with an argument post , return value of the function six.text_type [ six . text_type ] , called with an argument cookies and return value of the function six.text_type [ six . text_type ] called with an argument meta . define the function bytes_to_text with 2 arguments s and encoding .
if s is an instance of bytes class ,
call the method six.text_type [ six . text_type ] with 3 arguments : s , encoding and string _STR:0_ .
if not ,
return s .
define the function split_domain_port with an argument host .
convert host to lowercase .
call the method host_validation_re.match [ host_validation_re . match ] with an argument host .
return an empty string and an empty string .
if last element of host equals character _STR:0_ ,
return host and an empty string .
split host from the right side into 2 parts at the _STR:0_ , substitute the result for bits .
if length of bits equals integer 2 ,
add bits to a tuple , return it .
return the first element of bits and an empty string .
define the method validate_host with 2 arguments : host and allowed_hosts .
if host ends with _STR:0_ , remove the last element from host .
for every pattern in allowed_hosts :
convert pattern to lowercase , substitute it for pattern .
if pattern equals _STR:0_ or pattern starts with _STR:1_ or pattern equals host , and only if :
host ends with _STR:0_ and host ends with pattern or host is equal to all but first elements of pattern , substitute boolean true for match , otherwise substitute boolean False for match . if match is true ,
return boolean True .
return boolean False .
from __future__ import unicode_literals into default name space .
import module datetime .
import module json .
import module sys .
import module time .
from email.header [ email . header ] import Header into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.core [ django . core ] import signals into default name space .
from django.core [ django . core ] import signing into default name space .
from django.core.exceptions [ django . core . exceptions ] import DisallowedRedirect into default name space .
from django.core.serializers.json [ django . core . serializers . json ] import DjangoJSONEncode into default name space .
from django.http.cookie [ django . http . cookie ] import SimpleCookie into default name space .
from django.utils [ django . utils ] import six and timezone into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_bytes , force_text and iri_to_uri into default name space .
from django.utils.http [ django . utils . http ] import cookie_date into default name space .
from django.utils.six.moves [ django . utils . six . moves ] import map into default name space .
from django.utils.six.moves.urllib.parse [ django . utils . six . moves . urllib . parse ] import urlparse into default name space .
REASON_PHRASES is a dictionary containing 59 initial entries : _STR:0_ for 100 , _STR:1_ for 101 ,
_STR:0_ for 102 , _STR:1_ for 200 , _STR:2_ for 201 , _STR:3_ for 202 , _STR:4_ for 203 , _STR:5_ for 204 , _STR:6_ for 205 , _STR:7_ for 206 , _STR:8_ for 207 , _STR:9_ for 208 , _STR:10_ for 226 , _STR:11_ for 300 , _STR:12_ for 301 , _STR:13_ for 302 , _STR:14_ for 303 , _STR:15_ for 304 , _STR:16_ for 305 , _STR:17_ for 306 , _STR:18_ for 307 , _STR:19_ for 308 , _STR:20_ for 400 , _STR:21_ for 401 , _STR:22_ for 402 , _STR:23_ for 403 , _STR:24_ for 404 , _STR:25_ for 405 , _STR:26_ for 406 , _STR:27_ for 407 , _STR:28_ for 408 , _STR:29_ for 409 , _STR:30_ for 410 , _STR:31_ for 411 , _STR:32_ for 412 , _STR:33_ for 413 , _STR:34_ for 414 , _STR:35_ for 415 , _STR:36_ for 416 , _STR:37_ for 417 , _STR:38_M A TEAPOT_STR:39_UNPROCESSABLE ENTITY_STR:40_LOCKED_STR:41_FAILED DEPENDENCY_STR:42_UPGRADE REQUIRED_STR:43_PRECONDITION REQUIRED_STR:44_TOO MANY REQUESTS_STR:45_REQUEST HEADER FIELDS TOO LARGE_STR:46_INTERNAL SERVER ERROR_STR:47_NOT IMPLEMENTED_STR:48_BAD GATEWAY_STR:49_SERVICE UNAVAILABLE_STR:50_GATEWAY TIMEOUT_STR:51_HTTP VERSION NOT SUPPORTED_STR:52_VARIANT ALSO NEGOTIATES_STR:53_INSUFFICIENT STORAGE_STR:54_LOOP DETECTED_STR:55_NOT EXTENDED_STR:56_NETWORK AUTHENTICATION REQUIRED ' for 511. derive the class BadHeaderError from the ValueError base class .
do nothing .
derive the class HttpResponseBase from the six.Iterator [ six . Iterator ] base class .
status_code is an integer 200 .
reason_phrase is None .
define the method __init__ with 4 arguments : self , content_type set to None , status set to None , reason set to None .
self._headers [ self . _headers ] is an empty dictionary .
substitute settings.DEFAULT_CHARSET [ settings . DEFAULT_CHARSET ] for self._charset [ self . _charset ] .
self._closable_objects [ self . _closable_objects ] is an empty list .
self._handler_class [ self . _handler_class ] is None .
if content_type is false ,
replace ' % s ' in string _STR:0_ with settings.DEFAULT_CONTENT_TYPE [ settings . DEFAULT_CONTENT_TYPE ] and self._charset [ self . _charset ] , substitute it for content_type .
self.cookies [ self . cookies ] is an instance of a class SimpleCookie .
if status is not None .
substitute status for self.status_code [ self . status_code ] .
if reason is not None ,
substitute reason for self.reason_phrase [ self . reason_phrase ] .
otherwise if self.reason_phrase [ self . reason_phrase ] is None ,
get the value under the self.status_code [ self . status_code ] key of the REASON_PHRASES dictionary , if it exists substitute it for the self.reason_phrase [ self . reason_phrase ] ,
if not , self.reason_phrase [ self . reason_phrase ] is a string _STR:0_ . substitute content_type for value under the _STR:1_ key of the self dictionary .
define the method serialize_headers with an argument self .
define the function to_bytes with arguments val and encoding .
if val is an instance of bytes , return val , otherwise return result of the method val.encode [ val . encode ] called with an argument encoding .
for every key and value in return value of the self._headers.values [ self . _headers . values ] method , call the function to_bytes with 2 arguments : key ,
and string _STR:0_ and call the function to_bytes with 2 arguments : value and string _STR:1_ , join the previous 2 results into a string , separated by _STR:2_ , append it to a list , substitute the resulting list for headers . join headers into a string , separated by string _STR:3_ .
if six.PY3 [ six . PY3 ] is true ,
substitute serialize_headers for __bytes__ .
if not ,
substitute serialize_headers for __str__ .
define the method _convert_to_charset with 4 arguments : self , value , charset and mime_encode set to boolean False .
if value is not an instance of bytes or six.text_type [ six . text_type ] classes ,
convert value to an string and substitute it for value .
try ,
if six.PY3 [ six . PY3 ] is true ,
if value is an instance of str type ,
call the method value.encode [ value . encode ] with an argument charset .
if not ,
call the method value.decode [ value . decode ] with an argument charset , substitute the result for value .
if not ,
if value is an instance of str type ,
call the method value.decode [ value . decode ] with an argument charset .
if not ,
call the method value.encode [ value . encode ] with an argument charset , substitute the result for value .
if UnicodeError , renamed to e , exception is caught ,
if mime_encode is true ,
instantiate class Header with 3 arguments : value , string _STR:0_ , maxlinelen set to sys.maxsize [ sys . maxsize ] , call the encode method on it ,
convert the result into a string and substitute it for value . if not ,
replace ' % s ' in string _STR:0_ for charset , append it to e.reason [ e . reason ] .
raise an exception .
convert _STR:0_ to a string , if it is contained in value or _STR:1_ converted to an string is contained in value ,
raise an BadHeaderError exception with an argument string _STR:0_ , where _STR:1_ is replaced with value .
return value .
define the method __setitem__ with 3 arguments : self , header and value .
call the method self._convert_to_charset [ self . _convert_to_charset ] with arguments : header and string _STR:0_ , substitute the result for header .
call the method self._convert_to_charset [ self . _convert_to_charset ] with arguments : header , string _STR:0_ and mime_encode set to boolean True ,
substitute the result for value . substitute tuple containing 2 elements : header and value for the value under the header converted to lowercase key of the self._headers [ self . _headers ] dictionary .
define the method __delitem__ with 2 arguments : self and header .
try ,
delete the value under the header converted to lowercase key of the self._headers [ self . _headers ] dictionary .
if KeyError exception is caught ,
do nothing .
define the method __getitem__ with 2 arguments : self and header .
convert header to lowercase , use it as the key to get the value from the self._headers [ self . _headers ] dictionary , return the second element of the result .
define the method __getstate__ with an argument self .
call the method self.__dict__.copy [ self . __dict__ . copy ] , substitute the result for state .
get the value under the _STR:0_ key of the state dictionary ,
convert it to a string and substitute it for value under the _STR:0_ key of the state dictionary . return state .
define the method __setstate__ with 2 arguments : self and state .
add state element to self.__dict__ [ self . __dict__ ] dictionary .
self.cookies [ self . cookies ] is an instance of SimpleCookie class created with self.cookies [ self . cookies ] as an argument .
define the method has_header with 2 arguments : self and header .
convert deader to lowercase , if it is contained in self._headers [ self . _headers ] return boolean True , if not , return boolean False .
substitute has_header for __contains__ .
define the method items with an argument self .
call the method self._headers.values [ self . _headers . values ] , return the result ,
define the method get with 3 arguments : self , header and alternate set to None .
convert header to lowercase , use it to as a key to get the value of the self._headers [ self . _headers ] dictionary ,
if it exists return the second element of the result , if not , return alternate . define the method set_cookie with 9 arguments : self , key , value set to an empty string , max_age set to None , expires set to None ,
substitute value for self.cookies [ self . cookies ] dictionary value under the key key .
if expires is not None ,
if expires is an instance of datetime.datetime [ datetime . datetime ] class ,
call the method timezone.is_aware [ timezone . is_aware ] with an argument expires , if it evaluates to true ,
call the method timezone.make_naive [ timezone . make_naive ] with arguments : expires , timezone.utc [ timezone . utc ] , substitute the result for expires .
call the method expires.utcnow [ expires . utcnow ] , subtract the result from expires , substitute the result for delta .
call the method datetime.timedelta [ datetime . timedelta ] with an argument seconds set to integer 1 , increment delta by it .
expires is None .
multiply delta.days [ delta . days ] with an integer 86400 add to the result delta.seconds [ delta . seconds ] , if the result is greater than integer 0 ,
substitute it for max_age , if not , max_age is integer 0. if not ,
get the value under the key key of the self.cookies [ self . cookies ] dictionary , substitute expires for _STR:0_ key of the returned dictionary .
if max_age is not None ,
get the value under the key key of the self.cookies [ self . cookies ] dictionary , substitute max-age for _STR:0_ key of the returned dictionary .
if expires is false ,
get the value under the key key of the self.cookies [ self . cookies ] dictionary , call the cookie_date function with an argument :
sum of the result of the function time.time [ time . time ] and max_age , substitute it for _STR:0_ key of the previously returned dictionary . if path is not None ,
get the value under the key key of the self.cookies [ self . cookies ] dictionary , substitute path for _STR:0_ key of the returned dictionary .
if domain is not None ,
get the value under the key key of the self.cookies [ self . cookies ] dictionary , domain expires for _STR:0_ key of the returned dictionary .
if secure is true ,
get the value under the key key of the self.cookies [ self . cookies ] dictionary , substitute boolean True for _STR:0_ key of the returned dictionary .
if httponly is true ,
get the value under the key key of the self.cookies [ self . cookies ] dictionary , substitute boolean True for _STR:0_ key of the returned dictionary .
define the method set_signed_cookie with 5 arguments : self , key , value , salt as an empty string and unpacked dictionary kwarg .
call the method signing.get_cookie_signer [ signing . get_cookie_signer ] with an argument salt set to sum of key and salt ,
call the method sign on the result with an argument value , substitute the result for value . call the method self.set_cookie [ self . set_cookie ] with 3 arguments : key , value and unpacked dictionary kwargs , return the result .
define the method delete_cookie with 4 arguments : self , key , path set to character _STR:0_ and domain set to None .
call the method self.set_cookie [ self . set_cookie ] with 5 arguments : key , max_age as integer 0 , path as path , domain as domain ,
expires as a string _STR:0_ , return the result . define the method make_bytes with 2 arguments : self and value .
call the method self.has_header [ self . has_header ] with string _STR:0_ as an argument , if it evaluates to true ,
call the function bytes with an argument value , return the result .
if value is an instance of bytes class ,
call the function bytes with an argument value , return the result .
if value is an instance of six.text_type [ six . text_type ] class ,
call the method value.encode [ value . encode ] with an argument self._charset [ self . _charset ] , use the result as an argument for the call to the bytes function ,
return the result . call the function force_bytes with arguments value and self._charset [ self . _charset ] , return the result .
define the method close with an argument self .
for every closable in self._closable_objects [ self . _closable_objects ] ,
try ,
call the method closable.close [ closable . close ] .
if Exception exception is caught ,
do nothing .
call the method signals.request_finished.send [ signals . request_finished . send ] with an argument sender set to self._handler_class [ self . _handler_class ] .
define the method write with 2 arguments : self and value .
raise an Exception exception with an argument string _STR:0_ ,
where ' % s ' is replaced with self.__class__.__name__ [ self . __class__ . __name__ ] . define the method flush with an argument self .
do nothing .
define the method tell with an argument self .
raise an Exception exception with an argument string _STR:0_ ,
where ' % s ' is replaced with self.__class__.__name__ [ self . __class__ . __name__ ] . derive the class HttpResponse from the HttpResponseBase base class .
streaming is boolean False .
define the method __init__ with 4 arguments : self , content set to an empty list , unpacked list args and unpacked dictionary kwargs .
call the __init__ method from the base class of the HttpResponse class , with the arguments : unpacked list args and unpacked dictionary kwargs .
substitute content for self.content [ self . content ] .
define the serialize content with an argument self .
call method self.serialize_headers [ self . serialize_headers ] , append bytes string _STR:0_ to the result , append self.content [ self . content ] to the result , return it .
if six.PY3 [ six . PY3 ] is true ,
substitute serialize for __bytes__ .
if not ,
substitute serialize for __str__ .
property decorator ,
define the method content with an argument self .
join self._container [ self . _container ] elements into a string , return it .
content.setter [ content . setter ] decorator ,
define the method content with 2 arguments : self and value .
if value has an _STR:0_ attribute and value is not an instance of bytes or six.string_types [ six . string_types ] class .
if value has an _STR:0_ attribute ,
append value to the self._closable_objects [ self . _closable_objects ] list .
call the self.make_bytes [ self . make_bytes ] method with an argument chunk , for every chunk in value join the result to a bytes string ,
substitute the result for value . if not ,
call the method self.make_bytes [ self . make_bytes ] with an argument value , substitute the result for value .
self._container [ self . _container ] is a list containing element value .
define the method __iter__ with an argument self .
return self._container [ self . _container ] converted into a iterable .
define the method write with 2 arguments : self and content .
call the method self.make_bytes [ self . make_bytes ] with an argument content , append it to self._container [ self . _container ] .
define the method tell with an argument self .
return the length of self.content [ self . content ] .
derive the class StreamingHttpResponse from the HttpResponseBase base class .
streaming is boolean True .
define the method __init__ with 4 arguments : self , result of the function streaming_content= ( ) , unpacked list args ,
and unpacked dictionary kwargs . call the __init__ method from the base class of the StreamingHttpResponse class , called with arguments : unpacked list args ,
and unpacked dictionary kwargs . substitute streaming_content for self.streaming_content [ self . streaming_content ] .
property decorator ,
define the method content with an argument self .
raise an AttributeError with an argument string _STR:0_Use `streaming_content` instead . `` ,
where ' % s ' is replaced with self.__class__.__name__ [ self . __class__ . __name__ ] . property decorator ,
define the method serialize_headers with an argument self .
map elements of self._iterator [ self . _iterator ] through self.make_bytes [ self . make_bytes ] function , return the result .
streaming_content.setter [ streaming_content . setter ] decorator ,
define the method streaming_content with 2 arguments : self and value .
convert value into a iterator , substitute the result for self._iterator [ self . _iterator ] .
if value has an attribute _STR:0_ ,
append value to self._closable_objects [ self . _closable_objects ] list .
define the method __iter__ with an argument self .
return self.streaming_content [ self . streaming_content ]
derive the class HttpResponseRedirectBase from the HttpResponse base class .
allowed_schemes is an list containing 3 elements : strings _STR:0_ , _STR:1_ and _STR:2_ .
define the method __init__ with 4 arguments : self , redirect_to , unpacked list args and unpacked dictionary kwargs .
call the function force_text with an argument redirect_to , use the result as an argument for the call to the function urlparse ,
substitute the result for parsed . if parsed.scheme [ parsed . scheme ] is true and parsed.scheme [ parsed . scheme ] is not contained in self.allowed_schemes [ self . allowed_schemes ] ,
raise an DisallowedRedirect exception with an argument string _STR:0_ ,
where ' % s ' is replaced with parsed.scheme [ parsed . scheme ] . call the __init__ method from the base class of the HttpResponseRedirectBase class , called with arguments : unpacked list args ,
and unpacked dictionary kwargs . call the function iri_to_uri with an argument redirect_to , substitute the result for the value under the _STR:0_ key of the self dictionary .
url is a property of the class , lambda function is getter attribute with an argument self and return value is the value under the _STR:0_ key of the self dictionary .
derive the class HttpResponseRedirect from the HttpResponseRedirectBase base class .
status_code is an integer 302 .
derive the class HttpResponsePermanentRedirect from the HttpResponseRedirectBase base class .
status_code is an integer 301 .
derive the class HttpResponseNotModified from the HttpResponse base class .
status_code is an integer 304 .
define the method __init__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
call the __init__ method from the base class of the HttpResponseNotModified class , called with arguments : unpacked list args ,
and unpacked dictionary kwargs . delete the value under the _STR:0_ key of the self dictionary .
HttpResponse.content.setter [ HttpResponse . content . setter ] property ,
define the method content with self and value .
if value ,
raise an AttributeError exception with an argument string _STR:0_ .
self._container [ self . _container ] is an list .
derive the class HttpResponseBadRequest from the HttpResponse base class .
status_code is an integer 400 .
derive the class HttpResponseNotFound from the HttpResponse base class .
status_code is an integer 404 .
derive the class HttpResponseForbidden from the HttpResponse base class .
status_code is an integer 403 .
derive the class HttpResponseNotAllowed from the HttpResponse base class .
status_code is an integer 405 .
define the method __init__ with 4 arguments : self , permitted_methods , unpacked list args and unpacked dictionary kwargs .
call the __init__ method from the base class of the HttpResponseNotAllowed class , called with arguments : unpacked list args ,
and unpacked dictionary kwargs . join into a string permitted_methods , separated by string _STR:0_ , substitute it for value under the _STR:1_ key of the self dictionary .
derive the class HttpResponseGone from the HttpResponse base class .
status_code is an integer 410 .
derive the class HttpResponseServerError from the HttpResponse base class .
status_code is an integer 500 .
derive the class Http404 from the Exception base class .
do nothing .
derive the class JsonResponse from the HttpResponse base class .
define the method __init__ with 5 arguments : self , data , encoder set to DjangoJSONEncoder , safe set to boolean True ,
and unpacked dictionary kwargs . if safe is true and data is not an instance of dict type .
raise an TypeError exception with an argument string _STR:0_ .
if _STR:0_ key doesnt exist in kwargs , set its value to _STR:1_ .
serialize data to JSON format with cls set to encoder , substitute it for data .
call the __init__ method from the base class of the JsonResponse class , called with arguments : content set to data ,
define function fix_location_header with request and response as arguments .
if _STR:0_ is contained in response and function request.get_host [ request . get_host ] evaluates to True ,
modify value at the key _STR:0_ of the dictionary response by applying function request.build_absolute_uri [ request . build_absolute_uri ] on it .
return response .
define the function conditional_content_removal with request and response as the arguments .
if response.status_code [ response . status_code ] is lesser than integer 200 and grater or equal than 100 , or response.status_code [ response . status_code ] equals to integer 204 or 304 ,
if response.streaming [ response . streaming ] is True ,
response.streaming_content [ response . streaming_content ] is an empty list .
if not ,
response.content [ response . content ] is bytes empty string .
substitute char _STR:0_ for the value under the _STR:1_ key of the response dictionary .
if request.method [ request . method ] equals to string _STR:0_ ,
if response.streaming [ response . streaming ] is true ,
response.streaming_content [ response . streaming_content ] is an empty list .
if not ,
response.content [ response . content ] is bytes empty string .
return response .
from django.template.base [ django . template . base ] import ALLOWED_VARIABLE_CHARS , BLOCK_TAG_END , BLOCK_TAG_START , COMMENT_TAG_END , COMMENT_TAG_START ,
FILTER_ARGUMENT_SEPARATOR , FILTER_SEPARATOR , SINGLE_BRACE_END , SINGLE_BRACE_START , TOKEN_BLOCK , TOKEN_COMMENT , TOKEN_TEXT , TOKEN_VAR , TRANSLATOR_COMMENT_MARK , UNKNOWN_SOURCE , VARIABLE_ATTRIBUTE_SEPARATOR , VARIABLE_TAG_END , VARIABLE_TAG_START , filter_re and tag_re . from django.template.base [ django . template . base ] import ContextPopException , InvalidTemplateLibrary , TemplateDoesNotExist , TemplateEncodingError ,
TemplateSyntaxError and VariableDoesNotExist . from django.template.base [ django . template . base ] import Context , FilterExpression , Lexer , Node , NodeList , Parser , RequestContext , Origin , StringOrigin ,
Template , TextNode , Token , TokenParser , Variable , VariableNode , constant_string and filter_raw_string . from django.template.base [ django . template . base ] import compile_string , resolve_variable , unescape_string_literal and generic_tag_compiler .
from django.template.base [ django . template . base ] import Library , add_to_builtins , builtins , get_library , get_templatetags_modules , get_text_list ,
import_library and libraries . __all__ is a tuple containing 4 strings : _STR:0_ , _STR:1_ , _STR:2_ and _STR:3_ .
from __future__ import unicode_literals into default name space .
import module re .
from functools import partial into default name space .
from importlib import import_module into default name space .
from inspect import getargspec and getcallargs into default name space .
import module warnings .
from django.apps [ django . apps ] import apps into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.template.context [ django . template . context ] import BaseContext , Context , RequestContext and ContextPopException into default namespace .
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango20Warning into default name space .
from django.utils.itercompat [ django . utils . itercompat ] import is_iterable into default name space .
from django.utils.text [ django . utils . text ] import smart_split , unescape_string_literal and get_text_list into default namespace .
from django.utils.encoding [ django . utils . encoding ] import force_str and force_text into default name space .
from django.utils.translation [ django . utils . translation ] import ugettext_lazy and pgettext_lazy into default name space .
from django.utils.safestring [ django . utils . safestring ] import SafeData , EscapeData , mark_safe and mark_for_escaping into default namespace .
from django.utils.formats [ django . utils . formats ] import localize into default name space .
from django.utils.html [ django . utils . html ] import escape into default name space .
from django.utils.module_loading [ django . utils . module_loading ] import module_has_submodule into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.timezone [ django . utils . timezone ] import template_localtime into default name space .
from django.utils.encoding [ django . utils . encoding ] import python_2_unicode_compatible into default name space .
TOKEN_TEXT is integer 0
TOKEN_VAR is integer 1
TOKEN_BLOCK is integer 2
TOKEN_COMMENT is integer 3 .
TOKEN_MAPPING is a dictionary with 4 initial entries : _STR:0_ for TOKEN_TEXT , _STR:1_ for TOKEN_VAR , _STR:2_ for TOKEN_BLOCK ,
and _STR:0_ for TOKEN_COMMENT . FILTER_SEPARATOR is a string _STR:1_ .
FILTER_ARGUMENT_SEPARATOR is a string _STR:0_ .
VARIABLE_ATTRIBUTE_SEPARATOR is a string _STR:0_ .
BLOCK_TAG_START is a string _STR:0_ .
BLOCK_TAG_END is a string _STR:0_ .
VARIABLE_TAG_START is a string _STR:0_ .
VARIABLE_TAG_END is a string _STR:0_ .
COMMENT_TAG_START is a string _STR:0_ .
COMMENT_TAG_END is a string _STR:0_ .
TRANSLATOR_COMMENT_MARK is a string _STR:0_ .
SINGLE_BRACE_START is a string _STR:0_ .
SINGLE_BRACE_END is a string _STR:0_ .
ALLOWED_VARIABLE_CHARS is a string _STR:0_ .
UNKNOWN_SOURCE is a string _STR:0_ .
call the function re.compile [ re . compile ] with an argument string _STR:0_ , substitute all occurrences of ' % s ' with ,
return value of the function re.escape [ re . escape ] called with an argument BLOCK_TAG_START , return value of the function re.escape [ re . escape ] called with an argument BLOCK_TAG_END , return value of the function re.escape [ re . escape ] called with an argument VARIABLE_TAG_START , return value of the function re.escape [ re . escape ] called with an argument VARIABLE_TAG_END , return value of the function re.escape [ re . escape ] called with an argument COMMENT_TAG_START , and return value of the function re.escape [ re . escape ] called with an argument COMMENT_TAG_END , substitute the result for tag_re . libraries is an empty dictionary .
builtins is an empty list .
invalid_var_format_string is None .
derive the class TemplateSyntaxError form the base class Exception .
do nothing .
derive the class TemplateDoesNotExist form the base class Exception .
do nothing .
derive the class TemplateEncodingError form the base class Exception .
do nothing .
python_2_unicode_compatible decorator ,
derive the class VariableDoesNotExist form the base class Exception .
define the method __init__ with 3 arguments : self , msg and params set to an empty tuple .
substitute msg for self.msg [ self . msg ] .
substitute params for self.params [ self . params ] .
define the method __str__ with an argument self .
return self.msg [ self . msg ] formatted with a tuple , with elements generated from return value of the function force_text with 2 arguments :
p and errors set to string _STR:0_ , for p in self.params [ self . params ] . derive the class InvalidTemplateLibrary form the base class Exception .
do nothing .
derive the class Origin form the base class object .
define the method __init__ with 2 arguments : self and name .
substitute name for self.name [ self . name ] .
define the method reload with an argument self .
raise an NotImplementedError exception with an argument string _STR:0_ .
define the method with reload with an argument self .
return self.name [ self . name ] .
derive the class StringOrigin form the base class Origin .
define the method __init__ with 2 arguments : self and source .
call the method __init__ with an argument UNKNOWN_SOURCE , from the base class of the class StringOrigin .
substitute source for self.source [ self . source ] .
define the method with reload with an argument self .
return self.source [ self . source ] .
derive the class Template form the base class object .
define the method __init__ with 4 arguments : self , template_string , origin set to None and name set to None .
try ,
call the function force_text with an argument template_string .
if UnicodeDecodeError exception is caught ,
raise an TemplateEncodingError exception with an argument _STR:0_ .
if settings.TEMPLATE_DEBUG [ settings . TEMPLATE_DEBUG ] is true and origin is None ,
origin is an instance of StringOrigin class created with an argument template_string .
call the function compile_string with 2 arguments : template_string and origin , substitute the result for self.nodelist [ self . nodelist ] .
substitute name for self.name [ self . name ] .
substitute origin for self.origin [ self . origin ] .
define the method __iter__ with an argument self .
for every node in self.nodelist [ self . nodelist ] ,
for every subnode in node ,
yield subnode .
define the method _render with 2 arguments self and context .
call the method self.nodelist.render [ self . nodelist . render ] with an argument context , return the result .
define the method render with 2 arguments self and context .
call the method context.render_context.push [ context . render_context . push ] .
try ,
call the method self._render [ self . _render ] with an argument context , return the result ,
finally perform ,
remove the first element from context.render_context [ context . render_context ] .
define the method compile_string with 2 arguments : template_string and origin .
if settings.TEMPLATE_DEBUG [ settings . TEMPLATE_DEBUG ] is true ,
from django.template.debug [ django . template . debug ] import DebugLexer and DebugParser .
substitute DebugLexer and DebugParser for lexer_class and parser_class .
if not ,
substitute Lexer and Parser for lexer_class and parser_class .
call the method lexer_class with an arguments template_string and origin , substitute the result for lexer .
call the method lexer.tokenize [ lexer . tokenize ] , use it as an argument for the call to the parser_class function , substitute the result for parser .
call the method parser.parse [ parser . parse ] , return the result .
derive the class Token form the base class object .
define the method __init__ with 3 arguments : self , token_type and contents .
substitute token_type and contents for self.token_type [ self . token_type ] and self.contents [ self . contents ] .
self.lineno [ self . lineno ] is None .
define the method __str__ with an argument self .
substitute value under the self.token_type [ self . token_type ] key of the TOKEN_MAPPING dictionary for token_name .
return a string _STR:0_ with ' % s ' , replace ' % s ' with token_name and 20 self.contents [ self . contents ] elements with every newline deleted .
define the method split_contents with an argument self .
split is an empty list .
call the function smart_split with an argument self.contents [ self . contents ] , substitute the result converted to an iterable for bits .
for every bit in bits ,
if bit starts with _STR:0_ ot bit starts with _STR:1_ ,
append _STR:0_ to third element of bit , substitute it for sentinal .
trans_bit is a list with an element bit .
while bit doesnt end with sential ,
call the method next with an argument bits , substitute the result for bit .
append bit to trans_bit .
join trans_bit into a string separated with whitespaces , substitute the result for bit .
append bit to split .
return split .
derive the class Lexer form the base class object .
define the method __init__ with 3 arguments : self , template_string and origin .
substitute template_string for self.template_string [ self . template_string ] .
substitute origin for self.origin [ self . origin ] .
self.lineno [ self . lineno ] is integer 1 .
self.verbatim [ self . verbatim ] is boolean False .
define the method tokenize with an argument self .
in_tag is boolean False .
result is an empty list .
split tag_re by self.template_string [ self . template_string ] separator , for every bit in result ,
if bit is true ,
call the method self.create_token [ self . create_token ] with 2 arguments bit and in_tag , append the result to result .
in_tag is boolean True if in_tag is False , otherwise is boolean False .
return result .
define the method create_token with 3 arguments : self , token_string and in_tag .
if in_tag is true and token_string starts with BLOCK_TAG_START .
take elements of token_string from second to second last element and strip the whitespaces surrounding the result ,
substitute the result for block_content . if self.verbatim [ self . verbatim ] is true and block_content equals self.verbatim [ self . verbatim ] ,
self.verbatim [ self . verbatim ] is boolean False .
if in_tag and is not contained in self.verbatim [ self . verbatim ] ,
if token_string starts with VARIABLE_TAG_START ,
token is an instance of Token class , created with 2 arguments : TOKEN_VAR ,
and elements of token_string from second to second last element wiht the whitespaces striped from the both sides . otherwise if token_string starts with BLOCK_TAG_START ,
if first nine elements of block_content is string _STR:0_ or _STR:1_ ,
append block_content to a string _STR:0_ , substitute the result for self.verbatim [ self . verbatim ] .
token is an instance of Token class , created with 2 arguments : TOKEN_BLOCK and block_content .
otherwise if token_string starts with COMMENT_TAG_START ,
content is an empty string .
call the method token_string.find [ token_string . find ] with an argument TRANSLATOR_COMMENT_MARK , if it evaluates to true ,
take elements of token_string from second to second last element and strip the whitespaces surrounding the result ,
substitute the result for content . token is an instance of Token class , created with 2 arguments : TOKEN_COMMENT and content .
if not ,
token is an instance of Token class , created with 2 arguments : TOKEN_TEXT and token_string .
substitute self.lineno [ self . lineno ] for token.lineno [ token . lineno ] .
call the method token_string.count [ token_string . count ] with an argument _STR:0_ , append the result to self.lineno [ self . lineno ] .
return token .
derive the class Parser form the base class object .
define the method __init__ with 2 arguments : self and token .
substitute tokens for self.tokens [ self . tokens ] .
self.tags [ self . tags ] is an empty dictionary .
self.filters [ self . filters ] is an empty dictionary .
for every lib in builtins ,
call the method self.add_library [ self . add_library ] with an argument lib .
define the emethod parse with 2 arguments : self and parse_until set to None .
if parse_until is None ,
parse_until is an empty list ,
call the method self.create_nodelist [ self . create_nodelist ] , substitute the result for nodelist .
while self.tokens [ self . tokens ] is true ,
call the method self.next_token [ self . next_token ] , substitute the result for token .
if token.token_type [ token . token_type ] equals integer 0 ,
call the method self.extend_nodelist [ self . extend_nodelist ] with 3 arguments : nodelist , instance of TextNode class , created with an argument token.contents [ token . contents ] ,
and token . otherwise if token.token_type [ token . token_type ] equals integer 1 ,
if token.contents [ token . contents ] is false ,
call the method self.empty_variable [ self . empty_variable ] with an argument token ,
try ,
call the method self.compile_filter [ self . compile_filter ] with an argument token.contents [ token . contents ] , substitute the result for filter_expression .
if TemplateSyntaxError , replaced with e , exception is caught ,
call the method self.compile_filter_error [ self . compile_filter_error ] with 2 arguments : token and e , if it evaluates to false ,
raise an exception ,
call the method self.create_variable_node [ self . create_variable_node ] with an argument filter_expression , substitute the result for var_node .
call the method self.extend_nodelist [ self . extend_nodelist ] with 3 arguments : nodelist , var_node and token .
otherwise if token.token_type [ token . token_type ] equals integer 2 ,
try ,
split token.contents [ token . contents ] into separate words , substitute the first element of the result for command .
if IndexError exception is caught ,
call the method self.empty_block_tag [ self . empty_block_tag ] with an argument token .
if command is contained in parse_until ,
call the method self.prepend_token [ self . prepend_token ] with an argument token ,
return nodelist .
call the method self.enter_command [ self . enter_command ] with 2 arguments command and token .
try ,
substitute the value under the command key of self.tags [ self . tags ] dictionary for compile_func .
if KeyError exception is caught ,
call the method self.invalid_block_tag [ self . invalid_block_tag ] with 3 arguments : token , command and parse_until .
try ,
call the method compile_func with 2 arguments self and token , substitute the result for compiled_result .
if TemplateSyntaxError , renamed to e , exception is caught ,
call the method self.compile_function_error [ self . compile_function_error ] with 2 arguments token and e , if it evaluates to false ,
raise an exception ,
call the method self.extend_nodelist [ self . extend_nodelist ] with 3 arguments : nodelist , compiled_result and token .
call the method self.exit_command [ self . exit_command ] .
if parse_until is true ,
call the method self.unclosed_block_tag [ self . unclosed_block_tag ] with an argument parse_until .
return nodelist .
define the method skip_past with 2 arguments : self and endtag .
while self.tokens [ self . tokens ] is true ,
call the method self.next_token [ self . next_token ] , substitute the result for token .
if token.token_type [ token . token_type ] equals TOKEN_BLOCK and token.contents [ token . contents ] equals endtag ,
return nothing .
call the method self.unclosed_block_tag [ self . unclosed_block_tag ] with an argument list with an element endtag .
define the method create_variable_node with 2 arguments self and filter_expression .
return an instance of VariableNode class with an argument filter_expression .
define the method create_nodelist with an argument self .
return an instance of NodeList class .
define the method extend_nodelist with 4 arguments : self , nodelist , node and token .
if node.must_be_first [ node . must_be_first ] is true and nodelist is true ,
try ,
if nodelist.contains_nontext [ nodelist . contains_nontext ] is true ,
raise AttributeError exception ,
if AttributeError exception is raised ,
raise TemplateSyntaxError ( _STR:0_ , where ' % s ' is replaced with node .
if nodelist is an instance of NodeList and node is not an instance of TextNode class .
nodelist.contains_nontext [ nodelist . contains_nontext ] is boolean True .
append node to nodelist .
define the method enter_command with 3 arguments : self , command and token .
do nothing .
define the method exit_command with an argument self .
do nothing .
define the method enter_command with 3 arguments : self , token and msg .
return an instance of TemplateSyntaxError class with an argument msg .
define the method empty_variable with 2 arguments : self and token .
call the method self.error [ self . error ] with 2 arguments : token and string _STR:0_ , return the result .
define the method empty_block_tag with 2 arguments : self and token .
call the method self.error [ self . error ] with 2 arguments : token and string _STR:0_ , return the result .
define the method invalid_block_tag with 4 arguments : self , token , command and parse_until as None .
if parse_until is true ,
raise an self.error [ self . error ] exception with 2 arguments : token and string _STR:0_ ,
where ' % s ' is replaced with command and result of the function get_text_list called with an argument list , with p converted into a string and surrounded with single quotes for every p in parse_until . call the method self.error [ self . error ] with 2 arguments : token and string _STR:0_ , where ' % s ' is replaced with command ,
return the result . define the method unclosed_block_tag with 2 arguments : self and parse_until .
raise an self.error [ self . error ] with 2 arguments : None and string _STR:0_ ,
where ' % s ' is replaced with parse_until elements joined into a string , separated with _STR:0_ . define the method compile_filter_error with 3 arguments : self , token and e .
do nothing .
define the method compile_function_error with 3 arguments : self , token and e .
do nothing .
define the method next_token with an argument self .
remove first element from self.tokens [ self . tokens ] , return removed element .
define the function prepend_token with 2 arguments : self and token .
insert token at the beginning of self.tokens [ self . tokens ] .
define the method delete_first_token with an argument self .
delete the first element of self.tokens [ self . tokens ] .
define the function add_library with 2 arguments : self and lib .
update self.tags [ self . tags ] dictionary with lib.tags [ lib . tags ] .
update self.filters [ self . filters ] dictionary with lib.filters [ lib . filters ] .
define the function compile_filter with 2 arguments : self and token .
return an instance of FilterExpression class , created with 2 arguments : token and self .
define the function find_filter with 2 arguments : self and filter_name .
if filter_name is contained in self.filters [ self . filters ] ,
return the value under the filter_name key of the self.filters [ self . filters ] dictionary .
if not ,
raise an TemplateSyntaxError with an argument string _STR:0_ , substitute ' % s ' with filter_name .
derive the class TokenParser form the base class object .
define the function next_space_index with 2 arguments : self and subject .
substitute subject for self.subject [ self . subject ] .
self.pointer [ self . pointer ] is integer 0 .
self.backout [ self . backout ] is an empty list .
call the method self.tag [ self . tag ] , substitute the result for self.tagname [ self . tagname ] .
define the method top with an argument self .
raise an NotImplementedError with an argument string _STR:0_ .
define the method more with an argument self .
if self.pointer [ self . pointer ] is smaller than length of self.subject [ self . subject ] , return boolean True , otherwise return False .
define the method back with an argument self .
if length of self.backout [ self . backout ] is greater than zero ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ .
remove the first element from self.backout [ self . backout ] , substitute the result for self.pointer [ self . pointer ] .
define the method tag with an argument self .
substitute self.subject [ self . subject ] for subject .
substitute self.pointer [ self . pointer ] for i .
if i is greater than or equal to length of subject .
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with subject . substitute i for p .
while i is lesser than length of subject and i-th element of subject is not an empty space or tab character ,
increment i by integer 1 .
take subject elements from p-th to i-th index , substitute it for s .
while i is lesser than length of subject and i-th element of subject is an empty space or tab character ,
increment i by integer 1 .
append self.pointer [ self . pointer ] to self.backout [ self . backout ] .
substitute i for self.pointer [ self . pointer ] .
return s .
define the method value with an argument self .
substitute self.subject [ self . subject ] for subject .
substitute self.pointer [ self . pointer ] for i .
define the next_space_index with 2 arguments : subject and i .
while i is lesser than length of subject and i-th element of subject is not an empty space or tab character ,
if i-th element of subject is _STR:0_ character or _STR:1_ character ,
substitute i-th element of subject for c .
increment i by integer 1 .
while i is lesser than length of subject and i-th element of subject is not equal to c ,
increment i by one .
if i is greater than , or equal to subject ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where _STR:0_ is replaced with i and ' % s ' is replaced with subject . increment i by one .
return i .
if i is greater than or equal to length of subject ,
raise an TemplateSyntaxError exception with an argument _STR:0_ ,
where ' % s ' is replaced with subject . if i-th element of subject is _STR:0_ character or _STR:1_ character ,
substitute i for p .
increment i by integer 1 ,
while i is lesser than length of subject and i-th element of subject is not equal to p-th element of subject ,
increment i by integer 1 ,
if i is greater than length of subject ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where _STR:0_ is replaced with i and ' % s ' is replaced with subject . increment i by integer 1 ,
call the function next_space_index with 2 arguments : subject and i , substitute the result for i .
substitute subject elements from p-th to i-th index for res .
while i is lesser than length of subject and i-th element of subject is an empty space or tab character .
increment i by integer 1 ,
append self.pointer [ self . pointer ] to self.backout [ self . backout ] .
substitute i for self.pointer [ self . pointer ] .
return res .
if not ,
substitute i for p .
call the function next_space_index with 2 arguments subject and i , substitute the result for i .
take subject elements from p-th to i-th index , substitute it for s .
while i is lesser than length of subject and i-th element of subject is an empty space or tab character .
increment i by integer 1 , .
append self.pointer [ self . pointer ] to self.backout [ self . backout ] .
substitute i for self.pointer [ self . pointer ] .
return s .
constant_string is a raw string _STR:0_ ,
where _STR:0_ is replaced with _STR:1_ , _STR:2_ is replaced with _STR:3_ , _STR:4_ is replaced with return value of function re.escape [ re . escape ] called with an argument string _STR:5_ , _STR:6_ is replaced with return value of function re.escape [ re . escape ] called with an argument string _STR:7_ . remove all occurrences of newline character from constant_string .
filter_raw_string is a raw string `` ^ ( ? P < constant > % ( constant ) s ) |^ ( ? P < var > [ % ( var_chars ) s ] +| % ( num ) s ) | ( ? : \s* % ( filter_sep ) s\s*
( ? P < filter_name > \w+ ) ( ? : % ( arg_sep ) s ( ? : ( ? P < constant_arg > % ( constant ) s ) | ( ? P < var_arg > [ % ( var_chars ) s ] +| % ( num ) s ) ) ) ? ) _STR:0_\w\ . `` , _STR:1_ with result of the function re.escape [ re . escape ] called with an argument FILTER_SEPARATOR , anbd _STR:2_ with result of the function re.escape [ re . escape ] called with an argument FILTER_ARGUMENT_SEPARATOR . call the function re.compile [ re . compile ] with 2 arguments : filter_raw_string and result for bitwise OR on 2 operands re.UNICODE [ re . UNICODE ] and re.VERBOSE [ re . VERBOSE ] ,
substitute the result for filter_re . derive the class FilterExpression form the base class object .
define the function __init__ with 3 arguments : self , token and parser .
substitute token for self.token [ self . token ] .
call the method filter_re.finditer [ filter_re . finditer ] with an argument token , substitute the result for matches .
var_obj is None .
filters is an empty list .
upto is integer 0 .
for every match in matches ,
call the method match.start [ match . start ] , substitute the result for start .
if upto is not equal to start .
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with first upto elements of token string , token string elements from upto to start index , and token string elements from start index to the end . if var_obj is None ,
call the method match.group [ match . group ] with 2 arguments : strings _STR:0_ and _STR:1_ , substitute the result for var and constant , respectively .
if constant is true ,
try ,
instantiate Variable class , with an argument constant , call the resolve method with an empty dictionary as an argument , substitute the result for var_obj .
if VariableDoesNotExist exception is not caught ,
var_obj is None .
otherwise if var is None ,
raise an TemplateSyntaxError exception with an argument _STR:0_ , replace ' % s ' with token .
if not ,
var_obj is an instance of Variable class , created with an argument var .
if not ,
call the methof match.group [ match . group ] with an argument _STR:0_ , substitute the result for filter_name .
args is an empty list .
call the method match.group [ match . group ] with 2 arguments : strings _STR:0_ and _STR:1_ , substitute the result for constant_arg ,
and var_arg , respectively . if constant_arg is true ,
take a tuple with 2 elements : boolean False and method resolve called with an empty dictionary on the instance of Variable class ,
created with an argument constant_arg , append it to args . otherwise if var_arg is true ,
take a tuple with 2 elements : boolean False and instance of Variable class , created with an argument constant_arg , append it to args .
call the method parser.find_filter [ parser . find_filter ] with an argument filter_name , substitute the result for filter_func .
call the method self.args_check [ self . args_check ] with 3 arguments : filter_name , filter_func and args .
append a tuple with 2 arguments : filter_func and args to filters .
call the method match.end [ match . end ] , substitute the result for upto .
if upto is not equal to length of token ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with elemnts of token from upto index till the end , and token . substitute filters for self.filters [ self . filters ] .
substitute var_obj for self.var [ self . var ] .
define the method resolve with 3 arguments : self , context and ignore_failures set to boolean False .
if self.var [ self . var ] is an instance of Variable class ,
try ,
call the method self.var.resolve [ self . var . resolve ] with an argument context , substitute it for obj .
if VariableDoesNotExist exception is caught ,
if ignore_failures is true ,
obj is None ,
if not ,
if settings.TEMPLATE_STRING_IF_INVALID [ settings . TEMPLATE_STRING_IF_INVALID ] is true ,
use global variable invalid_var_format_string .
if invalid_var_format_string is None ,
if ' % s ' is contained in settings.TEMPLATE_STRING_IF_INVALID [ settings . TEMPLATE_STRING_IF_INVALID ] , invalid_var_format_string is boolean True , otherwise it is False .
if invalid_var_format_string is true ,
format settings.TEMPLATE_STRING_IF_INVALID [ settings . TEMPLATE_STRING_IF_INVALID ] with self.var [ self . var ] , return the result .
return settings.TEMPLATE_STRING_IF_INVALID [ settings . TEMPLATE_STRING_IF_INVALID ] .
if not ,
substitute settings.TEMPLATE_STRING_IF_INVALID [ settings . TEMPLATE_STRING_IF_INVALID ] with obj .
if not ,
substitute self.var [ self . var ] for obj .
for every func and args in self.filters [ self . filters ] ,
arg_vals is an empty list ,
for every lookup and arg in args ,
if lookup is false ,
call the function mark_safe with an argument arg , append it to arg_vals .
if not ,
call the method arg.resolve [ arg . resolve ] with an argument context , append the result to arg_vals .
if _STR:0_ attribute of func object exists and is true ,
call the function template_localtime with 2 arguments : obj and context.use_tz [ context . use_tz ] , substitute the result for obj .
if _STR:0_ attribute of func object exists and is true ,
call the function func with 3 arguments : obj , autoescape set to context.autoescape [ context . autoescape ] and unpacked list arg_vals ,
substitute the result for new_obj . if not ,
call the function func with 2 arguments : obj and unpacked list arg_vals , substitute the result for new_obj .
if _STR:0_ attribute of func object exists and is true and obj is an instance of SafeData ,
call the function mark_safe with an argument new_obj , substitute the result for obj .
otherwise if obj is an instance of EscapeData ,
call the function mark_for_escaping with an argument new_obj , substitute the result for obj .
if not ,
substitute new_obj for obj .
return obj .
define the method args_check with 3 arguments : name , func and provided .
convert provided into a list and substitute it for provided .
calculate length of provided and increment it by one , substitute the result for plen .
get the _STR:0_ attribute from func object , if it exists substitute it for func .
call the function getargspec with an argument func , substitute the result for args , varargs , varkw and defaults , respectively .
calculate the length of args , substitute it for alen .
substitute the length of defaults for dlen .
if plen is lesser than difference of alen and dlen , or if plen is greater than alen ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where _STR:0_ is replaced with name , dlen subtracted from alen , and plen . return boolean True .
args_check is a static method .
define the method __str__ with an argument self .
return self.token [ self . token ] .
define the method resolve_variable with 2 arguments : path and context .
call the function warnings.warn [ warnings . warn ] with 3 arguments :
string _STR:0_ , RemovedInDjango20Warning , and stacklevel set to integer 2. call the method resolve with an argument context , from the instance of Variable class , created with an argument path .
derive the class Variable form the base class object .
define the method __init__ with 2 arguments self and var .
substitute var for self.var [ self . var ] .
self.literal [ self . literal ] is None ,
self.lookups [ self . lookups ] is None .
self.translate [ self . translate ] is boolean False .
self.message_context [ self . message_context ] is None .
if var is not an instance of six.string_types [ six . string_types ] ,
raise an TypeError exception with an argument string _STR:0_ , replace ' % s ' with type of var .
try ,
convert var into an floating point number , substitute it for self.literal [ self . literal ] .
if _STR:0_ is not contained in var and _STR:1_ is not contained in var converted into lowercase ,
convert self.literal [ self . literal ] into an integer , substitute it for self.literal [ self . literal ] .
if var ends with _STR:0_ ,
raise an ValueError exception .
if ValueError exception is caught ,
if var starts with _STR:0_ and var ends with _STR:1_ ,
self.translate [ self . translate ] is boolean True .
remove first 2 and last 2 elements from var .
try ,
call the function unescape_string_literal with an argument var , use it as an argument for the call to the function mark_safe ,
substitute the result for self.literal [ self . literal ] . if ValueError exception is caught ,
call the function var.find [ var . find ] with an argument : _STR:0_ appended to VARIABLE_ATTRIBUTE_SEPARATOR , if the result is greater than integer -1 ,
or first element of var equals _STR:0_ , raise an TemplateSyntaxError exception with an argument string _STR:1_ ,
where ' % s ' is replaced with var . call the method var.split [ var . split ] with an argument VARIABLE_ATTRIBUTE_SEPARATOR , convert the result to a tuple and substitute it for self.lookups [ self . lookups ] .
define the method resolve with 2 arguments : self and context .
if self.lookups [ self . lookups ] is not None ,
call the function self._resolve_lookup [ self . _resolve_lookup ] with an argument context , substitute the result for value .
if else ,
substitute self.literal [ self . literal ] for value .
if self.translate [ self . translate ] is true ,
if self.message_context [ self . message_context ] is true ,
call the function pgettext_lazy with an argument self.message_context [ self . message_context ] and value , return the result .
if not ,
call the function ugettext_lazy with an argument value , return the result .
return value .
define the method __repr__ with an argument self .
return an string _STR:0_ , where ' % s ' is replaced with self.__class__.__name__ [ self . __class__ . __name__ ] and self.var [ self . var ] , respectively .
define the method __str__ with an argument self .
return self.var [ self . var ] .
define the method _resolve_lookup with 2 arguments : self and context .
substitute context for current .
try ,
for bit in self.lookups [ self . lookups ] ,
try ,
substitute element at the bit index of current for current .
if TypeError , AttributeError , KeyError or ValueError exceptions are caught ,
try ,
if current is an instance of BaseContext and bit attribute of type of current is true ,
raise an AttributeError exception .
get the bit attribute of current object , substitute it for current .
if TypeError and AttributeError exceptions are caught ,
try ,
convert bit to an integer and use it as index to obtain an element for list current , substitute it for current .
if IndexError , ValueError , KeyError or TypeError exceptions are caught ,
raise an VariableDoesNotExist exception with an argument string _STR:0_ ,
where ' % s ' is replaced with bit and _STR:0_ is replaced with current . if current is callable object ,
get the _STR:0_ attribute of current object , if it exists and is true ,
do nothing .
otherwise , get the _STR:0_ attribute of current object , if it exists and is true ,
substitute settings.TEMPLATE_STRING_IF_INVALID [ settings . TEMPLATE_STRING_IF_INVALID ] for current .
if not ,
try ,
call the function current , substitute the result for current .
if TypeError exception is caught ,
try ,
call the function getcallargs with an argument current ,
if TypeError exception is caught ,
substitute settings.TEMPLATE_STRING_IF_INVALID [ settings . TEMPLATE_STRING_IF_INVALID ] for current ,
if not ,
raise an exception ,
if Exception , renamed to e , exception is caught ,
get the _STR:0_ attribute of e object , if it exists and is true ,
substitute settings.TEMPLATE_STRING_IF_INVALID [ settings . TEMPLATE_STRING_IF_INVALID ] for current .
if not ,
raise an exception .
return current .
derive the class Node form the base class object .
must_be_first is boolean False .
child_nodelists is an tuple with an element _STR:0_ .
define the method render with 2 arguments : self and context .
do nothing .
define the method __iter__ with an argument self .
yield self .
define the method get_nodes_by_type with 2 arguments : self and nodetype .
nodes is an empty list .
if self is an instance of nodetype ,
append self to nodes .
for every attr in self.child_nodelists [ self . child_nodelists ] ,
get attr attribute of self object , if it exists substitute it for nodelist , if not nodelist is None .
if nodelist is true ,
call the method nodelist.get_nodes_by_type [ nodelist . get_nodes_by_type ] with an argument nodetype , extend nodes with the result .
return nodes .
derive the class NodeList form the base class list .
contains_nontext is boolean False .
define the method render with 2 arguments : self and context .
bits is an empty list .
for every node in self ,
if node is an instance of Node ,
call the method self.render_node [ self . render_node ] with 2 arguments : node and context , substitute the result for bit .
if not ,
substitute node for bit .
call the function force_text with an argument bit , append the result to bits .
call the function mark_safe with an argument , elements of bits joined into a string , return the result .
define the method get_nodes_by_type with 2 arguments : self and nodetype .
modes is an empty list .
for every node in self ,
call the method node.get_nodes_by_type [ node . get_nodes_by_type ] with an argument nodetype , extend nodes with it .
return nodes .
define the method render_node with 3 arguments : self , node and context .
call the method node.render [ node . render ] with an argument context , return the result .
derive the class TextNode form the base class Node .
define the method __init__ with 2 arguments : self and s .
substitute s for self.s [ self . s ] .
define the method __repr__ with an argument self .
call the function force_str with 3 arguments : string _STR:0_ , with ' % s ' replaced with first 25 elements of self.s [ self . s ] string ,
string _STR:0_ and errors set to a string _STR:1_ , return the result . define the method render with 2 arguments : self and context .
return self.s [ self . s ] .
define the function render_value_in_context with 2 arguments : value and context .
call the method template_localtime with 2 arguments : value and use_tz=context.use_tz [ use_tz=context . use_tz ] , substitute the result for value .
call the function localize with 2 arguments : value and use_l10n=context.use_l10n [ use_l10n=context . use_l10n ] , substitute the result for value .
call the function force_text with an argument value , substitute the result for value .
if context.autoescape [ context . autoescape ] is true and value is not an instance of SafeData , or value is an instance of EscapeData ,
call the function escape with an argument value , return the result .
if not ,
return value .
derive the class VariableNode form the base class Node .
define the method __init__ with 2 arguments : self and filter_expression .
substitute filter_expression for self.filter_expression [ self . filter_expression ] .
define the method __repr__ with an argument self .
return a string _STR:0_ , substitute ' % s ' with self.filter_expression [ self . filter_expression ] .
define the method render with 2 arguments self and context .
try ,
call the method self.filter_expression.resolve [ self . filter_expression . resolve ] with an argument context , substitute the result for output .
if UnicodeDecodeError exception is caught ,
return an empty string .
call the function render_value_in_context with 2 arguments output and context , return the result .
call the function re.compile [ re . compile ] with an argument raw string _STR:0_ , substitute the result for kwarg_re .
define the method token_kwargs : bits , parser and support_legacy set to boolean False .
if bits is false ,
return an empty dictionary .
call the method kwarg_re.match [ kwarg_re . match ] with an argument first element of bits , substitute the result for match .
if match is true and call to the method match.group [ match . group ] with an argument integer 1 evaluates to true , kwarg_format is boolean True ,
otherwise it is boolean False . if kwarg_format is false ,
if support_legacy is false ,
return an empty dictionary .
if length of bits is lesser than integer 3 or second element of bits is not equal to string _STR:0_ ,
return an empty dictionary .
kwargs is an empty dictionary ,
while bits is true ,
if kwarg_format is true ,
call the method kwarg_re.match [ kwarg_re . match ] with an argument first element of bits , substitute the result for match .
if match is false or call to the method match.group [ match . group ] with an argument integer 1 evaluates to boolean false ,
return kwargs .
call the method match.groups [ match . groups ] with 2 arguments : key and value .
delete first element of bits .
if not ,
if length of bits is lesser than integer 3 or second element of bits is not equal to string _STR:0_ ,
return kwargs .
substitute third and first element of bits for key and value , respectively .
delete first 3 elements of bits .
call the method parser.compile_filter [ parser . compile_filter ] with an argument value , substitute the result for value under the key key of kwargs dictionary .
if bits is true and kwarg_format is false ,
if first element of bits is not equal to string _STR:0_ ,
return kwargs .
delete first element of bits .
return kwargs .
define the function parse_bits with 8 arguments : parser , bits , params , varargs , varkw , defaults , takes_context and name .
if takes_context is true ,
if first element of params equals a string _STR:0_ ,
substitute params without the first element for params .
if not ,
raise an TemplateSyntaxError exception _STR:0_ ,
where ' % s ' is replaced with name . args is an empty list .
kwargs is an empty dictionary .
convert params into a list , substitute it for unhandled_params .
for every bit in bits ,
call the function
if kwarg is true ,
call the method six.iteritems [ six . iteritems ] with an argument kwarg , convert the result into a list ,
substitute first element of the result for param and value . if param is not in params and varkw is None ,
raise an TemplateSyntaxError exception with an argument _STR:0_ ,
where ' % s ' are replaced with name and param . otherwise if param is contained in kwargs ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' are replaced with name and param . if not ,
convert param to a string , use it as a key to get the value from kwargs dictionary , assign it value .
if param is contained in unhandled_params ,
call the method unhandled_params.remove [ unhandled_params . remove ] with an argument param .
if not ,
if kwargs is true ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ , where ' % s ' is replaced with name .
if not ,
call the method parser.compile_filter [ parser . compile_filter ] with an argument bit , append the result to args .
try ,
remove first element of unhandled_params .
if IndexError exception is caught ,
if varargs is None ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with name . if defaults is not None ,
slice list unhandled_params from the beginning to the length of defaults last element ,
if unhandled_params is true ,
raise TemplateSyntaxError (
return args and kwargs .
define the method generic_tag_compiler with 9 arguments : parser , token , params , varargs , varkw , defaults , name , takes_context ,
call the function token.split_contents [ token . split_contents ] , substitute the result without the first element for bits .
call the method parse_bits with 8 arguments : parser , bits , params , varargs , varkw , defaults , takes_context and name ,
substitute the result for args and kwargs , respectively . call the function node_class with 3 arguments : takes_context , args and kwargs .
derive the class TagHelperNode form the base class Node .
define the method __init__ with 4 arguments : self , takes_context , args and kwargs .
substitute takes_context for self.takes_context [ self . takes_context ] .
substitute args for self.args [ self . args ] .
substitute kwargs for self.kwargs [ self . kwargs ] .
define the method get_resolved_arguments with 2 arguments : self and context .
resolved_args is an list with elements , return value of the method var.resolve [ var . resolve ] with an argument context , for every var in self.args [ self . args ] .
if self.takes_context [ self . takes_context ] is true ,
append resolved_args to a list containing context element , substitute it for resolved_args .
resolved_kwargs is dictionary with elements : return value of the method v.resolve [ v . resolve ] called with an argument context , for k ,
for every k and v in return value of the method self.kwargs.items [ self . kwargs . items ] . return resolved_args and resolved_kwargs .
derive the class Library form the base class object .
define the method with reload with an argument self .
self.filters [ self . filters ] is an empty dictionary .
self.tags [ self . tags ] is an empty dictionary .
define the method tag with 3 arguments : self , name set to None and compile_function set to None .
if name is None and compile_function is None ,
return self.tag_function [ self . tag_function ] .
otherwise if name is not None and compile_function is None ,
if name is callable object ,
call the method self.tag_function [ self . tag_function ] with an argument name , return the result .
if not ,
define the function dec with an argument func ,
call the method self.tag [ self . tag ] with 2 arguments name and func , return the result .
return dec .
otherwise if name is not None and compile_function is not None ,
substitute compile_function for self.tags [ self . tags ] dictionary value under the name key .
return compile_function .
if not ,
raise an InvalidTemplateLibrary exception with an argument string _STR:0_ ,
substitute _STR:0_ with name and compile_function . define the method tag_function with 2 argument : self and func .
get _STR:0_ attribute from func , return func if the attribute doesnt exists ,
use its __name__ field as a key to get the value from self.tags [ self . tags ] , assign func to it . return func .
define the method filter with 4 arguments : self , name set to None , filter_func set to None and unpacked dictionary flags .
if name is None and filter_func is None ,
define the function dec with an argument func ,
call the method self.filter_function [ self . filter_function ] with 2 arguments func and unpacked dictionary flags , return the result .
return dec .
otherwise if name is not None and filter_func is None ,
if name is callable object ,
call the method self.filter_function [ self . filter_function ] with arguments name and unpacked dictionary flags , return the result .
if not ,
define the function dec with an argument func ,
call the method self.filter [ self . filter ] with 3 arguments : name , func and unpacked dictionary flags , return the result .
return dec .
otherwise if name is not None and filter_func is not None ,
substitute filter_func for value under the name key of self.filters [ self . filters ] dictionary .
for every attr in tuple with 3 arguments : strings _STR:0_ , _STR:1_ and _STR:2_ ,
if attr is contained in flags ,
substitute value under the attr key of flags dictionary for value .
set filter_func objec attr attribute to value .
if filter_func has an attribute _STR:0_ ,
set filter_func._decorated_function [ filter_func . _decorated_function ] objects attr attribute to value .
substitute name for filter_func._filter_name [ filter_func . _filter_name ] .
return filter_func .
if not ,
raise an InvalidTemplateLibrary exception with an argument string ( _STR:0_ ,
where _STR:0_ is replaced with name and filter_func , respectively . define the method filter_function with 3 arguments : self , func and unpacked dictionary flags .
get _STR:0_ attribute from func object , if it exists substitute __name__ field of the result for name ,
if not , substitute func.__name__ [ func . __name__ ] for name . call the method self.filter [ self . filter ] with 3 arguments : name , func and unpacked dictionary flags .
define the method simple_tag with 4 arguments : self , func and None , takes_context and None and name set to None .
define the function dec with an argument func .
call the function getargspec with an argument func , substitute the result for params , varargs , varkw and defaults , respectively .
derive the class SimpleNode form the base class TagHelperNode .
define the method render with 2 arguments self and context .
call the method self.get_resolved_arguments [ self . get_resolved_arguments ] with an argument context , substitute the result for resolved_args and resolved_kwargs .
call the function func with 2 arguments : unpacked list resolved_args and unpacked dictionary resolved_kwargs , return it .
if name is true , substitute it for function_name , if not get attribute _STR:0_ from func object ,
substitute its __name__ field for function name , if it doesnt exists substitute func.__name__ [ func . __name__ ] for function_name . call the function generic_tag_compiler , params set to params , varargs set to varargs , varkw set to varkw , defaults set to defaults ,
name set to function_name , and takes_context set to takes_context and node_class set to SimpleNode . substitute func.__doc__ [ func . __doc__ ] for compile_func.__doc__ [ compile_func . __doc__ ] .
call the method self.tag [ self . tag ] with 2 arguments : function_name and compile_func .
return func .
if func is None ,
return dec .
otherwise if func is callable object ,
call the function dec with an argument func , return the result .
if not ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ .
define the method assignment_tag with 4 arguments : self , func set to None , takes_context set to None and name set to None .
define the function dec with an argument func .
call the function getargspec with an argument func , substitute the result for params , varargs , varkw and defaults .
derive the class AssignmentNode form the base class TagHelperNode .
define the function __init__ with 5 arguments : self , takes_context , args , kwargs and target_var .
call the method __init__ from the base class of the class AssignmentNode , with 3 arguments : takes_context , args and kwargs .
substitute target_var for self.target_var [ self . target_var ] .
define the method render with 2 arguments self and context .
call the method self.get_resolved_arguments [ self . get_resolved_arguments ] with an argument context , substitute the result for resolved_args and resolved_kwargs .
call the function func with 2 arguments : unpacked list resolved_args and unpacked dictionary resolved_kwargs ,
substitute the result for value under the self.target_var [ self . target_var ] key of the context dictionary . return an empty string .
if name is true , substitute it for function_name , if not get _STR:0_ attribute from func object , if it exists ,
substitute __name__ field of the result for function_name , in not , substitute func.__name__ [ func . __name__ ] for function_name . define the function compile_func with 2 arguments : parser and token .
call the function token.split_contents [ token . split_contents ] , substitute the result without the first element for bits .
if length of bits is smaller than integer 2 or second last element of bits is not equal to _STR:0_ ,
raise an TemplateSyntaxError exception with an argument string , `` ' % s ' tag takes at least 2 arguments and the second last argument
must be _STR:0_ '' , where ' % s ' is replaced with function_name . substitute last element of bits for target_var .
substitute bits without last two elements for bits .
call the function parse_bits with 8 arguments : parser , bits , params , varargs , varkw , defaults , takes_context and function_name ,
substitute the result for args and kwargs . return an instance of AssignmentNode class created with 4 arguments : takes_context , args , kwargs and target_var .
substitute func.__doc__ [ func . __doc__ ] for compile_func.__doc__ [ compile_func . __doc__ ] .
call the method self.tag [ self . tag ] with 2 arguments : function_name and compile_func .
return func .
if func is None ,
return dec .
otherwise if func is callable ,
call the function dec with an argument func , return the result .
if not ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ .
define the method inclusion_tag with 5 arguments : self , file_name , context_class set to Context , takes_context set to boolean False ,
and name set to None . define the function dec with an argument func .
call the function getargspec with an argument func , substitute the result for params , varargs , varkw and defaults .
derive the class InclusionNode form the base class TagHelperNode .
define the method render with 2 arguments : self and context .
call the method self.get_resolved_arguments [ self . get_resolved_arguments ] with context as an argument , substitute the result for resolved_args and resolved_kwargs .
call the function func with 2 arguments : unpacked list resolved_args and unpacked dictionary resolved_kwargs , substitute the result for _dict .
get _STR:0_ attribute from self object . if it doesnt exists return boolean False , if the result evaluates to false ,
from django.template.loader [ django . template . loader ] import get_template , select_template .
if file_name is an instance of Template class .
substitute file_name for t .
otherwise if file_name is not an instance of six.string_types [ six . string_types ] and call to the function is_iterable with an argument file_name ,
evaluates to true , call the function select_template with an argument file_name , substitute the result for t .
if not ,
call the function get_template with an argument file_name , substitute the result for t .
substitute t.nodelist [ t . nodelist ] for self.nodelist [ self . nodelist ] .
call the function context_class with 2 arguments : _dict and unpacked dictionary containing 4 entries :
context.autoescape [ context . autoescape ] for _STR:0_ , context.autoescape [ context . autoescape ] for _STR:1_ , context.use_l10n [ context . use_l10n ] for _STR:2_ , and context.use_tz [ context . use_tz ] for _STR:3_ , substitute the result for new_context . call the function context.get [ context . get ] with 2 argument _STR:4_ and None , substitute the result for csrf_token .
if csrf_token is not None ,
substitute csrf_token for value under the _STR:0_ key of new_context dictionary .
call the method self.nodelist.render [ self . nodelist . render ] with an argument new_context , return the result .
if name is true , substitute it for function_name , if not get _STR:0_ attribute from func object , if it exists ,
substitute __name__ field of the result for function_name , in not , substitute func.__name__ [ func . __name__ ] for function_name . call the function partial with 8 arguments : generic_tag_compiler , params set to params , varargs set to varargs , varkw set to varkw ,
defaults set to defaults , name set to function_name , takes_context set to takes_context and node_class set to InclusionNode , substitute the result for compile_func . substitute func.__doc__ [ func . __doc__ ] for compile_func.__doc__ [ compile_func . __doc__ ] .
call the function self.tag [ self . tag ] with 2 arguments : function_name and compile_func .
return func .
return dec .
define the function is_library_missing with an argument name .
split string name into two parts from the right side by the separator _STR:0_ , substitute parts for path and module , respectively .
try ,
call the function import_module with an argument path , substitute it for package .
call the function module_has_submodule with 2 arguments : package and module , return inverted boolean result .
if ImportError exception is caught ,
call the function is_library_missing with an argument path , return the result .
define the function import_library with an argument taglib_module .
try ,
call the function import_module with an argument taglib_module , substitute the result for mod .
if ImportError , renamed to e , exception is caught ,
call the function is_library_missing with an argument taglib_module , if it evaluates to true ,
return None .
if not ,
raise an InvalidTemplateLibrary exception with an argument string _STR:0_ ,
where ' % s ' is replaced with taglib_module and e. try ,
return mod.register [ mod . register ] .
if AttributeError exception is caught ,
raise an InvalidTemplateLibrary exception with an argument string _STR:0_ ,
where ' % s ' is replaced with taglib_module . templatetags_modules is an empty list .
define the function get_templatetags_modules .
use global variable templatetags_modules .
if templatetags_modules is false ,
_templatetags_modules is an empty list .
templatetags_modules_candidates is an list with an argument string _STR:0_ .
add string _STR:0_ to a list , where ' % s ' is replaced with app_config.name [ app_config . name ] ,
for every app_config in result of the method apps.get_app_configs [ apps . get_app_configs ] , append the resulting list to templatetags_modules_candidates . for every templatetag_module in templatetags_modules_candidates ,
try ,
call the function import_module with an argument templatetag_module .
append templatetag_module to _templatetags_modules .
if ImportError exception is caught ,
skip this loop iteration .
substitute _templatetags_modules for templatetags_modules .
return templatetags_modules .
define the function get_library with an argument library_name .
get the value under the library_name key of the libraries dictionary , if it exists , substitute it for lib , if not , lib is None .
if lib is false ,
call the function get_templatetags_modules , substitute the result for templatetags_modules .
tried_modules is an empty list .
for every module in templatetags_modules ,
taglib_module is an string _STR:0_ , where ' % s ' is replaced to module and library_name .
append taglib_module to tried_modules .
call the function import_library with an argument taglib_module , substitute the result for lib .
if lib is true ,
substitute lib for value under the library_name key of libraries dictionary .
break loop execution .
if lib is false ,
raise an InvalidTemplateLibrary exception with an argument string _STR:0_ ,
where ' % s ' is replaced with library_name and elements of tried_modules joined into a string , separated by _STR:0_ . return lib .
define the function add_to_builtins with an argument module .
call the function import_library with an argument module , append the result to builtins .
call the function add_to_builtins with an argument string _STR:0_ .
call the function add_to_builtins with an argument string _STR:0_ .
call the function add_to_builtins with an argument string _STR:0_ .
from copy import copy into default name space .
from django.utils.module_loading [ django . utils . module_loading ] import import_string into default name space .
_standard_context_processors is None .
_builtin_context_processors is a tuple containing a string _STR:0_ .
derive the class ContextPopException from the Exception base class .
do nothing .
derive the class ContextDict from the dict base class .
define the method __init__ with 4 arguments : self , context , unpacked list args and unpacked dictionary kwargs .
call the method __init__ from the base class of the class ContextDict , with 2 arguments : unpacked list args and unpacked dictionary kwargs .
append self to context.dicts [ context . dicts ] .
substitute context for self.context [ self . context ] .
define the method __enter__ with an argument self .
return self .
define the method __exit__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
remove the first element from the self.context [ self . context ] .
derive the class BaseContext from the object base class .
define the method __init__ with 2 arguments : self and dict_ set to None .
call the method self._reset_dicts [ self . _reset_dicts ] with an argument dict_ .
define the method _reset_dicts with 2 arguments : self and value set to None .
builtins is an dictionary with 3 initial entries : boolean True for _STR:0_ , boolean False for _STR:1_ and None for _STR:2_ .
self.dicts [ self . dicts ] is an list with element builtins .
if value is not None ,
append value to self.dicts [ self . dicts ] list .
define the method __copy__ with an argument self .
call the function copy with an argument base class of the class BaseContext , substitute the result for duplicate .
hard copy list self.dicts [ self . dicts ] to duplicate.dicts [ duplicate . dicts ] .
return duplicate .
define the method __repr__ with an argument self .
return printable representation of self.dicts [ self . dicts ] .
define the method __iter__ with an argument self .
for every d in reversed list self.dicts [ self . dicts ] ,
yield d .
define the method push with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
instantiate class ContextDict with 3 arguments : self , unpacked list args and unpacked dictionary kwargs , return it .
define the method pop with an argument self .
if length of self.dicts [ self . dicts ] is equal to an integer 1 ,
raise an ContextPopException .
call the method self.dicts.pop [ self . dicts . pop ] , return the result .
define the method __setitem__ with 3 arguments : self , key and value .
substitute value for value under the key key of dictionary at last element of self.dicts [ self . dicts ] .
define the method __getitem__ with 2 arguments : self and key .
for every d in reversed list self.dicts [ self . dicts ] ,
if key is contained in d ,
return value under the key key of d dictionary .
raise KeyError exception with an argument key .
define the method __delitem__ with 2 arguments : self and key .
delete value under the key key of dictionary at last element of self.dicts [ self . dicts ] .
define the method has_key with 2 arguments : self and key .
for every d in self.dicts [ self . dicts ] ,
if key is contained in d ,
return boolean True .
return boolean False .
define the method __contains__ with 2 arguments : self and key .
call the method self.has_key [ self . has_key ] with an argument key , return the result .
define the method got with 3 arguments : self , key and otherwise set to None .
for every d in reversed list self.dicts [ self . dicts ] ,
if key is contained in d ,
return value under the key key of d dictionary .
return otherwise .
define the method new with 2 arguments : self and values set to None .
call the function copy with an argument self , substitute the result for new_context .
call the method new_context._reset_dicts [ new_context . _reset_dicts ] values .
return new_context .
define the method flatten with an argument self .
flat is an empty dictionary ,
for every d in self.dicts [ self . dicts ] ,
update flat dictionary with d .
return flat .
define the method __eq__ with 2 arguments : self and other .
if other is an instance of BaseContext class ,
call the flatten method of the self and other objects , if they are equal , return boolean True , if not return boolean False .
return boolean False .
derive the class Context from the BaseContext base class .
define the method __init__ with 6 arguments : self , dict_ set to None , autoescape set to True , current_app set to None ,
use_l10n set to None and use_tz set to None . substitute autoescape for self.autoescape [ self . autoescape ] .
substitute current_app for self.current_app [ self . current_app ] .
substitute use_l10n for self.use_l10n [ self . use_l10n ] .
substitute use_tz for self.use_tz [ self . use_tz ] .
self.render_context [ self . render_context ] is a instance of RenderContext class .
call the the method __init__ from the base class of the class Context .
define the method __copy__ with an argument self .
call the the method __copy__ from the base class of the class Context , substitute the result for duplicate .
call the function copy with an argument self.render_context [ self . render_context ] , substitute the result for duplicate.render_context [ duplicate . render_context ] .
return duplicate
define the method update with 2 arguments : self and other_dict .
if other_dict doesnt have an _STR:0_ attribute ,
raise an TypeError exception with an argument string _STR:0_ .
append other_dict to self.dicts [ self . dicts ] .
return other_dict .
derive the class RenderContext from the BaseContext base class .
define the method __iter__ with an argument self .
for every d in last element of self.dicts [ self . dicts ] ,
yield d .
define the method has_key with 2 arguments : self and key .
if key is contained in last element of self.dicts [ self . dicts ] , return boolean True , otherwise return boolean False .
define the method get with 3 arguments : self , key and otherwise set to None .
return value under the key key of dictionary in last element of self.dicts [ self . dicts ] ,
if it doesnt exists return otherwise . define the method __getitem__ with 2 arguments : self and key .
return value under the key key of dictionary in last element of self.dicts [ self . dicts ] .
define the function get_standard_processors .
from django.conf [ django . conf ] import settings into default namespace .
use global variable _standard_context_processors .
if _standard_context_processors is None ,
processors is an empty list .
collect is an empty list .
extend collect list with _builtin_context_processors .
extend collect list with settings.TEMPLATE_CONTEXT_PROCESSORS [ settings . TEMPLATE_CONTEXT_PROCESSORS ] .
for every path in collect ,
call the function import_string with an argument path , substitute the result for func .
append func to processors .
convert processors elements into a tuple , substitute it for _standard_context_processors .
return _standard_context_processors .
derive the class RequestContext from the Context base class .
define the method __init__ with 7 arguments : self , request , dict_ set to None , processors set to None , current_app set to None ,
use_l10n set to None and use_tz set to None . call the method Context.__init__ [ Context . __init__ ] with 5 arguments : self , dict_ , current_app as current_app , use_l10n as use_l10n , use_tz as use_tz .
if processors is None ,
processors is an empty tuple .
if not ,
convert processors into a tuple and substitute it for processors .
updates is an empty dictionary .
call the function get_standard_processors , append processors to the result , for every processor is the result ,
call the function processor with an argument request , update updates dictionary with the result .
update self dictionary with updates .
from django.template.base [ django . template . base ] import Lexer , Parser , tag_re , NodeList , VariableNode and TemplateSyntaxError into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_text into default name space .
from django.utils.html [ django . utils . html ] import escape into default name space .
from django.utils.safestring [ django . utils . safestring ] import SafeData and EscapeData into default name space .
from django.utils.formats [ django . utils . formats ] import localize into default name space .
from django.utils.timezone [ django . utils . timezone ] import template_localtime into default name space .
derive the class DebugLexer from the Lexer base class .
define the method __init__ with 3 arguments : self , template_string and origin .
call the method __init__ from the base class of the class DebugLexer , with 2 arguments : template_string and origin .
define the method tokenize with an argument self .
result is an empty list , upto is integer 0 .
call the method tag_re.finditer [ tag_re . finditer ] with an argument self.template_string [ self . template_string ] , for every match in result ,
call the method match.span [ match . span ] , substitute the result for start an end , respectively .
if start is greater than upto ,
call the method self.create_token [ self . create_token ] with 3 arguments : self.template_string [ self . template_string ] list elements from upto index to start index ,
tuple with 2 elements : upto and start and boolean False , append the result to result . substitute start for upto .
call the method self.create_token [ self . create_token ] with 3 arguments : self.template_string [ self . template_string ] list elements from start index to end index ,
tuple with 2 elements : start and end and boolean False , append the result to result . substitute end for upto .
substitute elements of self.template_string [ self . template_string ] list from upto index to the end for last_lit .
if last_bit is true ,
call the method self.create_token [ self . create_token ] with 3 arguments : last_bit , tuple with 2 elements : upto and sum of upto and length of last_bit ,
and boolean False , append the result to result . return result .
define the method create_token with 4 arguments : self , token_string , source and in_tag .
call the method create_token from the base class of the class DebugLexer , with 2 arguments : template_string and in_tag ,
substitute the result for token . assign self.origin [ self . origin ] , source to token.source [ token . source ] .
return token .
derive the class DebugParser from the Parser base class .
define the method __init__ with 2 arguments : self and lexer .
call the method __init__ with an argument lexer , from the base class of the class DebugParser .
self.command_stack [ self . command_stack ] is an empty list .
define the method enter_command with 3 arguments : self , command and token .
append tuple with 2 elements : command and token.source [ token . source ] , append the result to self.command_stack [ self . command_stack ] .
define the method exit_command with an argument self .
remove first element from self.command_stack [ self . command_stack ] .
define the method error with 3 arguments : self , token and msg .
call the method self.source_error [ self . source_error ] with 2 arguments : token.source [ token . source ] and msg , return the result .
define the method source_error with 3 arguments : self , source and msg .
e is an instance of TemplateSyntaxError class , created with an argument msg .
substitute source for e.django_template_source [ e . django_template_source ] .
return e .
define the method create_nodelist with an argument self .
return an instance of DebugNodeList class .
define the method create_variable_node with 2 arguments : self and contents .
return an instance of DebugVariableNode , created with an argument contents .
define the method extend_nodelist with 4 arguments : self , nodelist , node and token .
substitute token.source [ token . source ] for node.source [ node . source ] .
call the method extend_nodelist with 3 arguments : nodelist , node and token , from the base class of the class DebugParser .
define the method unclosed_block_tag with 2 arguments : self and parse_until .
remove the first element from self.command_stack [ self . command_stack ] , assign the result to command and source , respectively .
msg is an string _STR:0_ , where ' % s ' is replaced with command ,
and elements of parse_until joined into a string , separated by string _STR:0_ . raise an self.source_error [ self . source_error ] exception with 2 arguments : source and msg .
define the method compile_filter_error with 3 arguments : self , token and e .
if e doesnt have an _STR:0_ attribute ,
substitute token.source [ token . source ] for e.django_template_source [ e . django_template_source ] .
define the method compile_function_error with 3 arguments : self , token and e .
if e doesnt have an _STR:0_ attribute ,
substitute token.source [ token . source ] for e.django_template_source [ e . django_template_source ] .
derive the class DebugNodeList from the NodeList base class .
define the method render_node with 3 arguments : self , node and context .
try ,
call the method node.render [ node . render ] with an argument context , return the result .
if Exception , renamed to e , exception is caught ,
if e doesnt have an _STR:0_ attribute ,
substitute node.source [ node . source ] for e.django_template_source [ e . django_template_source ] .
raise an exception .
derive the class DebugVariableNode from the VariableNode base class .
define the method render with 2 arguments : self and context .
try ,
call the method self.filter_expression.resolve [ self . filter_expression . resolve ] with an argument context , substitute the result for output .
call the function template_localtime with 2 arguments : output and use_tz set to context.use_tz [ context . use_tz ] , substitute the result for output .
call the function localize with 2 arguments : output and use_l10n set to context.use_l10n [ context . use_l10n ] , substitute the result for output .
call the function force_text with an argument output , substitute the result for output .
if UnicodeDecodeError exception is caught ,
return an empty string .
if Exception , renamed to e , exception is caught ,
if e doesnt have an _STR:0_ attribute ,
substitute self.source [ self . source ] for e.django_template_source [ e . django_template_source ] .
raise an exception .
if context.autoescape [ context . autoescape ] is true and output is not an instance of SafeData class or output is an instance of EscapeData class ,
call the function escape with an argument output .
if not ,
return output .
from __future__ import unicode_literals into default name space .
import module re .
import module random as random_module .
from decimal import Decimal , InvalidOperation , Context and ROUND_HALF_UP into default name space .
from functools import wraps into default name space .
from pprint import pformat into default name space .
from django.template.base [ django . template . base ] import Variable , Library and VariableDoesNotExist into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.utils [ django . utils ] import formats into default name space .
from django.utils.dateformat [ django . utils . dateformat ] import format and time_format into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_text and iri_to_uri into default name space .
from django.utils.html [ django . utils . html ] import conditional_escape , escapejs , escape , urlize as _urlize , linebreaks , strip_tags , avoid_wrapping ,
and remove_tags . from django.utils.http [ django . utils . http ] import urlquote into default name space .
from django.utils.text [ django . utils . text ] import Truncator , wrap and phone2numeric into default name space .
from django.utils.safestring [ django . utils . safestring ] import mark_safe , SafeData and mark_for_escaping into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.timesince [ django . utils . timesince ] import timesince and timeuntil into default name space .
from django.utils.translation [ django . utils . translation ] import ugettext and ungettext into default name space .
from django.utils.text [ django . utils . text ] import normalize_newlines and slugify as _slugify into default name space .
register is an instance of Library class .
define the method stringfilter with an argument func .
define the method _dec with 2 arguments : unpacked list args and unpacked dictionary kwargs .
if args in true ,
convert args into a list , substitute it for args .
call the function force_text with an argument first element of args , substitute the result for first element of args .
if first element of args is an instance of SafeData , and _STR:0_ attribute of dec._decorated_function [ dec . _decorated_function ] object is true ,
call the function func with 2 arguments : unpacked list args and unpacked dictionary kwargs ,
use the result as an argument for the call to the mark_safe function , return the result . call the function func with 2 arguments : unpacked list args and unpacked dictionary kwargs , return the result .
get _STR:0_ attribute from the func object , substitute it for _dec._decorated_function [ _dec . _decorated_function ] , if it doesnt exist ,
substitute func for _dec._decorated_function [ _dec . _decorated_function ] . call the function wraps with an argument func , call the result with an argument _dec , return the result .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
decorator stringfilter ,
define the function addslashes with an argument value .
replace all occurrences of _STR:0_\\\\_STR:1_ '' _STR:2_\\ '' ' in the previous result ,
replace all occurrences of _STR:0_ with _STR:1_ in the previous result , return the result . decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
decorator stringfilter ,
define the function capfirst with an argument value .
if value is false , return it , if it is true convert first element of value to uppercase letter , return the value .
decorator function register.filter [ register . filter ] with an argument string _STR:0_ .
decorator stringfilter ,
define the function escapejs_filter with an argument value .
call the function escapejs with an argument value , return the result .
multiply 10 to the power of 200 , with itself , substitute the result for pos_inf .
multiply 10 to the power of 200 , with 10 to the power of 200 , negative , substitute the result for neg_inf .
divide 10 to the power of 400 by 10 to the power of 400 , substitute the result for nan .
special_floats is an list with 3 elements , pos_inf , neg_inf and nan , all converted to strings .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
define the function floatformat with 2 arguments text and arg set to integer -1 .
try ,
call the function force_text with an argument text , substitute the result for input_val .
d is an instance of Decimal class created with an argument input_val .
if UnicodeEncodeError exception is caught ,
return an empty string .
if InvalidOperation exception is caught ,
if every input_val in special_floats ,
return input_val .
try ,
d is an instance of class Decimal , created with result of the function force_text ,
called with an argument text converted into a floating point number . if ValueError , InvalidOperation , TypeError or UnicodeEncodeError exceptions are caught ,
return an empty string .
try ,
convert arg to an integer , substitute it for p .
if ValueError exception is caught ,
return input_val .
try ,
convert d into a integer , subtract d from it , substitute the result for m .
if ValueError , OverflowError or InvalidOperation exceptions are caught ,
return input_val .
if m is false and p is lesser than integer 0 ,
call the method formats.number_format [ formats . number_format ] with 2 arguments , d converted to a integer and then to string , and integer 0 ,
use the result as an argument for the call to the function mark_safe , return the result . if p equals integer 0 ,
exp is an instance of Decimal , created with an argument integer 1 .
if not ,
instantiate class Decimal with string _STR:0_ as argument , divide it by product of instance of Decimal class created with integer 10 ,
and absolute value of p , substitute the result for exp . try ,
call the method d.as_tuple [ d . as_tuple ] , substitute the result for tupl .
subtract third element of tupl from length of second element of tupl , substitute the result for units .
sum absolute p with units an integer 1 , substitute the result for prec .
call the method d.quantize [ d . quantize ] with 3 arguments : exp , ROUND_HALF_UP and instance of Context class created with prec as prec ,
call the method as_tuple on the result , substitute the result for sign , digits and exponent , respectively . append result of method six.text_type [ six . text_type ] called with an argument digit to an list , for every digit in reversed order of digits ,
substitute the resulting list for digits . while length of digits is smaller than or equal to absolute value of exponent ,
append _STR:0_ to digits .
insert _STR:0_ to digits at negative exponent index .
if sign is true ,
append _STR:0_ to digits .
reverse element order of dicts , join them in a string , substitute the result for number .
call the method formats.number_format [ formats . number_format ] with 2 arguments : number and absolute value of p ,
use the result as an argument for the call to the mark_safe function , return the result . if InvalidOperation exception is caught ,
return input_val .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
decorator stringfilter ,
define the function iriencode with an argument value .
call the function iri_to_uri with an argument value , use the result as an argument for the call to the force_text function ,
return the result . decorator function register.filter [ register . filter ] with 2 arguments is_safe set to boolean True and needs_autoescape set to boolean True .
decorator stringfilter ,
define the function linenumbers with 2 arguments value and autoescape set to None .
split value by newline characters , substitute the result for lines .
call the function six.text_type [ six . text_type ] with length of lines as an argument ,
use length of result as an argument for the call to the function six.text_type [ six . text_type ] , substitute the result for width . if autoescape is false , if value is an instance of SafeData ,
for every i and line in enumerated iterable lines ,
concatenate string _STR:0_ , width and string _STR:1_ , format the previous string with i incremented by 1 and line ,
substitute the result for i-th element of lines . if not ,
for every i and line in enumerated iterable lines ,
concatenate string _STR:0_ , width and string _STR:1_ , format the previous string with i incremented by 1 ,
and result of the function escape called with an argument line , substitute the result for i-th element of lines . call the method mark_safe with lines joined into a string , separated by newlines as argument , return the result .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
decorator stringfilter ,
define the function lower with an argument value .
convert value to lowercase and return the result .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean False .
decorator stringfilter ,
define the function make_list with an argument value .
return value converted into a list .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
decorator stringfilter ,
define the function slugify with an argument value .
call the function _slugify with an argument value , return the result .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
define the function stringformat with 2 arguments value and arg .
try ,
call the function six.text_type [ six . text_type ] with an argument arg , append the result to _STR:0_ , format the previous with value , return the result .
if TypeError or ValueError exceptions are caught ,
return an empty string .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
decorator stringfilter ,
define the function title with an argument value .
call the function re.sub [ re . sub ] with 3 arguments : string _STR:0_ , lambda function with an argument m and return value ,
result of the m.group [ m . group ] method called with an argument integer 0 converted into lowercase and result of the method value.title [ value . title ] , substitute the result for t. call the function re.sub [ re . sub ] with 3 arguments : string _STR:0_ , lambda function with an argument m and return value ,
result of the m.group [ m . group ] method called with an argument integer 0 converted into lowercase and t , return the result . decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
decorator stringfilter ,
define the function truncatechars with 2 arguments value and arg .
try ,
substitute arg converted into a integer for length .
if ValueError exception is caught ,
return value .
instantiate class Truncator , with an argument value , call the method chars on the result with an argument length , return the result .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
decorator stringfilter ,
define the function truncatechars_html with 2 arguments value and arg .
try ,
substitute arg converted into an integer for length .
if ValueError exception is caught ,
return value .
instantiate class Truncator , with an argument value , call the method chars on the result with 2 arguments length ,
and html set to boolean True , return the result . decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
decorator stringfilter ,
define the function truncatewords with 2 arguments value and arg .
try ,
substitute arg converted into an integer for length .
if ValueError exception is caught ,
return value .
instantiate class Truncator , with an argument value , call the method words on the result with 2 arguments length ,
and truncate set to string _STR:0_ , return the result . decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
decorator stringfilter ,
define the function truncatewords_html with 2 arguments value and arg .
try ,
substitute arg converted into an integer for length .
if ValueError exception is caught ,
return value .
instantiate class Truncator , with an argument value , call the method words on the result with 3 arguments length ,
html set to boolean True and truncate set to string _STR:0_ , return the result . decorator function register.filter [ register . filter ] with an argument is_safe set to boolean False .
decorator stringfilter ,
define the function upper with an argument value .
convert value to uppercase , return the result .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean False .
decorator stringfilter ,
define the function urlencode with 2 arguments value and safe set to None .
kwargs is an empty dictionary .
if safe is not None ,
substitute safe for value under the _STR:0_ key of kwargs dictionary .
call the function urlquote with 2 arguments value and unpacked dictionary kwargs , return the result .
decorator function register.filter [ register . filter ] with 2 arguments is_safe set to boolean True and needs_autoescape set to boolean True .
decorator stringfilter ,
define the function urlize with 2 arguments value and autoescape set to None .
call the function _urlize with 3 arguments : value , nofollow set to boolean True , autoescape set to autoescape ,
use the result as an argument for the call to the function mark_safe , return the result . decorator function register.filter [ register . filter ] with 2 arguments is_safe set to boolean True and needs_autoescape set to boolean True .
decorator stringfilter ,
define the function urlizetrunc with 3 arguments value , limit and autoescape set to None .
call the function _urlize with 4 arguments : value , trim_url_limit as limit converted into an integer , nofollow as boolean True ,
and autoescape as autoescape , use the result as an argument for the call to the function mark_safe , return the result . decorator function register.filter [ register . filter ] with an argument is_safe set to boolean False .
decorator stringfilter ,
define the function wordcount with an argument value .
split value into words , return the length of the result .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
decorator stringfilter ,
define the function wordwrap with 2 arguments value and arg .
call the method wrap with 2 arguments , value and arg converted into a integer , return the result .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
decorator stringfilter ,
define the function ljust with 2 arguments value and arg .
call the method value.ljust [ value . ljust ] with an argument , arg converted into a integer , return the result .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
decorator stringfilter ,
define the function rjust with 2 arguments value and arg .
call the method value.rjust [ value . rjust ] with an argument , arg converted into a integer , return the result .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
decorator stringfilter ,
define the function center with 2 arguments value and arg .
call the method value.center [ value . center ] with an argument , arg converted into a integer , return the result .
decorator register.filter [ register . filter ] .
decorator stringfilter ,
define the function cut with 2 arguments value and arg .
if value is an instance of SafeData , safe is boolean True , otherwise it is boolean False .
replace every occurrence of arg is value for an empty string , substitute the result for value .
if safe is true and arg is not equal to string _STR:0_ ,
call the function mark_safe with an argument value , return the result .
return value .
decorator function register.filter [ register . filter ] with 2 arguments string _STR:0_ and is_safe set to boolean True .
decorator stringfilter ,
define the function escape_filter with an argument value .
call the function mark_for_escaping with an argument value , return the result .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
decorator stringfilter ,
define the function force_escape with an argument value .
call the function escape with an argument value , return the result .
decorator function register.filter [ register . filter ] with 3 arguments string _STR:0_ , is_safe set to boolean True and needs_autoescape set to True .
decorator stringfilter ,
define the function linebreaks_filter with 2 arguments value and autoescape set to None .
if autoescape is true and value is not an instance of SafeData , autoescape is boolean True , otherwise it is boolean False .
call the function linebreaks with 2 arguments value and autoescape , use the result as an argument for the call to the mark_safe ,
return the result . decorator function register.filter [ register . filter ] with 2 arguments is_safe set to boolean True and needs_autoescape set to boolean True .
decorator stringfilter ,
define the function linebreaksbr with 2 arguments value and autoescape set to None .
if autoescape is true and value is not an instance of SafeData , autoescape is boolean True , otherwise it is boolean False .
call the function normalize_newlines with an argument value , substitute the result for value .
if autoescape is true ,
call the function escape with an argument value , substitute it for value .
replace every occurrence of newline character in value with string _STR:0_ , use it as an argument for the call to the mark_safe ,
return the result . decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
decorator stringfilter ,
define the function safe with an argument value .
call the function mark_safe with an argument value , return the result .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
define the function safeseq with an argument value .
for every obj in value call the function mark_safe with an argument result of the function force_text called with an argument obj ,
return all the results in a list . decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
decorator stringfilter ,
define the function removetags with 2 arguments value and arg .
call the function remove_tags with 2 arguments value and tags , return the result .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
decorator stringfilter ,
define the function striptags with an argument value .
call the function strip_tags with an argument value , return the result .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean False .
define the function dictsort with 2 arguments value and arg .
try ,
sort value with key set to filed resolve of instance of a class Variable , created with an argument arg , return the result .
if TypeError or VariableDoesNotExist exceptions are caught ,
return an empty string .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean False .
define the function dictsortreversed with 2 arguments value and arg .
try ,
sort value with key set to filed resolve of instance of a class Variable , created with an argument arg , reverse the sort and return the result .
if TypeError or VariableDoesNotExist exceptions are caught ,
return an empty string .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean False .
define the function first with an argument value .
try ,
return first element of value .
if IndexError exception is caught ,
return an empty string .
decorator function register.filter [ register . filter ] with 2 arguments is_safe set to boolean True and needs_autoescape set to boolean True .
define the function join with 3 arguments : value , arg and autoescape set to None .
map elements of value through mapping function force_text , substitute the result for value .
if autoescape is true ,
for every v in value call the function conditional_escape with an argument v , append the result in a list , substitute the resulting list for value .
try ,
call the function conditional_escape with an argument arg , call the method join on the result with an argument value ,
substitute the result for data . if AttributeError exception is caught ,
return value .
call the function mark_safe with an argument data , return the result .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
define the function last with an argument value .
try ,
return last element of value .
if IndexError exception is caught ,
return an empty string .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean False .
define the function length with an argument value .
try ,
return length of value ,
if TypeError or ValueError exceptions are caught ,
return integer 0 .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean False .
define the function length_is with 2 arguments value and arg .
try ,
if lengths of value and arg are equal , return boolean True , otherwise return boolean False .
if TypeError or ValueError exceptions are caught ,
return an empty string .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
define the function random with an argument value .
call the function random_module.choice [ random_module . choice ] with an argument value , return the result .
decorator function register.filter [ register . filter ] with 2 arguments string _STR:0_ and is_safe set to boolean True .
define the function slice_filter with 2 arguments value and arg .
try ,
bits is an empty list .
split arg by _STR:0_ , for every x in result ,
if length of x is equal to integer 0 ,
append None to bits .
if not ,
append x converted to an integer to bits .
slice the list value with unpacked list bits as an argument , return the result .
if TypeError or ValueError exceptions are caught ,
return value .
decorator function register.filter [ register . filter ] with 2 arguments is_safe set to boolean True and needs_autoescape set to boolean True .
define the function unordered_list with 2 arguments value and autoescape set to None .
if autoescape is true ,
substitute conditional_escape for escaper .
if not ,
escaper is an identity lambda function .
define the function convert_old_style_list with an argument list_ .
if list_ is not an instance of tuple or list types and length of list_ is not equal to integer 2 ,
return list_ and boolean False .
substitute list_ for first_item and second_item , respectively .
if second_item is an empty list ,
return list with an element first_item , and boolean True .
try ,
convert second item to an iterable ,
if TypeError exception is caught ,
return list_ and boolean False .
old_style_list is boolean True .
new_second_item is an empty list .
for every sublist in second_item ,
call the function convert_old_style_list with an argument sublist , substitute the result for item and old_style_list .
if old_style_list is false ,
break from the loop execution ,
extend new_second_item with item .
if old_style_list is true ,
substitute new_second_item with second_item .
return list with 2 elements : first_item and second_item , and old_style_list .
define the function _helper with 2 arguments list and tabs set to integer 1 .
indent contain tabs number of tab character .
output is an empty list .
substitute length of list_ for list_length .
i is integer 0 .
while i is smaller than list_length ,
substitute i-th element of list for title .
sublist is an empty string .
sublist_item is None .
if title is an instance of list or tuple ,
substitute title for sublist_item .
title is an empty string .
otherwise if i is smaller than list_length decremented by one ,
substitute ( i+1 ) -th element of list_ for next_item .
if next_item is true and next_item is an instance of list or tuple type ,
substitute next_item for sublist_item .
increment i by integer 1 .
if sublist_item is true ,
call the function _helper with 2 arguments : sublist_item and tabs incremented by 1 , substitute the result for sublist .
sublist is an string _STR:0_ , where every ' % s ' is replaced with indent , sublist , indent and indent , respectively .
substitute every ' % s ' in string _STR:0_ with indent , with result of the function escaper called with an argument :
result of the function force_text called with an argument title , and with sublist , append the string to output . increment i by 1 .
join elements of output into a string , separated with newlines , return the result .
call the function convert_old_style_list with an argument value , substitute the result for value and converted , respectively .
call the function _helper with an argument value , use it as an argument for the call to the function mark_safe , return the result .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean False .
define the function add with 2 arguments value and arg .
try ,
convert value and arg into a integers , return their sum .
if TypeError or ValueError exceptions are caught ,
try ,
sum value and arg , return the result .
if Exception exception is caught ,
return an empty string .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean False .
define the function get_digit with 2 arguments value and arg .
try ,
convert arg to an integer .
convert value to an integer .
if ValueError exception is caught ,
return value .
if arg is smaller than integer 1 ,
return value .
try ,
convert value into a string , take character at the negative arg index , convert it into an integer , return it .
if IndexError exception is caught ,
return integer 0 .
decorator function register.filter [ register . filter ] with 2 arguments expects_localtime set to boolean True and is_safe set to boolean False .
define the function date with 2 arguments value and arg set to None .
if vale is None or an empty string ,
return an empty string .
if arg is None ,
substitute settings.DATE_FORMAT [ settings . DATE_FORMAT ] for arg .
try ,
call the method formats.time_format [ formats . time_format ] with 2 arguments : value and arg , return the result .
if AttributeError exception is caught ,
try ,
format value into printable data representation with formating rules arg , return the result .
if AttributeError exception is caught ,
return an empty string .
decorator function register.filter [ register . filter ] with 2 arguments expects_localtime set to boolean True and is_safe set to boolean False .
define the function time with 2 arguments value and arg set to None .
if vale is None or an empty string ,
return an empty string .
if arg is None
substitute settings.TIME_FORMAT [ settings . TIME_FORMAT ] for arg .
try ,
call the method formats.time_format [ formats . time_format ] with 2 arguments : value and arg , return the result .
if AttributeError exception is caught ,
try ,
call the function time_format with 2 arguments : value and arg , return the result .
if AttributeError exception is caught ,
return an empty string .
decorator function register.filter [ register . filter ] with 2 arguments string _STR:0_ and is_safe set to boolean False .
define the function timesince_filter with 2 arguments value and arg set to None .
if value is false ,
return an empty string .
try ,
if arg is true ,
call the function timesince with 2 arguments : value and arg , return the result .
call the function timesince with an argument value , return the result .
if TypeError or ValueError exceptions are caught ,
return an empty string .
decorator function register.filter [ register . filter ] with 2 arguments string _STR:0_ and is_safe set to boolean False .
define the function timeuntil_filter with 2 arguments value and arg set to None .
if value is false ,
return an empty string .
try ,
call the function timeuntil with 2 arguments value and arg , return the result .
if TypeError or ValueError exceptions are caught ,
return an empty string .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean False .
define the function default with 2 arguments value and arg .
return value , if it is None return arg .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean False .
define the function default_if_none with 2 arguments value and arg .
if value is None ,
return arg .
return value .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean False .
define the function divisibleby with 2 arguments value and arg .
convert value and arg to integers , if value is divisible by arg , return True , otherwise return boolean False .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean False .
define the function yesno with 2 arguments value and arg set to None .
if arg is None
call the function ugettext with string _STR:0_ as an argument , substitute the result for arg .
split arg by _STR:0_ , substitute the result for bits .
if length of bits is lesser than integer 2 ,
return value .
try ,
assign bits elements to yes , no and maybe , respectively .
if ValueError exception is caught ,
substitute first , second and second elements of bits for yes , no , maybe , respectively .
if value is None ,
return maybe .
if value is true ,
return yes .
return no .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
define the function filesizeformat with an argument bytes .
try ,
convert bytes to floating point number , substitute it for bytes .
if TypeError , ValueError or UnicodeDecodeError exceptions are caught ,
call the function ungettext with 3 arguments : string _STR:0_ , string _STR:1_ and 0 , _STR:2_ is replaced with 0 ,
substitute the result for value . call the function avoid_wrapping with an argument value , return the result .
filesize_number_format is an lambda function with an argument value , return value is the result of the method formats.number_format [ formats . number_format ] ,
called with 2 arguments : value rounded to 1 decimal point and integer 1. move integer 1 left for 10 bits , substitute the result for KB .
move integer 1 left for 20 bits , substitute the result for MB .
move integer 1 left for 30 bits , substitute the result for GB .
move integer 1 left for 40 bits , substitute the result for TB .
move integer 1 left for 50 bits , substitute the result for PB .
if bytes is smaller than KB ,
call the function ugettext with 3 arguments , string _STR:0_ , string _STR:1_ and bytes ,
replace ' % ( size ) d with bytes , substitute the result for value . otherwise if bytes is smaller than MB ,
call the function ugettext with an argument string _STR:0_ , substitute ' % s ' with the result of the call to the function ,
filesize_number_format with result of division of bytes by KB as an argument , substitute the result for value . otherwise if bytes is smaller than GB ,
call the function ugettext with an argument string _STR:0_ , substitute ' % s ' with the result of the call to the function ,
filesize_number_format with result of division of bytes by MB as an argument , substitute the result for value . otherwise if bytes is smaller than TB ,
call the function ugettext with an argument string _STR:0_ , substitute ' % s ' with the result of the call to the function ,
filesize_number_format with result of division of bytes by GB as an argument , substitute the result for value . otherwise if bytes is smaller than PB ,
call the function ugettext with an argument string _STR:0_ , substitute ' % s ' with the result of the call to the function ,
filesize_number_format with result of division of bytes by TB as an argument , substitute the result for value . if not ,
call the function ugettext with an argument string _STR:0_ , substitute ' % s ' with the result of the call to the function ,
filesize_number_format with result of division of bytes by PB as an argument , substitute the result for value . call the function avoid_wrapping with an argument value , return the result .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean False .
define the function pluralize with 2 arguments value and arg set to character _STR:0_ .
if _STR:0_ is not contained in arg ,
append arg to _STR:0_ , substitute the result for arg .
split arg by _STR:0_ , substitute the result for bits.s [ bits . s ]
if length of bits is greater than integer 2 ,
return an empty string .
substitute first 2 elements of bits for singular_suffix and plural_suffix , respectively .
try ,
convert value to an floating point number if it is not equal to integer 1 ,
return plural_suffix .
if ValueError exception is caught ,
do nothing ,
if TypeError exception is caught ,
try ,
if length of value is not equal to integer 1 ,
return plural_suffix .
if TypeError exception is caught ,
do nothing ,
return singular_suffix .
decorator function register.filter [ register . filter ] with 2 arguments string _STR:0_ and is_safe set to boolean True .
define the function phone2numeric_filter with an argument value .
call the function phone2numeric with an argument value , return the result .
decorator function register.filter [ register . filter ] with an argument is_safe set to boolean True .
define the function pprint with an argument value .
try ,
call the function pformat with an argument value , return the result .
if Exception , renamed to e , exception is caught ,
return an string _STR:0_ , replace ' % s ' with result of the function force_text ,
from __future__ import unicode_literals into default name space .
import module os .
import module sys .
import module re .
from datetime import datetime into default name space .
from itertools import groupby and cycle as itertools_cycle into default name space .
import module warnings .
from django.conf [ django . conf ] import settings into default name space .
from django.template.base [ django . template . base ] import Node , NodeList , Template , Context , Library , TemplateSyntaxError , VariableDoesNotExist ,
validTemplateLibrary , BLOCK_TAG_START , BLOCK_TAG_END , VARIABLE_TAG_START , VARIABLE_TAG_END , SINGLE_BRACE_START , SINGLE_BRACE_END , COMMENT_TAG_START , COMMENT_TAG_END , VARIABLE_ATTRIBUTE_SEPARATOR , get_library , token_kwargs , kwarg_re and render_value_in_context . from django.template.smartif [ django . template . smartif ] import IfParser and Literal into default name space .
from django.template.defaultfilters [ django . template . defaultfilters ] import date into default name space .
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango20Warning into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_text and smart_text into default name space .
from django.utils.safestring [ django . utils . safestring ] import mark_safe into default name space .
from django.utils.html [ django . utils . html ] import format_html into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils [ django . utils ] import timezone into default name space .
register is an instance of Library class .
derive the class AutoEscapeControlNode from Node base class .
define the method __init__ with 3 arguments : self , setting and nodelist .
substitute setting and nodelist for self.setting [ self . setting ] and self.nodelist [ self . nodelist ] , respectively .
define the method render with 2 arguments : self and context .
substitute context.autoescape [ context . autoescape ] for old_setting .
substitute self.setting [ self . setting ] for context.autoescape [ context . autoescape ] .
call the method self.nodelist.render [ self . nodelist . render ] with an argument context , substitute the result for output .
substitute old_setting for context.autoescape [ context . autoescape ] .
if self.setting [ self . setting ] is true ,
call the function mark_safe with an argument output .
if not ,
return output .
derive the class CommentNode from Node base class .
define the method render with 2 arguments : self and context .
return an empty string ,
derive the class CsrfTokenNode from Node base class .
define the method render with 2 arguments : self and context .
get the value under the _STR:0_ key of the context dictionary , if it exists substitute the result for csrf_token ,
if not csrf_token is None . if csrf_token is true ,
if csrf_token equals string _STR:0_ ,
call the function format_html with an argument empty string , return the result .
if not ,
call the function format_html with 2 arguments : string _STR:0_ ,
and csrf_token , return the result . if not ,
if settings.DEBUG [ settings . DEBUG ] is true ,
call the function warnings.warn [ warnings . warn ] with an argument string _STR:0_ .
return an empty string ,
derive the class CycleNode from Node base class .
define the method __init__ with 4 arguments : self , cyclevars , variable_name set to None and silent set to boolean False .
substitute cyclevars for self.cyclevars [ self . cyclevars ] .
substitute variable_name for self.variable_name [ self . variable_name ] .
substitute silent for self.silent [ self . silent ] .
define the method render with 2 arguments : self and context .
if self is not contained in context.render_context [ context . render_context ] ,
call the function itertools_cycle with an argument self.cyclevars [ self . cyclevars ] , substitute the result for value under the self dictionary context.render_context [ context . render_context ] .
get the value under the self key of the context.render_context [ context . render_context ] dictionary , substitute it for cycle_iter .
call the function next with an argument cycle_iter , call the method resolve on the result with an argument context , substitute the result for value .
if self.variable_name [ self . variable_name ] is true .
substitute value for value under the self.variable_name [ self . variable_name ] key of the context dictionary .
if self.silent [ self . silent ] is true ,
return an empty string ,
call the function render_value_in_context with 2 arguments : value and context , return the result .
derive the class DebugNode from Node base class .
define the method render with 2 arguments : self and context .
from pprint import pformat .
output is an list with initial elements generated with call to the function pformat with an argument val , for every val in context .
append 2 consecutive newlines to output .
call the function pformat with an argument sys.modules [ sys . modules ] , append the result for output .
join elements of output into a string , return the result .
derive the class FilterNode from Node base class .
define the method __init__ with 3 arguments : self , filter_expr and nodelist ) .
substitute filter_expr and nodelist for self.filter_expr [ self . filter_expr ] and self.nodelist [ self . nodelist ] , respectively .
define the method render with 2 arguments : self and context .
call the method self.nodelist.render [ self . nodelist . render ] with an argument context , substitute the result output .
call the method context.push [ context . push ] with an argument var set to output , with the result perform ,
call the function self.filter_expr.resolve [ self . filter_expr . resolve ] with an argument context , return the result .
derive the class FirstOfNode from Node base class .
define the method __init__ with 2 arguments : self and variables .
substitute variables for self.vars [ self . vars ] .
define the method render with 2 arguments : self and context .
for every var in self.vars [ self . vars ] ,
call the method var.resolve [ var . resolve ] with 2 arguments : context and True , substitute the result for value .
if value is true ,
call the function render_value_in_context with 2 arguments : value and context , return the result .
return an empty string ,
derive the class ForNode from Node base class .
child_nodelists is an tuple with 2 elements : strings _STR:0_ and _STR:1_ .
define the method __init__ with 6 arguments : self , loopvars , sequence , is_reversed , nodelist_loop and nodelist_empty set to None .
substitute loopvars and sequence for self.loopvars [ self . loopvars ] and self.sequence [ self . sequence ] , respectively .
substitute is_reversed for self.is_reversed [ self . is_reversed ] .
substitute nodelist_loop for self.nodelist_loop [ self . nodelist_loop ] .
if nodelist_empty is None ,
self.nodelist_empty [ self . nodelist_empty ] is an instance of NodeList class .
if not ,
substitute nodelist_empty for self.nodelist_empty [ self . nodelist_empty ] .
define the method __repr__ with an argument self .
if self.is_reversed [ self . is_reversed ] is true , substitute reversed_text is an string _STR:0_ , if not , reversed_text is an empty string .
return an string _STR:0_ , substitute ' % s ' with elements of self.loopvars [ self . loopvars ] joined into a string ,
separated with string _STR:0_ , substitute ' % s ' with self.sequence [ self . sequence ] , substitute _STR:1_ with length of self.nodelist_loop [ self . nodelist_loop ] , substitute ' % s ' with reversed_text . define the method __iter__ with an argument self .
for every node in self.nodelist_loop [ self . nodelist_loop ] ,
yield node .
for every node in self.nodelist_empty [ self . nodelist_empty ] ,
yield node .
define the method render with 2 arguments : self and context .
if string _STR:0_ is contained in context ,
substitute value under the the _STR:0_ key of the context dictionary for parentloop .
if not ,
parentloop is an empty dictionary .
call the method context.push [ context . push ] , with the result perform ,
try ,
call the method self.sequence.resolve [ self . sequence . resolve ] with 2 arguments : context and boolean True , substitute the result for values .
if VariableDoesNotExist exception is caught ,
values is an empty list .
if values is None ,
if values is None ,
if values has an attribute _STR:0_ ,
convert values into a list , substitute it for value .
substitute length of values for len_values .
if len_values is smaller than integer 1 ,
call the method self.nodelist_empty.render [ self . nodelist_empty . render ] with an argument context , return the result .
nodelist is an empty list .
if self.is_reversed [ self . is_reversed ] is true ,
reverse elements order of values .
substitute length of self.loopvars [ self . loopvars ] for num_loopvars .
if num_loopvars is greater than integer 1 , unpack is an boolean True , otherwise is an boolean False .
loop_dict and value under the _STR:0_ key of the context dictionary are dictionaries with an entry : parentloop for _STR:1_ .
for every i and item in enumerated iterable values ,
substitute i for value under the _STR:0_ key of the loop_dict dictionary .
substitute i incremented by 1 for value under the _STR:0_ key of the loop_dict dictionary .
subtract i from len_values , substitute the result for value under the _STR:0_ key of the loop_dict dictionary .
subtract i from len_values , decrement the result by integer 1 , substitute it for value under the _STR:0_ key of the loop_dict dictionary .
if i is equal to integer 0 , value under the _STR:0_ key of the loop_dict dictionary is boolean True , otherwise it is False .
if i is equal to len_values decremented by 1 , value under the _STR:0_ key of the loop_dict dictionary is boolean True , otherwise it is False .
pop_context is boolean False .
if unpack is true ,
if item is not an instance of list or tuple class ,
len_item is integer 1 .
if not ,
substitute length of item for len_item .
if num_loopvars is not equal to len_item ,
call the function warnings.warn [ warnings . warn ] with 2 arguments : string `` Need { 0 } values to unpack in for loop ; got { 1 } . This will raise an
exception in Django 2.0 [ 2 . 0 ] . '' formated with num_loopvars and len_item , respectively , and RemovedInDjango20Warning . try ,
zip self.loopvars [ self . loopvars ] and item is a list to tuples , convert the result to an dictionary , substitute it for unpacked_vars .
if TypeError exception is caught ,
do nothing .
if not ,
pop_context is boolean True .
call the method context.update [ context . update ] with an argument unpacked_vars .
if not ,
substitute item for value under the first element of self.loopvars [ self . loopvars ] key of the context dictionary .
if settings.TEMPLATE_DEBUG [ settings . TEMPLATE_DEBUG ] is true ,
for every node in self.nodelist_loop [ self . nodelist_loop ] ,
try ,
call the method node.render [ node . render ] with an argument context , append the result to the nodelist .
if Exception , renamed to e , exception is caught ,
if e doesnt have an _STR:0_ attribute ,
substitute node.source [ node . source ] for e.django_template_source [ e . django_template_source ] .
raise an exception .
if not ,
for every node in self.nodelist_loop [ self . nodelist_loop ] ,
call the method node.render [ node . render ] with an argument context , append the result to the nodelist .
if pop_context is true ,
remove the first element of context .
call the function mark_safe with an arguments : for every n in nodelist results of the function force_text called with an argument n , joined in a string , return the result .
derive the class IfChangedNode from Node base class .
child_nodelists is a tuple with 2 initial elements : strings _STR:0_ and _STR:1_ .
define the method __init__ with 4 arguments : self , nodelist_true , nodelist_false and unpacked list varlist .
substitute nodelist_true and nodelist_false for self.nodelist_true [ self . nodelist_true ] and self.nodelist_false [ self . nodelist_false ] , respectively .
substitute varlist for self.varlist [ self . varlist ] .
define the method render with 2 arguments : self and context .
call the method self._get_context_stack_frame [ self . _get_context_stack_frame ] with an argument context , substitute the result for state_frame .
if self is not contained in state_frame ,
value under the self key of state_frame dictionary is None .
nodelist_true_output is None .
try ,
if self._varlist [ self . _varlist ] is true ,
compare_to is an list with elements generated by calling the var.resolve [ var . resolve ] method with 2 arguments : context and boolean True ,
for every var in self._varlist [ self . _varlist ] . if not ,
call the method self.nodelist_true.render [ self . nodelist_true . render ] with an argument context , assign the result to compare_to and nodelist_true_output .
if VariableDoesNotExist exception is caught ,
compare_to is None .
if compare_to is not equal to value under the self key of state_frame .
substitute compare_to for value under the state_frame dictionary under the self key .
return nodelist_true_output , if true , if not call the method self.nodelist_true.render [ self . nodelist_true . render ] with an argument context and return the result .
otherwise if self.nodelist_false [ self . nodelist_false ] is true ,
call the method self.nodelist_false.render [ self . nodelist_false . render ] with an argument context , return the result .
return an empty string ,
define the method _get_context_stack_frame with 2 arguments : self and context .
if string _STR:0_ is contained in context ,
return value under the _STR:0_ key of the context dictionary .
if not ,
return context.render_context [ context . render_context ] .
derive the class IfEqualNode from Node base class .
child_nodelists is a tuple with 2 elements strings _STR:0_ and _STR:1_ .
define the method __init__ with 6 arguments : ( self , var1 , var2 , nodelist_true , nodelist_false and negate .
substitute var1 and var2 for self.var1 [ self . var1 ] and self.var2 [ self . var2 ] , respectively .
substitute nodelist_true and nodelist_false for self.nodelist_true [ self . nodelist_true ] and self.nodelist_false [ self . nodelist_false ] , respectively .
substitute negate for self.negate [ self . negate ] .
define the method __repr__ with an argument self .
return an string _STR:0_ .
define the method render with 2 arguments : self and context .
call the method self.var1.resolve [ self . var1 . resolve ] with 2 arguments : context and boolean True , substitute the result for val2 .
call the method self.var2.resolve [ self . var2 . resolve ] with 2 arguments : context and boolean True , substitute the result for val2 .
if self.negate [ self . negate ] is true and val1 is not equal to val2 , or if , self.negate [ self . negate ] is false and val1 equals val2 ,
call the method self.nodelist_true.render [ self . nodelist_true . render ] with an argument context , return the result .
call the method self.nodelist_false.render [ self . nodelist_false . render ] with an arguments context , return the result .
derive the class IfNode from Node base class .
define the method __init__ with 2 arguments : self and conditions_nodelists .
substitute conditions_nodelists for self.conditions_nodelists [ self . conditions_nodelists ] .
define the method __repr__ with an argument self .
return an string _STR:0_ .
define the method __iter__ with an argument self .
for every _ and nodelist in self.conditions_nodelists [ self . conditions_nodelists ] ,
for every node in nodelist ,
yield node as an return value of a generator .
property decorator ,
define the method nodelist with an argument self .
return an instance of a NodeList class , created with arguments node , for every node in nodelist ,
and for every _ , nodelist in self.conditions_nodelists [ self . conditions_nodelists ] . define the method render with 2 arguments : self and context .
for every condition and nodelist in self.conditions_nodelists [ self . conditions_nodelists ] ,
if condition is not None ,
try ,
call the method condition.eval [ condition . eval ] with an argument context , substitute the result for match .
if VariableDoesNotExist exception is caught ,
match is None .
if not ,
match is boolean True .
if match is true ,
call the method nodelist.render [ nodelist . render ] with an argument context , return the result .
return an empty string ,
derive the class RegroupNode from Node base class .
define the method __init__ with 4 arguments : self , target , expression and var_name .
substitute target and expression for self.target [ self . target ] and self.expression [ self . expression ] , respectively .
substitute var_name for self.var_name [ self . var_name ] .
define the method resolve_expression with 3 arguments : self , obj and context .
substitute obj for value under the self.var_name [ self . var_name ] key of the context dictionary .
call the method self.expression.resolve [ self . expression . resolve ] with 2 arguments : context and boolean True , return the result .
define the method render with 2 arguments : self and context .
call the method self.target.resolve [ self . target . resolve ] with 2 arguments : context and boolean True , substitute it for obj_list .
if obj_list is None ,
value under the self.var_name [ self . var_name ] key of the context dictionary is an empty list .
return an empty string ,
value under the self.var_name [ self . var_name ] key of the context dictionary is an list with dictionary elements with 2 entries :
key for _STR:0_ and val converted into a list for _STR:1_ , for every key and val in result of the function groupby , called with 2 arguments : obj_list and lambda function with an argument obj and return value as a result of the function , self.resolve_expression [ self . resolve_expression ] called with 2 arguments obj and context . return an empty string ,
define the function include_is_allowed with an argument filepath .
return the absolute path of file path filepath , substitute it for filepath .
for every root in settings.ALLOWED_INCLUDE_ROOTS [ settings . ALLOWED_INCLUDE_ROOTS ] ,
if filepath starts with root ,
return boolean True .
return boolean False .
derive the class SsiNode from Node base class .
define the method __init__ with 3 arguments : self , filepath and parsed .
substitute filepath for self.filepath [ self . filepath ] .
substitute parsed for self.parsed [ self . parsed ] .
define the method render with 2 arguments : self and context .
call the function self.filepath.resolve [ self . filepath . resolve ] with an argument context , substitute the result for filepath .
call the function include_is_allowed with an argument filepath , if it evaluates to false ,
if settings.DEBUG [ settings . DEBUG ] is true ,
return string _STR:0_ .
if not ,
return an empty string ,
try ,
open filepath file in read mode , with file descriptor as fp , perform ,
read file fp , substitute the read data for output .
if IOError exception is caught ,
output is an empty string .
if self.parsed [ self . parsed ] is true ,
try ,
t is an instance of Template class , created with 2 arguments output and name set to filepath .
call the function t.render [ t . render ] with an argument context , return the result .
if TemplateSyntaxError , renamed to e , exception is caught ,
if settings.DEBUG [ settings . DEBUG ] is true ,
return an string _STR:0_ , where ' % s ' is replaced with e .
if not ,
return an empty string ,
return output .
derive the class LoadNode from Node base class .
define the method render with 2 arguments : self and context .
return an empty string ,
derive the class NowNode from Node base class .
define the method __init__ with 2 arguments : self and format_string .
substitute format_string for self.format_string [ self . format_string ] .
define the method render with 2 arguments : self and context .
if settings.USE_TZ [ settings . USE_TZ ] is true substitute result of the function timezone.get_current_timezone [ timezone . get_current_timezone ] for tzinfo , if not tzinfo is None .
call the function date with 2 arguments : result of the call to the function datetime.now [ datetime . now ] with an argument tz set to tzinfo ,
and self.format_string [ self . format_string ] , return the result . derive the class SpacelessNode from Node base class .
define the method __init__ with 2 arguments : self and nodelist .
substitute nodelist for self.nodelist [ self . nodelist ] .
define the method render with 2 arguments : self and context .
from django.utils.html [ django . utils . html ] import strip_spaces_between_tags .
call the method self.nodelist.render [ self . nodelist . render ] with an argument context , strip the result of the surrounding whitespaces ,
use the result as an argument for the call to the function strip_spaces_between_tags , return the result . derive the class TemplateTagNode from Node base class .
mapping is an dictionary with 8 initial entries : BLOCK_TAG_START for _STR:0_ , BLOCK_TAG_END for _STR:1_ ,
VARIABLE_TAG_START for _STR:0_ , VARIABLE_TAG_END for _STR:1_ , SINGLE_BRACE_START for _STR:2_ , SINGLE_BRACE_END _STR:3_ , COMMENT_TAG_START _STR:4_ and COMMENT_TAG_END for _STR:5_ . define the method __init__ with 2 arguments : self and tagtype .
substitute tagtype for self.tagtype [ self . tagtype ] .
define the method render with 2 arguments : self and context .
call the method self.mapping.get [ self . mapping . get ] with 2 arguments : self.tagtype [ self . tagtype ] and an empty list , return the result .
derive the class URLNode from Node base class .
define the method __init__ with 5 arguments : self , view_name , args , kwargs and asvar .
substitute view_name for self.view_name [ self . view_name ] .
substitute args for self.args [ self . args ] .
substitute kwargs for self.kwargs [ self . kwargs ] .
substitute asvar for self.asvar [ self . asvar ] .
define the method render with 2 arguments : self and context .
from django.core.urlresolvers [ django . core . urlresolvers ] import reverse , NoReverseMatch .
for every arg in self.args [ self . args ] call the method arg.resolve [ arg . resolve ] with an argument context , substitute the results in a list for args .
kwargs is an dictionary , populated for every k and v in result of the method self.kwargs.items [ self . kwargs . items ] with :
result of the call to the method v.resolve [ v . resolve ] with an argument context , for result of the function smart_text called with 2 arguments k and string _STR:0_ . call the method self.view_name.resolve [ self . view_name . resolve ] with an argument context , substitute the result for view_name .
url is an empty string .
try ,
call the function reverse with 4 arguments : view_name , args as args , kwargs as kwargs and current_app as context.current_app [ context . current_app ] ,
substitute the result for url . if NoReverseMatch exception is caught ,
call the function sys.exc_info [ sys . exc_info ] with an argument exc_info .
if settings.SETTINGS_MODULE [ settings . SETTINGS_MODULE ] is true ,
split settings.SETTINGS_MODULE [ settings . SETTINGS_MODULE ] by _STR:0_ character , substitute the first element of the result for project_name .
try ,
call the function reverse with 4 arguments : concatenated project_name , character _STR:0_ and view_name , args as args , kwargs as kwargs ,
current_app as context.current_app [ context . current_app ] , substitute the result for url . if NoReverseMatch exception is caught ,
if self.asvar [ self . asvar ] is None ,
call the function six.reraise [ six . reraise ] with unpacked list exc_info as an argument .
if not ,
if self.asvar [ self . asvar ] is None ,
raise an exception .
if self.asvar [ self . asvar ] is true ,
substitute url for value under the self.asvar [ self . asvar ] key of context dictionary .
return an empty string .
if not ,
return url .
derive the class VerbatimNode from Node base class .
define the method __init__ with 2 arguments : self and content .
substitute content for self.content [ self . content ] .
define the method render with 2 arguments : self and context .
return self.content [ self . content ]
derive the class WidthRatioNode from Node base class .
define the method __init__ with 5 arguments : self , val_expr , max_expr , max_width and asvar set to None .
substitute val_expr for self.val_expr [ self . val_expr ] .
substitute max_expr for self.max_expr [ self . max_expr ] .
substitute max_width for self.max_width [ self . max_width ] .
substitute asvar for self.asvar [ self . asvar ] .
define the method render with 2 arguments : self and context .
try ,
call the method self.val_expr.resolve [ self . val_expr . resolve ] with an argument context , substitute the result for value .
call the method self.max_expr.resolve [ self . max_expr . resolve ] with an argument context , substitute the result for max_value .
call the method self.max_width.resolve [ self . max_width . resolve ] with an argument context , convert the result to an integer and substitute it for max_width .
if VariableDoesNotExist exception is caught ,
return an empty string .
if ValueError or TypeError exceptions are caught ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ .
try ,
convert value into an floating point number , substitute it for value .
convert max_value into an floating point number , substitute it for max_value .
divide value by max_value , multiply the result with max_width , substitute it for ratio .
round up radio , convert it to an integer and the convert it to a string and substitute the result for result .
if ZeroDivisionError exception is caught ,
return an string _STR:0_ .
if ValueError , TypeError or OverflowError exceptions are caught ,
return an empty string ,
if self.asvar [ self . asvar ] is true ,
substitute result for value under the self.asvar [ self . asvar ] key of context dictionary .
return an empty string ,
if not ,
return result .
derive the class WithNode from Node base class .
define the method __init__ with 5 arguments : self , var , name , nodelist and extra_context set to None .
substitute nodelist for self.nodelist [ self . nodelist ] .
if extra_context is true , substitute it for self.extra_context [ self . extra_context ] , if not self.extra_context [ self . extra_context ] is an empty dictionary .
if name is true ,
substitute var for value under the name key of the self.extra_context [ self . extra_context ] dictionary .
define the method __repr__ with an argument self .
return a string _STR:0_
define the method render with 2 arguments : self and context .
values is an dictionary created with result of the method val.resolve [ val . resolve ] called with an argument context , for key ,
for every key and val in return value of the function six.iteritems [ six . iteritems ] called with an arguments self.extra_context [ self . extra_context ] . call the method context.push [ context . push ] with an argument unpacked dictionary values , with the result as an argument ,
call the method self.nodelist.render [ self . nodelist . render ] with an argument context , return the result .
register.tag [ register . tag ] decorator ,
define the function autoescape with 2 arguments : parser and token .
call the method token.contents.split [ token . contents . split ] , substitute the result for args .
if length of args is not equal to integer 2 ,
raise an TemplateSyntaxError with an argument string _STR:0_ .
substitute first element of args for arg .
if arg is not string _STR:0_ or _STR:1_ ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ .
call the method parser.parse [ parser . parse ] with an argument tuple with an element string _STR:0_ , substitute the result for nodelist .
call the method parser.delete_first_token [ parser . delete_first_token ] .
return an instance of AutoEscapeControlNode with 2 arguments : boolean exception arg equals to string _STR:0_ , and nodelist .
register.tag [ register . tag ] decorator ,
define the function comment with 2 arguments : parser and token .
call the method parser.skip_past [ parser . skip_past ] with an argument string _STR:0_ .
return an instance of CommentNode class .
register.tag [ register . tag ] decorator ,
define the function cycle with 2 arguments : parser and token .
call the method token.split_contents [ token . split_contents ] , substitute the result for args .
if length of args is smaller than integer 2 ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ .
if _STR:0_ is contained in second element of args ,
split first element of args by _STR:0_ , convert separated elements to strings , substitute the first 2 elements of the result ,
for second and third element of args , respectively . if length of args equals integer 2 ,
substitute second element of args for name .
if parser doesnt have an _STR:0_ attribute ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with name . if name is not contained in parser._namedCycleNodes [ parser . _namedCycleNodes ] ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ , where ' % s ' is replaced with name .
get the index name , of the parser._namedCycleNodes [ parser . _namedCycleNodes ] , return the result .
as_form is boolean False .
if length of args is greater than 4 .
if third element from the end of the args equals string _STR:0_ ,
if last element of args is not equal to a string _STR:0_ ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with last element of args . as_form is boolean True
silent is boolean True .
substitute args , without the last element for args .
if second from the end element of args equals a string _STR:0_ ,
as_form is boolean True .
silent is boolean False .
if as_form is true ,
substitute the last element of args for name .
call the function parser.compile_filter [ parser . compile_filter ] with an argument arg for every arg in args from the index 1 to the index -2 ,
append the results into a list , substitute it for value . node is an instance CycleNode class , created with values , name and silent set to silent .
if parser doesnt have an _STR:0_ attribute ,
parser._namedCycleNodes [ parser . _namedCycleNodes ] is an empty dictionary .
substituet node for value under the name key of the parser._namedCycleNodes [ parser . _namedCycleNodes ] dictionary .
if not ,
call the function parser.compile_filter [ parser . compile_filter ] with an argument arg for every arg in args from first element to the end ,
append the results into a list , substitute it for value . node is an instance of CycleNode class , created wiht an argument values .
return node .
register.tag [ register . tag ] decorator ,
define the function csrf_token with 2 arguments : parser and token .
return an instance of CsrfTokenNode class .
register.tag [ register . tag ] decorator ,
define the function debug with 2 arguments : parser and token .
return an instance of DebugNode class .
register.tag [ register . tag ] decorator function with an argument _STR:0_ ,
define the function do_filter with 2 arguments : parser and token .
split into two parts token.contents [ token . contents ] by None , substitute the parts for _ and rest , respectively .
call the method parser.compile_filter [ parser . compile_filter ] with an argument string _STR:0_ , where ' % s ' is replaced with rest , substitute the result for filter_expr .
for every func and unused in filter_expr.filters [ filter_expr . filters ] ,
get _STR:0_ attribute of the func object , if it exists , substitute it for filter_name , if not , filter_name is None .
if every filter_name in strings _STR:0_ or _STR:1_ ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with filter_name . call the method parser.parse [ parser . parse ] with an argument tuple with an element string _STR:0_ , substitute the result for nodelist .
call the method parser.delete_first_token [ parser . delete_first_token ] .
return a class instance FilterNode , called with an arguments filter_expr and nodelist .
register.tag [ register . tag ] decorator ,
define the function firstof with 2 arguments : parser and token .
call the method token.split_contents [ token . split_contents ] , substitute the result without the first element for bits .
if length of bits is smaller than integer 1 ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ .
return an instance of FirstOfNode class , created with an argument , result of the method parser.compile_filter [ parser . compile_filter ] called with bit ,
for every bit in bits . register.tag [ register . tag ] decorator function with an argument _STR:0_ ,
define the function do_for with 2 arguments : parser and token .
call the method token.split_contents [ token . split_contents ] , substitute the result .
if length bits is smaller than intger 4 ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with token.contents [ token . contents ] . assign the string _STR:0_ to is_reversed and bits last elements .
if index is negative inter 3 , if is_reversed , substitute it for in_index , if not , in_index is negative integer 2 .
if in_index-th element of bits equals to string _STR:0_ ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with token.contents [ token . contents ] . call the method re.split [ re . split ] with 2 arguments : raw string _STR:0_ and elements of bits from 1 index to in_index index ,
joined into a string , separated by whitespaces , substitute the result for loopvars . for every var in loopvars ,
if var is false or whitespaces are contained in var ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with token.contents [ token . contents ] . call the method parser.compile_filter [ parser . compile_filter ] with an argument , in_index incremented by one , and used to index parser.compile_filter [ parser . compile_filter ] ,
substitute the result for sequence . call the method parser.parse [ parser . parse ] with an argument tuple with 2 elements strings _STR:0_ and _STR:1_ , substitute the result for nodelist_loop .
call the method parser.next_token [ parser . next_token ] , substitute the result for token .
if token.contents [ token . contents ] equals string _STR:0_ ,
call the method parser.parse [ parser . parse ] with an argument tuple with an element string _STR:0_ , substitute the result for nodelist_empty .
call the method parser.delete_first_token [ parser . delete_first_token ] .
if not ,
nodelist_empty is None .
return an instance of ForNode class , created with 5 arguments : loopvars , sequence , is_reversed , nodelist_loop and nodelist_empty .
define the function do_ifequal with 2 arguments : parser , token and negate .
call the method token.split_contents [ token . split_contents ] , convert the result into a list and substitute it for bits .
if length of bits is not equal to integer 3 ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where _STR:0_ is replaced with first element of bits . append first element of bits to _STR:1_ . substitute the result for end_tag .
call the method parser.parse [ parser . parse ] with an argument tuple with an element string _STR:0_ and end_tag , substitute the result for nodelist_true .
call the method parser.next_token [ parser . next_token ] , substitute the result for token .
if token.contents [ token . contents ] equals a string _STR:0_ ,
call the method parser.parse [ parser . parse ] with an argument tuple with an element end_tag , substitute the result for nodelist_false .
call the method parser.delete_first_token [ parser . delete_first_token ] .
if not ,
nodelist_false is an instance of NodeList class .
call the method parser.compile_filter [ parser . compile_filter ] with an argument , second element of bits , substitute the result for val1 .
call the method parser.compile_filter [ parser . compile_filter ] with an argument , third element of bits , substitute the result for val2 .
return an instance of IfEqualNode class , created with 5 arguments : val1 , val2 , nodelist_true , nodelist_false and negate .
register.tag [ register . tag ] decorator ,
define the function ifequal with 2 arguments : parser and token .
call the function do_ifequal with 3 arguments : parser , token and boolean False , return the result .
register.tag [ register . tag ] decorator ,
define the function ifnotequal with 2 arguments : parser and token .
call the function do_ifequal with 3 arguments : parser , token and boolean False , return the result .
derive the class TemplateLiteral from Literal base class .
define the method __init__ with 3 arguments : self , value and text .
substitute value for self.value [ self . value ] .
substitute text for self.text [ self . text ] .
define the method display with an argument self .
return self.text [ self . text ] .
define the method eval with 2 arguments : self and context .
call the method self.value.resolve [ self . value . resolve ] with 2 arguments context and ignore_failures set to boolean True , return the result .
derive the class TemplateIfParser from IfParser base class .
substitute TemplateSyntaxError for error_class .
define the method __init__ with 4 arguments : self , parser , unpacked list args and unpacked dictionary kwargs .
substitute parser for self.template_parser [ self . template_parser ] .
call the method __init__ from the base class of the class TemplateIfParser , with 2 arguments : unpacked list args and unpacked dictionary .
define the method create_var with 2 arguments : self and value .
return an instance of TemplateLiteral with 2 arguments : result of the function self.template_parser.compile_filter [ self . template_parser . compile_filter ] ,
called with an argument value and value . register.tag [ register . tag ] decorator function with an argument _STR:0_ ,
define the function do_if with 2 arguments : parser and token .
call the method token.split_contents [ token . split_contents ] , substitute results without the first element for bits .
call the method parse from the instance of TemplateIfParser class , created with 2 arguments parser and bits , substitute the result for condition .
call the method parser.parse [ parser . parse ] with an argument tuple with 3 elements : strings _STR:0_ , _STR:1_ and _STR:2_ , substitute the result for nodelist .
conditions_nodelists is a list containing tuple with 2 elements condition and nodelist .
call the method parser.next_token [ parser . next_token ] , substitute the result for token .
while token.contents [ token . contents ] starts with a string _STR:0_ ,
call the method token.split_contents [ token . split_contents ] , substitute results without the first element for bits .
call the method parse from the instance of TemplateIfParser class , created with 2 arguments parser and bits , substitute the result for condition .
call the method parser.parse [ parser . parse ] with an argument tuple with 3 elements strings _STR:0_ , _STR:1_ and _STR:2_ , substitute the result for nodelist .
append a tuple with 2 elements : condition and nodelist to conditions_nodelists .
call the method parser.next_token [ parser . next_token ] , substitute the result for token .
if token.contents [ token . contents ] equals string _STR:0_ ,
call the method parser.parse [ parser . parse ] with an argument tuple with an element string _STR:0_ , substitute the result for nodelist .
append a tuple with 2 elements : None and nodelist to conditions_nodelists .
call the method parser.next_token [ parser . next_token ] , substitute the result for token .
if token.contents [ token . contents ] doesn not equals a string _STR:0_ , raise an AssertionError exception ,
return an instance of IfNode class , created with an argument conditions_nodelists .
register.tag [ register . tag ] decorator ,
define the function ifchanged with 2 arguments : parser and token .
call the method token.split_contents [ token . split_contents ] , substitute the result for bits .
call the method parser.parse [ parser . parse ] with an argument tuple with 2 elements strings : _STR:0_ and _STR:1_ , substitute the result for nodelistelse .
call the method parser.next_token [ parser . next_token ] , substitute the result for token .
if token.contents [ token . contents ] equals string _STR:0_ ,
call the method parser.parse [ parser . parse ] with an argument tuple with an element string _STR:0_ , substitute the result for nodelist_false .
call the method parser.delete_first_token [ parser . delete_first_token ] .
if not ,
nodelist_false is an instance of NodeList .
for every bit in elements of bits without the first element , call the method parser.compile_filter [ parser . compile_filter ] , with an argument bit ,
substitute the list of results for values . return an instance of a class IfChangedNode , created with 3 arguments : nodelist_true , nodelist_false and unpacked list values .
register.tag [ register . tag ] decorator ,
define the function ssi with 2 arguments : parser and token .
call the method token.split_contents [ token . split_contents ] , substitute the result for bits .
parsed is boolean False .
if length of bits is not integer 2 or 3 ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ .
if length of bits equals integer 3 ,
if third element of bits equals a string _STR:0_ ,
parsed is boolean True .
if not ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with first element of bits . call the method parser.compile_filter [ parser . compile_filter ] with second element of bits as an argument , substitute the result for filepath .
return an instance of a SsiNode class , created with 2 arguments : filepath and parsed .
register.tag [ register . tag ] decorator ,
define the function load with 2 arguments : parser and token .
call the method token.split_contents [ token . split_contents ] , substitute the result for bits .
if length of bits is greater or equal to integer 4 and second last element of bits equals sting _STR:0_ ,
try ,
substitute last element of bits for taglib .
call the function get_library with an argument taglib , substitute the result for lib .
if InvalidTemplateLibrary , renamed to e , exception is caught ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with taglib and e. if not ,
temp_lib is an instance of Library class .
for every name in bits from the start index 1 to the end index negative 2 ,
if name is contained in lib.tags [ lib . tags ] ,
substitute value under the name key of the lib.tags [ lib . tags ] dictionary for value under the name key of the temp_lib.tags [ temp_lib . tags ] dictionary .
if name is contained in lib.filters [ lib . filters ] .
substitute value under the name key of the lib.filters [ lib . filters ] dictionary for value under the name key of the temp_lib.filters [ temp_lib . filters ] dictionary .
otherwise if name is contained in lib.filters [ lib . filters ] ,
substitute value under the name key of the lib.filters [ lib . filters ] dictionary for value under the name key of the temp_lib.filters [ temp_lib . filters ] dictionary .
if not ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with name and taglib . call the method parser.add_library [ parser . add_library ] with an argument temp_lib .
if not ,
for every taglib in bits without the first element ,
try ,
call the function get_library with an argument taglib , substitute the result for lib .
call the method parser.add_library [ parser . add_library ] with an argument lib .
if InvalidTemplateLibrary , renamed to e , exception is caught ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with taglib and e. return an instance of a LoadNode class .
register.tag [ register . tag ] decorator ,
define the function now with 2 arguments : parser and token .
call the method token.split_contents [ token . split_contents ] , substitute the result for bits .
if length of bits is not equal to integer 2 ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ .
substitute second element of bits without the first and last element for format_string .
return an instance of a NowNode class , created with an argument format_string .
register.tag [ register . tag ] decorator ,
define the function regroup with 2 arguments : parser and token .
call the method token.split_contents [ token . split_contents ] , substitute the result for bits .
if length of bits is not equal to integer 6 ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ .
call the method parser.compile_filter [ parser . compile_filter ] with an argument first element of bits , substitute the result for target .
if third element of bits is not equal to a string _STR:0_ ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ .
if fift element of bits is not equal to a string _STR:0_ ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ .
substitute sixth element of bits for var_name .
concatenate var_name , VARIABLE_ATTRIBUTE_SEPARATOR and fourth element of bits , use the result as an argument for the call the method ,
parser.compile_filter [ parser . compile_filter ] , substitute the result for expression . return an instance of a RegroupNode class , created with 3 arguments target , expression and var_name .
register.tag [ register . tag ] decorator ,
define the function spaceless with 2 arguments : parser and token .
call the method parser.parse [ parser . parse ] with an argument tuple with an element string _STR:0_ , substitute the result for nodelist .
call the method parser.delete_first_token [ parser . delete_first_token ] .
return an instance of a SpacelessNode class , created with an argument nodelist .
register.tag [ register . tag ] decorator ,
define the function templatetag with 2 arguments : parser and token .
call the method token.split_contents [ token . split_contents ] , substitute the result for bits .
if length of bits is not equal to integer 2 ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ .
substitute second element of bits for tag .
if tag is not contained in TemplateTagNode.mapping [ TemplateTagNode . mapping ] ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with tag and TemplateTagNode.mapping [ TemplateTagNode . mapping ] converted into a list . return an instance of a TemplateTagNode class , created with an argument tag .
register.tag [ register . tag ] decorator ,
define the function url with 2 arguments : parser and token .
call the method token.split_contents [ token . split_contents ] , substitute the result for bits .
if length of bits is lesser than integer 2 ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with first element of bits . call the method parser.compile_filter [ parser . compile_filter ] with second element of bits as an argument , substitute the result for viewname .
args is an empty list .
kwargs is an empty dictionary .
asvar is None .
remove first two elements from bits .
if length of bits is greater or equal to intger 2 and second last element of bits is equal to string _STR:0_ ,
substitute last element of bits for asvar .
remove last 2 elements from bits .
if length of bits is not zero ,
for every bit in bits ,
call the method kwarg_re.match [ kwarg_re . match ] with an argument bit , substitute it for match .
if match is true ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ .
call the method match.groups [ match . groups ] , assign the result to name and value , respectively .
if name is true ,
call the method parser.compile_filter [ parser . compile_filter ] with an argument value , substitute the result for value under the name key of kwargs dictionary .
if not ,
call the method parser.compile_filter [ parser . compile_filter ] with an argument value , append the result to args .
return an instance of a URLNode class , created with 4 arguments viewname , args , kwargs and asvar .
register.tag [ register . tag ] decorator ,
define the function verbatim with 2 arguments : parser and token .
call the method parser.parse [ parser . parse ] with an argument tuple with an element string _STR:0_ , substitute the result for nodelist .
call the method parser.delete_first_token [ parser . delete_first_token ] .
call the method nodelist.render [ nodelist . render ] with an argument , an instance of Context class , use the result as an argument for the creation of ,
an instance of VerbatimNode class , return it . register.tag [ register . tag ] decorator ,
define the function widthratio with 2 arguments : parser and token .
call the method token.split_contents [ token . split_contents ] , substitute the result for bits .
if length of bits equals integer 4 ,
assign the bits elements to tag , this_value_expr , max_value_expr and max_width , respectively .
asvar is None .
otherwise if length of bits equals integer 6 ,
assign the bits elements to tag , this_value_expr , max_value_expr , max_width , as_ and asvar .
if as_ is not equal to string _STR:0_ ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ .
if not ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ .
return an instance of a class WidthRatioNode , created with 4 arguments : result of the method parser.compile_filter [ parser . compile_filter ] ,
called with an argument this_value_expr , result of the method parser.compile_filter [ parser . compile_filter ] called with an argument max_value_expr , return value of the method parser.compile_filter [ parser . compile_filter ] called with an argument max_width and asvar as asvar . register.tag [ register . tag ] decorator function with an argument _STR:0_ ,
define the function do_with with 2 arguments : parser and token .
call the method token.split_contents [ token . split_contents ] , substitute the result for bits .
substitute bits without the first element for remaining_bits .
call the function token_kwargs with 3 arguments : remaining_bits , parser and support_legacy set to boolean True , substitute the result for extra_context .
if extra_context is false ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where _STR:0_ is replaced with first element of bits . if remaining_bits is true ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ , where _STR:1_ is replaced with ,
first element of bits and first element of remaining_bits . call the method parser.parse [ parser . parse ] with an argument tuple , with an element string _STR:0_ , substitute the result for nodelist .
call the method parser.delete_first_token [ parser . delete_first_token ] .
return an instance of a class WithNode , created with 4 arguments : None , None , nodelist and extra_context as extra_context .
from django.core.exceptions [ django . core . exceptions ] import ImproperlyConfigured into default name space .
from django.template.base [ django . template . base ] import Origin , Template , Context and TemplateDoesNotExist into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.utils.module_loading [ django . utils . module_loading ] import import_string into default name space .
from django.utils [ django . utils ] import six into default name space .
template_source_loaders is None .
derive the class BaseLoader from the object base class .
is_usable is boolean False .
define the method __init__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
do nothing .
define the method __call__ with 3 arguments : self , template_name and template_dirs set to None .
call the method self.load_template [ self . load_template ] with 2 arguments : template_name and template_dirs , return the result .
define the method load_template with 3 arguments : self , template_name and template_dirs set to None .
call the method self.load_template_source [ self . load_template_source ] with arguments template_name and template_dirs , assign the result to source and display_name .
call the function make_origin with 4 arguments : display_name , self.load_template_source [ self . load_template_source ] , template_name and template_dirs ,
substitute the result for origin . try ,
call the function get_template_from_string with 3 arguments : source , origin and template_name , substitute the result for template .
return template and None .
if TemplateDoesNotExist exception is caught ,
return source and display_name .
define the method load_template_source with 3 arguments : self , template_name and template_dirs set to None .
raise an NotImplementedError with an argument string _STR:0_ .
define the method reset with an argument self .
do nothing .
derive the class LoaderOrigin from the Origin base class .
define the method __init__ with 5 arguments : self , display_name , loader , name and dirs .
call the method __init__ with an argument display_name , from the base class of the LoaderOrigin class .
substitute loader , name and dirs for self.loader [ self . loader ] , self.loadname [ self . loadname ] and self.dirs [ self . dirs ] , respectively .
define the method reload with an argument self .
call the method self.loader [ self . loader ] with 2 arguments : self.loadname [ self . loadname ] and self.dirs [ self . dirs ] , return the first element of the result .
define the function make_origin with 4 arguments : display_name , loader , name and dirs .
if settings.TEMPLATE_DEBUG [ settings . TEMPLATE_DEBUG ] and display_name are both true ,
return an instance of LoaderOrigin class , created with 4 arguments : display_name , loader , name and dirs .
if not ,
return None .
define the function find_template_loader with an argument loader .
if loader is an instance of tuple or list ,
substitute first element of loader for loader and loader without the first element for args .
if not ,
args is an empty list .
if loader is an instance of six.string_types [ six . string_types ] ,
call the function import_string with an argument loader , substitute the result for TemplateLoader .
if TemplateLoader has an attribute _STR:0_ ,
func is an instance of TemplateLoader class , created with unpacked list args .
if not ,
if args is true ,
raise an ImproperlyConfigured exception with an argument string `` Error importing template source loader % s - ca n't pass arguments to
function-based loader . `` , where ' % s ' is replaced with loader . substitute TemplateLoader for func .
func.is_usable [ func . is_usable ] in false ,
import module warnings .
call the function warnings.warn [ warnings . warn ] with an argument string `` Your TEMPLATE_LOADERS setting includes % r , but your Python installation
doesn_STR:0_ % r ' is replaced with loader . return None .
if not ,
return func .
if not ,
raise an ImproperlyConfigured with an argument string _STR:0_ .
define the function find_template with 2 : template_name and dirs set to None .
use global variable template_source_loaders .
if template_source_loaders is None ,
loaders is an empty list .
for every loader_name in settings.TEMPLATE_LOADERS [ settings . TEMPLATE_LOADERS ] ,
call the function find_template_loader with an argument loader_name , substitute the result for loader .
if loader is not None ,
append loader to loaders .
put loaders elements in a tuple , substitute it for template_source_loaders .
for every loader in template_source_loaders ,
try ,
call the function loader with 2 arguments name and dirs , substitute the result for source and display_name , respectively .
call the function make_origin with 4 arguments : display_name , loader , name and dirs , return a tuple containing 2 elements :
source and previous result . if TemplateDoesNotExist exception is caught ,
do nothing ,
raise an TemplateDoesNotExist exception with an argument name .
define the function get_template with 2 : template_name and dirs set to None .
call the function find_template with 2 arguments : template_name and dirs , substitute the result for template and origin .
if template has an attribute _STR:0_ ,
call the function get_template_from_string with 3 arguments : template , origin and template_name , substitute the result for template .
return template .
define the function get_template_from_string with 3 : source , origin set to None and name set to None .
return an instance of Template class , created with 2 arguments : source , origin and name , return the result .
define the function render_to_string with 4 arguments : template_name , dictionary set to None , context_instance set to None and dirs set to None .
if template_name is an instance of list or tuple types ,
call the function select_template with 2 arguments : template_name , dirs , substitute the result for t .
if not ,
call the function get_template with 2 arguments : template_name and dirs , substitute the result for t .
if context_instance is false ,
call the method t.render [ t . render ] with an argument , instance of Context class , created with an argument dictionary , return the result .
if dictionary is false ,
call the function t.render [ t . render ] with an argument context_instance , return the result .
call the method context_instance.push [ context_instance . push ] with an argument dictionary , with the result perform ,
call the function t.render [ t . render ] with an argument context_instance , return the result .
define the function select_template with 2 arguments : template_name_list and dirs set to None .
if template_name_list is false ,
raise an TemplateDoesNotExist exception with an argument string _STR:0_ .
not_found is an empty list .
for every template_name in template_name_list ,
try ,
call the function get_template with 2 arguments template_name and dirs , return the result .
if TemplateDoesNotExist , renamed to e , exception is caught ,
if first element of e.args [ e . args ] is not contained in not_found ,
append first element of e.args [ e . args ] to not_found list .
skip this loop iteration .
raise an TemplateDoesNotExist exception with an argument , elements of not_found joined into a string , separated with _STR:0_
from collections import defaultdict into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.template.base [ django . template . base ] import TemplateSyntaxError , Library , Node , TextNode , token_kwargs and Variable into default namespace .
from django.template.loader [ django . template . loader ] import get_template into default name space .
from django.utils.safestring [ django . utils . safestring ] import mark_safe into default name space .
from django.utils [ django . utils ] import six into default name space .
register is an instance of Library class .
BLOCK_CONTEXT_KEY is a strign _STR:0_ .
derive the class ExtendsError from the Exception base class .
do nothing .
derive the class BlockContext from the Exception base class .
define the method __init__ with an argument self .
convert elements of defaultdict to list , substitute it for self.blocks [ self . blocks ] .
define the method self and blocks .
call the function six.iteritems [ six . iteritems ] with an argument blocks , for every name and block in result ,
get the value under the name key of self.blocks [ self . blocks ] dictionary , insert to it block at the beginning .
define the method self and name .
try ,
remove the first element of value under the name key of self.blocks [ self . blocks ] dictionary , return it .
if IndexError exception is caught ,
return None .
define the method push with 3 arguments : self , name and block .
append block to the value under the name key of self.blocks [ self . blocks ] dictionary .
define the method get_block with 2 arguments self and name .
try ,
get value under the self.blocks [ self . blocks ] dictionary under the name key , return the last element .
if IndexError exception is caught ,
return None .
derive the class BlockNode from the Node base class .
define the method __init__ with 4 arguments : self , name , nodelist , parent set to None .
substitute name , nodelist and parent for self.name [ self . name ] , self.nodelist [ self . nodelist ] and self.parent [ self . parent ] .
define the method __repr__ with an argument self .
return string _STR:0_ , where ' % s ' is replaced with self.name [ self . name ] and _STR:1_ with self.nodelist [ self . nodelist ] .
define the method render with 2 arguments self and context .
get value under the BLOCK_CONTEXT_KEY key of context.render_context [ context . render_context ] dictionary , substitute it for block_context .
call the context.push [ context . push ] method , with the result , perform ,
if block_context is None ,
substitute self for value under the _STR:0_ key of context dictionary .
call the method self.nodelist.render [ self . nodelist . render ] with an argument context , substitute the result for result .
if not ,
call the method block_context.pop [ block_context . pop ] with an argument self.name [ self . name ] , assign the result to push and block .
if block is None ,
substitute self for block .
convert self to a tuple , call the result with 2 arguments : block.name [ block . name ] and block.nodelist [ block . nodelist ] , substitute the result for block .
substitute context for block.context [ block . context ] .
substitute block for value under the _STR:0_ key of context dictionary .
call the method block.nodelist.render [ block . nodelist . render ] with an argument context , substitute the result for result .
if push is not None ,
call the method block_context.push [ block_context . push ] with 2 arguments : self.name [ self . name ] and push .
return result .
define the method super with an argument self .
substitute self.context.render_context [ self . context . render_context ] for render_context .
if BLOCK_CONTEXT_KEY is contained in render_context and call to the method get_block with an argument self.name [ self . name ] from the object ,
under the BLOCK_CONTEXT_KEY key of render_context dictionary dictionary evaluates to be not equal to None , call the method self.render [ self . render ] with an argument self.context [ self . context ] , use it as an argument for the call to the mark_safe function , return the result .
return an empty string .
derive the class ExtendsNode from the Node base class .
must_be_first is boolean True .
define the method __init__ with 4 arguments : self , nodelist , parent_name and template_dirs set to None .
substitute nodelist for self.nodelist [ self . nodelist ] .
substitute parent_name for self.parent_name [ self . parent_name ] .
substitute template_dirs for self.template_dirs [ self . template_dirs ] .
self.blocks [ self . blocks ] is a dictionary with elements : n for n.name [ n . name ] , for every n in return value of the method nodelist.get_nodes_by_type [ nodelist . get_nodes_by_type ] ,
called with an argument BlockNode . define the method __repr__ with an argument self .
return an string _STR:0_ , where ' % s ' is replaced with self.parent_name.token [ self . parent_name . token ] .
define the method get_parent with 2 arguments self and context .
call the method self.parent_name.resolve [ self . parent_name . resolve ] with an argument context .
if parent is false ,
error_msg is a string _STR:0_ , where ' % s ' is replaced with parent .
if self.parent_name.filters [ self . parent_name . filters ] is true or self.parent_name.var [ self . parent_name . var ] is an instance of Variable .
append string _STR:0_ to error_msg , where ' % s is replaced with self.parent_name.token [ self . parent_name . token ] .
raise an TemplateSyntaxError exception with an argument error_msg .
if parent has an attribute _STR:0_ ,
return parent .
call the function get_template with an argument parent , return the result .
define the method render with 2 arguments self and context .
call the method self.get_parent [ self . get_parent ] with an argument context , substitute the result for compiled_parent .
if BLOCK_CONTEXT_KEY is not contained in context.render_context [ context . render_context ] ,
value under the BLOCK_CONTEXT_KEY key of context.render_context [ context . render_context ] dictionary is BlockContext class instance .
get the value under the BLOCK_CONTEXT_KEY key of the context.render_context [ context . render_context ] dictionary , substitute it for block_context .
call the method block_context.add_blocks [ block_context . add_blocks ] with an argument self.block [ self . block ] .
for every node in compiled_parent.nodelist [ compiled_parent . nodelist ] ,
if node is not an instance of TextNode ,
if node is not an instance of ExtendsNode ,
blocks is a dictionary with elements : n for n.name [ n . name ] , for every n in return value of the method ,
compiled_parent.nodelist.get_nodes_by_type [ compiled_parent . nodelist . get_nodes_by_type ] , called with an argument BlockNode . call the method block_context.add_blocks [ block_context . add_blocks ] with an argument blocks .
break from the loop execution .
call the method compiled_parent._render [ compiled_parent . _render ] with an argument context , return the result .
derive the class IncludeNode from the Node base class .
define the method __init__ with 4 arguments : self , template , unpacked list args and unpacked dictionary kwargs .
substitute template for self.template [ self . template ] .
remove kwargs dictionary entry under the _STR:0_ key , if it exists substitute it for self.extra_context [ self . extra_context ] ,
if not self.extra_context [ self . extra_context ] is an empty dictionary . remove kwargs dictionary entry under the _STR:0_ key , if it exists substitute it for self.isolated_context [ self . isolated_context ] ,
if not self.isolated_context [ self . isolated_context ] is boolean False . call the method __init__ from the base class of the class IncludeNode , called with 2 arguments : unpacked dictionary args ,
and unpacked dictionary kwargs . define the method render with 2 arguments self and context .
try ,
call the method self.template.resolve [ self . template . resolve ] with an argument context , substitute the result for template .
get _STR:0_ attribute of template object , if it is callable ,
call the method get_template with an argument template , substitute the result for template .
values is an dictionary with entries : return value of the method var.resolve [ var . resolve ] with an argument context for name ,
for every name and var in return value of the function six.iteritems [ six . iteritems ] called with an argument self.extra_context [ self . extra_context ] . if self.isolated_context [ self . isolated_context ] is true ,
call the method context.new [ context . new ] with an argument values , use it as an argument for the call to the method template.render [ template . render ] , return the result .
call the method context.push [ context . push ] with unpacked dictionary values as an argument , with the result perform ,
call the method template.render [ template . render ] with an argument context , return the result .
if Exception exception is caught ,
if settings.TEMPLATE_DEBUG [ settings . TEMPLATE_DEBUG ] is true ,
raise an exception ,
return an empty string .
decorator method register.tag [ register . tag ] with an argument _STR:0_ ,
define the function do_block with 2 arguments parser and token .
call the method token.contents.split [ token . contents . split ] , substitute the result for bits .
if length of bits is not equal to integer 2 ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with first element of bits . substitute second element for bits for block_name .
try ,
if block_name is contained in parser.__loaded_blocks [ parser . __loaded_blocks ] ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
substitute ' % s ' with first element of bits and block_name , respectively . append block_name to parser.__loaded_blocks [ parser . __loaded_blocks ] .
if AttributeError exception is caught ,
substitute list with an element block_name for parser.__loaded_blocks [ parser . __loaded_blocks ] .
call the method parser.parse [ parser . parse ] with an argument tuple with one element string _STR:0_ , substitute the result for nodelist .
call the method parser.next_token [ parser . next_token ] , substitute the result for endblock .
acceptable_endblocks is a tuple with 2 elements : string _STR:0_ and _STR:1_ , where ' % s ' replaced with block_name .
if endblock.contents [ endblock . contents ] is not contained in acceptable_endblocks ,
call the method parser.invalid_block_tag [ parser . invalid_block_tag ] with 3 arguments : endblock , _STR:0_ and acceptable_endblocks .
return an instance of a BlockNode class , created with 2 arguments : block_name and nodelist .
decorator method register.tag [ register . tag ] with an argument _STR:0_ ,
define the function do_extends with 2 arguments parser and token .
call the method token.split_contents [ token . split_contents ] , substitute the result for bits .
if length of bits is not equalt to integer 2 ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ , where ' % s ' is replaced with first element of bits .
call the method parser.compile_filter [ parser . compile_filter ] with an argument second element for bits , substitute the result for parent_name .
call the method parser.parse [ parser . parse ] , substitute the result for nodelist .
call the method nodelist.get_nodes_by_type [ nodelist . get_nodes_by_type ] with an argument ExtendsNode , if it evaluates to true ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with first element of bits . return an instance of ExtendsNode with 2 arguments nodelist and parent_name .
decorator method register.tag [ register . tag ] with an argument _STR:0_ ,
define the function do_include with 2 arguments parser and token .
call the method token.split_contents [ token . split_contents ] , substitute the result for bits .
if length of bits is lesser than integer 2 ,
raise an TemplateSyntaxError with an argument string _STR:0_ ,
where _STR:0_ is replaced with first element of bits . options is an empty dictionary .
substitute bits , without the first two elements , substitute the result for remaining_bits .
while remaining_bits is true ,
remove first element from remaining_bits , substitute the result for option .
if option is contained in options ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where _STR:0_ is replaced with options . if option equals a string _STR:1_ ,
call the function token_kwargs with 3 arguments : remaining_bits , parser , support_legacy set to boolean False , substitute the result for value .
if value is true ,
raise an TemplateSyntaxError exception with an argument string _STR:0_ ,
where ' % s ' is replaced with first element of bits . otherwise if options equals _STR:0_ ,
value is boolean True .
if not ,
raise an TemplateSyntaxError with an argument string _STR:0_ , where _STR:1_ is replaced with first element of bits and options .
substitute value for value under the options key of options dictionary .
get the value under the key _STR:0_ of the options dictionary , if it exists substitute the result for isolated_context ,
if not , isolated_context is boolean False . get the value under the _STR:0_ key of the options dictionary , if it exists , substitute it for namemap , if not namemap is an empty dictionary .
return an instance of IncludeNode class , created with 3 arguments : return value of the method parser.compile_filter [ parser . compile_filter ] ,
import module os .
import module sys .
from django.apps [ django . apps ] import apps into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.template.base [ django . template . base ] import TemplateDoesNotExist into default name space .
from django.template.loader [ django . template . loader ] import BaseLoader into default name space .
from django.utils._os [ django . utils . _os ] import safe_join into default name space .
from django.utils [ django . utils ] import six into default name space .
define the function calculate_app_template_dirs .
if six.PY2 [ six . PY2 ] is true ,
call the function sys.getfilesystemencoding [ sys . getfilesystemencoding ] , if it evaluates to true , substitute the result for fs_encoding ,
if not , call the function sys.getdefaultencoding [ sys . getdefaultencoding ] and substitute the result for fs_encoding . app_template_dirs is an empty list .
call the function apps.get_app_configs [ apps . get_app_configs ] , for every app_config in result ,
if app_config.path [ app_config . path ] is true ,
skip this loop iteration .
join app_config.path [ app_config . path ] and string _STR:0_ into file path , substitute it for template_dir .
if template_dir is directory ,
if six.PY2 [ six . PY2 ] is true ,
call the function template_dir.decode [ template_dir . decode ] with an argument fs_encoding , substitute the result for template_dir .
append template_dir to app_template_dirs .
convert app_template_dirs to a tuple , return it .
call the function calculate_app_template_dirs , substitute the result for app_template_dirs .
derive the class Loader from the BaseLoader base class .
is_usable is boolean True .
define the method get_template_sources with 3 arguments : self , template_name , template_dirs set to None .
if template_dirs is false ,
substitute app_template_dirs for template_dirs .
for every template_dir in template_dirs ,
try ,
call the function safe_join with 2 arguments template_dir and template_name , yield the result .
if UnicodeDecodeError exception is caught ,
raise an exception .
if ValueError exception is caught ,
do nothing .
define the method load_template_source with 3 arguments : self , template_name , template_dirs set to None .
call the method self.get_template_sources [ self . get_template_sources ] with 2 arguments template_name and template_dirs , for every filepath in the result ,
try ,
open the file named filepath in read mode , with file descriptor renamed to fp perform ,
read file fp , call the method decode on the result with an argument settings.FILE_CHARSET [ settings . FILE_CHARSET ] , return tuple containing 2 elements ,
previous result and filepath . if IOError exception is caught ,
do nothing .
raise an TemplateDoesNotExist exception with an argument template_name .
import module hashlib .
from django.template.base [ django . template . base ] import TemplateDoesNotExist into default name space .
from django.template.loader [ django . template . loader ] import BaseLoader , get_template_from_string , find_template_loader and make_origin into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_bytes into default name space .
derive the class Loader from the BaseLoader base class .
is_usable is boolean True .
define the method __init__ with 2 arguments : self and loaders .
self.template_cache [ self . template_cache ] is an empty dictionary .
self.find_template_cache [ self . find_template_cache ] is an empty dictionary .
substitute loaders for self._loaders [ self . _loaders ] .
self._cached_loaders [ self . _cached_loaders ] is an empty list .
property decorator .
define the method loaders with an argument self .
if self._cached_loaders [ self . _cached_loaders ] is false ,
cached_loaders is an empty list .
for every loader in self._loaders [ self . _loaders ] ,
call the function find_template_loader with an argument loader , append the result to cached_loaders .
substitute cached_loaders for self._cached_loaders [ self . _cached_loaders ] .
return self._cached_loaders [ self . _cached_loaders ] .
define the method cache_key with 3 arguments : self , template_name and template_dirs .
if template_dirs is true ,
join template_dirs elements into a string , separated by _STR:0_ , use it as an argument for the call to the function force_bytes ,
use the result as the argument for the call to the function hashlib.sha1 [ hashlib . sha1 ] , call the hexdigest method on the result , join template_name and previous final result into a string , separated with _STR:0_ , return it . if not ,
return template_name .
define the method find_template with 3 arguments : self , name , dirs set to None .
call the method self.cache_key [ self . cache_key ] with 2 arguments name and dirs , substitute the result for key .
try ,
get the value under the key key of the self.find_template_cache [ self . find_template_cache ] dictionary , substitute it for result .
if KeyError exception is caught ,
result is None .
for every loader in self.loaders [ self . loaders ] ,
try ,
call the function loader with arguments name and dirs , assign the result to template and display_name , respectively .
if TemplateDoesNotExist exception is caught ,
do nothing .
if not ,
result is an tuple with 2 elements : template and return value of the function make_origin called with 4 arguments : display_name , loader , name and dirs .
break from the loop execution .
substitute result for self.find_template_cache [ self . find_template_cache ] dictionary value under the key key .
if result is true ,
return result
if not ,
substitute TemplateDoesNotExist for self.find_template_cache [ self . find_template_cache ] dictionary value under the key key .
raise an TemplateDoesNotExist exception with an argument name .
define the method load_template with 3 arguments : self , template_name , template_dirs set to None .
get the value under the template_name key of the self.cache_key [ self . cache_key ] dictionary , if it exists , substitute it for key ,
if not , substitute template_dirs for key . get the value under the key key of the self.template_cache [ self . template_cache ] dictionary , substitute it for template_tuple .
if template_tuple is contained in TemplateDoesNotExist ,
raise an TemplateDoesNotExist exception .
otherwise if template_tuple is None ,
call the method self.find_template [ self . find_template ] with 2 argumetns : template_name and template_dirs , assign the result to template , origin , respectively .
if template doesnt have a _STR:0_ attribute ,
try ,
call the function get_template_from_string with 3 arguments : template , origin and template_name , substitute the result for template .
if TemplateDoesNotExist exception is caught ,
substitute a tuple with 2 elements : template and origin , for self.find_template_cache [ self . find_template_cache ] dictionary value under the key key .
substitute a tuple with 2 elements : template and None , for self.find_template_cache [ self . find_template_cache ] dictionary value under the key key .
return self.find_template_cache [ self . find_template_cache ] dictionary value under the key key .
define the method reset with an argument self .
call the method self.template_cache.clear [ self . template_cache . clear ] .
call the method self.find_template_cache.clear [ self . find_template_cache . clear ] .
from __future__ import unicode_literals into default name space .
try ,
from pkg_resources import resource_string into default name space .
if ImportError exception is caught ,
resource_string is None .
from django.apps [ django . apps ] import apps into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.template.base [ django . template . base ] import TemplateDoesNotExist into default name space .
from django.template.loader [ django . template . loader ] import BaseLoader into default name space .
from django.utils [ django . utils ] import six into default name space .
derive the class Loader from the BaseLoader base class .
if resource_string is not None , is_usable is boolean True , otherwise is_usable is boolean False .
define the method load_template_source with 3 arguments : self , template_name , template_dirs set to None .
if resource_string is not None ,
concatenate string _STR:0_ and template_name , substitute the result for pkg_name .
call the method apps.get_app_configs [ apps . get_app_configs ] , for app_config in the result ,
try ,
call the function resource_string with 2 arguments app_config.name [ app_config . name ] and pkg_name , substitute the result for resource .
if Exception exception is caught ,
skip this loop iteration .
if six.PY2 [ six . PY2 ] is true ,
call the method resource.decode [ resource . decode ] with an argument settings.FILE_CHARSET [ settings . FILE_CHARSET ] , substitute the result for resource .
return a tuple with 2 elements : resource and string _STR:0_ , where ' % s ' is replaced with app_config.name [ app_config . name ] and pkg_name , respective .
raise an TemplateDoesNotExist exception with an argument template_name .
from django.conf [ django . conf ] import settings into default name space .
from django.template.base [ django . template . base ] import TemplateDoesNotExist into default name space .
from django.template.loader [ django . template . loader ] import BaseLoader into default name space .
from django.utils._os [ django . utils . _os ] import safe_join into default name space .
derive the class Loader from the BaseLoader base class .
is_usable is boolean True .
define the method get_template_source with 3 arguments : self , template_name , template_dirs set to None .
if template_dirs is false ,
substitute settings.TEMPLATE_DIRS [ settings . TEMPLATE_DIRS ] for template_dirs .
for every template_dir in template_dirs ,
try ,
call the function safe_join with 2 arguments template_dir and template_name , yield the result .
if UnicodeDecodeError exception is caught ,
raise an exception .
if ValueError exception is caught ,
do nothing .
define the method load_template_source with 3 arguments : self , template_name , template_dirs set to None .
tried is an empty list .
call the method self.get_template_sources [ self . get_template_sources ] with 2 arguments template_name and template_dirs , for every filepath in the result ,
try ,
open the file named filepath in read mode , with file descriptor renamed to fp perform ,
read file fp , call the method decode on the result with an argument settings.FILE_CHARSET [ settings . FILE_CHARSET ] , return tuple containing 2 elements ,
previous result and filepath . if IOError exception is caught ,
append filepath to tried .
if tried is true ,
err_msg is a string _STR:0_ , where ' % s ' is replaced with tried .
if not ,
error_msg is a string _STR:0_ .
raise an TemplateDoesNotExist exception with an argument error_msg .
load_template_source.is_usable [ load_template_source . is_usable ] is boolean True .
from django.http [ django . http ] import HttpResponse into default name space .
from django.template [ django . template ] import loader , Context and RequestContext into default name space .
from django.utils [ django . utils ] import six into default name space .
derive the class ContentNotRenderedError from the Exception base class .
do nothing .
derive the class SimpleTemplateResponse from the HttpResponse base class .
rendering_attrs is a list containing 3 strings : _STR:0_ , _STR:1_ and _STR:2_ .
define the method __init__ with 5 arguments : self , template , context set to None , content_type set to None and status set to None .
substitute template for self.template_name [ self . template_name ] .
substitute context for self.context_data [ self . context_data ] .
self._post_render_callbacks [ self . _post_render_callbacks ] is an empty list .
call the __init__ method from the base class of the class SimpleTemplateResponse , with 3 arguments : an empty string , content_type and status .
self._is_rendered [ self . _is_rendered ] is boolean False .
define the method __getstate__ with an argument self .
call the __getstate__ method from the base class of the class SimpleTemplateResponse , substitute the result for obj_dict .
if self._is_rendered [ self . _is_rendered ] is false ,
raise an ContentNotRenderedError exception with an argument string _STR:0_ .
for every attr in self.rendering_attrs [ self . rendering_attrs ] ,
if attr is contained in obj_dict ,
delete entry under the attr key of obj_dict dictionary .
return obj_dict .
define the method resolve_template with 2 arguments : self and template .
if template is an instance of list or tuple types ,
call the method loader.select_template [ loader . select_template ] with an argument template , return the result .
otherwise is template is six.string_types [ six . string_types ] instance ,
call the method loader.get_template [ loader . get_template ] with an argument template , return the result .
if not ,
return template .
define the method resolve_context with 2 arguments : self and context .
if context is an instance of Context ,
return context .
if not ,
return an instance of Context class , created with an argument context .
property decorator ,
define the method rendered_content with an argument self .
call the method self.resolve_template [ self . resolve_template ] with an argument self.template_name [ self . template_name ] , substitute the result for template .
call the method self.resolve_context [ self . resolve_context ] with an argument self.context_data [ self . context_data ] , substitute the result for context .
call the method template.render [ template . render ] with an argument context , substitute the result for content .
return content .
define the method add_post_render_callback with 2 arguments : self and callback .
if self._is_rendered [ self . _is_rendered ] is true ,
call the functoin callback with an argument self .
if not ,
append callback to self._post_render_callbacks [ self . _post_render_callbacks ] list .
define the method render with an argument self .
substitute self for retval .
if self._is_rendered [ self . _is_rendered ] is false ,
substitute self.rendered_content [ self . rendered_content ] for self.content [ self . content ] .
for every post_callback in self._post_render_callbacks [ self . _post_render_callbacks ] ,
call the function post_callback with an argument retval , substitute the result for newretval .
if newretval is not None ,
substitute newretval for retval .
return retval .
property decorator ,
define the method is_rendered with an argument self .
return self._is_rendered [ self . _is_rendered ] .
define the method __iter__ with an argument self .
if self._is_rendered [ self . _is_rendered ] is false ,
raise an ContentNotRenderedError exception with an string _STR:0_ .
call the method __init__ from the base class of the class SimpleTemplateResponse , return the result .
property decorator ,
define the method content with an argument self .
if self._is_rendered [ self . _is_rendered ] is false .
raise an ContentNotRenderedError exception with an sring _STR:0_ .
return the content field of the base class of the class SimpleTemplateResponse .
content.setter [ content . setter ] decorator ,
define the method content with 2 arguments : self and value .
call the method HttpResponse.content.fset [ HttpResponse . content . fset ] with 2 arguments : self and value .
self._is_rendered [ self . _is_rendered ] is boolean True .
derive the class TemplateResponse from the SimpleTemplateResponse base class .
append list with 2 strings : _STR:0_ and _STR:1_ to SimpleTemplateResponse.rendering_attrs [ SimpleTemplateResponse . rendering_attrs ] , substitute the result for rendering_attrs .
define the method __init__ with 7 arguments : self , request , template , context set to None , content_type set to None ,
status set to None and current_app set to None . substitute request for self._request [ self . _request ] .
substitute current_app for self._current_app [ self . _current_app ] .
call the __init__ method from the base class of the class TemplateResponse , with 4 arguments : template , context , content_type , status .
define the method resolve_context with 2 arguments : self and context .
if context is an instance of Context class .
return context .
return an instance of RequestContext class , created with 3 arguments : self._request [ self . _request ] , context and current_app set to self._current_app [ self . _current_app ] .
derive the class TokenBase from the object base class .
id is None .
value is None .
first and second are None .
define the method nud with 2 arguments : self and parser .
raise an exception parser.error_class [ parser . error_class ] with an argument string _STR:0_ ,
where ' % s ' is replaced with self.id [ self . id ] . define the method led with 3 arguments : self , left and parser .
raise an exception parser.error_class [ parser . error_class ] with an argument string _STR:0_ ,
where ' % s ' is replaced with self.id [ self . id ] . define the method display with an argument self .
return self.id [ self . id ] .
define the method __repr__ with an argument self .
for x in a list containing 3 elements : self.id [ self . id ] , self.first [ self . first ] and self.second [ self . second ] , if x is not None ,
convert x into a string and append it to a list , substitute the resulting list for out . join elements of out into a string , separated with whitespaces , append _STR:0_ to it , append the result to _STR:1_ , return it .
define the function infix with 2 arguments bp and func .
derive the class Operator from the base class TokenBase .
substitute bp for lbp .
define the method led with 3 arguments self , left and parser .
substitute left for self.first [ self . first ] .
call the method parser.expression [ parser . expression ] with an argument bp , substitute it for self.seconds [ self . seconds ] .
return self .
define the method eval with 2 arguments self and context .
try ,
call the function func with 3 arguments : context , self.first [ self . first ] and self.second [ self . second ] , return the result .
if Exception exception is caught ,
return boolean False .
return Operator .
define the function prefix with 2 arguments bp and func .
derive the class Operator from the base class TokenBase .
substitute bp for lbp .
define the method nud with 2 arguments self and parser .
call the method parser.expression [ parser . expression ] with an argument bp , substitute the result for self.first [ self . first ] .
self.second [ self . second ] is None .
return self .
define the method evalu with 2 arguments self and context .
try ,
call the function func with 2 arguments : context and self.first [ self . first ] , return the result .
if Exception exception is caught ,
return boolean False .
return Operator .
OPERATORS is an dictionary with 12 initial entries : result of the function inflix called with 2 arguments , integer 6 ,
and lambda function with 3 arguments context , x and y , returns boolean True if x.eval [ x . eval ] ( context ) or y.eval [ y . eval ] ( context ) is True , for _STR:0_ , result of the function inflix called with 2 arguments , integer 7 , and lambda function with 3 arguments context , x and y , returns boolean True if x.eval [ x . eval ] ( context ) and y.eval [ y . eval ] ( context ) is True for _STR:1_ , result of the function prefix called with 2 arguments , integer 8 , and lambda function with 2 arguments context and x , returns boolean True if x.eval [ x . eval ] ( context ) is True for _STR:2_ , result of the function inflix called with 2 arguments , integer 9 , and lambda function with 2 arguments context and x , returns boolean True if x.eval [ x . eval ] ( context ) is contained in y.eval [ y . eval ] ( context ) for _STR:3_ , result of the function inflix called with 2 arguments , integer 9 , and lambda function with 2 arguments context and x , returns boolean True if x.eval [ x . eval ] ( context ) is not contained in y.eval [ y . eval ] ( context ) , for _STR:4_ , result of the function inflix called with 2 arguments , integer 10 , and lambda function with 3 arguments context , x and y , returns boolean True if x.eval [ x . eval ] ( context ) equals y.eval [ y . eval ] ( context ) for _STR:5_ , result of the function inflix called with 2 arguments , integer 10 , and lambda function with 3 arguments context , x and y , returns boolean True if x.eval [ x . eval ] ( context ) equals y.eval [ y . eval ] ( context ) for _STR:6_ , result of the function inflix called with 2 arguments , integer 10 , and lambda function with 3 arguments context , x and y , returns boolean True if x.eval [ x . eval ] ( context ) doesnt equals y.eval [ y . eval ] ( context ) for _STR:7_ , result of the function inflix called with 2 arguments , integer 10 and , lambda function with 3 arguments context , x and y , returns boolean True if x.eval [ x . eval ] ( context ) is greater than y.eval [ y . eval ] ( context ) for _STR:8_ , result of the function inflix called with 2 arguments , integer 10 and and lambda function with 3 arguments context , x and y , returns boolean True if x.eval [ x . eval ] ( context ) is greater than or equal to y.eval [ y . eval ] ( context ) for _STR:9_ , result of the function inflix called with 2 arguments , integer 10 and and lambda function with 3 arguments context , x and y , returns boolean True if x.eval [ x . eval ] ( context ) is smaller than y.eval [ y . eval ] ( context ) for _STR:10_ , result of the function inflix called with 2 arguments , integer 10 and and lambda function with 3 arguments context , x and y , returns boolean True if x.eval [ x . eval ] ( context ) is smaller than or equal to y.eval [ y . eval ] ( context ) for _STR:11_ , call the function OPERATORS.items [ OPERATORS . items ] , for every key and op in result ,
substitute key for op.id [ op . id ] .
derive the class Literal from the TokenBase base class .
id is a string _STR:0_ .
lbp is integer 0 .
define the method __init__ with 2 arguments : self and value .
substitute value for self.value [ self . value ] .
define the method display with an argument self .
return printable representation of self.value [ self . value ] .
define the method nud with 2 arguments : self and parser .
return self .
define the method eval with 2 arguments : self and context .
return self.value [ self . value ] .
define the method __repr__ with an argument self .
return string _STR:0_ , replace ' % s ' with self.if [ self . if ] and _STR:1_ with self.value [ self . value ] .
derive the class EndToken from the TokenBase base class .
lbp is an integer 0 .
define the method nud with 2 arguments : self and parser .
raise an exception parser.error_class [ parser . error_class ] with an argument string _STR:0_ .
EndToken is an instance of EndToken class .
derive the class IfParser from the object base class .
substitute ValueError for error_class .
define the method __init__ with 2 arguments : self and tokens .
substitute length of tokens for l .
mapped_tokens is an empty list .
i is integer 0 .
while i is smaller than l ,
substitute i-th element of tokens for token .
if token equals a string _STR:0_ and i incremented by 1 is lesser than l ,
and element of tokens at i incremented by 1 index equals a string _STR:0_ , token is a string _STR:1_ .
increment i by integer 1 .
call the method self.translate_token [ self . translate_token ] with an argument token , append the result to mapped_tokens .
increment i by integer 1 .
substitute mapped_tokens for self.tokens [ self . tokens ] .
self.pos [ self . pos ] is integer 0 .
call the method self.next_token [ self . next_token ] , substitute the result for self.current_token [ self . current_token ] .
define the method translate_token with 2 arguments : self and token .
try ,
substitute OPERATORS dictionary element under token key for op .
if KeyError and TypeError exceptions are caught ,
call the function self.create_var [ self . create_var ] with an argument token , return the result .
if not ,
call the function op , return the result .
define the method next_token with an argument self .
if self.pos [ self . pos ] is greater than or equal to self.tokens [ self . tokens ] ,
return EndToken .
if not ,
substitute element at self.pos [ self . pos ] index of self.tokens [ self . tokens ] for retval .
increment self.pos [ self . pos ] by integer 1 .
return retval .
define the method parse with an argument self .
call the method self.expression [ self . expression ] , substitute the result for retval .
if self.current_token [ self . current_token ] is not EndToken ,
raise an exception self.error_class [ self . error_class ] with an argument string _STR:0_Unused ' % s ' at end of if expression '' ,
where ' % s ' is replaced with result of the method self.current_token.display [ self . current_token . display ] . return retval .
define the method expression with 2 arguments : self and rbp set to integer 0 .
substitute self.current_token [ self . current_token ] for t .
call the method self.next_token [ self . next_token ] , substitute the result for self.current_token [ self . current_token ] .
call the method t.nud [ t . nud ] with an argument self , substitute the result for left .
while rbp is smaller than self.current_token.lbp [ self . current_token . lbp ] ,
substitute self.current_token [ self . current_token ] for t .
call the method self.next_token [ self . next_token ] , substitute the result for self.current_token [ self . current_token ] .
call the method t.led [ t . led ] with 2 arguments left and self .
return left .
define the method create_var with 2 arguments : self and value .
return an instance of Literal class , created with an argumen value .
from __future__ import unicode_literals into default name space .
from lib2to3 import fixer_base into default name space .
from lib2to3.fixer_util [ lib2to3 . fixer_util ] import find_indentation , Name , syms and touch_import into default name space .
from lib2to3.pgen2 [ lib2to3 . pgen2 ] import token into default name space .
from lib2to3.pytree [ lib2to3 . pytree ] import Leaf and Node into default name space .
derive the class FixUnicode from the base class fixer_base.BaseFix [ fixer_base . BaseFix ] .
BM_compatible is boolean True .
PATTERN is a string _STR:0_ .
define the method transform with 3 arguments : self , node and results .
substitute value under the _STR:0_ key of the results dictionary for unifunc .
strfunc is an instance of a class Name , created with 2 arguments : string _STR:0_ and prefix as unifunc.prefix [ unifunc . prefix ] .
call the method unifunc.replace [ unifunc . replace ] with an argument strfunc .
call the method node.clone [ node . clone ] , substitute the result for klass .
call the method find_indentation with an argument node , append the result to newline , substitute the result for klass.prefix [ klass . prefix ] .
decorator is an instance of class Node , created with 2 arguments : instance of Leaf class created with 2 arguments : token.AT [ token . AT ] and `` @ ' ,
and instance of Name class created with an argument string _STR:0_ . decorated is an instance of class Node , created with 3 arguments : syms.decorated [ syms . decorated ] , list with 2 arguments : decorator and klass ,
and prefix as node.prefix [ node . prefix ] . call the method node.replace [ node . replace ] with an argument decorated .
call the function touch_import with 3 arguments : string _STR:0_ , string _STR:1_ and decorated .
import module os .
import module sta .
import module sys .
import module tempfile .
from os.path [ os . path ] import join , normcase , normpath , abspath , isabs , sep and dirname into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_text into default name space .
from django.utils [ django . utils ] import six into default name space .
try ,
substitute WindowsError for WindowsError .
if NameError exception is caught ,
derive class WindowsError from Exception base class .
do nothing .
if six.PY2 [ six . PY2 ] is true ,
call the function sys.getfilesystemencoding [ sys . getfilesystemencoding ] if it evaluates to true , substitute its result for fs_encoding ,
otherwise call the function sys.getdefaultencoding [ sys . getdefaultencoding ] and substitute its result for fs_encoding . if six.PY3 [ six . PY3 ] is true or os.name [ os . name ] equals a string _STR:0_ ,
substitute abspath for abspathu .
if not ,
define the function abspathu with an argument path .
call the function isabs with an argument path , if it evaluates to false ,
get the unicode representation of current working directory , join it and path into a string , substitute the result for path .
call the function normpath with an argument path , return the result .
define the function upath with an argument path .
if six.PY2 [ six . PY2 ] is true and path is not an instance of six.text_type [ six . text_type ] type ,
call the method path.decode [ path . decode ] with an argument fs_encoding , return the result .
return path .
define the function npath with an argument path .
if six.PY2 [ six . PY2 ] is true and path is not an instance of byes type ,
call the method path.encode [ path . encode ] with an argument fs_encoding , return the result .
return path .
define the function safe_join with 2 arguments base and unpacked dictionary paths .
call the function force_text with an argument base , substitute the result for base .
paths is a list containing results of the function force_text called with an argument p , for every p in paths .
join base an unpacked list paths into a string , get the absolute path in unicode representation of the result , substitute the result for final_path .
get the unicode representation of the absolute path of base , substitute it for base_path .
if return value of the function normcase called with an argument final_path doesnt starts with result of the function normcase ,
called with sep appended to base_path as an argument and results of the function normcase called twice with final_path , and base_pah are not equal and directory name of the result of the function normcase called with an argument base_path , if not equal to the result of the function normcase called with an argument base_path . raise an ValueError with an argument string _STR:0_ ,
where ' % s ' is replaced with final_path and base_path . return final_path .
define the function rmtree_errorhandler with 3 arguments func , path and exc_info .
substitute fist and second element of exc_info for exctype and value , respectively .
if exctype is not WindowsError or string _STR:0_ is not contained in value converted into a string ,
raise an exception .
call the function os.stat [ os . stat ] with an argument path , perform bitwise and on 2 operands st_mode field of the result and stat.S_IREAD [ stat . S_IREAD ] ,
if it is not equal to stat.S_IREAD [ stat . S_IREAD ] , raise an exception .
change access mode of path to stat.S_IWRITE [ stat . S_IWRITE ] mode .
call the function func with an argument path .
define the method symlinks_supported .
call the function tempfile.mkdtemp [ tempfile . mkdtemp ] , substitute the result for tmpdir .
join tmpdir and sting _STR:0_ into a file path name , substitute it for original_path .
join tmpdir and sting _STR:0_ into a file path name , substitute it for symlink_path .
make a directory named original_path .
try ,
make a system symbolic link between original_path and symlink_path .
supported is boolean True .
if OSError , NotImplementedError or AttributeError exceptions are caught ,
supported is boolean False .
if not ,
remove symlink_path file .
finally perform ,
remove original_path directory .
remove tmpdir directory .
return supported .
import module os .
import module shutil .
import module tarfile .
import module zipfile .
from django.utils [ django . utils ] import six into default name space .
derive the class ArchiveException from the Exception base class .
derive the class UnrecognizedArchiveFormat from the ArchiveException base class .
define the function extract with 2 arguments path and to_path set to empty string .
instantiate Archive class with an argument path , with it renamed to archive , perform ,
call the method archive.extract [ archive . extract ] with an argument to_path .
derive the class Archive from the object base class .
define the method __init__ with 2 arguments self and file .
call the method self._archive_cls [ self . _archive_cls ] with an argument file , call the result with an argument file , substitute the result for self._archive [ self . _archive ] .
static method ,
define the method _archive_cls with an argument file .
cls is None .
if file is an instance of six.string_types [ six . string_types ] .
substitute file for filename .
if not ,
try ,
substitute file.name [ file . name ] for filename .
if AttributeError exception is caught .
raise an UnrecognizedArchiveFormat exception with an argument string _STR:0_ .
convert filename to lowercase , use the result as an argument for the call to the function os.path.splitext [ os . path . splitext ] ,
substitute the result for base and tail_ext . get the value under the tail_ext key of the extension_map dictionary , substitute it for cls .
if cls is false ,
call the method os.path.splitext [ os . path . splitext ] with an argument base , substitute the result for base and ext , respectively .
get the value under the ext key of the extension_map dictionary , substitute it for cls .
if cls is false ,
raise an UnrecognizedArchiveFormat exception with an argument string _STR:0_ ,
where ' % s ' is replaced with filename . return cls .
define the method __enter__ with an argument self .
return self .
define the method __exit__ with 4 arguments : self , exc_type , exc_value and traceback .
call the method self.close [ self . close ] .
define the method extract with 2 arguments : self and to_path set to an empty string .
call the method self._archive.extract [ self . _archive . extract ] with an argument to_path .
define the method list with an argument self .
call the method self._archive.list [ self . _archive . list ] .
define the method close with an argument self .
call the method self._archive.close [ self . _archive . close ] .
derive the class BaseArchive from the object base class .
define the method split_leading_dir with 2 arguments self and path .
convert path to a string , substitute the result for path .
strip path of all leading _STR:0_ and '\\ ' characters , substitute the result for path .
if _STR:0_ is contained in path , and only if '\\ ' is contained in path and index of the first occurrence of _STR:0_ in path is lesser than ,
index of the first occurrence of _STR:0_\\_STR:1_/ ' character , return the result .
otherwise if '\\ ' is contained in path ,
split path in two parts by '\\ ' string , return the result .
if not ,
return path an an empty string .
define the method has_leading_dir with 2 arguments self and paths .
common_prefix is None .
for every path in paths ,
call the method self.split_leading_dir [ self . split_leading_dir ] with an argument path , assign the result to prefix and rest , respectively .
if prefix is false ,
return boolean False .
otherwise if common_prefix is None ,
substitute prefix for common_prefix .
otherwise if prefix is not equal to common_prefix ,
return boolean False .
return boolean True .
define the method list with an argument self .
raise an NotImplementedError exception with an argument string _STR:0_ .
define the method list with an argument self .
raise an NotImplementedError exception with an argument string _STR:0_ .
derive the class TarArchive from the BaseArchive base class .
define the method __init__ with 2 arguments self and file .
call the method tarfile.open [ tarfile . open ] with an argument file , substitute the result for self._archive [ self . _archive ] .
define the method __init__ with 3 arguments self and unpacked list args and unpacked dictionary kwargs .
define the method list with 3 arguments : self and unpacked list args and unpacked dictionary kwargs .
define the method extract with 2 arguments self and to_path .
members is a list with elements member for every member in the result of the function self._archive.getmembers [ self . _archive . getmembers ] ,
only if member.name [ member . name ] is not equal to string _STR:0_ . call the method self.has_leading_dir [ self . has_leading_dir ] with an argument list , with elements x.name [ x . name ] for every x in members , substitute the result for leading .
for every member in members ,
substitute member.name [ member . name ] for name .
if leading is true ,
call the method self.split_leading_dir [ self . split_leading_dir ] with an argument name , substitute the first element of result for name .
join to_path and name into a valid system path , substitute the result for filename .
if member is a directory ,
if filename is true and filename path doesnt exist ,
create directories from the elements in filename .
if not ,
try ,
call the method self._archive.extractfile [ self . _archive . extractfile ] with an argument member , substitute the result for extracted .
if KeyError or AttributeError , renamed to exc , exceptions are caught ,
print a string _STR:0_ , where ' % s ' is substituted with : name , member.name [ member . name ] and exc , respectively .
if not ,
get the directory name of filename , substitute it for dirname .
if dirname is true and dirname directory doesnt exists ,
create directories from the elements in filename .
open filename file in write mode , with the file descriptor renamed to outfile , perform ,
call the method shutil.copyfileobj [ shutil . copyfileobj ] with 2 arguments : extracted and outfile .
finally ,
if extracted is true ,
call the method extracted.close [ extracted . close ] .
define the method close with an argument self .
call the method self._archive.close [ self . _archive . close ] .
derive the class ZipArchive from the BaseArchive base class .
define the method __init__ with 2 arguments self and file .
call the method zipfile.ZipFile [ zipfile . ZipFile ] with an argument self , substitute the result for self._archive [ self . _archive ] .
define the method list with 3 arguments : self and unpacked list args and unpacked dictionary kwargs .
call the method self._archive.printdir [ self . _archive . printdir ] with 2 arguments : unpacked list args and unpacked dictionary kwargs .
define the method extract with 2 arguments self and to_path .
call the method self._archive.namelist [ self . _archive . namelist ] , substitute the result for namelist .
call the method self.has_leading_dir [ self . has_leading_dir ] with an argument namelist , substitute the result for leading .
for every name in namelist ,
call the method self._archive.read [ self . _archive . read ] with an argument name , substitute the result for data .
if leading is true ,
call the method self.split_leading_dir [ self . split_leading_dir ] with an argument name , substitute the second element of the result for name .
join to_path and name into a file path , substitute the result for filename .
get the directory name of filename , substitute the result for dirname .
if dirname is true and dirname path doesnt exists ,
create directories from the elements in filename .
if filename ends with _STR:0_ or with '\\ ' ,
if filename path doesnt exists ,
create directories from the elements in filename .
if not ,
open filename file in write mode , with the file descriptor renamed to outfile , perform ,
write data bytes to outfile .
define the method close with an argument self .
call the method self._archive.close [ self . _archive . close ] .
extension_map is a dictioanry with 6 initial elntries : TarArchive for _STR:0_ , TarArchive for _STR:1_ , TarArchive for _STR:2_ ,
from __future__ import absolute_import into default name space .
import module os .
import module signal .
import module sys .
import module time .
import module traceback .
from django.apps [ django . apps ] import apps into default name space .
from django.conf [ django . conf ] import settings into default name space .
from django.core.signals [ django . core . signals ] import request_finished into default name space .
try ,
from django.utils.six.moves [ django . utils . six . moves ] import _thread as thread into default name space .
if imoportError exception is caught ,
from django.utils.six.moves [ django . utils . six . moves ] import _dummy_thread as thread into default name space .
try ,
import threading module .
if ImportError exception is caught ,
do nothing .
try ,
import termios module .
if ImportError exception is caught ,
termios is None .
USE_INOTIFY is boolean False .
try ,
import pyinotify module .
call the method pyinotify.INotifyWrapper.create [ pyinotify . INotifyWrapper . create ] , on the return value call the inotify_init method , substitute the result for fd .
if fd is greater or equal to integer 0 .
USE_INOTIFY is boolean True .
close fd file descriptor .
if ImportError exception is caught ,
do nothing .
RUN_RELOADER is boolean True .
FILE_MODIFIED is integer 1 .
I18N_MODIFIED is integer 2
_mtimes is an empty dictionary .
_win is a tuple containing 1 initial boolean : True is sys.platform [ sys . platform ] equals to string _STR:0_ , False otherwise .
_error_files is an empty list .
_cached_modules is an empty set .
_cached_filenames is an empty list .
define the function gen_filenames with an argument only_new defaulting to boolean False .
declare that we use global variables cached_modules and _cached_filenames in this function .
module_values is a set created from the elements of sys.modules.values [ sys . modules . values ] method return value .
if _cached_modules equals to module_values ,
if only_new is true ,
return an empty list .
if not ,
return _cached_filenames .
subtract _cached_modules from module_values , assign the result to new_modules .
create the list of paths from which filename module was included for every filename in new_modules , only is filename has _STR:0_ attribute , substitute the resulting list for new_filenames .
if _cached_filenames is empty and settings.USE_I18N [ settings . USE_I18N ] is True ,
return the directory name two directories up from the __file__ path , join it with _STR:0_ and _STR:1_ into valid path , separated by _STR:2_ , basedirs is a list containing 2 elements : previous result and string _STR:1_ .
for app_config in reversed list of apps.get_app_configs [ apps . get_app_configs ] ( ) elements ,
join app_config.path [ app_config . path ] and _STR:0_ into a valid directory path , separated by _STR:1_ , append it to basedirs .
extend basedirs list with settings.LOCALE_PATHS [ settings . LOCALE_PATHS ] .
replace all the elements of the basedir list by its corresponding absolute directory path , only is that directory exists .
for every basedir in basedirs ,
for every dirpath , dirnames and locale_filenames in directory tree starting at the basedir directory .
for every filenam in locale_filenames ,
if filename ends with string _STR:0_ ,
join dirpath and filename into a path separated by _STR:0_ , append it to new_filenames .
if only_new is True ,
substitute new_filenames for filelist .
if not ,
sum _cached_filenames , new_filenames and _error_files , store the result in filelist .
filenames is an empty list .
for every filename is filelist ,
if filename is empty ,
skip this loop iteration ,
if filename ends with string _STR:0_ or it ends with _STR:1_ ,
truncate the last element of filename .
if filename ends with string _STR:0_ ,
truncate last 9 elements of filename and append it string _STR:0_ .
if file filename exists ,
append filename to filenames .
add elements from new_modules set to _cached_modules set .
append new_filenames to _cached_filenames .
return filenames .
define the function reset_translation .
import gettext module .
from django.utils.translation [ django . utils . translation ] import trans_real into default namespace .
gettext._translations [ gettext . _translations ] is an empty dictionary .
trans_real._translations [ trans_real . _translations ] is an empty dictionary .
trans_real._default [ trans_real . _default ] is None .
call the threading.local [ threading . local ] method , assign the result to trans_real._active [ trans_real . _active ] .
define the function inotify_code_changed .
derive the EventHandler class from the base class pyinotify.ProcessEvent [ pyinotify . ProcessEvent ] .
modified_code is None .
define the method process_default with self class instance and event as arguments .
if event.path [ event . path ] ends with string _STR:0_ ,
EventHandler.modified_code [ EventHandler . modified_code ] is I18N_MODIFIED .
if not ,
EventHandler.modified_code [ EventHandler . modified_code ] is FILE_MODIFIED .
call the pyinotify.WatchManager [ pyinotify . WatchManager ] method , assign the result to wm .
call the method pyinotify.Notifier [ pyinotify . Notifier ] with wm and EventHandler ( ) as arguments , assign the result to notifier .
define the method update_watch with sender defaulting to None and dictionary pair of elements kwargs .
if sender is true and sender attribute _STR:0_ is also True ,
return nothing .
perform the bitwise or operation on the next 6 operands pyinotify.IN_MODIFY [ pyinotify . IN_MODIFY ] pyinotify.IN_DELETE [ pyinotify . IN_DELETE ] , pyinotify.IN_ATTRIB [ pyinotify . IN_ATTRIB ] ,
pyinotify.IN_MOVED_FROM [ pyinotify . IN_MOVED_FROM ] , pyinotify.IN_MOVED_TO [ pyinotify . IN_MOVED_TO ] and pyinotify.IN_CREATE [ pyinotify . IN_CREATE ] , store the result in mask . for every path in return value of the call to the function gen_filenames with argument only_new set to boolean True ,
call the method wm.add_watch [ wm . add_watch ] with path and mask as arguments .
call the method request_finished.connect [ request_finished . connect ] with argument update_watch .
call the method update_watch .
call the method notifier.check_events [ notifier . check_events ] with argument timeout set to None .
call the method notifier.read_events [ notifier . read_events ] .
call the method notifier.process_events [ notifier . process_events ] .
call the method notifier.stop [ notifier . stop ] .
return EventHandler.modified_code [ EventHandler . modified_code ] .
define the function code_changed .
use the global variables _mtimes and _win in this function .
for every filename in gen_filenames ( ) ,
call the os.stat [ os . stat ] function with argument filename , store the return value in stat .
substitute stat.st_mtime [ stat . st_mtime ] for mtime .
if _win is true ,
decrement mtime by stat.st_ctime [ stat . st_ctime ] .
if filename is not contained in _mtimes ,
substitute mtime for the value under the filename key of _mtimes dictionary .
skip this loop iteration .
if mtime is different than the value of dictionary _mtimes under the key filename ,
_mtimes is an empty dictionary .
try ,
remove the first occurrence of the filename value in the _error_files list .
if ValueError exception is caught ,
do nothing .
if filename ends with string _STR:0_ return I18N_MODIFIED , otherwise return FILE_MODIFIED .
return boolean False .
define the function check_errors with argument fn .
define the function wrapper with list args , and dictionary pair of values kwargs as arguments .
try ,
call the function fn with list of arguments args and dictionary of argument values kwargs .
if ImportError , IndentationError , NameError , SyntaxError , TypeError or AttributeErrorexception is caught ,
call the sys.exc_info [ sys . exc_info ] function , assign the result to et , ev and tb , respectively .
if _STR:0_ attribute of ev is None ,
call the traceback.extract_tb [ traceback . extract_tb ] method with argument tb , substitute the first element of last row of the result to filename .
if not ,
substitute ev.filename [ ev . filename ] for filename .
if filename is not contained in _error_files ,
append filename to _error_files .
raise an exception .
return wrapper .
define ensure_echo_on function .
if termios is true ,
substitute sys.stdin [ sys . stdin ] for fd .
evaluate the fd.isatty [ fd . isatty ] method , if the result is true ,
call the method termios.tcgetattr [ termios . tcgetattr ] with argument fd , substitute the result for attr_list .
if fourth element of attr_list and termios.ECHO [ termios . ECHO ] are both true ,
perform binary or for operands : fourth element of_attr_list and termios.ECHO [ termios . ECHO ] , store the result in fourth element of attr_list .
if signal has an attribute _STR:0_ ,
call the signal.signal [ signal . signal ] method with signal.SIGTTOU [ signal . SIGTTOU ] and signal.SIG_IGN [ signal . SIG_IGN ] as arguments , store the result in old_handler .
if not ,
old_handler is None .
call the method termios.tcsetattr [ termios . tcsetattr ] with fd , termios.TCSANOW [ termios . TCSANOW ] and attr_list , as arguments .
if old_handler is not None ,
call the method signal.signal [ signal . signal ] with signal.SIGTTOU [ signal . SIGTTOU ] and old_handler , as arguments .
define the function reloader_thread .
call the function ensure_echo_on .
if USE_INOTIFY is true ,
substitute inotify_code_changed for fn .
if not ,
substitute code_changed for fn .
while RUN_RELOADER is true .
assign the return value of the function fn to change .
if change equals to FILE_MODIFIED ,
call the function sys.exit [ sys . exit ] with argument integer 3 .
otherwise id change equals to I18N_MODIFIED ,
call the function reset_translations .
call the function time.sleep [ time . sleep ] with an argument integer 1 .
define the function restart_with_reloader .
endless loop ,
in string _STR:0_ replace ' % s ' with o for every o in sys.warnoptions [ sys . warnoptions ] , put the result into a list , append the list to a list containing sys.executable [ sys . executable ] , append sys.argv [ sys . argv ] to the end of the resulting list , substitute the result for args .
if sys.platform [ sys . platform ] equals to string _STR:0_ ,
args is a list containing arg surrounded by double quotes for every arg in args .
call the method os.environ.copy [ os . environ . copy ] , substitute the result for new_environ .
value under the _STR:0_ key of new_environ dictionary is a string _STR:1_ .
call the function os.spawnve [ os . spawnve ] with os.P_WAIT [ os . P_WAIT ] , sys.executable [ sys . executable ] , args and new_environ as arguments , substitute the result for exit_code .
if exit_code is not equal to integer 3 .
return exit_code .
define the function python_reloader with main_func and kwargs as arguments .
if value under the _STR:0_ key of the os.environ [ os . environ ] dictionary equals to string _STR:1_ ,
call the function thread.start_new_thread [ thread . start_new_thread ] with main_func , args and kwargs as arguments .
try ,
call the function reloader_thread .
if KeyboardInterrupt exception is caught ,
do nothing .
if not ,
try ,
call the function restart_with_reloader , substitute the return value for exit_code .
if exit_code is lesser than integer 0 ,
call the function os.kill [ os . kill ] with os.getpid [ os . getpid ] ( ) and negative exit_code as arguments .
if not ,
call the function sys.exit [ sys . exit ] with argument exit_code .
if KeyboardInterrupt exception is caught ,
do nothing ,
define the function jython_reloader with main_func , args and kwargs as arguments .
from _systemrestart import SystemRestart into default name space .
call the function thread.start_new_thread [ thread . start_new_thread ] with main_func and args as arguments .
endless loop ,
if return value of the code_changed function is true ,
raise an SystemRestart exception ,
call the function time.sleep [ time . sleep ] with argument integer 1 .
define the function main , with main_func , args defaulting to None and kwargs defaulting to None as arguments .
if args is None ,
args is a empty tuple .
if kwargs is None ,
kwargs is a empty dictionary .
if sys.platform [ sys . platform ] starts with string _STR:0_ ,
substitute jython_reloader for reloader .
if not ,
substitute python_reloader for reloader .
call the function check_errors with argument main_func , substitute the result for wrapped_main_func .
call the function reloader with wrapped_main_func , args and kwargs as arguments .
BASE2_ALPHABET is a string _STR:0_ .
BASE16_ALPHABET is a string _STR:0_ .
BASE56_ALPHABET is a string _STR:0_ .
BASE36_ALPHABET is a string _STR:0_ .
BASE62_ALPHABET is string _STR:0_ .
append string _STR:0_ to the BASE62_ALPHABET , substitute it for BASE64_ALPHABET .
derive class BaseCOnverter from object base class .
decimal_digits is a string _STR:0_ .
define the initialization function with self class instance , digits and sign defaulting to _STR:0_ as arguments .
substitute sign for self.sign [ self . sign ] .
substitute digits for self.digits [ self . digits ] .
if sign is contained in self.digits [ self . digits ] ,
raise ValueError exception with string _STR:0_ as an argument .
define private method __repr__ with argument self .
replace ' % s ' in the string _STR:0_ with length of self.digits [ self . digits ] and self.digits [ self . digits ] , respectively , return the string .
define the method encode with self class instance and i as arguments .
call the self.convert [ self . convert ] method with i , self.decimal_digits [ self . decimal_digits ] , self.digits [ self . digits ] and _STR:0_ as arguments , assign the result to the neg and value , respectively .
if neg is true ,
append value to the self.sign [ self . sign ] , return the result .
return value .
define the decode method with self class instance and s as arguments .
call the self.convert [ self . convert ] method with s , self.decimal [ self . decimal ] , self.decimal_digits [ self . decimal_digits ] and self.sign [ self . sign ] as arguments , assign the result to the neg and value , respectively .
if neg is true ,
append value to the _STR:0_ , substitute it for value .
convert value to an integer , return it .
define convert method with self class instance , number , from_digits , to_digits and sign as arguments .
convert number to string , if first element equals to sign ,
convert number to a string , truncate first element .
neg is integer 1 .
if not ,
neg is integer 0 .
x is integer 0 .
for every digit in number coverted to a string ,
multiply x by length of from_digits add the return value of method from_digits.index [ from_digits . index ] with digit argument , substitute the result for x .
if x equals to integer 0 ,
substitute first element of to_digits for res .
if not ,
res is an empty string .
while x is greater than zero ,
calculate reminder of division of x by length to_digits , substitute it for digit .
increment res by element of to_digit at the digit index .
divide x by length of to_digits , convert floor value of the result to an integer , substitute it for x .
return neg and res .
call the BaseConverter function with BASE2_ALPHABET as argument , store the result in base2 .
call the BaseConverter function with BASE16_ALPHABET as argument , store the result in base16 .
call the BaseConverter function with BASE36_ALPHABET as argument , store the result in base36 .
call the BaseConverter function with BASE56_ALPHABET as argument , store the result in base56 .
call the BaseConverter function with BASE62_ALPHABET as argument , store the result in base62 .
call the BaseConverter function with BASE64_ALPHABET and sign set to _STR:0_ as arguments , store the result in base64 .
from module __future__ import unicode_literals to default name space .
import hashlib module .
import re module .
import time module .
from django.conf [ django . conf ] import settings object to the default name space .
from django.core.cache [ django . core . cache ] import caches to the default name space .
from django.utils [ django . utils ] import iri_to_uri , force_bytes , force_text to the default name space .
from django.utils.http [ django . utils . http ] import http_date to the default name space .
from django.utils.timezone [ django . utils . timezone ] import get_current_timezone_name to the default name space .
from django.utils.translation [ django . utils . translation ] import get_language to the default name space .
compile regular expression based on the string _STR:0_ and assign the result to cc_delim_re .
define function patch_cache_control , with response and dictionary set of arguments , kwargs , as arguments .
define function dictitem with s as an argument .
split string s once , with _STR:0_ sign as a delimiter , assign the resulting list to the t .
if length of t is greater than integer 1 ,
return first element of t converted to lowercase and second element of t , as a tuple .
if not ,
return first element of t converted to lowercase and boolean True , as a tuple .
define function dictvale , with an argument t .
if second element of t is boolean True ,
return first element of t .
if not ,
return string first element of t , _STR:0_ , second element of t .
if call to the method response.has_header [ response . has_header ] with string _STR:0_ as an argument returns boolean True ,
find the value of response under the key _STR:0_ , use it as a delimiter to split string ss_delim_re ,
assign the result to cc . cc is a dictionary populated with items by calling function dictitem with el as argument , for every el in cc .
if not ,
cc is an empty dictionary .
if cc contains item _STR:0_ and kwargs contains item _STR:1_ ,
convert to integer value of dictionary cc under the key _STR:0_ ,
if it is smaller than the value of dictionary kwargs under the key _STR:0_ , substitute kwargs value under the key _STR:1_ by it . if cc contains item _STR:2_ and kwargs contains item _STR:3_ ,
delete dictionary item _STR:0_ from cc .
if cc contains item _STR:0_ and kwargs contains item _STR:1_ ,
delete dictionary item _STR:0_ from cc .
for every k and v in items of dictionary kwargs , respectively ,
replace all occurrences of symbol _STR:0_ in string k with symbol _STR:1_ , use new string as key to find a value in dictionary cc ,
replace this value with v. call the function dictvalue with el as argument for every el in values of dictionary cc ,
join the resulting sequence in a string with comma as separator , assign the string to cc . substitute response dictionary value under the key _STR:0_ for cc .
define function get_max_age with response as an argument .
if the result to the method call response.has_header [ response . has_header ] , with string _STR:0_ as an argument is boolean False ,
return from the function
cc is a dictionary populated with items by calling function _to_tuple with el as an argument ,
for every el in split string cc_delim_re , with delimiter being the value of dictionary response under the key _STR:0_ . if cc contains item _STR:1_ ,
try ,
convert to integer the value of dictionary cc under the key _STR:0_ , and return it
if exception ValueError or TypeError is raised ,
do nothing .
define the function _set_response_etag , with response as an argument .
if response.streaming [ response . streaming ] is boolean False ,
create md5 hash from string response.content [ response . content ] in hexadecimal format , surround the hash with double quotes ,
and store it in the value of the dictionary response under the key _STR:0_ . return response
define the function patch_response_headers , with response and cache_timeout with None as default value , as arguments .
if cache_timeout equals to None ,
substitute settings.CACHE_MIDDLEWARE_SECONDS [ settings . CACHE_MIDDLEWARE_SECONDS ] for cache_timeout .
if cache_timeout is lesser than integer 0 ,
substitute integer 0 for cache_timeout .
if settings.USE_ETAGS [ settings . USE_ETAGS ] is True and function call response.has_header [ response . has_header ] with string _STR:0_ as argument returns boolean False ,
if object response has an attribute _STR:0_ and if response.render [ response . render ] is callable object ,
call the method response.add_post_render_callback [ response . add_post_render_callback ] with _set_response_etag as argument .
if not ,
substitute return value of call to the function _set_response_etag with response as an argument , for response .
if call to the function response.has_header [ response . has_header ] with string _STR:0_ as an argument returns boolean False ,
call the function http_date with no arguments , and substitute its return value
for value of dictionary response under the key _STR:0_ . if call to the function response.has_header [ response . has_header ] with _STR:1_ as argument returns boolean False ,
sum return value of the function call time.time [ time . time ] ( ) and cache_timeout , use it as an argument for function call of http_date ,
and substitute the return value for value under the key _STR:0_ of dictionary response . call the function patch_cache_control , with response and max_age set to cache_timeout as arguments .
define function add_never_cache_headers , with response as an argument .
call the function patch_response with response and cache_timeout decremented by integer 1 as arguments .
define function patch_vary_headers , with response and newheaders as arguments .
doctring
if call to the function response.has_header [ response . has_header ] with argument _STR:0_ returns boolean True ,
split the string cc_delim_re with value under the key _STR:0_ of response dictionary as delimiter , substitute result for vary_headers .
if not ,
vary_headers is an empty list .
existing_headers is a set of lowercase headers for every header in vary_headers .
put every header in newheaders in a list , only if newheader converted to lowercase does not exist in existing_headers ,
substitute this list for additional_headers . join all of the elements of vary_headers and additional_headers in a string delimited by a comma ,
substitute it for value of dictionary response under the key _STR:0_ . define function has_vary_header , with response and header_query as arguments .
if return value of function response.has_header [ response . has_header ] with string _STR:0_ as argument is boolean False ,
return boolean False .
split string cc_delim_re by value of dictionary response under the key _STR:0_ as a delimiter , substitute it for vary_headers .
existing_headers is a set containing lowercase strings header for every header in vary_headers .
check if lowercase header_query exists is existing_headers , return the boolean result .
define function _i18n_cache_key_suffix , with request and cache_key as arguments .
if eather one of settings.USE_I18N [ settings . USE_I18N ] or settings.USE_L10N [ settings . USE_L10N ] is True ,
call the function getattr with request , string _STR:0_ and function get_language as arguments ,
append the result at the end of string _STR:0_ , append it all at the end of string cache_key . if settings.USE_TZ [ settings . USE_TZ ] is True ,
call the function force_text , with the function get_current_timezone_name and errors set to string _STR:0_ as arguments ,
replace the result for tz_name . call the method tz_name.encode [ tz_name . encode ] with the arguments _STR:0_ and _STR:1_ , call the method decode on the result with _STR:0_ as argument ,
in the resulting string replace all occurrences of _STR:0_ with _STR:1_ and append it to the end of cache_key . return cache_key .
define function _generate_cache_key , with request , method , headerlist and key_prefix as arguments .
ctx is an hashlib object , for calculating hash function with md5 algorithm .
for every header in headerlist ,
call method request.META.get [ request . META . get ] with arguments header and None .
if value is not None ,
call function force_bytes with value as argument , use the result to as the result for the call to the methgod ctx.update [ ctx . update ] .
call iri_to_uri with return value of the request.build_absolute_uri [ request . build_absolute_uri ] method , us the result as the argument for the call to the
force_bytes function , use the result as the argument for the call to the hashlib.mdb [ hashlib . mdb ] function , store the result in url . substitute the ' % s ' in string _STR:0_ with key_prefix , method ,
return value of method url.hexdigest [ url . hexdigest ] ( ) , return value of method ctx.hexdigest [ ctx . hexdigest ] , respectively , substitute it for cache_key . call the function _i18n_cache_key_suffix with request and cache_key as arguments , return the result .
define the funtion _generate_cache_header_key with key_prefix and request as arguments .
call method request.build_absolute_uri [ request . build_absolute_uri ] , use the result as an argument for function call of iri_to_uri ,
use the result as an argument for function call of force_bytes , use the result as an argument for calling the method hashlib.md5 [ hashlib . md5 ] , put the result in url . substitute the ' % s ' in string _STR:0_ with key_prefix and result of the function call ,
to the function url.hexdigest [ url . hexdigest ] ( ) , respectively , substitute it for cache_key . call the function _i18n_cache_key_suffix with request and cache_key as arguments , return the result .
define the function get_cache_key , with request key_prefix set to None , method set to _STR:0_ and cache set to None as arguments .
if key_prefix is None ,
substitute settings.CACHE_MIDDLEWARE_KEY_PREFIX [ settings . CACHE_MIDDLEWARE_KEY_PREFIX ] for key_prefix .
call the function _generate_cache_header_key with key_prefix and request as arguments , substitute the result for cache_key .
if cache is None ,
set cache to the value of the dictionary caches under the key settings.CACHE_MIDDLEWARE_ALIAS [ settings . CACHE_MIDDLEWARE_ALIAS ] .
get the value of dictionary cache under the key cache_key , if key is not available return None , substitute it for headerlist .
if header list is not None ,
call the function _generate_cache_key with request , method , headerlist , key_prefix as arguments , return the result .
if not ,
return None .
define function learn_cache_key with request , response , cache_timeout set to None , key_prefix set to None , cache set to None as arguments .
if key_prefix is None ,
substitute settings.CACHE_MIDDLEWARE_KEY_PREFIX [ settings . CACHE_MIDDLEWARE_KEY_PREFIX ] for key_prefix .
if cache_timeout is None ,
substitute settings.CACHE_MIDDLEWARE_SECONDS [ settings . CACHE_MIDDLEWARE_SECONDS ] for cache_timeout .
call function _generate_cache_header_key with arguments key_prefix and request , substitute the result for cache_key .
if cache is None ,
get value under the key settings.CACHE_MIDDLEWARE_ALIAS [ settings . CACHE_MIDDLEWARE_ALIAS ] of caches dictionary , substitute with it the cache .
if call to the function response.has_header [ response . has_header ] with string _STR:0_ as an argument returns True ,
if eather of settings.USE_I18N [ settings . USE_I18N ] or settings.USE_L10N [ settings . USE_L10N ] is True , set is_accept_language_redundant to True .
headerlist is an empty list .
for every header in list of strings compiled by splitting string cc_delim_re with value under the key _STR:0_ of response dictionary as a delimiter .
convert string header to uppercase and replace all occurrences of _STR:0_ with _STR:1_ , substitute it for header .
if header equals a string _STR:0_ and is_accept_language_redundant is boolean True ,
continue with the next iteration of the for loop .
append header to the string _STR:0_ , append the result to the list headerlist .
call method sort on the headerlist .
call the method cache.set [ cache . set ] , with cache_key , headerlist , cache_timeout as arguments .
call the function _generate_cache_key with request , request.method [ request . method ] , headerlist , key_prefix as arguments , return the result .
if not ,
call the method cache.set [ cache . set ] with cache_key , an empty list and cache_timeout as arguments .
call the function _generate_cache_key with request , request.method [ request . method ] , an empty list and key_prefix as arguments , return the result .
define function _to_tuple with s as an argument .
split string s once , with _STR:0_ as delimiter , substitute the result for t .
if length of t equals to integer 2 ,
return tuple , consisting of first element of t converted to lowercase and second element of t .
return tuple , consisting of first element of t converted to lowercase and True .
__all__ is an list with an element _STR:0_ .
from django.utils [ django . utils ] import six into default name space .
LUHN_ODD_LOOKUP is a tuple with 10 elements : integers 0 , 2 , 4 , 6 , 8 , 1 , 3 , 5 , 7 and 9 .
define the function luhn with an argument candidate .
if candidate is not an instance of six.string_types [ six . string_types ] ,
convert candidate to a string .
try ,
for every c in reversed order of candidate , convert c into an integer , sum all the results and substitute the result for evens .
for every c in candidate without the last element and in reversed order , convert c into an integer ,
use the result as an key to get the value from the LUHN_ODD_LOOKUP dictionary , sum all the results and substitute the result for odds . sum evens and odds , if the result is divisible by integer 10 , return boolean True , if not return boolean False .
if ValueError exception is caught ,
return boolean False .
from __future__ import unicode_literals into default name space .
import module hmac .
import module struc .
import module hashlib .
import module binascii .
import module time .
import module random .
try ,
random is an instance of random.SystemRandom [ random . SystemRandom ] class .
using_sysrandom is boolean True .
if NotImplementedError exception is caught ,
import warnings .
call the function warnings.warn [ warnings . warn ] with an argument ,
string _STR:0_ . using_sysrandom is boolean False .
from django.conf [ django . conf ] import settings into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_bytes into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.six.moves [ django . utils . six . moves ] import xrange into default name space .
define the function salted_hmac with 3 arguments : key_salt , value and secret set to None .
if secret is None ,
substitute settings.SECRET_KEY [ settings . SECRET_KEY ] for secret .
call the function force_bytes with an argument key_salt , substitute the result for key_salt .
call the function force_bytes with an argument secret , substitute the result for secret .
call the method hashlib.sha1 [ hashlib . sha1 ] with an argument secret appended to key_salt , call the method digest on the result , return the result .
call the method hmac.new [ hmac . new ] with 3 arguments : key , msg set to result of the function force_bytes with an argument value ,
and digestmod set to hashlib.sha1 [ hashlib . sha1 ] , return the result . define the function constant_time_compare with 2 arguments : length set to integer 12 ,
if using_sysrandom is false ,
format string _STR:0_ with 3 elements : result of the function random.getstate [ random . getstate ] , result of the call the the function time.time [ time . time ] ,
and settings.SECRET_KEY [ settings . SECRET_KEY ] , call on it method encode with an argument string _STR:0_ , use the result as an argument for the call to the method hashlib.sha256 [ hashlib . sha256 ] , call the method digest on the result , use the result as an argument for the call to the function random.seed [ random . seed ] . call the function random.choice [ random . choice ] with an argument allowed_chars , for every i in range of integers from 0 to lengths ,
join the results into a string , return it . if hmac has an attribute _STR:0_ ,
define the function constant_time_compare with 2 arguments : val1 and val2 .
call the function hmac.compare_digest [ hmac . compare_digest ] with 2 arguments : result of the function force_bytes called with an argument val1 ,
and result of the function force_bytes called with an argument val2 , return the result . if not ,
call the function constant_time_compare with 2 arguments : val1 and val2 .
if lengths of val1 and val2 are not equal ,
return boolean False .
result is an integer 0 .
if six.PY3 [ six . PY3 ] is true and val1 and val2 are an instances of bytes ,
zip val1 and va2 into list of tuples , for every x and y in the result ,
perform bitwise exclusive OR on 2 operands x and y , perform bitwise OR with 2 operands : previous result and result , substitute the result for result .
if not ,
zip val1 and va2 into list of tuples , for every x and y in the result ,
perform bitwise exclusive OR on 2 operands integer representation of x and integer representation of y ,
perform bitwise OR with 2 operands : previous result and result , substitute the result for result . if result is equal to integer 0 , return boolean True , otherwise return boolean False .
define the function _bin_to_long with an argument x .
call the function binascii.hexlify [ binascii . hexlify ] with an argument x , convert the result to base 16 integer , return the result .
define the function _long_to_bin with 2 arguments : x and hex_format_string .
format string hex_format_string with x , call the method encode on the result with an argument string _STR:0_ ,
use the result as an argument for the call to the function binascii.unhexlify [ binascii . unhexlify ] , return the result . if hashlib had an instance _STR:0_ ,
define the function pbkdf2 with 5 arguments : password , salt , iterations , dklen set to integer 0 and digest set to None .
if digest is None ,
substitute hashlib.sha256 [ hashlib . sha256 ] for digest .
if dklen is false ,
dklen is None .
call the function force_bytes with an argument password , substitute the result for password .
call the function force_bytes with an argument salt , substitute the result for salt .
call the function hashlib.pbkdf2_hmac [ hashlib . pbkdf2_hmac ] with 5 arguments : field name of the result of the function digest , password , salt ,
iterations and dklen , return the result . if not ,
define the function pbkdf2 with 5 arguments : password , salt , iterations , dklen set to integer 0 and digest set to None .
if iterations is lesser than integer 0 , raise an error .
if digest is false ,
substitute hashlib.sha256 [ hashlib . sha256 ] for digest .
call the function force_bytes with an argument password , substitute the result for password .
call the function force_bytes with an argument salt , substitute the result for salt .
call the function digest , substitute the filed digest_size of the result for hlen .
if dklen is false ,
substitute hlen for dklen .
bring intger 2 to integer 32 , decrement the result by 1 , multiply it with hlen , if dklen is greater than the previous result ,
raise an OverflowError exception with an argument string _STR:0_ .
divide negative dklen with hlen , substitute floored result for l .
decrement l by integer 1 , multiply it with hlen , subtract the result from dklen , substitute the result for r .
hex_format_string is a string _STR:0_ formated with hlen multiplied with integer 2 .
call the function digest twice , substitute the results for inner , outer , respectively .
if length of password is greater than inner.block_size [ inner . block_size ] ,
call the function digest with an argument password , call the method digest on the result , substitute the result or password .
decrement by length of password , create bytes string with previous result number of characters _STR:0_ ,
append the result to password . call the method password.translate [ password . translate ] with an argument hmac.trans_36 [ hmac . trans_36 ] , update inner dictionary with the result .
call the method password.translate [ password . translate ] with an argument hmac.trans_5C [ hmac . trans_5C ] , update outer dictionary with the result .
define the function F with an argument i .
call the method struct.pack [ struct . pack ] with 2 arguments : bytes string _STR:0_ and i , append the result to salt , substitute the result or u .
result is an integer 0 .
for every j in range of integers from 0 to iterations converted to an integer ,
call the function inner.copy [ inner . copy ] , substitute the result for dig1 , call the function outer.copy [ outer . copy ] , substitute the result for dig2 .
call the method dig1.update [ dig1 . update ] with an argument u .
call the method dig1.digest [ dig1 . digest ] , use the result as an argument for the call to the function dig2.update [ dig2 . update ] .
call the method dig2.digest [ dig2 . digest ] , substitute the result for u .
call the function _bin_to_long with an argument u perform bitwise exclusive OR with 2 operands , previous result an result ,
substitute the result for result . call the function _long_to_bin with 2 arguments : result and hex_format_string , return the result .
call the function F with an argument x , for every x in sequence of integers from 1 to l , not included ,
substitute the results in a list for T. join elements of T in a bytes string , append first r elements of result of the call to the function F with an argument l to it ,
import module os .
import module sys .
from . import six into default name space .
convert six.PY3 [ six . PY3 ] to an integer , substitute it for buffering .
if os.name [ os . name ] equals string _STR:0_ ,
define the function become_daemon with 4 arguments : our_home_dir set to _STR:0_ , out_log set to a string _STR:1_ ,
try ,
fork a child process , if the result equals integer 0 ,
close the process with an argument 0 .
if OSError , renamed to e , exception is caught ,
call the method sys.stderr.write [ sys . stderr . write ] with an argument string _STR:0_ , formated with e.errno [ e . errno ] and e.strerror [ e . strerror ] .
close the process with an argument 1 .
call the method os.setsid [ os . setsid ] .
call the method os.chdir [ os . chdir ] with an argument our_home_dir .
call the function os.umask [ os . umask ] with an argument umask .
try ,
fork a child process , if the result equals integer 0 ,
close the process with an argument 0 .
if OSError , renamed to e , exception is caught ,
call the method sys.stderr.write [ sys . stderr . write ] with an argument string _STR:0_ , formated with e.errno [ e . errno ] and e.strerror [ e . strerror ] .
call the method os._exit [ os . _exit ] with an argument integer 1 .
open _STR:0_ file in read mode , substitute the result for si .
open out_log flie in append mode with buffering size of input buffer , substitute the result for so .
open err_log flie in append mode with buffering size of input buffer , substitute the result for se .
call the method os.dup2 [ os . dup2 ] with 2 arguments : result of the method si.fileno [ si . fileno ] and result of the method sys.stdin.fileno [ sys . stdin . fileno ] .
call the method os.dup2 [ os . dup2 ] with 2 arguments : result of the method so.fileno [ so . fileno ] and result of the method sys.stdout.fileno [ sys . stdout . fileno ] .
call the method os.dup2 [ os . dup2 ] with 2 arguments : result of the method se.fileno [ se . fileno ] and result of the method sys.stderr.fileno [ sys . stderr . fileno ] .
substitute so and se for sys.stdout [ sys . stdout ] and sys.stderr [ sys . stderr ] .
if not ,
define the function become_daemon with 4 argument : our_home_dir set to _STR:0_ , out_log set to None , err_log set to None ,
call the method os.chdir [ os . chdir ] with an argument our_home_dir .
call the method os.umask [ os . umask ] with an argument umask .
call the method sys.stdin.close [ sys . stdin . close ] .
call the method sys.stdout.close [ sys . stdout . close ] .
call the method sys.stderr.close [ sys . stderr . close ] .
if err_log is true ,
open err_log file in append mode with buffering size of the input buffer , substitute the result for sys.stderr [ sys . stderr ] .
if not ,
sys.stderr [ sys . stderr ] is an instance of NullDevice class .
if out_log is true ,
open out_log file in append mode with buffering size of the input buffer , substitute the result for sys.stdout [ sys . stdout ] .
if not ,
sys.stdout [ sys . stdout ] is an instance of NullDevice class .
derive the class NullDevice .
define the method write with 2 arguments : self and s .
do nothing .
import module copy .
import module warnings .
from collections import OrderedDict into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
derive the class MergeDict from the object base class .
define the method __init__ with 2 arguments : self and unpacked list dicts .
call the function warnings.warn [ warnings . warn ] with 3 arguments : string _STR:0_ ,
RemovedInDjango19Warning and integer 2. substitute dicts for self.dicts [ self . dicts ] .
define the method __bool__ with an argument self .
if any element of self.dicts [ self . dicts ] is true , return boolean True , otherwise return boolean False .
define the method __nonzero__ with an argument self .
get the type of self object , call its method __bool__ with an argument self , return the result .
define the method __getitem__ with 2 arguments : self and key .
for every dict_ in self.dicts [ self . dicts ] ,
try ,
return value under key key of dict_ dictionary .
if KeyError exception is caught ,
do nothing .
rise an KeyError exception with an argument key .
define the method __copy__ with an argument self .
call the method __copy__ with an argument unpacked list self.dicts [ self . dicts ] , return the result .
define the method get with 3 arguments : self , key and default set to None .
try ,
return value under key key of self dictionary
if KeyError exception is caught ,
return default .
define the method getlist with 2 arguments : self and key .
for every dict_ in self.dicts [ self . dicts ] ,
if key is contained in dict_ ,
call the method dict_.getlist [ dict_ . getlist ] with an argument key , return the result .
return an empty list .
define the method _iteritems with an argument self .
seen is an empty set .
for every dict_ in self.dicts [ self . dicts ] ,
call the function six.iteritems [ six . iteritems ] with an argument dict_ , for every item in the result ,
substitute first element of item for k .
if k is contained in seen ,
skip this loop iteration .
add k to seen .
yield item .
define the method _iterkeys with an argument self .
call the method self._iteritems [ self . _iteritems ] , for every k and v in the result ,
yield k .
define the method _itervalues with an argument self .
call the method self._iteritems [ self . _iteritems ] , for every k and v in the result ,
yield v .
if six.PY3 [ six . PY3 ] is true ,
substitute _iteritems for items .
substitute _iterkeys for keys .
substitute _itervalues for values .
if not ,
substitute _iteritems for iteritems .
substitute _iterkeys for iterkeys .
substitute _itervalues for itervalues .
define the method items with an argument self .
call the method self.iteritems [ self . iteritems ] , return the list of results .
define the method keys with an argument self .
call the method self.iterkeys [ self . iterkeys ] , return the list of results .
define the method values with an argument self .
call the method self.itervalues [ self . itervalues ] , return the list of results .
define the method has_key with 2 arguments : self and key .
for every dict_ in self.dicts [ self . dicts ] ,
if key is contained in dict_ ,
return boolean True .
return boolean False .
substitute has_key for __contains__ .
substitute _iterkeys for __iter__ .
define the method copy with an argument self .
call the method self.__copy__ [ self . __copy__ ] , return the result .
define the method __str__ with an argument self .
get dictionary self items , convert the result into a dictionary , convert the result into a string and return it .
define the method __repr__ with an argument self .
join printable representation of d into a string separated with _STR:0_ , for every d in self.dicts [ self . dicts ] , substitute the result for dictreprs .
return a string _STR:0_ formated with self.__class__.__name__ [ self . __class__ . __name__ ] and dictreprs .
derive the class SortedDict from the dict base class .
define the method __new__ with 3 arguments : cls , unpacked list args and unpacked dictionary kwargs .
call the method __new__ from the base class of the class SortedDict , with 3 arguments : cls , unpacked list args ,
and unpacked dictionary kwargs . instance.keyOrder [ instance . keyOrder ] is an empty list .
return instance .
define the method __init__ with 2 arguments : self and data set to None .
call the function warnings.warn [ warnings . warn ] with 3 arguments : string _STR:0_ ,
RemovedInDjango19Warning and stacklevel set to integer 2. if data is None or data is an instance of dict type ,
if data is true , substitute it for data , otherwise data is an empty list .
call the method __init__ from the base class of the class SortedDict , called with an argument data .
if data is true , substitute list created from elements of data , substitute it for self.keyOrder [ self . keyOrder ] , otherwise self.keyOrder [ self . keyOrder ] is an empty list .
if not ,
call the method __init__ from the base class of the class SortedDict .
substitute __setitem__ filed of the base class of the class SortedDict for super_set .
for every key and value in data ,
if key is not contained in self ,
append key to self.keyOrder [ self . keyOrder ] .
call the function super_set with 2 arguments : key and value .
define the method __deepcopy__ with 2 arguments : self and memo .
call the method self.__class__ [ self . __class__ ] with an argument list , with 2 elements : key and result of the function copy.deepcopy [ copy . deepcopy ] ,
called with 2 arguments : value and memo , for every key and value in result for the method self.items [ self . items ] , return the result . define the method __copy__ with an argument self .
call the method self.copy [ self . copy ] , return the result .
define the method __setitem__ with 3 arguments : self , kay and value .
if key is not contained in self ,
append key to self.keyOrder [ self . keyOrder ] .
call the method __setitem__ from the base class of the class SortedDict , with 2 arguments key and value .
define the method __delitem__ with 2 arguments : self and key .
call the method __delitem__ from the base class of the class SortedDict , with an argument key .
remove key element from self.keyOrder [ self . keyOrder ] dictionary .
define the method __iter__ with an argument self .
return iterable self.keyOrder [ self . keyOrder ] .
define the method __reversed__ with an argument self .
reverse order of elements of self.keyOrder [ self . keyOrder ] , return the result .
define the method pop with 3 arguments : self , k and unpacked list args .
call the method pop from the base class of the class SortedDict , with 2 arguments k and unpacked list args ,
substitute the result for result . try ,
remove k element from self.keyOrder [ self . keyOrder ] dictionary .
if ValueError exception is caught ,
do nothing .
return result .
define the method popitem with an argument self .
call the method popitem from the base class of the class SortedDict , substitute the result for result .
remove first element of result from self.keyOrder [ self . keyOrder ] dictionary .
return result .
define the method _iteritems with an argument self .
for every key in self.keyOrder [ self . keyOrder ] ,
yield key and value under key key of self dictionary .
define the method _iterkeys with an argument self .
for every key in self.keyOrder [ self . keyOrder ] ,
yield key .
define the method _itervalues with an argument self .
for every key in self.keyOrder [ self . keyOrder ] ,
yield value under key key of self dictionary .
if six.PY3 [ six . PY3 ] is true ,
substitute _iteritems for items .
substitute _iterkeys for keys .
substitute _itervalues for values .
if not ,
substitute _iteritems for iteritems .
substitute _iterkeys for iterkeys .
substitute _itervalues for itervalues .
define the method items with an argument self .
put a tuple with 2 elements : k and value under k key of self dictionary into a list , for every k in self.keyOrder [ self . keyOrder ] ,
return resulting list . define the method keys with an argument self .
return hard copy of self.keyOrder [ self . keyOrder ] elements .
define the method values with an argument self .
append value under k key of self dictionary to a list , for every k in self.keyOrder [ self . keyOrder ] , return the result .
define the method update with 2 arguments : self and dict_ .
call the method six.iteritems [ six . iteritems ] with an argument dict_ , for every k and v in the result ,
substitute v for value under the k key of self dictionary .
define the method setdefault with 3 arguments : self , key and default .
if key is not contained in self ,
append key to self.keyOrder [ self . keyOrder ] dictionary .
call the method setdefault from the base class of the class SortedDict , with 2 arguments key and default , return the result .
define the method copy with an argument self .
call the method self.__class__ [ self . __class__ ] with an argument self , return the result .
define the method __repr__ with an argument self .
for every k and v in result of the function six.iteritems [ six . iteritems ] , called with an argument self ,
joining string _STR:0_ formated with k and v into a string , separated with _STR:1_ , use it to format a string _STR:2_ , return it . define the method clear with an argument self .
call the method clear from the base class of the class SortedDict .
self.keyOrder [ self . keyOrder ] is an empty list .
derive the class OrderedSet from the object base class .
define the method __init__ with 2 arguments : self and iterable set to None .
self.dict [ self . dict ] is an instance of OrderedDict class , created with arguments : tuples with 2 argument x and None , for every x in iterables ,
if iterable is true , otherwise use an empty list as an argument . define the method add with 2 arguments : self and item .
value under the item key of self.dict [ self . dict ] dictionary is None .
define the method remove with 2 arguments : self and item .
delete entry under item key of self.dict [ self . dict ] dictionary .
define the method discard with 2 arguments : self and item .
try ,
remove item from self dictionary .
if KeyError exception is caught ,
do nothing .
define the method __iter__ with an argument self .
convert keys of dictionary self.dict [ self . dict ] into a iterable , return it .
define the method __contains__ with 2 arguments : self and item .
if item is contained in self.dict [ self . dict ] , return boolean True , otherwise return boolean False .
define the method __nonzero__ with an argument self .
convert self.dict [ self . dict ] into boolean , return the result .
derive the class MultiValueDictKeyError from the KeyError base class .
do nothing .
derive the class MultiValueDict from the dict base class .
define the method __init__ with 2 arguments : self and key_to_list_mapping set to an empty tuple .
call the method __init__ from the base class of the class MultiValueDict , with an argument key_to_list_mapping .
define the method __repr__ with an argument self .
return a string _STR:0_ formated with self.__class__.__name__ [ self . __class__ . __name__ ] ,
and a result of the method __repr__ called from instance of base class of the MultiValueDict class . define the method __getitem__ with 2 arguments : self and key .
try ,
call the method __getitem__ from the base class of the class MultiValueDict , with an argument key , substitute the result for list_ .
if KeyError exception is caught ,
raise an MultiValueDictKeyError exception with printable representation of key .
try ,
return last element of list_ .
if IndexError exception is caught ,
return an empty list .
define the method __setitem__ with 3 arguments : self , key and value .
call the method __setitem__ from the base class of the class MultiValueDict , with 2 arguments key and list containing element value .
define the method __copy__ with an argument self .
call the method self.__class__ [ self . __class__ ] with an argument list , with elements : tuples with 2 elements : k and hard copy of list v ,
for every k and v in result of method the self.lists [ self . lists ] . define the method __deepcopy__ with 2 arguments : self and memo set to None .
if memo is None ,
memo is an empty dictionary .
call the method self.__class__ [ self . __class__ ] , substitute the result for result .
substitute result for value under the id of self key of memo dictionary .
for every key and value in items of dictionary self ,
call the method dict.__setitem__ [ dict . __setitem__ ] with 3 arguments : result , result of the function copy.deepcopy [ copy . deepcopy ] , called with 2 arguments : key ,
and memo , and result of the function copy.deepcopy [ copy . deepcopy ] called with 2 arguments : value and memo . return result .
define the method __getstate__ with an argument self .
call the method self.__dict__.copy [ self . __dict__ . copy ] , substitute the result for obj_dict .
value under _STR:0_ key of obj_dict is a dictionary created with tuples containing 2 elements : k and result of the function ,
self.getlist [ self . getlist ] with an argument k , for every k in self . return obj_dict .
define the method __setstate__ with 2 arguments : self and obj_dict .
remove element under _STR:0_ key of obj_dict dictionary , if it exists substitute it for data , if not data is an empty list .
call the method data.items [ data . items ] , for every k and v in the result ,
call the method self.setlist [ self . setlist ] with 2 arguments : k and v .
update self.__dict__ [ self . __dict__ ] dictionary with obj_dict .
define the method get with 3 arguments : self , key and default set to None .
try ,
substitute value under the key key of self dictionary for val .
if KeyError exception is caught ,
return default ,
if val equals an empty list .
return default .
return val .
define the method getlist with 3 arguments : self , key and default set to None .
try ,
call the method __getitem__ from the base class of the class MultiValueDict , with an argument key , return the result.. [ result .  .  ]
if KeyError exception is caught ,
if default is None ,
return an empty list .
return default .
define the method setlist with 3 arguments : self , key and list_ .
call the method __setitem__ from the base class of the class MultiValueDict , with 2 arguments key and list_ .
define the method setdefault with 3 arguments : self , key and default set to None .
if key is not contanied in self ,
substitute default for value under the key key of self dictionary .
return value under the key key of self dictionary .
define the method setlistdefault with 3 arguments : self , key and default_list set to None .
if key is not contained in self ,
if default_list is None ,
default_list is an empty list .
call the method self.setlist [ self . setlist ] with 2 arguments : key and default_list .
call the method self.getlist [ self . getlist ] with an argument key , return the result .
define the method appendlist with 3 arguments : self , key and value .
call the method self.setlistdefault [ self . setlistdefault ] with an argument key , append value to the result .
define the method _iteritems with an argument self .
for every key in self ,
yield key and value under the key key of self dictionary .
define the method _iterlists with an argument self .
call the function six.iteritems [ six . iteritems ] with an argument : instance of base class of the MultiValueDict class , return the result .
define the method _itervalues with an argument self .
for every key in self ,
yield value under key key of self dictionary .
if six.PY3 [ six . PY3 ] is true ,
substitute _iteritems for items .
substitute _iterlists for lists .
substitute _itervalues for values .
if not ,
substitute _iteritems for iteritems .
substitute _iterlists for iterlists .
substitute _itervalues for itervalues .
define the method items with an argument self .
call the method self.iteritems [ self . iteritems ] , return list of results .
define the method lists with an argument self .
call the method self.iterlists [ self . iterlists ] , return list of results .
define the method values with an argument self .
call the method self.itervalues [ self . itervalues ] , return list of results .
define the method copy with an argument self .
call the method copy.copy [ copy . copy ] with an argument self , return the result .
define the method update with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
if length of args is greater than integer 1 ,
raise an TypeError with an argument string _STR:0_ formated with length of args .
if args is true ,
substitute first args for other_dict .
if other_dict is an instance of MultiValueDict .
call the method other_dict.lists [ other_dict . lists ] , for every key and value_list in result ,
call the method self.setlistdefault [ self . setlistdefault ] with an argument key , extend the result with value_list .
if not ,
trym
for every key and value in items of other_dict dictionary ,
call the method self.setlistdefault [ self . setlistdefault ] with an argument key , append value to the result .
if TypeError exception is caught ,
raise an ValueError with an argument string _STR:0_ .
call the function six.iteritems [ six . iteritems ] with an argument kwargs , for every key and value in the result ,
call the method self.setlistdefault [ self . setlistdefault ] with an argument key , append value to the result .
define the method dict with an argument self .
return dictionary created with tuples with 2 elements : key and value under the key key of self dictionary , for every key in self .
derive the class ImmutableList from the tuple base class .
define the method __new__ with 3 arguments : cls , unpacked list args and unpacked dictionary kwargs .
if _STR:0_ is contained in kwargs ,
substitute value under _STR:0_ key of kwargs dictionary for warning .
delete element under _STR:0_ key of kwargs dictionary .
if not ,
warning is a string _STR:0_ .
call the method tuple.__new__ [ tuple . __new__ ] with 3 arguments : cls , unpacked list args and unpacked dictionary kwargs , substitute the result for self .
substitute warning for self.warning [ self . warning ] .
return self .
define the method complain with 3 arguments : self , unpacked dictionary wargs and unpacked dictionary kwargs .
if self.warning [ self . warning ] is an instance of Exception class ,
raise self.warning [ self . warning ] .
if not ,
raise an raise self.warning [ self . warning ] with an argument self.warning [ self . warning ] .
substitute complain for __delitem__ .
substitute complain for __delslice__ .
substitute complain for __iadd__ .
substitute complain for __imul__ .
substitute complain for __setitem__ .
substitute complain for __setslice__ .
substitute complain for append .
substitute complain for extend .
substitute complain for insert .
substitute complain for pop .
substitute complain for remove .
substitute complain for sort .
substitute complain for reverse .
derive the class DictWrapper from the dict base class .
define the method __init__ with 4 arguments : self , data , func and prefix .
call the method __init__ with an argument data , from the base class of the class DictWrapper .
substitute func for self.func [ self . func ] .
substitute prefix for self.prefix [ self . prefix ] .
define the method __getitem__ with 2 arguments : self and key .
if key starts with self.prefix [ self . prefix ] .
use_func is boolean True .
key is a list with elements of list key from length of self.prefixes [ self . prefixes ] index to the end ,
if not ,
use_func is boolean False .
call the method __getitem__ with an argument key from the base class of the class DictWrapper , substitute the result for value .
if use_func is true ,
call the method self.func [ self . func ] with an argument value .
return value .
from __future__ import unicode_literals into default name space .
import module re .
import module time .
import module calendar .
import module datetime .
from django.utils.dates [ django . utils . dates ] import MONTHS , MONTHS_3 , MONTHS_ALT , MONTHS_AP , WEEKDAYS and WEEKDAYS_ABBR into default name space .
from django.utils.translation [ django . utils . translation ] import ugettext as _ into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_text into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.timezone [ django . utils . timezone ] import get_default_timezone , is_aware and is_naive into default name space .
compile regex from a string _STR:0_ , substitute it for re_formatchars .
compile regex from a string _STR:0_ , substitute it for re_escaped .
derive the class Formatter from object base class .
define the function format with 2 arguments self and formatstr .
pieces is an empty list .
call the function force_text with an argument formatstr , use the result as an argument for the call to the method ,
re_formatchars.split [ re_formatchars . split ] , for every i and piece in enumerated result , if i is even number ,
get attribute piece of the self object , call it and use the result as an argument for the call to the function force_text ,
append the result to pieces . otherwise if piece is true ,
call the method re_escaped.sub [ re_escaped . sub ] with 2 arguments : raw string _STR:0_ and piece , append the result to pieces .
join elements of pieces into a string , return it .
derive the class TimeFormat from the base class Formatter .
define the method __init__ with 2 arguments : self and obj .
substitute obj for self.data [ self . data ] .
self.timezone [ self . timezone ] is None .
if obj is an instance of datetime.datetime [ datetime . datetime ] ,
call the function is_naive with an argument obj .
call the function get_default_timezone , substitute the result for self.timezone [ self . timezone ] .
if not ,
substitute obj.tzinfo [ obj . tzinfo ] for self.timezone [ self . timezone ] .
define the method a with an argument self .
if self.data.hour [ self . data . hour ] is greater than integer 11 ,
call the function _ with an argument string _STR:0_ , return the result .
call the function _ with an argument string _STR:0_ , return the result .
define the method A with an argument self .
if self.data.hour [ self . data . hour ] is greater than integer 11 ,
call the function _ with an argument string _STR:0_ , return the result .
call the function _ with an argument string _STR:0_ , return the result .
define the method B with an argument self .
raise an NotImplementedError exception with an argument string _STR:0_ .
define the method e with an argument self .
if self.timezone [ self . timezone ] is false ,
return an empty string .
try ,
is self.data [ self . data ] has an attribute _STR:0_ and self.data.tzinfo [ self . data . tzinfo ] is true ,
call the method self.data.tzinfo.tzname [ self . data . tzinfo . tzname ] with an argument self.data [ self . data ] , if it is true , return it , otherwise return an empty string .
if NotImplementedError exception is caught ,
do nothing .
return an empty string .
define the method f with an argument self .
if self.data.minute [ self . data . minute ] equals integer 0 ,
call the method self.g [ self . g ] , return the result .
return a string _STR:0_ formated with the results of the functions self.g [ self . g ] and self.i [ self . i ] , respectivley .
define the method g with an argument self .
if self.data.hour [ self . data . hour ] equals integer 0 ,
return integer 12 .
if self.data.hour [ self . data . hour ] is greater than inreger 12 ,
subtract integer 12 from self.data.hour [ self . data . hour ] , return the result .
return self.data.hour [ self . data . hour ] .
define the method G with an argument self .
return self.data.hour [ self . data . hour ] .
define the method h with an argument self .
return a string _STR:0_ formated with the result of the function self.g [ self . g ] .
define the method H with an argument self .
return a string _STR:0_ formated with the result of the function self.G [ self . G ] .
define the method i with an argument self .
return a string _STR:0_ formated with self.data.minute [ self . data . minute ] .
define the method O with an argument self .
if self.timezone [ self . timezone ] is false ,
return an empty string .
call the method self.Z [ self . Z ] , substitute the result for seconds .
if seconds smaller than integer 0 , sign is _STR:0_ , otherwise sign is _STR:1_ ,
substitute absolute seconds for seconds .
return a string _STR:0_ formated with sign , floored result of the division of seconds by integer 3000 ,
reminder of the division of floored result of division of seconds by 60 , by integer 60. define the method P with an argument self .
if self.data.minute [ self . data . minute ] equals integer 0 and self.data.hour [ self . data . hour ] equals integer 0 ,
call the function _ with an argument string _STR:0_ , return the result .
if self.data.minute [ self . data . minute ] equals integer 0 and self.data.hour [ self . data . hour ] equals integer 12 ,
call the function _ with an argument string _STR:0_ , return the result .
return a string _STR:0_ formated with self.data.month [ self . data . month ] .
define the method s with an argument self .
return a string _STR:0_ formated with self.data.second [ self . data . second ] .
define the method T with an argument self .
if self.timezone [ self . timezone ] is false ,
return an empty string .
if self.timezone [ self . timezone ] is true , call the method self.timezone.tzname [ self . timezone . tzname ] with an argument self.data [ self . data ] , substitute the result for name ,
otherwise name is None . if name is None ,
call the method self.format [ self . format ] with an argument string _STR:0_ , substitute the result for name .
call the function six.text_type [ six . text_type ] with an argument name , return the result .
define the method u with an argument self .
return a string _STR:0_ formated with self.data.microsecond [ self . data . microsecond ] .
define the method Z with an argument self .
if self.timezone [ self . timezone ] is true ,
return an empty string .
call the method self.timezone.utcoffset [ self . timezone . utcoffset ] with an argument self.data [ self . data ] , substitute the result for offset .
multiply offset.days [ offset . days ] with 86400 , add offset.seconds [ offset . seconds ] to the result , return the result .
derive the class DateFormat from the base class TimeFormat .
year_days is a list with 13 elements : None , integer 0 , integer 31 , integer 59 , integer 90 , integer 120 , integer 151 , integer 181 ,
integer 212 , integer 243 , integer 273 , integer 304 and integer 334. define the method b with an argument self .
return the value under the self.data.month [ self . data . month ] key of the MONTHS_3 dictionary .
define the method c with an argument self .
call the method self.data.isoformat [ self . data . isoformat ] , return the result .
define the method d with an argument self .
return a string _STR:0_ formated with self.data.day [ self . data . day ] .
define the method D with an argument self .
call the method self.data.weekday [ self . data . weekday ] , use the result as an key for obtaining WEEKDAYS_ABBR dictionary value , return it .
define the method E with an argument self .
return the value under the self.data.month [ self . data . month ] key of the MONTHS_ALT dictionary .
define the method F with an argument self .
return the value under the self.data.month [ self . data . month ] key of the MONTHS dictionary .
define the method I with an argument self .
if self.timezone [ self . timezone ] is true and call to the method self.timezone.dst [ self . timezone . dst ] with an argument self.data [ self . data ] , evaluates to true ,
return string _STR:0_ .
if not ,
return string _STR:0_ .
define the method j with an argument self .
return self.data.day [ self . data . day ] .
define the method l with an argument self .
call the method self.data.weekday [ self . data . weekday ] , use the result as an key for obtaining WEEKDAYS dictionary value , return it .
define the method L with an argument self .
call the method calendar.isleap [ calendar . isleap ] with an argument self.data.year [ self . data . year ] , return the result .
define the method m with an argument self .
return a string _STR:0_ formated with self.data.month [ self . data . month ] .
define the method M with an argument self .
get the value under the self.data.month [ self . data . month ] key of the MONTHS_3 dictionary , call on it the method title , return the result .
define the method n with an argument self .
return self.data.month [ self . data . month ] .
define the method N with an argument self .
return the value under the self.data.month [ self . data . month ] key of the MONTHS_AP dictionary .
define the method o with an argument self .
call the method self.data.isocalendar [ self . data . isocalendar ] , return the first element of the result .
define the method r with an argument self .
call the method return self.format [ self . format ] with an argument string _STR:0_ , return the result .
define the method S with an argument self .
if self.data.day [ self . data . day ] equals integer 11 , 12 or 13 ,
return string _STR:0_ .
divide self.data.day [ self . data . day ] by 10 , substitute reminder of the result for last .
if las equals integer 1 ,
return string _STR:0_ .
if las equals integer 2 ,
return string _STR:0_ .
if las equals integer 3 ,
return string _STR:0_ .
return string _STR:0_ .
define the method t with an argument self .
call the method calendar.monthrange [ calendar . monthrange ] with 2 arguments : self.data.year [ self . data . year ] and self.data.month [ self . data . month ] ,
format string _STR:0_ with the second element of the result , return it . define the method U with an argument self .
if self.data [ self . data ] is an instance of datetime.datetime [ datetime . datetime ] and result of the function is_aware called with an argument self.data [ self . data ] evaluates to true ,
call the method self.data.utctimetuple [ self . data . utctimetuple ] , use the result as an argument for the call to the function calendar.timegm [ calendar . timegm ] ,
return result converted into an integer . if not ,
call the method self.data.timetuple [ self . data . timetuple ] , use the result as an argument for the call to the function time.mktime [ time . mktime ] ,
return result converted into an integer . define the method w with an argument self .
call the method self.data.weekday [ self . data . weekday ] , increment the result by an integer 1 , divide it with integer 7 , return the reminder of the division .
define the method W with an argument self .
week_number is None .
call the method self.data.replace [ self . data . replace ] with 2 arguments : month as integer 1 and day as integer 1 , on the result call the method ,
weekday , increment the result by integer 1 and substitute it for jan1_weekday . call the method self.data.weekday [ self . data . weekday ] , increment the result by integer 1 , substitute the result for weekday .
call the method self.z [ self . z ] , substitute the result for day_of_year .
if day_of_year is smaller than or equalt to jan1_weekday subtracted from integer 8 and jan1_weekday is greater than integer 4 ,
if jan1_weekday equals integer 5 , or if jan1_weekday equals integer 6 and call to the function calendar.isleap [ calendar . isleap ] ,
with an argument self.data.year [ self . data . year ] decremented by 1 , evaluates to true , week_number is integer 53 .
if not ,
week_number is integer 52 .
if not ,
call the function calendar.isleap [ calendar . isleap ] with an argument self.data.year [ self . data . year ] , if it evaluates to true ,
i is integer 366 .
if not ,
i is integer 365 .
subtract day_of_year from i , if the result is smaller than the result of subtraction of weekday from integer 4 ,
week_number is integer 1 .
if not ,
sum day_of_year , result of the subtraction of weekday from integer 7 and subtraction of integer 1 from jan1_weekday .
divide j by integer 7 , substitute the floored result for week_number .
if jan1_weekday is greater than integer 4 ,
decrement week_number by integer 1 .
return week_number .
define the method y with an argument self .
call the function six.text_type [ six . text_type ] with an argument self.data.year [ self . data . year ] , return the result without the first 2 elements .
define the method Y with an argument self .
return self.data.year [ self . data . year ] .
define the method z with an argument self .
append self.data.day [ self . data . day ] to the value under the self.data.month [ self . data . month ] key of the self.year_days [ self . year_days ] dictionary , substitute the result for doy .
if call to the method self.L [ self . L ] evaluates to true , and result of the call to the method self.data.month [ self . data . month ] is greater than integer 2 ,
increment doy by integer 1 .
return doy .
define the function format with 2 arguments : value and format_string .
df is an instance of DateFormat class , created with an argument value .
call the method df.format [ df . format ] with an argument format_string , return the result .
define the function time_format with 2 arguments : value and format_string .
tf is an instance of TimeFormat class , created with an argument value .
call the method tf.format [ tf . format ] with an argument format_string , return the result .
import module datetime .
import module re .
from django.utils [ django . utils ] import six into default name space .
from django.utils.timezone [ django . utils . timezone ] import utc and get_fixed_timezone into default name space .
compile regex from raw string _STR:0_ , substitute it for date_re .
compile regex from raw string _STR:0_ ,
substitute it for time_re . compile regex from raw string _STR:0_
_STR:0_ , substitute it for datetime_re . define the function parse_date with an argument value .
match regex date_re with value , substitute the result for match .
if match is true ,
call the method match.groupdict [ match . groupdict ] , use the result as an argument for the call to the function six.iteritems [ six . iteritems ] ,
for every k and v in the previous result , add a key into a dictionary : v converted to an integer for k , substitute the resulting dictionary for kw . call the method datetime.date [ datetime . date ] with an argument unpacked dictionary kw , return the result .
define the function parse_time with an argument value .
match regex time_re with value , substitute the result for match .
if match is true ,
call the method match.groupdict [ match . groupdict ] , substitute the result for kw .
if value under the _STR:0_ key of the kw dictionary is true ,
left justify value under the _STR:0_ key of the kw dictionary , in the field of width 6 , fill the rest with _STR:1_ ,
substitute the result for value under the _STR:0_ key of the kw dictionary . update a dictionary with an entry v converted to an integer for k , for every k and v in result of the function six.iteritems [ six . iteritems ] ,
called with an argument kw , only if v is not None , substitute the result for kw . call the method datetime.time [ datetime . time ] with an argument unpacked dictionary kw , return the result .
define the function parse_datetime with an argument value .
match regex datetime_re with value , substitute the result for match .
if match is true ,
call the method match.groupdict [ match . groupdict ] , substitute the result for kw .
if value under the _STR:0_ key of the kw dictionary is true ,
left justify value under the _STR:0_ key of the kw dictionary , in the field of width 6 , fill the rest with _STR:1_ ,
substitute the result for value under the _STR:0_ key of the kw dictionary . remove entry under the _STR:1_ key of the kw dictionary , substitute it for tzinfo .
if tzinfo equals a string _STR:0_ ,
substitute utc for tzinfo .
otherwise if tzinfo is not None ,
if length of tzinfo is greater than integer 3 , convert elements of tzinfo from indexes 1 to 3 to an integer ,
substitute the result for offset_mins , otherwise offset_mins is integer 0. convert elements of tzinfo from indexes 1 to 3 to an integer , multiply it by integer 60 and increment it by offset_mins ,
substitute the result for offset . if first element of tzinfo equals _STR:0_ ,
multiply offset by integer -1 .
call the function get_fixed_timezone with an argument offset , substitute the result for tzinfo .
update a dictionary with an entry v converted to an integer for k , for every k and v in result of the function six.iteritems [ six . iteritems ] ,
called with an argument kw , only if v is not None , substitute the result for kw . substitute tzinfo for value under the _STR:0_ key of the kw dictionary .
call the method datetime.datetime [ datetime . datetime ] with an argument unpacked dictionary kw , return the result .
from django.utils.translation [ django . utils . translation ] import ugettext_lazy as _ and pgettext_lazy into default name space .
WEEKDAYS is an dictionary with 7 entries : result of the call to the function _ with an argument string _STR:0_ for 0 ,
result of the call to the function _ with an argument string _STR:0_ for 1 , result of the call to the function _ with an argument string _STR:1_ for 2 , result of the call to the function _ with an argument string _STR:2_ for 3 , result of the call to the function _ with an argument string _STR:3_ for 4 , result of the call to the function _ with an argument string _STR:4_ for 5 , and result of the call to the function _ with an argument string _STR:5_ for 6 . WEEKDAYS_ABBR is an dictionary with 7 entries : result of the call to the function _ with an argument string _STR:6_ for 0 ,
result of the call to the function _ with an argument string _STR:0_ for 1 , result of the call to the function _ with an argument string _STR:1_ for 2 , result of the call to the function _ with an argument string _STR:2_ for 3 , result of the call to the function _ with an argument string _STR:3_ for 4 , result of the call to the function _ with an argument string _STR:4_ for 5 , and result of the call to the function _ with an argument string _STR:5_ for 6 . WEEKDAYS_REV is an dictionary with 7 entries : 0 for _STR:6_ , 1 for _STR:7_ , 2 for _STR:8_ , 3 for _STR:9_ , 4 for _STR:10_ , 5 for _STR:11_ and 6 for _STR:12_ .
MONTHS is an dictionary with 12 entries : result of the call to the function _ with an argument string _STR:0_ for 1 ,
result of the call to the function _ with an argument string _STR:0_ for 2 , result of the call to the function _ with an argument string _STR:1_ for 3 , result of the call to the function _ with an argument string _STR:2_ for 4 , result of the call to the function _ with an argument string _STR:3_ for 5 , result of the call to the function _ with an argument string _STR:4_ for 6 , result of the call to the function _ with an argument string _STR:5_ for 7 , result of the call to the function _ with an argument string _STR:6_ for 8 , result of the call to the function _ with an argument string _STR:7_ for 9 , result of the call to the function _ with an argument string _STR:8_ for 10 , result of the call to the function _ with an argument string _STR:9_ for 11 , and result of the call to the function _ with an argument string _STR:10_ for 12 . MONTHS_3 is an dictionary with 12 entries : result of the call to the function _ with an argument string _STR:11_ for 1 ,
result of the call to the function _ with an argument string _STR:0_ for 2 , result of the call to the function _ with an argument string _STR:1_ for 3 , result of the call to the function _ with an argument string _STR:2_ for 4 , result of the call to the function _ with an argument string _STR:3_ for 5 , result of the call to the function _ with an argument string _STR:4_ for 6 , result of the call to the function _ with an argument string _STR:5_ for 7 , result of the call to the function _ with an argument string _STR:6_ for 8 , result of the call to the function _ with an argument string _STR:7_ for 9 , result of the call to the function _ with an argument string _STR:8_ for 10 , result of the call to the function _ with an argument string _STR:9_ for 11 , result of the call to the function _ with an argument string _STR:10_ for 12 . MONTHS_3_REV is an dictionary with 12 entries : 1 for _STR:11_ , 2 for _STR:0_ , 3 for _STR:1_ , 4 for _STR:2_ , 5 for _STR:3_ , 6 for _STR:4_ ,
7 for _STR:0_ , 8 for _STR:1_ , 9 for _STR:2_ , 10 for _STR:3_ , 11 for _STR:4_ and 12 for _STR:5_ . MONTHS_AP is an dictionary with 12 entries : result of the function pgettext_lazy with 2 arguments : _STR:6_ and _STR:7_ for 1 ,
result of the function pgettext_lazy with 2 arguments : strings _STR:0_ and _STR:1_ for 2 , result of the function pgettext_lazy with 2 arguments : strings _STR:0_ and _STR:2_ for 3 , result of the function pgettext_lazy with 2 arguments : strings _STR:0_ and _STR:3_ for 4 , result of the function pgettext_lazy with 2 arguments : strings _STR:0_ and _STR:4_ for 5 , result of the function pgettext_lazy with 2 arguments : strings _STR:0_ and _STR:5_ for 6 , result of the function pgettext_lazy with 2 arguments : strings _STR:0_ and _STR:6_ for 7 , result of the function pgettext_lazy with 2 arguments : strings _STR:0_ and _STR:7_ for 8 , result of the function pgettext_lazy with 2 arguments : strings _STR:0_ and _STR:8_ for 9 , result of the function pgettext_lazy with 2 arguments : strings _STR:0_ and _STR:9_ for 10 , result of the function pgettext_lazy with 2 arguments : strings _STR:0_ and _STR:10_ for 11 , result of the function pgettext_lazy with 2 arguments : strings _STR:0_ and _STR:11_ for 12 , MONTHS_ALT is an dictionary with 12 entries : result of the function pgettext_lazy with 2 arguments : _STR:12_ and _STR:13_ for 1 ,
from datetime import date as real_date and datetime as real_datetime into default name space .
import module re .
import module time .
derive the class date from the real_date base class .
define the method strftime with 2 arguments : self and fmt .
call the function strftime with 2 arguments : self and fmt , return the result .
derive the class datetime from the real_datetime base class .
define the method strftime with 2 arguments : self and fmt .
call the function strftime with 2 arguments : self and fmt , return the result .
decorator classmethod ,
define the method combine with 3 arguments : cls , date and time .
call the function cls with 8 arguments : date.year [ date . year ] , date.month [ date . month ] , date.day [ date . day ] , time.hour [ time . hour ] , time.minute [ time . minute ] , time.second [ time . second ] , time.microsecond [ time . microsecond ] ,
and time.tzinfo [ time . tzinfo ] , return the result . define the method date with an argument self .
call the function data with 3 arguments : self.year [ self . year ] , self.month [ self . month ] and self.day [ self . day ] , return the result .
define the function new_date with an argument d .
call the function data with 3 arguments : d.year [ d . year ] , d.month [ d . month ] and d.day [ d . day ] , return the result .
define the function new_datetime with an argument d .
kw is a list with 3 elements : d.year [ d . year ] , d.month [ d . month ] and d.day [ d . day ] .
if d is an instance of real_datetime class ,
extend list kw with a list with 5 elements : d.hour [ d . hour ] , d.minute [ d . minute ] , d.second [ d . second ] , d.microsecond [ d . microsecond ] and d.tzinfo [ d . tzinfo ] .
call the function datetime with an argument unpacked list kw , return the result .
compile the regex from the raw string _STR:0_ , substitute the result for _illegal_formatting .
define the function _findall with 2 arguments text and substr .
sites is an empty list .
i is integer 0 .
endless loop ,
call the method text.find [ text . find ] with 2 arguments : substr and i , substitute the result for j .
if j equals to integer -1 ,
break from the loop execution .
append j to sites .
add j and integer 1 , substitute the result for i .
return sites .
define the function strftime with 2 arguments dt and fmt .
if dt.year [ dt . year ] is greater than or equal to integer 1900 ,
call the method strftime with an argument fmt , from the base class of the type of dt class .
call the method _illegal_formatting.search [ _illegal_formatting . search ] with an argument fmt , substitute the result for illegal_formatting .
if illegal_formatting is true ,
raise an TypeError exception with an argument : result of the method illegal_formatting.group [ illegal_formatting . group ] called with an argument ,
integer 0 , appended to a string _STR:0_ . substitute dt.year [ dt . year ] for year .
subtract year from integer 2000 , substitute the result for delta .
floor the division of delta by integer 100 and delta by integer 400 , sum the two results , multiply integer 6 by it , substitute the result for off .
sum year and off , substitute the result for year .
subtract year from integer 2000 , divide the result by integer 28 , floor the result , multiply it with 28 and increment by year ,
substitute the result for year . call the method dt.timetuple [ dt . timetuple ] , substitute the result for timetuple .
call the function time.strftime [ time . strftime ] with 2 arguments : fmt and and timetuple without the first element ,
added to a tuple with an element year , substitute the result for s1 . call the function _findall with 2 arguments : s1 and year converted into a string , substitute the result for sites1 .
call the function time.strftime [ time . strftime ] with 2 arguments : fmt and and timetuple without the first element ,
added to a tuple with an element sum of year an integer 28 , substitute the result for s2 . call the function _findall with 2 arguments : s2 and sum of year and integer 28 , converted into a string , substitute the result for sites2 .
sites is an empty list .
if site is contained in sites1 ,
if site is contained in sites2 ,
append site to sites .
substitute s1 for s .
syear is a string _STR:0_ formated with dt.year [ dt . year ] .
for every site in sites ,
concatenate first site elements of s , syear and elements of s from the site incremented by integer 4 index , substitute the result for s .
return s .
define the function deconstructible with 2 arguments : unpacked list args and unpacked dictionary kwargs .
remove elements under the _STR:0_ key of the kwargs dictionary , if it exists substitute it for path , if not path is None .
define the function decorator with an argument klass .
define the method __new__ with 3 arguments : cls , unpacked list args and unpacked dictionary kwargs .
call the method __new__ with an argument cls from the base class of the klass function .
obj._constructor_args [ obj . _constructor_args ] is a tuple with 2 elements : args and kwargs .
return obj .
define the function deconstruct with an argument obj .
return a tuple with 3 elements : if path is true , path , in not , a string _STR:0_ formated with obj.__class__.__module__ [ obj . __class__ . __module__ ] ,
and obj.__class__.__name__ [ obj . __class__ . __name__ ] , first element of obj._constructor_args [ obj . _constructor_args ] and second element of obj._constructor_args [ obj . _constructor_args ] . klass.__new__ [ klass . __new__ ] is a static method of the function __new__ .
substitute deconstruct for klass.deconstruct [ klass . deconstruct ] .
return klass .
if args is true ,
return decorator .
call the function decorator with 2 arugments : unpacked list args and unpacked dictionary kwargs , return the result .
from functools import wraps , update_wrapper and WRAPPER_ASSIGNMENTS into default name space .
from django.utils [ django . utils ] import six into default name space .
derive the class classonlymethod from the classmethod base class .
define the method __get__ with 3 arguments : self , instance and owner .
if instance is not None ,
raise an AttributeError exception with an argument string _STR:0_ .
call the method __get__ with 2 arguments : instance and owner , from the base class of the classonlymethod class , return the result .
define the function method_decorator with an argument decorator .
define the function _dec with an argument func .
define the method _wrapper with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
decorator decorator .
define the function bound_func with 2 arguments : unpacked list args2 and unpacked dictionary kwargs2 .
call the method func.__get__ [ func . __get__ ] with 2 arguments : self and type of self object , call the result with 2 arguments :
unpacked list args2 and unpacked dictionary kwargs2 , return the result . call the function bound_func with 2 arguments : unpacked list args and unpacked dictionary kwargs , return the result .
decorator decorator .
define the function dummy with 2 arguments : unpacked list args and unpacked dictionary kwargs .
do nothing .
call the function update_wrapper with 2 arguments : _wrapper and dummy .
call the function update_wrapper with 2 arguments : _wrapper and func .
return _wrapper .
call the function update_wrapper with 3 arguments : _dec , decorator and assigned as result of the function available_attrs ,
called with an argument decorator . if decorator has an attribute _STR:0_ ,
_dec.__name__ [ _dec . __name__ ] is a string _STR:0_ formated with decorator.__name__ [ decorator . __name__ ] .
if not ,
_dec.__name__ [ _dec . __name__ ] is a string _STR:0_ formated with decorator.__class__.__name__ [ decorator . __class__ . __name__ ] .
return _dec .
define the function decorator_from_middleware_with_args with an argument middleware_class .
call the function make_middleware_decorator with an argument middleware_class , return the result .
define the function decorator_from_middleware with an argument middleware_class .
call the function make_middleware_decorator with an argument middleware_class , call the result , return the new result .
define the function available_attrs with an argument fn .
if six.PY3 [ six . PY3 ] is true ,
return WRAPPER_ASSIGNMENTS .
if not ,
if fh has an attribute a , for every a in WRAPPER_ASSIGNMENTS , put a into a tuple , return the resulting tuple .
define the function make_middleware_decorator with an argument middleware_class .
define the function make_decorator with 2 arguments : unpacked list m_args and unpacked dictionary m_kwargs .
call the function middleware_class with 2 arguments : unpacked list m_args and unpacked dictionary m_kwargs ,
substitute the middleware . define the function _decorator with an argument view_func .
decorator function wraps with 2 arguments : view_func and assigned set to result of the function available_attrs ,
called with an argument view_func . define the function _wrapped_view with 3 arguments : request , unpacked list args and unpacked dictionary kwargs .
if middleware has an attribute _STR:0_ ,
call the method middleware.process_request [ middleware . process_request ] with an argument request , substitute the result for result .
if result is not None ,
return result .
if middleware has an attribute _STR:0_ ,
call the method middleware.process_view [ middleware . process_view ] with 4 arguments : request , view_func , args and kwargs , substitute the result for result .
if result is not None ,
return result .
try ,
call the function view_func with 3 arguments : request , unpacked list args , unpacked dictionary kwargs , substitute the result for response .
if Exception , renamed to e , exception is caught ,
if middleware has an attribute _STR:0_ ,
call the method middleware.process_exception [ middleware . process_exception ] with 2 arguments : request and e , substitute the result for result .
if result is not None ,
return result ,
raise an exception .
if response has an attribute _STR:0_ and response.render [ response . render ] is a callable object ,
if middleware has an attribute _STR:0_ ,
call the method middleware.process_template_response [ middleware . process_template_response ] with 2 arguments : request and response , substitute the result for response .
if middleware has an attribute _STR:0_ ,
callback is an lambda function with an argument response and with return value result of the method middleware.process_response [ middleware . process_response ] ,
called with 2 arguments : request and response . call the method response.add_post_render_callback [ response . add_post_render_callback ] with an argument callback .
if not ,
if middleware has an attribute _STR:0_ ,
call the method middleware.process_response [ middleware . process_response ] with 2 arguments : request and response , return the result .
return response .
return _wrapped_view .
return _decorator .
return _make_decorator .
import module inspect .
import module warnings .
derive the class RemovedInDjango20Warning from PendingDeprecationWarning base class .
do nothing .
derive the class RemovedInDjango19Warning from DeprecationWarning base class .
do nothing .
substitute RemovedInDjango19Warning for RemovedInNextVersionWarning .
derive the class warn_about_renamed_method from object base class .
deifne the method __init__ with 5 arguments : self , class_name , old_method_name , new_method_name and deprecation_warning .
substitute class_name for self.class_name [ self . class_name ] .
substitute old_method_name for self.old_method_name [ self . old_method_name ] .
substitute new_method_name for new_method_name .
substitute deprecation_warning for self.deprecation_warning [ self . deprecation_warning ] .
define the method __call__ with 2 arguments : self and f .
define the function wrapped with 2 arguments : unpacked list args and unpacked dictionary kwargs .
call the function warnings.warn [ warnings . warn ] with 3 arguments : string _STR:0_ ,
formated with 3 elements : self.class_name [ self . class_name ] , self.old_method_name [ self . old_method_name ] and self.new_method_name [ self . new_method_name ] , self.deprecation_warning [ self . deprecation_warning ] and integer 2. call the function f with a arguments : unpacked list args and unpacked dictionary kwargs , return the result .
return wrapped .
derive the class RenameMethodsBase from type base class .
renamed_methods is an tuple .
define the method __new__ with 4 arguments : cls , name , bases and attrs .
call the method __new__ with 4 arguments : cls , name , bases and attrs , from the base class of the class RenameMethodsBase .
call the method inspect.getmro [ inspect . getmro ] with an argument new_class , for every base in the result ,
substitute base.__name__ [ base . __name__ ] for class_name .
for every renamed_method in cls.renamed_methods [ cls . renamed_methods ] ,
substitute first element of renamed_method for old_method_name .
get the value under the old_method_name key of the base.__dict__ [ base . __dict__ ] dictionary , substitute it for old_method .
substitute second element of renamed_method for new_method_name .
get the value under the new_method_name key of the base.__dict__ [ base . __dict__ ] dictionary , substitute it for new_method .
substitute third element of renamed_method for deprecation_warning .
call the function warn_about_renamed_method with 2 arguments : class_name and unpacked list renamed_method , substitute the result for wrapper .
if new_method is false and old_method is true ,
call the function warnings.warn [ warnings . warn ] with 3 arguments : string _STR:0_ ,
formated with 3 elements : class_name , old_method_name and new_method_name , deprecation_warning and integer 2. set new_method_name attribute of the base object to old_method .
set old_method_name attribute of the base object to the result of the function wrapper called with an argument old_method .
if old_method is false and new_method is true ,
set old_method_name attribute of the base object to the result of the function wrapper called with an argument new_method .
return new_class .
import module warnings .
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
call the function warnings.warn [ warnings . warn ] with 3 arguments : string _STR:0_ ,
RemovedInDjango19Warning and stacklevel set to integer 2. import module logging.handlers [ logging . handlers ] .
import module re .
import module sys .
import module types .
from django.utils [ django . utils ] import six into default name space .
compile regex from string _STR:0_ in case insensitive mode , substitute it for IDENTIFIER .
define the function valid_ident with an argument s .
match string s with regex IDENTIFIER , substitute the result for m .
if m is false ,
raise an ValueError exception with an argument string _STR:0_ formated with s .
return boolean True .
try ,
from logging import _checkLevel .
if ImportError exception is caught ,
define the function _checkLevel with an argument level .
if level is an instance of int type ,
substitute level for rv .
otherwise if level converted into a string equals level ,
if level is not contained in logging._levelNames [ logging . _levelNames ] ,
raise an ValueError exception with an argument string _STR:0_ formated with level .
substitute value under level key of logging._levelNames [ logging . _levelNames ] dictionary for rv .
if not ,
raise an TypeError exception with an argument string _STR:0_ formated with level .
return rv .
derive the class ConvertingDict from dict base class .
define the method __getitem__ with 2 arguments : self and key .
call the method dict.__getitem__ [ dict . __getitem__ ] with 2 arguments self and key , substitute the result for value .
call the method self.configurator.convert [ self . configurator . convert ] with an argument value , substitute the result for result .
if value is not contained in result ,
substitute result for self dictionary under key key .
if type of result is ConvertingDict , ConvertingList or ConvertingTuple ,
substitute self for result.parent [ result . parent ] .
substitute key for result.key [ result . key ] .
return result .
define the method get with 3 arguments : self , key and default set to None .
get value under key key of self dictionary , if it doesnt exists return default , substitute the result for value .
call the method self.configurator.convert [ self . configurator . convert ] with an argument value , substitute the result for result .
if value is not contained in result ,
substitute result for value under key key of self dictionary .
if type of result is ConvertingDict , ConvertingList or ConvertingTuple ,
substitute self for result.parent [ result . parent ] .
substitute key for result.key [ result . key ] .
return result .
define the method pop with 3 arguments : self , key and default set to None .
remove value under key key of self dictionary , if it doesnt exists return default , substitute the result for value .
call the method self.configurator.convert [ self . configurator . convert ] with an argument value .
if value is not contained in result ,
if type of result is ConvertingDict , ConvertingList or ConvertingTuple ,
substitute self for result.parent [ result . parent ] .
substitute key for result.key [ result . key ] .
return result .
derive the class ConvertingList from list base class .
define the method __getitem__ with 2 arguments : self and key .
call the method list.__getitem__ [ list . __getitem__ ] with 2 arguments self and key , substitute the result for value .
call the method self.configurator.convert [ self . configurator . convert ] with an arugment value , substitute the result for result .
if value is not contained in result ,
substitute result for value under key key of self dictionary .
if type of result is ConvertingDict , ConvertingList or ConvertingTuple ,
substitute self for result.parent [ result . parent ] .
substitute key for result.key [ result . key ] .
return result .
define the method pop with 2 arguments : self and idx set to negative integer 1 .
remove idx-th element from self list .
call the method self.configurator.convert [ self . configurator . convert ] with an argument value , substitute the result for result .
if value is not contained in result ,
if type of result is ConvertingDict , ConvertingList or ConvertingTuple ,
substitute self for result.parent [ result . parent ] .
return result .
derive the class ConvertingTuple from tuple base class .
define the method __getitem__ with 2 arguments : self and key .
call the method tuple.__getitem__ [ tuple . __getitem__ ] with 2 arguments : self and key , substitute the result for value .
call the method self.configurator.convert [ self . configurator . convert ] with an argument value , substitute the result for result .
if value is not contained in result ,
if type of result is ConvertingDict , ConvertingList or ConvertingTuple ,
substitute self for result.parent [ result . parent ] .
substitute key for result.key [ result . key ] .
return result .
derive the class BaseConfigurator from object base class .
compile a regex from raw string _STR:0_ , substitute it for CONVERT_PATTERN .
compile a regex from raw string _STR:0_ , substitute it for WORD_PATTERN .
compile a regex from raw string _STR:0_ , substitute it for DOT_PATTERN .
compile a regex from raw string _STR:0_ , substitute it for INDEX_PATTERN .
compile a regex from raw string _STR:0_ , substitute it for DIGIT_PATTERN .
value_converters is a dictionary with 2 entries : _STR:0_ for _STR:1_ and _STR:2_ for _STR:3_ .
substitute __import__ for importer .
define the method __init__ with 2 arguments : self and config .
self.config [ self . config ] is an instance of ConvertingDict , called with an argument config .
substitute self for self.config.configurator [ self . config . configurator ] .
define the method resolve with 2 arguments : self and s .
split s into parts by _STR:0_ , substitute the result for name .
remove first element from name , substitute the result for used .
try ,
call the method self.importer [ self . importer ] with an argument used , substitute the result for found .
for every frag in name .
append _STR:0_ to frag , append the result to used .
try ,
get frag attribute from found object , substitute it for found .
if AttributeError exception is caught ,
call the method self.importer [ self . importer ] with an argument used .
get frag attribute from found object , substitute it for found .
return found .
if ImportError exception is caught ,
call the method sys.exc_info [ sys . exc_info ] , substitute the result without the first element for e and tb .
raise an ValueError exception with an argument string _STR:0_ , formated with s and e .
substitute e and tb for v.__cause__ [ v . __cause__ ] and v.__traceback__ [ v . __traceback__ ] .
raise an v exception .
define the method ext_convert with 2 arguments : self and value .
call the method self.resolve [ self . resolve ] with an argument value , return the result .
define the method cfg_convert with 2 arguments : self and value .
substitute value for rest .
match rest string with self.WORD_PATTERN [ self . WORD_PATTERN ] regex , substitute the result for m .
if m is None ,
raise an ValueError exception with an argument string _STR:0_ formated with value .
if not ,
call the method m.end [ m . end ] , slice list rest from previous result as starting index to the end , substitute the result for rest .
call the method m.groups [ m . groups ] , use the first element of the result as key for obtaining value from self.config [ self . config ] dictionary ,
substitute it for d. while rest is true ,
match rest string with self.DOT_PATTERN [ self . DOT_PATTERN ] regex , substitute the result for m .
if m is true ,
call the method m.groups [ m . groups ] , use the first element of the result as key for obtaining value from d dictionary ,
if not ,
match rest string with self.INDEX_PATTERN [ self . INDEX_PATTERN ] regex , substitute the result for m .
if m is true ,
call the method m.groups [ m . groups ] , substitute the first element of the result for idx .
match rest string with self.DIGIT_PATTERN [ self . DIGIT_PATTERN ] regex , if it evaluates to false ,
substitute value under idx key of dictionary d for d .
if not ,
try ,
convert idx to an integer , substitute it or n .
substitute value under n key of dictionary d for d .
if TypeError exception is caught ,
substitute value under idx key of dictionary d for d .
if m is true ,
call the method m.end [ m . end ] , slice list rest from previous result as starting index to the end , substitute the result for rest .
if not ,
raise an ValueError exception with an argument string _STR:0_ formated with value and rest .
return d .
define the method convert with 2 arguments : self and value .
if vale is not an instance of ConvertingDict and value is an instance of dict type ,
value is an instance of ConvertingDict class , created with an argument value .
substitute self for value.configurator [ value . configurator ] .
otherwise if vale is not an instance of ConvertingList and value is an instance of list type ,
value is an instance of ConvertingList class , created with an argument value .
substitute self for value.configurator [ value . configurator ] .
otherwise if vale is not an instance of ConvertingTuple and value is an instance of tuple type ,
value is an instance of ConvertingTuple class , created with an argument value .
substitute self for value.configurator [ value . configurator ] .
otherwise if vale is an instance of value ,
match value string with regex self.CONVERT_PATTERN [ self . CONVERT_PATTERN ] , substitute the result for m .
if m is true ,
call the method m.groupdict [ m . groupdict ] , substitute the result for d .
substitute value under the _STR:0_ key of dictionary d , substitute it for prefix .
remove self.value_converters [ self . value_converters ] dictionary element under prefix key , if it exists substitute it for converter , if not , converter is None .
if converter is true ,
substitute value under the _STR:0_ key of dictionary d , substitute it for suffix .
get converter attribute from self object , substitute it for converter .
call the function converter with an argument suffix , substitute the result for value .
return value .
define the method configure_custom with 2 arguments : self and config .
remove config dictionary element under _STR:0_ key , substitute it for c .
if c doesnt have an attribute _STR:0_ and types has an _STR:1_ attribute and type of c is not equal to types.ClassType [ types . ClassType ] ,
call the method self.resolve [ self . resolve ] with an argument c , substitute the result for c .
remove config dictionary element under _STR:0_ key , if it exists substitute it for props , if not , props is None .
kwargs is a dictionary with elements : config dictionary element under k key for k , for every k in result of function valid_ident ,
called with an argument k. call the function c with an argument unpacked dictionary kwargs , substitute the result for result .
if props is true ,
for every name and value in items of props dictionary ,
set result attribute name to value value .
return result .
define the method as_tuple with 2 arguments : self and value .
if valu is an instance of list type ,
convery value into a tuple , substitute it for value .
return value .
derive the class DictConfigurator from the BaseConfigurator base class .
define the method configure with an argument self .
substitute self.config [ self . config ] for config .
if string _STR:0_ is not contained in config ,
raise an ValueError exception with an argument string _STR:0_ .
if config dictionary value under _STR:0_ key is not equal to integer 1 ,
raise an ValueError exception with an argument string _STR:0_ formated with value under _STR:1_ key of config dictionary .
get config dictionary element under _STR:0_ key , if it exists substitute it for incremental , if not ,
incremental is boolean False . EMPTY_DICT is an empty dictionary .
call the method logging._acquireLock [ logging . _acquireLock ] .
try ,
if incremental is true ,
get config dictionary element under _STR:0_ key , if it exists substitute it for handlers , if not , handlers is EMPTY_DICT .
if first two elements of sys.version_info [ sys . version_info ] equal to integers 2 ant 7 , respectively ,
for every name in handlers ,
if name is not contained in logging._handlers [ logging . _handlers ] ,
raise an ValueError exception with an argument string _STR:0_ formated with name .
if not ,
try ,
substitute value under name key of logging._handlers [ logging . _handlers ] dictionary for handler .
substitute value under name key of handlers dictionary for handler_config .
get handler_config dictionary element under _STR:0_ key , if it exists substitute it for level , if not , level is None .
if level is true ,
call the function _checkLevel with an argument level , use the result as an argument for the call to the function handler.setLevel [ handler . setLevel ] .
if StandardError , renamed to e , exception is caught ,
raise an ValueError exception with an argument string _STR:0_ formated with name and e .
get config dictionary element under _STR:0_ key , if it exists substitute it for loggers , if not , loggers is EMPTY_DICT .
for every name in loggers ,
try ,
call the method self.configure_logger [ self . configure_logger ] with 3 arguments : name , value under name key of loggers dictionary and boolean True .
if StandardError , renamed to e , exception is caught ,
raise an ValueError exception with an argument string _STR:0_ formated with name and e .
get config dictionary element under _STR:0_ key , if it exists substitute it for root , if not , root is None .
if root is true ,
try ,
call the method self.configure_root [ self . configure_root ] with 2 arguments : root and boolean True .
if StandardError , renamed to e , exception is caught ,
raise an ValueError exception with an argument string _STR:0_ formated with e .
if not ,
remove config dictionary element under _STR:0_ key , if it exists substitute it for disable_existing , if not ,
disable_existing is boolean True . call the method logging._handler.clear [ logging . _handler . clear ] .
delete logging._handlerList [ logging . _handlerList ] list .
get config dictionary element under _STR:0_ key , if it exists substitute it for formatters , if not , formatters is EMPTY_DICT .
for every name in formatters ,
try ,
call the method self.configure_filter [ self . configure_filter ] with an argument value under name key of formatters dictionary ,
substitute the result for formatters dictionary value under name key . if StandardError , renamed to e , exception is caught ,
raise an ValueError exception with an argument string _STR:0_ formated with name and e .
get config dictionary element under _STR:0_ key , if it exists substitute it for filters , if not , filters is EMPTY_DICT .
for every name in filters ,
try ,
call the method self.configure_filter [ self . configure_filter ] with an argument value under name key of filters dictionary ,
substitute the result for filters dictionary value under name key . if StandardError , renamed to e , exception is caught ,
raise an ValueError exception with an argument string _STR:0_ formated with name and e .
get config dictionary element under _STR:0_ key , if it exists substitute it for handlers , if not , handlers is EMPTY_DICT .
sort elements of handlers , for every name in result ,
try ,
call the method self.configure_handler [ self . configure_handler ] with an argument value under name key of handlers dictionary , substitute the result for handler .
substitute name for handler.name [ handler . name ] .
substitute handler for value under name key of handlers dictionary .
if StandardError , renamed to e , exception is caught ,
raise an ValueError exception with an argument string _STR:0_ formated with name and e .
substitute logging.root [ logging . root ] for root .
convert root.manager.loggerDict [ root . manager . loggerDict ] into a list , substitute it for existing .
sort elements of list existing .
child_loggers is an empty list .
get config dictionary element under _STR:0_ key , if it exists substitute it for loggers , if not , loggers is EMPTY_DICT .
for every name in loggers ,
if name is contained in existing ,
get the index of first occurrence of name in existing , substitute it for i .
append _STR:0_ to name , substitute the result for prefixed .
substitute length of prefixed for pflen .
substitute length of existing for num_existing .
increment i by integer 1 , substitute the result for i .
while i is lesser than num_existing and first pflen elements of i-th element of existing equals prefixed ,
append i-th element of existing to child_loggers .
increment i by integer 1 , substitute the result for i .
remove name from existing .
try ,
call the method self.configure_logger [ self . configure_logger ] with 2 arguments : name and value under loggers dictionary key name .
if StandardError , renamed to e , exception is caught ,
raise an ValueError exception with an argument string _STR:0_ formated with name and e .
for every log in existing ,
get the value under log key of root.manager.loggerDict [ root . manager . loggerDict ] dictionary , substitute it for logger .
if log is contained in child_loggers ,
substitute logging.NOTSET [ logging . NOTSET ] for logger.level [ logger . level ] .
logger.handlers [ logger . handlers ] is an empty list .
logger.propagate [ logger . propagate ] is boolean True .
otherwise if disable_existing is true ,
logger.disabled [ logger . disabled ] is boolean True .
get config dictionary element under _STR:0_ key , if it exists substitute it for root , if not , root is None .
if root is true ,
try ,
call the method self.configure_root [ self . configure_root ] with an argument root .
if StandardError , renamed to e , exception is caught ,
raise an ValueError exception with an argument string _STR:0_Unable to configure root logger : % s ' formated with e .
finally perform ,
call the method logging._releaseLock [ logging . _releaseLock ] .
define the method configure_formatter with 2 arguments : self and config .
if string _STR:0_ is contained in config ,
substitute config dictionary value under _STR:0_ key for factory .
try ,
call the method self.configure_custom [ self . configure_custom ] with an argument config , substitute the result for result .
if TypeError , renamed to te , exception is caught ,
if string _STR:0_ is not contained in e converted into a string ,
raise an exception .
remove config dictionary entry under _STR:0_ key , substitute it for value under _STR:1_ key of config dictionary .
substitute factory for value under _STR:0_ key of config dictionary .
call the method self.configure_custom [ self . configure_custom ] with an argument config , substitute the result for result .
if not ,
get config dictionary element under _STR:0_ key , if it exists substitute it for fmt , if not , fmt is None .
get config dictionary element under _STR:0_ key , if it exists substitute it for dfmt , if not , dfmt is None .
call the method logging.Formatter [ logging . Formatter ] with 2 arguments : fmt and dfmt , substitute the result for result .
return result .
define the method configure_filter with 2 arguments : self and config .
if string _STR:0_ is contained in config ,
call the method self.configure_custom [ self . configure_custom ] with an argument config , substitute the result for result .
if not ,
remove config dictionary element under _STR:0_ key , if it exists substitute it for name , if not , name is an empty string .
call the method logging.Filter [ logging . Filter ] with an argument name , substitute the result for result .
return result .
define the method add_filters with 3 arguments : self , filterer and filters .
for every f in filters ,
try ,
get the value under f key of dictionary under _STR:0_ key of self.config [ self . config ] dictionary ,
use the result as an argument for the call to the method filterer.addFilter [ filterer . addFilter ] . if StandardError , renamed to e , exception is caught ,
raise an ValueError exception with an argument string _STR:0_ formated with f and e .
define the method configure_handler with 2 arguments : self and config .
remove config dictionary element under _STR:0_ key , if it exists substitute it for formatter , if not , formatter is None .
if formatter is true ,
try ,
get the value under formatter key of dictionary under _STR:0_ key of self.config [ self . config ] dictionary , substitute the result for formatter .
if StandardError , renamed to e , exception is caught ,
raise an ValueError exception with an argument string _STR:0_ formated with formatter and e .
remove config dictionary element under _STR:0_ key , if it exists substitute it for level , if not , level is None .
remove config dictionary element under _STR:0_ key , if it exists substitute it for filters , if not , filters is None .
if string _STR:0_ is contained in config ,
remove config dictionary element under _STR:0_ key , substitute it for c .
if c doesnt have an attribute _STR:0_ , and types has an attribute _STR:1_ , and type of c is not equal to types.ClassType [ types . ClassType ] ,
call the method self.resolve [ self . resolve ] with an argument c , substitute the result for c .
substitute c for factory .
if not ,
remove config dictionary element under _STR:0_ key , use it as an argument for the call to the method self.resolve [ self . resolve ] ,
substitute the result for klass . if klass is a subclass of logging.handlers.MemoryHandler [ logging . handlers . MemoryHandler ] base class and string _STR:0_ is contained in config ,
try ,
get value under _STR:0_ key of config dictionary , use it as a key to get the value from the dictionary ,
under the _STR:0_ key of self.config [ self . config ] dictionary , substitute the result for value under _STR:1_ key of config dictioanry . if StandardError , renamed to e , exception is caught ,
raise an ValueError exception with an argument string _STR:0_ ,
formated with value under _STR:0_ key of config dictionary and e. otherwise if klass is a subclass of logging.handlers.SMTPHandler [ logging . handlers . SMTPHandler ] and string _STR:1_ is contained in config ,
call the method self.as_tuple [ self . as_tuple ] with an argument value under _STR:0_ key of config dictionary ,
substitute the result for value under _STR:0_ key of config dictionary . otherwise if klass is subclass of logging.handlers.SysLogHandler [ logging . handlers . SysLogHandler ] class , and string _STR:1_ is contained in config ,
call the method self.as_tuple [ self . as_tuple ] with an argument value under _STR:0_ key of config dictionary ,
substitute the result for value under _STR:0_ key of config dictionary . substitute klass for factory .
kwargs is a dictionary created with tuples with 2 elements : k and value under k key of config dictionary ,
for every k in config , only if result of the function valid_ident called with an argument k evaluates to true . try ,
call the function factory with an argument unpacked dictionary kwargs , substitute the result for result .
if TypeError , renamed to te , exception is caught ,
if _STR:0_ is not contained in te converted into a string ,
raise an exception .
remove element under _STR:0_ key of kwargs dictionary , substitute the result for value under _STR:1_ key of kwargs dictionary .
call the function factory with an argument unpacked dictionary kwargs , substitute the result for result .
if formatter is true ,
call the method result.setFormatter [ result . setFormatter ] with an argument formatter .
if level is not None ,
call function _checkLevel with an argument level , use the result as an argument for the method result.setLevel [ result . setLevel ] .
if filters is true ,
call the method self.add_filters [ self . add_filters ] with 2 arguments : result and filters .
return result .
define the method add_handlers with 3 arguments : self , logger and handlers .
for every h in handlers ,
try ,
call the method logger.addHandler [ logger . addHandler ] with an argument : h-th element of value under _STR:0_ key of self.config [ self . config ] dictionary .
if StandardError , renamed to e , exception is caught ,
raise an ValueError exception with an argument string _STR:0_ formated with h and e .
define the method common_logger_config with 4 arguments : self , logger , config and incremental set to boolean False .
get value under the _STR:0_ key of the config dictioanry , if it exists substitute it for level , if not level is None .
if level is not None ,
call the function _checkLevel with an argument level , use the result as an argument for the call to the method logger.setLevel [ logger . setLevel ] .
if incremental is true ,
for every h in elements of logger.handlers [ logger . handlers ] list ,
call the method logger.removeHandler [ logger . removeHandler ] with an argument h .
get value under the _STR:0_ key of the config dictioanry , if it exists substitute it for handlers , if not handlers is None .
if handlers is true ,
call the method self.add_handlers [ self . add_handlers ] with 2 arguments : logger and handlers .
get value under the _STR:0_ key of the config dictioanry , if it exists substitute it for filters , if not filters is None .
if filters is true ,
call the method self.add_filters [ self . add_filters ] with 2 arguments : logger and filters .
define the method configure_logger with 4 arguments : self , name , config , incremental set to boolean False .
call the method logging.getLogger [ logging . getLogger ] with an argument name , substitute the result for logger .
call the method self.common_logger_config [ self . common_logger_config ] with 3 arguments : logger , config and incremental .
get value under the _STR:0_ key of the config dictioanry , if it exists substitute it for propagate , if not propagate is None .
if propagate is not None ,
substitute propagate for logger.propagate [ logger . propagate ] .
define the method configure_root with 3 arguments : self , config and incremental set to boolean False .
call the method logging.getLogger [ logging . getLogger ] , substitute the result for root .
call the method self.common_logger_config [ self . common_logger_config ] with 3 arguments : root , config and incremental .
substitute DictConfigurator for dictConfigClass .
define the function dictConfig with an argument config .
call the method dictConfigClass with an argument config , call the method configure on the result .
from __future__ import unicode_literals into default name space .
import module codecs .
import module datetime .
from decimal import Decimal into default name space .
import module locale .
from django.utils.functional [ django . utils . functional ] import Promise into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.six.moves.urllib.parse [ django . utils . six . moves . urllib . parse ] import quote into default name space .
derive the class DjangoUnicodeDecodeError from the base class UnicodeDecodeError .
define the private method __init__ , with self instance of this class , obj and list of arbitrary length *args as arguments .
assign obj to the obj field of self instance of this class .
call the initialization method UnicodeDecodeError.__init__ [ UnicodeDecodeError . __init__ ] , with self instance of this class and *args as arguments .
define the private method __str__ , with self instance of this class as the only argument .
call the method UnicodeDecodeError.__str__ [ UnicodeDecodeError . __str__ ] , with self as the argument , substitute the result for original .
in the string _STR:0_ replace every % s with original and type of the object self.obj [ self . obj ] as strings , respectively ,
and replace % r with self.obj [ self . obj ] , return the result . define function python_2_unicode_compatible , with klass as an argument .
if field PY2 of the module six is boolean True ,
if string _STR:0_ is not contained in __dict__ field of klass ,
raise the exception ValueError , with string as argument , _STR:0_ ,
_STR:0_ , replace % s with string value of klass.__name__ [ klass . __name__ ] . substitute __str__ filed of klass for __unicode__ field of klass .
define lambda function with self class instance as the argument , lambda function body encapsulates the call to the method ,
str.__unicode__ [ str . __unicode__ ] ( ) .encode ( _STR:0_ ) , call the lambda function and put the result in the __str__ filed of klass . return klass .
define the function smart_text , with s , encoding set to string _STR:0_ , strings_only set to False , errors set to _STR:1_ as arguments .
if s is instance of a class Promise ,
return s .
return the result of the call to the function force_text , with s , encoding , string_only and errors as arguments .
_PROTECTED_TYPES is a tuple containing next elements , six.integer_types [ six . integer_types ] , type of None , type of float , Decimal , detetime.datetime [ detetime . datetime ] ,
datetime.date [ datetime . date ] and datetime.time [ datetime . time ] . define the function is_protected_type with obj as the only argument .
check if obj is instance of the object _PROTECTED_TYPES , return the boolean result .
define the function force_text , with s , encoding set to _STR:0_ , strings_only set to False , errors set to string _STR:1_ as arguments .
if s is the instance of the object six.text_type [ six . text_type ] ,
return s .
if the boolean return vale of the call to the function is_protected_type ( s ) and string_onlys are boolean True ,
return s .
try ,
if s is not an instance of the object six/string_types ,
if PY3 filed of six is boolean True ,
if s is an instance of object bytes ,
call the function six.text_type [ six . text_type ] with s , encoding and errors as the arguments , substitute the result for s .
if not ,
call the function six.text_type [ six . text_type ] with s as an argument , substitute the result for s .
otherwise , if s has an attribute _STR:0_ ,
call the function six.text_type [ six . text_type ] with s as an argument , substitute result for s .
if not ,
call the function six.text_type [ six . text_type ] with return value of the function bytes ( s ) , encoding and errors as the arguments ,
substitute the result for s. if not ,
call the method s.decode [ s . decode ] with encoding and errors as the arguments , substitute the result for s .
if an exception of the type UnicodeDecodeError , renamed to e , is caught ,
if s is not an instance of the object Exception ,
raise an exception DjingoUnicodeDecodeError , with s and list of arguments *args from object e , as the arguments .
if not ,
for every arg in s , call the function force_text with arg , encoding , strings_only and errors as arguments ,
join the result in a string separated by whitespaces , substitute it for s. return s .
define function smart_bytes with s , encoding set to string _STR:0_ , strings_only set to False and errors set to string _STR:1_ , as arguments .
if s is an instance of an object Promise .
return s .
evaluate the function force_bytes , with the arguments s , encoding , strings_only and errors , return the result .
define function force_bytes with s , encoding set to _STR:0_ , strings_only set to False and errors set to _STR:1_ as arguments .
if s is an instance of an object bytes .
if encoding equals to string _STR:0_ .
return s .
if not ,
evaluate the method s.decode [ s . decode ] with string _STR:0_ and errors as the arguments ,
on the result call the method encode with the arguments encoding and errors , return the result . if strings_only and boolean return value of the call to the function is_protected_type for argument s are boolean True ,
return s .
if s is an instance of an object six.memoryview [ six . memoryview ] .
evaluate the function bytes with the argument s , and return the result .
if s is an instance of an object Promise .
return six.text_type [ six . text_type ] ( s ) .encode ( encoding , errors ) .
if s is not an instance of the object six.string_types [ six . string_types ] ,
try ,
if PY3 field of six is boolean True ,
evaluate the method six.text_type [ six . text_type ] ( s ) , on the result call the method encode with encoding as an argument , return the result .
if not ,
evaluate the function bytes with the argument s , and return the result .
if the UnicodeEncodeError exception is caught ,
if s is an instance of the subclass Exception ,
for every arg in s , evaluate the function force_bytes for the arguments arg , encoding , strings_only and errors ,
put the results in a list , join the list elements in a string separated by whitespace separator , return the string as the bytes string . evaluate the method six.text_type [ six . text_type ] ( s ) , on the result call the method encode with the arguments encoding and errors , return the result .
if not ,
evaluate the member method of s , encode with the encoding and errors as the arguments , return the result .
if PY3 field of module six is boolean True ,
substitute smart_text for smart_str .
substitute force_text for force_str .
if not ,
substitute smart_bytes for smart_str .
substitute force_bytes for force_str .
substitute smart_text for smart_unicode .
substitute force_text for force_unicode .
define the function iri_to_uri with iri as an argument .
if iri is not initialized ,
return iri .
call the function quote with return value of the evaluated function force_bytes ( iri ) ,
and with safe set to bytes string _STR:0_ , return the result . define function filepath_to_uri with path as the argument .
if path is not initialized ,
return path .
evaluate function force_bytes with path as the argument , replace all of the occurancies of the _STR:0_/ '' in the resulting string ,
call the function quote with the result and with the safe set to bytes string _STR:0_ , return the function result . define the function get_system_encoding without the input arguments .
try ,
evaluate the function getdefaultlocale from the module locale , if second element of return value exists assign it to encoding ,
otherwise assign string _STR:0_ to encoding . call the method lookup with the encoding as the argument .
if the Exception exception is caught ,
substitute string _STR:0_ for encoding .
return encoding .
evaluate the function get_system_encoding ( ) , substitute the return vale for DEFAULT_LOCALE_ENCODING .
from __future__ import unicode_literals into default name space .
import module datetime .
from django.utils.xmlutils [ django . utils . xmlutils ] import SimplerXMLGenerator into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_text and iri_to_uri into default name space .
from django.utils [ django . utils ] import datetime_safe into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.six [ django . utils . six ] import StringIO into default name space .
from django.utils.six.moves.urllib.parse [ django . utils . six . moves . urllib . parse ] import urlparse into default name space .
from django.utils.timezone [ django . utils . timezone ] import is_aware into default name space .
define the function rfc2822_date with an argument date .
months is a tuple with 12 elements : strings _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ , _STR:5_ , _STR:6_ , _STR:7_ , _STR:8_ , _STR:9_ , _STR:10_ and _STR:11_ .
days is a tuple with 7 elements : strings _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ , _STR:5_ and _STR:6_ .
call the method datetime_safe.new_datetime [ datetime_safe . new_datetime ] with an argument date , substitute the result for date .
call the method date.weekday [ date . weekday ] , use the result as an key to obtain the value from the days dictionary , substitute it for dow .
decrement date.month [ date . month ] by integer 1 , use the result as an key to obtain the value from the months dictionary , substitute it for month .
call the function date.strftime [ date . strftime ] with an argument string _STR:0_ formated with dow and month ,
substitute the result for time_str . if six.PY2 [ six . PY2 ] is true ,
call the method time_str.decode [ time_str . decode ] with an argument string _STR:0_ , substitute the result for time_str .
call the function is_aware with an argument date , if it evaluates to true ,
call the method date.tzinfo.utcoffset [ date . tzinfo . utcoffset ] with an argument date , substitute the result for offset .
multiply offset.days [ offset . days ] , integer 24 and integer 60 , sum the result with floored result of dividing offset.seconds [ offset . seconds ] by integer 60 ,
substitute the result for timezone . divide timezone by integer 60 , substitute the quotient of the division for hour and reminder for minute .
format string _STR:0_ with hour and minute , append it to time_str , return the result .
if not ,
append string _STR:0_ to time_str , return the result .
define the function rfc3339_date with an argument date .
call the function datetime_safe.new_datetime [ datetime_safe . new_datetime ] with an argument date , substitute the result for date .
call the function date.strftime [ date . strftime ] with an argument string _STR:0_ , substitute the result for time_str .
if six.PY2 [ six . PY2 ] ,
call the method time_str.decode [ time_str . decode ] with an argument string _STR:0_ , substitute the result for time_str .
call the function is_aware with an argument date , if it evaluates to true ,
call the method date.tzinfo.utcoffset [ date . tzinfo . utcoffset ] with an argument date , substitute the result for offset .
multiply offset.days [ offset . days ] , integer 24 and integer 60 , sum the result with floored result of division of offset.seconds [ offset . seconds ] ,
and integer 60 , substitute the result for timezone . divide timezone by integer 60 , substitute the quotient of the division for hour and reminder for minute .
format string _STR:0_ with hour and minute , append it to time_str , return the result .
if not ,
append _STR:0_ to time_str , return the result .
define the function get_tag_uri with 2 arguments : url and date .
call the method urlparse with an argument url , substitute the result for bits .
d is an empty string .
if date is not None ,
call the function datetime_safe.new_datetime [ datetime_safe . new_datetime ] with an argument date , on the result call the method strftime with an argument ,
string _STR:0_ , convert the result into a string and append it to _STR:1_ , substitute the result for d. format string _STR:2_ with bits.hostname [ bits . hostname ] , d , bits.path [ bits . path ] and bits.fragment [ bits . fragment ] , return it .
derive the class SyndicationFeed from the object base class .
define the method __init__ with 15 elements : self , title , link , description , language set to None , author_email set to None ,
author_name set to None , author_link set to None , subtitle set to None , categories set to None , feed_url set to None , feed_copyright set to None , feed_guid set to None , ttl set to None and unpacked dictionary kwargs . to_unicode is an lambda function with an argument s , result is the result of the function force_text ,
called with 2 arguments : s and string_only as boolean True . if categories is true ,
categories is a list containing the results of the function force_text , called with an argument c , for every c in categories .
if ttl is not None ,
call the function force_text with an argument ttl , substitute the result for ttl .
self.feed [ self . feed ] is an dictionary with 13 initial entries , result of the function to_unicode called with an argument title for _STR:0_ ,
result of the function iri_to_uri called with an argument link for _STR:0_ , result of the function to_unicode called with an argument description for _STR:1_ , result of the function to_unicode called with an argument language for _STR:2_ , result of the function to_unicode called with an author_email description for _STR:3_ , result of the function to_unicode called with an argument author_name for _STR:4_ , result of the function iri_to_uri called with an argument author_link for _STR:5_ , result of the function to_unicode called with an argument subtitle for _STR:6_ , if true , categories is value for _STR:7_ key , if not , empty tuple is value for _STR:7_ key , result of the function iri_to_uri called with an argument feed_url for _STR:8_ , result of the function to_unicode called with an argument feed_copyright for _STR:9_ , if true , feed_guid is value for _STR:10_ key , if not , lik is value for _STR:10_ key and ttl for _STR:11_ . update self.feed [ self . feed ] dictionary with kwargs .
self.items [ self . items ] is an empty list .
define the method add_item with 17 arguments : self , title , link , description , author_email set to None , author_name set to None ,
to_unicode is an lambda function with an argument s , result is the result of the function force_text ,
called with 2 arguments : s and string_only as boolean True . if categories is true ,
categories is a list containing the results of the function to_unicode , called with an argument c , for every c in categories .
if ttl is not None ,
call the function force_text with an argument ttl , substitute the result for ttl .
item is a dictionary with 15 initial entries : result of the function to_unicode called with an argument title for _STR:0_ ,
result of the function iri_to_uri called with an argument link for _STR:0_ , result of the function to_unicode called with an argument description for _STR:1_ , result of the function to_unicode called with an argument author_email for _STR:2_ , result of the function to_unicode called with an argument author_name for _STR:3_ , result of the function iri_to_uri called with an author_link link for _STR:4_ , pubdate for _STR:5_ , updateddate for _STR:6_ , result of the function to_unicode called with an comments author_name for _STR:7_ , result of the function to_unicode called with an argument unique_id ) for _STR:8_ , unique_id_is_permalink for _STR:9_ , enclosure for _STR:10_ , if true , categories is value for _STR:11_ key , if not , empty tuple is value for _STR:11_ key , result of the function to_unicode called with an argument item_copyright for _STR:12_ , ttl for _STR:13_ . update dictionary item with an argument kwargs .
append item to self.items [ self . items ] .
define the method num_items with an argument self .
return length of self.items [ self . items ] .
define the method root_attributes with an argument self .
return an empty dictionary .
define the method add_root_elements with 2 arguments self and handler .
do nothing .
define the method item_attributes with 2 arguments self and item .
return an empty dictionary .
define the method add_item_elements with 2 arguments , handler self and item .
do nothing .
define the method write with 3 arguments self , outfile and encoding .
raise an NotImplementedError with an argument string _STR:0_ .
define the method writeString with 2 arguments self and encoding .
s is an instance of StringIO class .
call the method self.write [ self . write ] with 2 arguments : s and encoding .
call the method s.getvalue [ s . getvalue ] , return the result .
define the method latest_post_date with an argument self .
latest_date is None .
date_keys is a tuple with 2 arguments : strings _STR:0_ and _STR:1_ .
for every item in self.items [ self . items ] ,
for every date_key in date_keys ,
get the value under the date_key key of the item dictionary , substitute it for item_date .
if item_date is true ,
if latest_date is None or item_date is greater than latest_date ,
substitute item_date for latest_date .
if latest_date is true , return it , if not , call the method datetime.datetime.now [ datetime . datetime . now ] and return the result .
derive the class Enclosure from the object base class .
define the method __init__ with 4 arguments : self , url , length and mime_type .
substitute length and mime_type for self.length [ self . length ] and self.mime_type [ self . mime_type ] .
call the function iri_to_uri with an argument url , substitute the result for self.url [ self . url ] .
derive the class RssFeed from the SyndicationFeed base class .
mime_type is a string _STR:0_ .
define the method write with 3 arguments : self , outfile and encoding .
handler is an instance of SimplerXMLGenerator class , created with 2 arguments : outfile and encoding .
call the method handler.startDocument [ handler . startDocument ] .
call the method handler.startElement [ handler . startElement ] with 2 arguments : string _STR:0_ and result of the method self.rss_attributes [ self . rss_attributes ] .
call the method handler.startElement [ handler . startElement ] with 2 arguments : string _STR:0_ and result of the method self.root_attributes [ self . root_attributes ] .
call the method self.add_root_elements [ self . add_root_elements ] with an argument handler .
call the method self.write_items [ self . write_items ] with an argument handler .
call the method self.endChannelElement [ self . endChannelElement ] with an argument handler .
call the method handler.endElement [ handler . endElement ] with an argument string _STR:0_ .
define the method rss_attributes with an argument self .
return a dictionary with 2 elements : self._version [ self . _version ] for _STR:0_ and _STR:1_ for _STR:2_ .
define the method write_items with 2 arguments : self and handler .
for every item in self.items [ self . items ] ,
call the method handler.startElement [ handler . startElement ] with 2 arguments : string _STR:0_ and result of the method self.item_attributes [ self . item_attributes ] with an argument item .
call the method self.add_item_elements [ self . add_item_elements ] with 2 arguments : handler and item .
call the method handler.endElement [ handler . endElement ] with an argument string _STR:0_ .
define the method add_root_elements with 2 arguments : self and handler .
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:0_ key of the self.feed [ self . feed ] dictionary .
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:0_ key of the self.feed [ self . feed ] dictionary .
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:0_ key of the self.feed [ self . feed ] dictionary .
if value under the _STR:0_ key of the self.feed [ self . feed ] dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 3 arguments : string _STR:0_ , None and dictionary with 2 entries : _STR:1_ for _STR:2_ ,
value under the _STR:0_ key of the self.feed [ self . feed ] dictionary for _STR:1_ . if value under the _STR:2_ key of the self.feed [ self . feed ] dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:0_ key of the self.feed [ self . feed ] dictionary .
for every cat in value under the _STR:0_ key of the self.feed [ self . feed ] dictionary .
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and cat .
if value under the _STR:0_ key of the self.feed [ self . feed ] dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:1_ key of the self.feed [ self . feed ] dictionary .
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and result of the function rfc2822_date ,
called with an argument result of the method self.latest_post_date [ self . latest_post_date ] . if value under the _STR:0_ key of the self.feed [ self . feed ] dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:0_ key of the self.feed [ self . feed ] dictionary .
define the method endChannelElement with 2 arguments : self and handler .
call the method handler.endElement [ handler . endElement ] with an argument string _STR:0_ .
derive the class RssUserland091Feed from the RssFeed base class .
_version is a string _STR:0_ .
define the method add_item_elements with 3 arguments : self , handler and item .
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:0_ key of the item dictionary .
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:0_ key of the item dictionary .
if value under the _STR:0_ key of the item dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:0_ key of item dictionary .
derive the class Rss201rev2Feed from the RssFeed base class .
_version is a string _STR:0_ .
define the method add_item_elements with 3 arguments : self , handler and item .
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:0_ key of the item dictionary .
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:0_ key of the item dictionary .
if value under the _STR:0_ key of the item dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:0_ key of the item dictionary .
if values under _STR:0_ and _STR:1_ keys of the item dictionary are both true ,
call the method handler.addQuickElement [ handler . addQuickElement ] with an argument string _STR:0_ , _STR:1_ ,
formated with values under the _STR:0_ and _STR:1_ keys of item dictionary . otherwise if value under the _STR:2_ key of the item dictionary is true ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:1_ key of the item dictionary .
otherwise if value under the _STR:0_ key of the item dictionary is true ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 3 arguments : string _STR:0_ ,
value under the _STR:0_ key of the item dictionary and dictionary with an entry : _STR:1_ for _STR:2_ . if value under the _STR:3_ key of the item dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and result of the function rfc2822_date ,
called with value under the _STR:0_ key of the item dictionary . if value under the _STR:1_ key of the item dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:0_ key of the item dictionary .
if value under the _STR:0_ key of the item dictionary is not None ,
guid_attrs is an empty dictionary .
if value object the _STR:0_ key of the item dictionary is an instance of bool type ,
covert to string value under the _STR:0_ key of the item dictionary , convert it to lowercase ,
substitute the result for value under the _STR:0_ key of the guid_attrs dictionary . call the method handler.addQuickElement [ handler . addQuickElement ] with 3 arguments : string _STR:1_ , value under the _STR:2_ key of the item dictionary ,
and guid_attrs . if value under the _STR:0_ key of the item dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:0_ key of the item dictionary .
if value under the _STR:0_ key of the item dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 3 arguments : string _STR:0_ , an empty string and a dictionary with 3 entries :
field url of the value under the _STR:0_ key of the item dictionary for _STR:1_ , field length of the value under the _STR:0_ key of the item dictionary for _STR:2_ , and field mime_type of the value under the _STR:0_ key of the item dictionary for _STR:3_ . for every cat in value under the _STR:4_ key of the item dictionary ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and cat .
derive the class Atom1Feed from the SyndicationFeed base class .
mime_type is a string _STR:0_ .
ns is a string _STR:0_ .
define the method write with 3 arguments : self , outfile and encoding .
handler is an instance of SimplerXMLGenerator class , created with 2 arguments : outfile and encoding .
call the method handler.startDocument [ handler . startDocument ] .
call the method handler.startElement [ handler . startElement ] with 2 arguments : string _STR:0_ and result of the method self.root_attributes [ self . root_attributes ] .
call the method self.add_root_elements [ self . add_root_elements ] with an argument handler .
call the method self.write_items [ self . write_items ] with an argument handler .
call the method handler.endElement [ handler . endElement ] with an argument string _STR:0_ .
define the method root_attributes with an argument self .
if value under the _STR:0_ key of the self.feed [ self . feed ] dictionary is not None ,
return a dictionary with 2 entries : value under the _STR:0_ key of the self.feed [ self . feed ] dictionary for _STR:1_ ,
and self.ns [ self . ns ] for _STR:0_ . if not ,
return a dictionary with an entry : self.ns [ self . ns ] for _STR:0_ .
define the method add_root_elements with 2 arguments : self and handler .
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:0_ key of the self.feed [ self . feed ] dictionary .
call the method handler.addQuickElement [ handler . addQuickElement ] with 3 arguments : string _STR:0_ , an empty string and a dictionary with 2 entries :
_STR:0_ for _STR:1_ and value under the _STR:2_ key of self.feed [ self . feed ] dictionary for _STR:3_ . if value under the _STR:4_ key of the self.feed [ self . feed ] dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 3 arguments : string _STR:0_ , an empty string and a dictionary with 2 entries :
_STR:0_ for _STR:1_ and value under the _STR:2_ key of self.feed [ self . feed ] dictionary for _STR:3_ . call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:4_ and value under the _STR:4_ key of the self.feed [ self . feed ] dictionary .
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and result of the function rfc3339_date ,
called with an argument result of the method self.latest_post_date [ self . latest_post_date ] . if value under the _STR:0_ key of the self.feed [ self . feed ] dictionary is not None ,
call the method handler.startElement [ handler . startElement ] with 2 arguments : string _STR:0_ and an empty dictionary .
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:1_ key of the self.feed [ self . feed ] dictionary .
if value under the _STR:0_ key of the self.feed [ self . feed ] dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:1_ key of the self.feed [ self . feed ] dictionary .
if value under the _STR:0_ key of the self.feed [ self . feed ] dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:1_ key of the self.feed [ self . feed ] dictionary .
call the method handler.endElement [ handler . endElement ] with an argument string _STR:0_ .
if value under the _STR:0_ key of the self.feed [ self . feed ] dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:0_ key of the self.feed [ self . feed ] dictionary .
for every cat in value under the _STR:0_ key of the self.feed [ self . feed ] dictionary .
call the method handler.addQuickElement [ handler . addQuickElement ] with 3 arguments : string _STR:0_ , an empty string and a dictionary with an entry :
cat for _STR:0_ . if value under the _STR:1_ key of the self.feed [ self . feed ] dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:1_ key of the self.feed [ self . feed ] dictionary .
define the method write_items with 2 arguments : self and handler .
for every item in self.items [ self . items ] ,
call the method handler.startElement [ handler . startElement ] with 2 arguments : string _STR:0_ and result of the function self.item_attributes [ self . item_attributes ] ,
called with an argument item . call the method self.add_item_elements [ self . add_item_elements ] with 2 arguments : handler and item .
call the method handler.endElement [ handler . endElement ] with an argument string _STR:0_ .
define the method add_item_elements with 3 arguments : self , handler and item .
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:0_ key of the item dictionary .
call the method handler.addQuickElement [ handler . addQuickElement ] with 3 arguments : string _STR:0_ , an empty string and a dictionary with 2 entries :
value under the _STR:0_ key of item dictionary for _STR:1_ and _STR:2_ for _STR:3_ . if value under the _STR:4_ key of the item dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and result of the function rfc3339_date ,
called with an argument value under the _STR:0_ key of the item dictionary . if value under the _STR:1_ key of the item dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and result of the function rfc3339_date ,
called with an argument value under the _STR:0_ key of the item dictionary . if value under the _STR:1_ key of the item dictionary is not None ,
call the method handler.endElement [ handler . endElement ] with 2 arguments : string _STR:0_ and an empty dictionary .
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:1_ key of the item dictionary .
if value under the _STR:0_ key of the item dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:1_ key of the item dictionary .
if value under the _STR:0_ key of the item dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:1_ key of the item dictionary .
call the method handler.endElement [ handler . endElement ] with an argument string _STR:0_ .
if value under the _STR:0_ key of the item dictionary is not None ,
substitute value under _STR:0_ key of item dictionary for unique_id .
if not ,
call the function get_tag_uri with 2 arguments : values under _STR:0_ and _STR:1_ keys of item dictionary , substitute the result for unique_id .
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and unique_id .
if value under the _STR:0_ key of the item dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 3 arguments : string _STR:0_ , value under the _STR:1_ key of item dictionary ,
and dictionary with an entry : _STR:0_ for _STR:1_ . if value under the _STR:2_ key of the item dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 3 arguments : string _STR:0_ , an empty string and a dictionary with 4 entries :
_STR:0_ for _STR:1_ , field url of value under the _STR:0_ key of item dictionary for _STR:2_ , field length of value under the _STR:0_ key of item dictionary for _STR:3_ , and field mime_type of value under the _STR:0_ key of item dictionary for _STR:4_ . for every cat in value under _STR:5_ key of item dictionary ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 3 arguments : string _STR:0_ , an empty string and a dictionary with an entry :
cat for _STR:0_ . if value under the _STR:1_ key of the item dictionary is not None ,
call the method handler.addQuickElement [ handler . addQuickElement ] with 2 arguments : string _STR:0_ and value under the _STR:1_ key of the item dictionary .
substitute Rss201rev2Feed for DefaultFeed .
from __future__ import absolute_ into default name space .
import module decimal .
import module datetime .
from importlib import import_module into default name space .
import module unicodedata .
from django.conf [ django . conf ] import settings into default name space .
from django.utils [ django . utils ] import dateformat , numberformat and datetime_safe into default name space .
from django.utils.encoding [ django . utils . encoding ] import force_str into default name space .
from django.utils.functional [ django . utils . functional ] import lazy into default name space .
from django.utils.safestring [ django . utils . safestring ] import mark_safe into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.translation [ django . utils . translation ] import get_language , to_locale and check_for_language into default name space .
_format_cache is an empty dictionary .
_format_modules_cache is an empty dictionary .
ISO_INPUT_FORMATS is a dictionary with 3 entries : tuple with an element string _STR:0_ for _STR:1_ ,
tuple with 3 elements : strings _STR:0_ , _STR:1_ and _STR:2_ for _STR:3_ , tuple with 4 elements : strings _STR:4_ , _STR:5_ , _STR:6_ and _STR:7_ for _STR:8_ . define the function reset_format_cache .
use global variables _format_cache and _format_modules_cache .
_format_cache is an empty dictionary .
_format_modules_cache is an empty dictionary .
define the function iter_format_modules with 2 arguments : lang and format_module_path set to None .
call the function check_for_language with an argument lang , if it evaluates to false ,
return nothing .
if format_module_path is None .
substitute settings.FORMAT_MODULE_PATH [ settings . FORMAT_MODULE_PATH ] for settings.FORMAT_MODULE_PATH [ settings . FORMAT_MODULE_PATH ] .
format_locations is an empty list .
if format_module_path is true ,
if format_module_path is an instance of six.string_types [ six . string_types ] ,
format_module_path is a list containing an element format_module_path .
for every path in format_module_path ,
concatenate path and string _STR:0_ , append the result to format_module_path .
append string _STR:0_ to format_locations .
call the function to_locale with an argument lang , substitute the result for locale .
locales is a list with an element locale .
if _STR:0_ is contained in locale ,
split locale by _STR:0_ , append the first element of the result to locales .
for every location in format_locations ,
for every loc in locales ,
try ,
call the function import_module with an argument string _STR:0_ formated with location , which is formated with loc ,
yield the result . if ImportError exception is caught ,
do nothing .
define the function get_format_modules with 2 arguments : lang set to None and reverse set to boolean False .
if lang is None ,
call the function get_language , substitute the result for lang .
call the method _format_modules_cache.setdefault [ _format_modules_cache . setdefault ] with 2 arguments : lang and list created out of the results of the function ,
iter_format_modules called with 2 arguments : lang and settings.FORMAT_MODULE_PATH [ settings . FORMAT_MODULE_PATH ] , substitute the result for modules . if reverse is true ,
reverse the order of modules elements , put them into a list , return it .
return modules.s [ modules . s ]
define the function get_format with 3 arguments : format_type , lang set to None and use_l10n set to None .
call the function force_str with an argument format_type , substitute the result for format_type .
if use_l10n is true , or if use_l10n is None and settings.USE_L10N [ settings . USE_L10N ] is true ,
if lang is None ,
call the function get_language , substitute the result for lang .
cache_key is a tuple with 2 argumetns : format_type and lang .
try ,
substitute value under the cache_key key of the _format_cache dictionary for cached .
if cached is not None ,
return cached .
if not ,
get format_type attribute of the settings object , return it .
if KeyError exception is caught ,
call the function get_format_modules with an argument lang , for every module in the result ,
try ,
get format_type attribute of module object , substitute the result for val .
get the value under the if iso_input not in val key of the ISO_INPUT_FORMATS dictionary , if it doesnt exists return an empty tuple ,
for every iso_input in the result , if iso_input is not contained in val ,
if val is an instance of tuple ,
convert val to an list , substitute it for val .
append iso_input to val .
substitute val for the value under the cache_key key of the _format_cache dictionary .
return val .
if AttributeError exception is caught ,
do nothing .
value under the cache_key key of the _format_cache dictionary is None .
get format_type attribute of the settings object , return it .
call the function lazy with 4 arguments : get_format , six.text_type [ six . text_type ] , list and tuple , substitute the result for get_format_lazy .
define the function date_format with 3 arguments : value , format set to None and use_l10n set to None .
call the function dateformat.format [ dateformat . format ] with 2 arguments : value and result of the function get_format called with 2 arguments :
format , if its true , otherwise string _STR:0_ and use_l10n as use_l10n , return the result . define the function time_format with 3 arguments : value , format set to None and use_l10n set to None .
call the function dateformat.time_format [ dateformat . time_format ] with 2 arguments : value and result of the function get_format called with 2 arguments :
format , if its true , otherwise string _STR:0_ and use_l10n as use_l10n , return the result . define the function number_format with 4 arguments : value , decimal_pos set to None , use_l10n set to None ,
if use_l10n is true , or use_l10n is None and settings.USE_L10N [ settings . USE_L10N ] is true ,
call the function get_language , substitute the result for lang .
if not ,
lang is None .
call the method numberformat.format [ numberformat . format ] with 6 arguments : value , result of the function get_format called with 3 arguments :
string _STR:0_ , lang and use_l10n set to use_l10n , decimal_pos , result of the function get_format called with 3 arguments : string _STR:1_ , lang and use_l10n as use_l10n , result of the function get_format called with an argument : string _STR:2_ , lang and use_l10n as use_l10n and force_grouping as force_grouping , return the result . define the function localize with 2 arguments value and use_l10n set to None .
if value is an instance of bool .
call the function six.text_type [ six . text_type ] with an argument value , use the result as an argument for the call to the function mark_safe ,
return the result . otherwise if value is an instance of decimal.Decimal [ decimal . Decimal ] , float or six.integer_types [ six . integer_types ] ,
call the function number_format with 2 arguments : value and use_l10 as use_l10n , return the result .
otherwise if value is an instance of datetime.datetime [ datetime . datetime ] ,
call the function date_format with 2 arguments : value , string _STR:0_ and use_l10n as use_l10n , return the result .
otherwise if value is an instance of datetime.date [ datetime . date ] ,
call the function date_format with 2 arguments : value and use_l10n as use_l10n , return the result .
otherwise if value is an instance of datetime.time [ datetime . time ] ,
call the function time_format with 3 arguments : value , string _STR:0_ and use_l10n as use_l10n , return the result .
if not ,
return value .
define the function localize_input with 2 arguments value and default set to None .
otherwise if value is an instance of decimal.Decimal [ decimal . Decimal ] , float or six.integer_types [ six . integer_types ] ,
call the function number_format with an argument value , return the result .
otherwise if value is an instance of datetime.datetime [ datetime . datetime ] ,
call the method datetime_safe.new_datetime [ datetime_safe . new_datetime ] with an argument value , substitute the result for value .
call the function force_str with an argument : default if it is true , or if not , first element of the result of the function ,
get_format called with an argument string _STR:0_ , substitute the result for format . call the method value.strftime [ value . strftime ] with an argument format , return the result .
otherwise if value is an instance of datetime.date [ datetime . date ] ,
call the method datetime_safe.new_date [ datetime_safe . new_date ] with an argument value , substitute the result for value .
call the function force_str with an argument : default if it is true , or if not , first element of the result of the function ,
get_format called with an argument string _STR:0_ , substitute the result for format . call the method value.strftime [ value . strftime ] with an argument format , return the result .
otherwise if value is an instance of datetime.time [ datetime . time ] ,
call the function force_str with an argument : default if it is true , or if not , first element of the result of the function ,
get_format called with an argument string _STR:0_ , substitute the result for format . call the method value.strftime [ value . strftime ] with an argument format , return the result .
return value .
define the function sanitize_separators with an argument value .
if settings.USE_L10N [ settings . USE_L10N ] is true and value is an instance of six.string_types [ six . string_types ] ,
parts is an empty list .
call the function get_format with an argument string _STR:0_ , substitute the result for decimal_separator .
if decimal_separator is contained in value ,
split value into two parts by decimal_separator , assign the result to value and decimals .
append decimals to parts .
if settings.USE_THOUSAND_SEPARATOR [ settings . USE_THOUSAND_SEPARATOR ] is true ,
call the function get_format with an argument string _STR:0_ , substitute the result for thousand_sep .
call the function unicodedata.normalize [ unicodedata . normalize ] with 2 arguments : string _STR:0_ and thousand_sep , put the result and thousand_sep into a set ,
for every replacement in the resulting set , replace every occurrence of replacement in value for an empty string , substitute the result for value .
append value to parts .
reverse order of parts , join them into a string , separated with _STR:0_ , substitute the result for value .
return value .
import module copy .
import module opera .
from functools import wraps into default name space .
import module sys .
import module warnings .
from django.utils [ django . utils ] import six into default name space .
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
from django.utils.six.moves [ django . utils . six . moves ] import copyreg into default name space .
define the function curry with 3 arguments : _curried_func , unpacked list args and unpacked dictionary kwargs .
define the function _curried with 2 arguments : unpacked list moreargs and unpacked dictionary morekwargs .
call the function _curried_func with 2 arguments : list moreargs appended to args and unpacked ,
unpacked dictionary created with elements of morekwargs dictionary through the kwargs mapping , return the result . return _curried .
define the function memoize with 3 arguments : func , cache and num_args .
call the function warnings.warn [ warnings . warn ] with 3 arguments :
string _STR:0_ , RemovedInDjango19Warning and stacklevel set to integer 2. decorator function wraps with an argument func .
define the function wrapper with an argument unpacked list args .
mem_args is a list containing of first num_args elements of args list .
if mem_args is contained in cache ,
get the value under the mem_args key of the cache dictionary , return it .
call the function func with an argument unpacked list args , substitute the result for result .
substitute result for value under the mem_args key of the cache dictionary .
return result .
return wrapper .
derive the class cached_property from the object base class .
define the method __init__ with 3 arguments : self , func and name set to None .
substitute func for self.func [ self . func ] .
if name is true , substitute it for self.name [ self . name ] , otherwise substitute func.__name__ [ func . __name__ ] for self.name [ self . name ] .
define the method __get__ with 3 arguments : self , instance and name type to None .
if instance is None ,
return self .
call the function self.func [ self . func ] with an argument instance , substitute the result for res and value under the self.name [ self . name ] key of the instance.__dict__ [ instance . __dict__ ] dictionary .
return res .
derive the class Promise from the object base class .
do nothing .
define the function lazy with 2 arguments : func and unpacked list resultclasses .
decorator total_ordering ,
derive the class __proxy__ from the Promise base class .
__dispatch is None .
define the method __init__ with 3 arguments : self , args and kw .
substitute args for self.__args [ self . __args ] .
substitute kw for self.__kw [ self . __kw ] .
if self.__dispatch [ self . __dispatch ] is None .
call the method self.__prepare_class__ [ self . __prepare_class__ ] .
define the method __reduce__ with an argument self .
return a tuple wit 2 elements : _lazy_proxy_unpickle and tuple with 3 elements : func , self.__args [ self . __args ] , self.__kw [ self . __kw ] and resultclasses .
classmethod decorator ,
define the method __prepare_class__ with an argument self .
cls.__dispatch [ cls . __dispatch ] is an empty dictionary .
for every resultclass in resultclasses ,
value under the resultclass key of the cls.__dispatch [ cls . __dispatch ] dictionary is an empty dictionary .
call the method resultclass.mro [ resultclass . mro ] , reverse the order of elements , for every type_ in the result .
for every k and v in result of the call to the method type_.__dict__.items [ type_ . __dict__ . items ] ,
call the method cls.__promise__ [ cls . __promise__ ] with 3 arguments : resultclass , k and v , substitute the result for meth .
if cls has an attribute k ,
skip this loop iteration ,
set k attribute of cls object to meth .
if bytes is contained in resultclasses , cls._delegate_bytes [ cls . _delegate_bytes ] is boolean True , otherwise it is boolean False .
if six.text_type [ six . text_type ] is contained in resultclasses , cls._delegate_text [ cls . _delegate_text ] is boolean True , otherwise it is boolean False .
if cls._delegate_bytes [ cls . _delegate_bytes ] and cls._delegate_text [ cls . _delegate_text ] are both false , raise an error , with an argument string _STR:0_ .
if cls._delegate_text [ cls . _delegate_text ] is true ,
if six.PY3 [ six . PY3 ] is true ,
substitute cls.__text_cast [ cls . __text_cast ] for cls.__str__ [ cls . __str__ ] .
if not ,
substitute cls.__text_cast [ cls . __text_cast ] for cls.__text_cast [ cls . __text_cast ] .
otherwise if cls._delegate_bytes [ cls . _delegate_bytes ] is true ,
if six.PY3 [ six . PY3 ] is true ,
substitute cls.__bytes_cast [ cls . __bytes_cast ] for cls.__bytes__ [ cls . __bytes__ ] .
if not ,
substitute cls.__bytes_cast [ cls . __bytes_cast ] for cls.__str__ [ cls . __str__ ] .
class method decorator ,
define the method __promise__ with 4 arguments : cls , klass , funcname and method .
define the method __wrapper__ with 3 arguments : self , unpacked list args and unpacked dictionary kw .
call the function func with 2 arguments : unpacked list self.__args [ self . __args ] and unpacked dictionary self.__kw [ self . __kw ] , substitute the result for res .
get the type of res , call the method mro on the result , for every t in the result ,
if t is contained in self.__dispatch [ self . __dispatch ] ,
get the value under the funcname key of the t-th elment of self.__dispatch [ self . __dispatch ] dictionary , call the result with 3 arguments : res ,
unpacked list args and unpacked dictionary kw , return the result . raise an TypeError exception with an argument sting _STR:0_ .
if klass is not contained in cls.__dispatch [ cls . __dispatch ] ,
value under the klass key of the cls.__dispatch [ cls . __dispatch ] dictionary is an empty dictionary .
substitute method for value under the funcname key of the dictionary under the klass key of the cls.__dispatch [ cls . __dispatch ] dictionary .
return __wrapper__ .
define the method __text_cast with an argument self .
call the function func with 2 arguments : unpacked list self.__args [ self . __args ] and unpacked dictionary self.__kw [ self . __kw ] , return the result .
define the method __bytes_cast with an argument self .
call the function func with 2 arguments : unpacked list self.__args [ self . __args ] and unpacked dictionary self.__kw [ self . __kw ] ,
use the result as an argument for the call to the function bytes , return the result . define the method __cast with an argument self .
if self._delegate_bytes [ self . _delegate_bytes ] is true ,
call the method self.__bytes_cast [ self . __bytes_cast ] , return the result .
otherwise if self._delegate_text [ self . _delegate_text ] is true ,
call the method self.__text_cast [ self . __text_cast ] , return the result .
if not ,
call the function func with 2 arguments : unpacked list self.__args [ self . __args ] and unpacked dictionary self.__kw [ self . __kw ] , return the result .
define the method __ne__ with 2 arguments : self and other .
if other is an instance of Promise class ,
call the method other.__cast [ other . __cast ] , substitute the result for other .
call the method self.__cast [ self . __cast ] , if the result doesnt equal to other , return boolean True , otherwise return boolean False .
define the method __ne__ with 2 arguments : self and other .
if other is an instance of Promise class ,
call the method other.__cast [ other . __cast ] , substitute the result for other .
call the method self.__cast [ self . __cast ] , if the result equals other , return boolean True , otherwise return boolean False .
define the method __lt__ with 2 arguments : self and other .
if other is an instance of Promise ,
call the method other.__cast [ other . __cast ] , substitute the result for other .
call the method self.__cast [ self . __cast ] , if the result is lesser than other , return boolean True , otherwise return boolean False .
define the method __hash__ with an argument self .
call the method self.__cast [ self . __cast ] , return the hash value of the result .
define the method __mod__ with 2 arguments : self and rhs .
if self._delegate_bytes [ self . _delegate_bytes ] and six.PY2 [ six . PY2 ] are both true ,
call the function bytes with an argument self , divide the result with rhs and return the reminder of the division .
otherwise if self._delegate_text [ self . _delegate_text ] is true ,
call the function six.text_type [ six . text_type ] with an argument self , divide the result with rhs and return the reminder of the division .
call the function sself.__cast [ sself . __cast ] with an argument self , divide the result with rhs and return the reminder of the division .
define the method __deepcopy__ with 2 arguments : self and memo .
get the id of the self object , use it as a key to obtain the value from the memo dictionary , substitute self with it .
return self .
decorator function wraps with an argument func .
define the function __wrapper__ with 2 arguments : unpacked list args and unpacked dictionary kw .
call the function __proxy__ with 2 arguments : args and kw , return the result .
return __wrapper__ .
define the function _lazy_proxy_unpickle with 4 arguments : func , args , kwargs and unpacked list resultclasses .
call the function lazy with 2 arguments : func and unpacked list resultclasses , call the result with 2 arguments : unpacked list args ,
and unpacked dictionary kwargs . define the function allow_lazy with 2 arguments : func and unpacked list resultclasses .
decorator function wraps with an argument func .
define the function wrapper with 2 arguments : unpacked list args and unpacked dictionary kwargs .
call the function six.itervalues [ six . itervalues ] with an argument kwargs , convert the result to a list and append it to a list containing args ,
for every arg in the result , if arg is an instance of Promise class ,
break from the loop execution ,
if not ,
call the function func with 2 arguments : unpacked list args and unpacked dictionary kwargs .
call the function lazy with 2 arguments : func and unpacked list resultclasses , call the result with 2 arguments : unpacked list args ,
and unpacked dictionary kwargs , return the result . return wrapper .
empty is an instance of object class .
define the function new_method_proxy with an argument func .
define the method inner with 2 arguments : self and unpacked list args .
if self._wrapped [ self . _wrapped ] is contained in empty ,
call the method self._setup [ self . _setup ] .
call the function func with 2 arguments : self._wrapped [ self . _wrapped ] and unpacked list args .
self._wrapped [ self . _wrapped ] .
derive the class LazyObject from the object base class .
_wrapped is None .
define the method __init__ with an argument self .
substitute empty for self._wrapped [ self . _wrapped ] .
call the function new_method_proxy with an argument getattr , substitute the result for __getattr__ .
define the method __setattr__ with 3 arguments : self , name and value .
if name equals string _STR:0_ ,
substitute value under the _STR:0_ key of the self.__dict__ [ self . __dict__ ] dictionary .
if not ,
if self._wrapped [ self . _wrapped ] is empty ,
call the method self._setup [ self . _setup ] .
set name attribute of self._wrapped [ self . _wrapped ] object to value .
define the method __delattr__ with 2 arguments self and name .
if name equals string _STR:0_ ,
raise an TypeError exception with an argument sting _STR:0_ .
if self._wrapped [ self . _wrapped ] is empty ,
call the method self._setup [ self . _setup ] .
delete name attribute from self._wrapped [ self . _wrapped ] object .
define the method _setup with an argument self .
raise an NotImplementedError exception with an argument sting _STR:0_ .
define the method __getstate__ with an argument self .
if self._wrapped [ self . _wrapped ] is empty ,
call the method self._setup [ self . _setup ] .
return self._wrapped.__dict__ [ self . _wrapped . __dict__ ] .
classmethod decorator ,
define the method __newobj__ with 2 arguments cls and unpacked list args .
call the method cls.__new__ [ cls . __new__ ] with 2 arguments : cls and unpacked list args .
define the method __reduce_ex__ with 2 arguments self and proto .
if proto is greater than or equal to integer 2 ,
return a tuple with 3 elements : self.__newobj__ [ self . __newobj__ ] , tuple with an element self.__class__ [ self . __class__ ] and result of the method self.__getstate__ [ self . __getstate__ ] .
if not ,
return a tuple with 3 elements : copyreg._reconstructor [ copyreg . _reconstructor ] , tuple with 3 elements : self.__class__ [ self . __class__ ] , object and None ,
and result of the method self.__getstate__ [ self . __getstate__ ] . define the method __deepcopy__ with 2 arguments self and memo .
if self._wrapped [ self . _wrapped ] is empty ,
get type of self , call it and substitute the result for result .
get the id of the self object , use it as a key to obtain the value from the memo dictionary , substitute self with it .
return result .
call the method copy.deepcopy [ copy . deepcopy ] with 2 arguments : self._wrapped [ self . _wrapped ] and memo , return the result .
if six.PY3 [ six . PY3 ] is true ,
call the function new_method_proxy with an argument bytes , substitute the result for __bytes__ .
call the function new_method_proxy with an argument str , substitute the result for __str__ .
call the function new_method_proxy with an argument bool , substitute the result for __bool__ .
if not ,
call the function new_method_proxy with an argument str , substitute the result for __str__ .
call the function new_method_proxy with an argument unicode , substitute the result for __unicode__ .
call the function new_method_proxy with an argument bool , substitute the result for __nonzero__ .
call the function new_method_proxy with an argument dir , substitute the result for __dir__ .
cal the method operator.attrgetter [ operator . attrgetter ] with an argument string _STR:0_ , use the result as an argument for the call to the function ,
new_method_proxy , __class__ is an property object created with previous result as an argument . call the function new_method_proxy with an argument operator.eq [ operator . eq ] , substitute the result for __eq__ .
call the function new_method_proxy with an argument operator.ne [ operator . ne ] , substitute the result for __ne__ .
call the function new_method_proxy with an argument hash , substitute the result for __hash__ .
call the function new_method_proxy with an argument operator.getitem [ operator . getitem ] , substitute the result for __getitem__ .
call the function new_method_proxy with an argument operator.setitem [ operator . setitem ] , substitute the result for __setitem__ .
call the function new_method_proxy with an argument operator.delitem [ operator . delitem ] , substitute the result for __delitem__ .
call the function new_method_proxy with an argument len , substitute the result for __len__ .
call the function new_method_proxy with an argument operator.contains [ operator . contains ] , substitute the result for __contains__ .
substitute super for _super .
derive the class SimpleLazyObject from the LazyObject base class .
define the method __init__ with 2 arguments self and func .
substitute func for value under the _STR:0_ key of the self.__dict__ [ self . __dict__ ] dictionary .
call the function _super with 2 arguments : class SimpleLazyObject and self , call the method __init__ on the result .
define the method _setup with an argument self .
call the method self._setupfunc [ self . _setupfunc ] , substitute the result for self._wrapped [ self . _wrapped ] .
define the method __repr__ with an argument self .
if self._wrapped [ self . _wrapped ] is empty ,
substitute self._setupfunc [ self . _setupfunc ] for repr_attr .
if not ,
substitute self._wrapped [ self . _wrapped ] for repr_attr .
return a string _STR:0_ , format it with __name__ field of the self class and repr_attr .
define the method __deepcopy__ with 2 arguments self and memo .
if self._wrapped [ self . _wrapped ] is empty ,
result is an instance of SimpleLazyObject class , created with an argument self._setupfunc [ self . _setupfunc ] .
get the id of the self object , use it as a key to obtain the value from the memo dictionary , substitute self with it .
return result .
call the method copy.deepcopy [ copy . deepcopy ] with 2 arguments : self._wrapped [ self . _wrapped ] and memo , return the result .
derive the class lazy_property from the property base class .
define the method __new__ with 5 arguments : cls , fget set to None , fset set to None , fdel set to None and doc set to None .
if fget is not None ,
decorator function wraps with an argument fget .
define the function fget with 3 arguments : instance , instance_type set to None and name set to fget.__name__ [ fget . __name__ ] .
get name attribute from the instance object , call it and return the result .
if fset is not None ,
decorator function wraps with an argument fset .
define the function fset with 3 arguments : instance , valse to None and name set to fset.__name__ [ fset . __name__ ] .
get name attribute from the instance object , call it with an argument value and return the result .
if fdel is not None ,
decorator function wraps with an argument fdel .
define the function fdel with 2 arguments : instance and name set to fdel.__name__ [ fdel . __name__ ] .
get name attribute from the instance object , call it and return the result .
return an property object with getter function fget , setter function fset , destructor fdel and documentation string doc .
define the function partition with 2 arguments : predicate and values .
results is a tuple with 2 elements , 2 empty lists .
for every item in values ,
call the function predicate with an argument item , use it as a key to get results dictionary value , append item to it .
return results .
if sys.version_info [ sys . version_info ] is greater than or equal to a tuple with 3 elements : integers 2 , 7 and 2 , respectively ,
from functools import total_ordering .
if not ,
define the function total_ordering with an argument cls .
convert is a dictionary with 4 initial entries : list with 3 tuples : tuple with 2 elements : string _STR:0_ ,
and lambda function with 2 arguments : self and other , resulting boolean False if self is lesser than other or self is equal to other , tuple with 2 elements : string _STR:0_ , and lambda function with 2 arguments : self and other , resulting boolean True if self is lesser than other or self is equal to other , tuple with 2 elements : string _STR:1_ , and lambda function with 2 arguments : self and other , resulting boolean False if self is lesser than other , for _STR:2_ , list with 3 tuples : tuple with 2 elements : string _STR:1_ , and lambda function with 2 arguments : self and other , resulting boolean False if self is lesser than or equal to other , or self is equal to other , tuple with 2 elements : string _STR:2_ , and lambda function with 2 arguments : self and other , resulting boolean True if self is lesser than or equal to other , or self is not equal to other , tuple with 2 elements : string _STR:3_ , and lambda function with 2 arguments : self and other , resulting boolean False if self is lesser than or equal to other , for _STR:0_ , list with 3 tuples : tuple with 2 elements : string _STR:2_ , and lambda function with 2 arguments : self and other , resulting boolean False if self is greater than other or self is equal to other , tuple with 2 elements : string _STR:1_ , and lambda function with 2 arguments : self and other , resulting boolean True if self is greater than other or self is equal to other , tuple with 2 elements : string _STR:0_ , and lambda function with 2 arguments : self and other , resulting boolean False if self is greater than other , for _STR:3_ , and list with 3 tuples : tuple with 2 elements : string _STR:0_ , and lambda function with 2 arguments : self and other , resulting boolean True if self is not greater than or is not equal to other , or self is equal to other , tuple with 2 elements : string _STR:3_ , and lambda function with 2 arguments : self and other , resulting boolean True if self is greater than or not equal to other , or self is not equal to other , tuple with 2 elements : string _STR:2_ , and lambda function with 2 arguments : self and other , resulting boolean False if self is greater than or equal to other , for _STR:1_ , convert cls to a dictionary , convert the result into a set and convert convert into a set , roots is a set of differences of the two previous sets .
if roots is false ,
raise an ValueError exception with an argument string _STR:0_ .
get maximal element from roots and substitute it for root .
get the value under the root key of the convert dictionary , for every opname and opfunc in the result ,
if opname is not contained in roots ,
substitute opname for opfunc.__name__ [ opfunc . __name__ ] .
get opname attribute from int object , substitute its field __doc__ for opfunc.__doc__ [ opfunc . __doc__ ] .
set opname attribute of cls object to opfunc .
return cls .
from __future__ import unicode_literals into default name space .
import module re .
import module sys .
from django.utils.encoding [ django . utils . encoding ] import force_text and force_str into default name space .
from django.utils.functional [ django . utils . functional ] import allow_lazy into default name space .
from django.utils.safestring [ django . utils . safestring ] import SafeData and mark_safe into default name space .
from django.utils [ django . utils ] import six into default name space .
from django.utils.six.moves.urllib.parse [ django . utils . six . moves . urllib . parse ] import quote , unquote , urlsplit and urlunsplit into default name space .
from django.utils.text [ django . utils . text ] import normalize_newlines into default name space .
from .html_parser import HTMLParser and HTMLParseError into default name space .
TRAILING_PUNCTUATION is a list with 7 elements : _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ , _STR:5_ and _STR:6_ .
WRAPPING_PUNCTUATION is a list with 6 elements : tuple with 2 elements : _STR:0_ and _STR:1_ , tuple with 2 elements : _STR:2_ and _STR:3_ ,
tuple with 2 elements : _STR:0_ and _STR:1_ , tuple with 2 elements : _STR:2_ and _STR:3_ , tuple with 2 elements : _STR:4_ and _STR:4_ , and tuple with 2 elements : _STR:5_ and _STR:5_ . DOTS is a list with 6 elements : strings _STR:6_ , _STR:7_ , _STR:8_ , _STR:9_ , _STR:10_ and _STR:11_ .
call the function re.compile [ re . compile ] with raw string _STR:0_ , substitute the result for unencoded_ampersands_re .
call the function re.compile [ re . compile ] with raw string _STR:0_ , substitute the result for word_split_re .
call the function re.compile [ re . compile ] with 2 arguments : raw string _STR:0_ and re.IGNORECASE [ re . IGNORECASE ] , substitute the result for simple_url_re .
call the function re.compile [ re . compile ] with 2 arguments : raw string _STR:0_ ,
and re.IGNORECASE [ re . IGNORECASE ] , substitute the result for simple_url_re . call the function re.compile [ re . compile ] with raw string _STR:0_ , substitute the result for simple_email_re .
call the function re.compile [ re . compile ] with raw string _STR:0_ , substitute the result for link_target_attribute_re .
call the function re.compile [ re . compile ] with 2 arguments :
raw string _STR:0_ and re.IGNORECASE [ re . IGNORECASE ] , substitute the result for html_gunk_re . call the function re.compile [ re . compile ] with 2 arguments : raw string _STR:1_ ,
formated with string created by joining elements of result of the function re.escape [ re . escape ] with an argument x , with separator _STR:0_ , for every x in DOTS , and re.DOTALL [ re . DOTALL ] , substitute the result for hard_coded_bullets_re . call the function re.compile [ re . compile ] with raw string _STR:1_ , substitute the result for trailing_empty_content_re .
define the function escape with an argument text .
call the function force_text with an argument text , replace every occurrence of _STR:0_ in the result with _STR:1_ ,
every occurrence of _STR:0_ with _STR:1_ , every occurrence of _STR:2_ with _STR:3_ , every occurrence of _STR:4_ with _STR:5_ , and every occurrence of _STR:6_ with _STR:7_ , call the function mark_safe with the previous result as an argument , return the result . call the function allow_lazy with 2 arguments : escape , six.text_type [ six . text_type ] , substitute the result for escape .
_js_escapes is a dictionary with 11 initial entries : _STR:0_ for integer representation of string '\\ ' ,
_STR:0_ for integer representation of string _STR:1_\\u0022_STR:2_ '' _STR:3_\\u003E_STR:2_ > _STR:4_\\u003C_STR:2_ < _STR:3_\\u0026_STR:2_ % _STR:4_\\u003D_STR:2_=_STR:3_\\u002D_STR:2_-_STR:4_\\u003B_STR:2_ ; _STR:3_\\u2028_STR:2_\u2028_STR:5_\\u2029_STR:2_\u2029_STR:6_\\u % 04X ' formated with z ,
for integer representation of z converted into a string . define the function escapejs with an argument value .
call the function force_text with an argument value , call the method translate on the result , with an argument _js_escapes ,
use the result as an argument for the call to the mark_safe function , return the result . call the function allow_lazy with 2 arguments : escapejs , six.text_type [ six . text_type ] , substitute the result for escapejs .
define the function conditional_escape with an argument text .
if text has an _STR:0_ attribute ,
call the method text.__html__ [ text . __html__ ] , return the result .
if not ,
call the function escape with an argument text , return the result .
define the function format_html with 3 arguments : format_string , unpacked list args and unpacked dictionary kwargs .
map elements from args through the function conditional_escape , substitute the result for args_safe .
kwargs_safe is a dictionary created for every k and v in result of the function six.iteritems [ six . iteritems ] called with an argument kwargs ,
with value result of the conditional_escape function called with an argument v for key k. call the method format_string.format [ format_string . format ] with 2 arguments : unpacked list args_safe and unpacked dictionary kwargs_safe ,
use the result as an argument for the call to the function mark_safe , return the result . define the function format_html_join with 3 arguments : sep , format_string and args_generator .
join results of format_html called with 2 arguments : format_string and tuple with an element args , into a string ,
separated with result of the function conditional_escape with an argument sep , for every args in args_generator , use the result as an argument for the call to the function mark_safe , return the result . define the function linebreaks with 2 arguments : value and autoescape set to boolean False .
call the function normalize_newlines with an argument value , substitute the result for value .
call the method re.split [ re . split ] with 2 arguments : string _STR:0_ and value , substitute the result for paras .
if autoescape is true ,
call the function escape with an argument p , replace every occurrence of _STR:0_ in the result for _STR:1_ ,
format the string _STR:0_ with the result , for every p in paras , substitute list of results for paras . if not ,
replace every occurrence of _STR:0_ in p for _STR:1_ ,
format the string _STR:0_ with the result , for every p in paras , substitute list of results for paras . join elements of paras into a string separated with _STR:1_ , return the result .
call the function allow_lazy with 2 arguments : linebreaks , six.text_type [ six . text_type ] , substitute the result for linebreaks .
derive the class MLStripper from the HTMLParser base class .
define the method __init__ with an argument self .
if fist and second element of sys.version_info [ sys . version_info ] equals to integer 3 and 2 , respectively ,
call the method HTMLParser.__init__ [ HTMLParser . __init__ ] with 2 arguments : self and strict set to boolean False .
if not ,
call the method HTMLParser.__init__ [ HTMLParser . __init__ ] with an argument self .
call the method self.reset [ self . reset ] .
self.fed [ self . fed ] is an empty list .
define the method handle_data with 2 arguments self and d .
append d to self.fed [ self . fed ] .
define the method handle_entityref with 2 arguments self and name .
format string _STR:0_ with name , append it to self.fed [ self . fed ] .
define the method handle_charref with 2 arguments self and name .
format string _STR:0_ with name , append it to self.fed [ self . fed ] .
define the method get_data with an argument self .
join elements of self.fed [ self . fed ] into a string , return the result .
define the function _strip_once with an argument value .
s is an instance of MLStripper class .
try ,
call the method s.feed [ s . feed ] with an argument value .
if HTMLParseError exception is caught ,
return value .
try ,
close file descriptor s .
if HTMLParseError or UnboundLocalError exceptions are caught ,
sum the result of the method s.get_data [ s . get_data ] and s.rawdata [ s . rawdata ] , return the result .
if not ,
call the method s.get_data [ s . get_data ] , return the result .
